const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/cube-recipes-bkvbiyhy.js","assets/cube-recipes-k8ooAsY7.css"])))=>i.map(i=>d[i]);
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
function initializeTC39Metadata() {
  Symbol.metadata ??= Symbol.for("Symbol.metadata");
}
const Metadata = {
  get(key, type) {
    return type[Symbol.metadata]?.[key];
  },
  define(value, type, ...keys) {
    let metadata = Object.getOwnPropertyDescriptor(type, Symbol.metadata)?.value;
    if (metadata == null) {
      Object.defineProperty(type, Symbol.metadata, { value: metadata = /* @__PURE__ */ Object.create(null), enumerable: true, configurable: true, writable: true });
    }
    const length = keys.length;
    switch (length) {
      case 0:
        throw new Error("At least one key must be provided");
      case 1:
        metadata[keys[0]] = value;
        return;
      case 2:
        metadata[keys[0]] = metadata[keys[1]] = value;
        return;
      default: {
        for (let i3 = 0; i3 < length; ++i3) {
          metadata[keys[i3]] = value;
        }
        return;
      }
    }
  },
  has(key, type) {
    const metadata = type[Symbol.metadata];
    return metadata == null ? false : key in metadata;
  },
  delete(key, type) {
    const metadata = type[Symbol.metadata];
    if (metadata == null)
      return;
    Reflect.deleteProperty(metadata, key);
    return;
  }
};
const objectFreeze$1 = Object.freeze;
const objectAssign$1 = Object.assign;
const safeString$2 = String;
const getMetadata$2 = Metadata.get;
const defineMetadata$2 = Metadata.define;
const isPromise = (v2) => v2 instanceof Promise;
const isArray = (v2) => v2 instanceof Array;
const isSet = (v2) => v2 instanceof Set;
const isMap = (v2) => v2 instanceof Map;
const isObject = (v2) => v2 instanceof Object;
function isObjectOrFunction(value) {
  return typeof value === "object" && value !== null || typeof value === "function";
}
const isFunction = (v2) => typeof v2 === "function";
const isString = (v2) => typeof v2 === "string";
const isNumber = (v2) => typeof v2 === "number";
const createLookup$1 = () => /* @__PURE__ */ Object.create(null);
const areEqual = Object.is;
const createMappedError$6 = (code, ...details) => new Error(`AUR${safeString$2(code).padStart(4, "0")}: ${getMessageByCode$4(code, ...details)}`);
const errorsMap$4 = {
  [
    1
    /* ErrorNames.no_registration_for_interface */
  ]: `No registration for interface: '{{0}}'`,
  [
    2
    /* ErrorNames.none_resolver_found */
  ]: `'{{0}}' was registered with "none" resolver, are you injecting the right key?`,
  [
    3
    /* ErrorNames.cyclic_dependency */
  ]: `Cyclic dependency found: {{0}}`,
  [
    4
    /* ErrorNames.no_factory */
  ]: `Resolver for {{0}} returned a null factory`,
  [
    5
    /* ErrorNames.invalid_resolver_strategy */
  ]: `Invalid resolver strategy specified: {{0}}. Did you assign an invalid strategy value?`,
  [
    6
    /* ErrorNames.unable_auto_register */
  ]: `Unable to autoregister dependency: {{0}}`,
  [
    7
    /* ErrorNames.resource_already_exists */
  ]: `Resource key "{{0}}" already registered`,
  [
    8
    /* ErrorNames.unable_resolve_key */
  ]: `Unable to resolve key: {{0}}`,
  [
    9
    /* ErrorNames.unable_jit_non_constructor */
  ]: `Attempted to jitRegister something that is not a constructor: '{{0}}'. Did you forget to register this resource?`,
  [
    10
    /* ErrorNames.no_jit_intrinsic_type */
  ]: `Attempted to jitRegister an intrinsic type: "{{0}}". Did you forget to add @inject(Key)`,
  [
    11
    /* ErrorNames.null_resolver_from_register */
  ]: `Invalid resolver, null/undefined returned from the static register method.`,
  [
    12
    /* ErrorNames.no_jit_interface */
  ]: `Attempted to jitRegister an interface: {{0}}`,
  [
    13
    /* ErrorNames.no_instance_provided */
  ]: `Cannot call resolve '{{0}}' before calling prepare or after calling dispose.`,
  [
    14
    /* ErrorNames.null_undefined_key */
  ]: `Key cannot be null or undefined. Are you trying to inject/register something that doesn't exist with DI?A common cause is circular dependency with bundler, did you accidentally introduce circular dependency into your module graph?`,
  [
    15
    /* ErrorNames.no_construct_native_fn */
  ]: `'{{0}}' is a native function and cannot be safely constructed by DI. If this is intentional, please use a callback or cachedCallback resolver.`,
  [
    16
    /* ErrorNames.no_active_container_for_resolve */
  ]: `There is not a currently active container to resolve "{{0}}". Are you trying to "new Class(...)" that has a resolve(...) call?`,
  [
    17
    /* ErrorNames.invalid_new_instance_on_interface */
  ]: `Failed to instantiate '{{0}}' via @newInstanceOf/@newInstanceForScope, there's no registration and no default implementation, or the default implementation does not result in factory for constructing the instances.`,
  [
    18
    /* ErrorNames.event_aggregator_publish_invalid_event_name */
  ]: `Invalid channel name or instance: '{{0}}'.`,
  [
    19
    /* ErrorNames.event_aggregator_subscribe_invalid_event_name */
  ]: `Invalid channel name or type: {{0}}.`,
  [
    20
    /* ErrorNames.first_defined_no_value */
  ]: `No defined value found when calling firstDefined()`,
  [
    21
    /* ErrorNames.invalid_module_transform_input */
  ]: `Invalid module transform input: {{0}}. Expected Promise or Object.`,
  [
    22
    /* ErrorNames.invalid_inject_decorator_usage */
  ]: `The @inject decorator on the target ('{{0}}') type '{{1}}' is not supported.`,
  [
    23
    /* ErrorNames.resource_key_already_registered */
  ]: `Resource key '{{0}}' has already been registered.`
};
const getMessageByCode$4 = (name2, ...details) => {
  let cooked = errorsMap$4[name2];
  for (let i3 = 0; i3 < details.length; ++i3) {
    cooked = cooked.replace(`{{${i3}}}`, String(details[i3]));
  }
  return cooked;
};
const logError = (...args) => globalThis.console.error(...args);
const isArrayIndex = /* @__PURE__ */ (() => {
  const isNumericLookup = {};
  let result = false;
  let length = 0;
  let ch = 0;
  let i3 = 0;
  return (value) => {
    switch (typeof value) {
      case "number":
        return value >= 0 && (value | 0) === value;
      case "string":
        result = isNumericLookup[value];
        if (result !== void 0) {
          return result;
        }
        length = value.length;
        if (length === 0) {
          return isNumericLookup[value] = false;
        }
        ch = 0;
        i3 = 0;
        for (; i3 < length; ++i3) {
          ch = value.charCodeAt(i3);
          if (i3 === 0 && ch === 48 && length > 1 || ch < 48 || ch > 57) {
            return isNumericLookup[value] = false;
          }
        }
        return isNumericLookup[value] = true;
      default:
        return false;
    }
  };
})();
const baseCase = /* @__PURE__ */ function() {
  const isDigit = objectAssign$1(createLookup$1(), {
    "0": true,
    "1": true,
    "2": true,
    "3": true,
    "4": true,
    "5": true,
    "6": true,
    "7": true,
    "8": true,
    "9": true
  });
  const charToKind = (char) => {
    if (char === "") {
      return 0;
    }
    if (char !== char.toUpperCase()) {
      return 3;
    }
    if (char !== char.toLowerCase()) {
      return 2;
    }
    if (isDigit[char] === true) {
      return 1;
    }
    return 0;
  };
  return (input, cb) => {
    const len = input.length;
    if (len === 0) {
      return input;
    }
    let sep = false;
    let output = "";
    let prevKind;
    let curChar = "";
    let curKind = 0;
    let nextChar2 = input.charAt(0);
    let nextKind = charToKind(nextChar2);
    let i3 = 0;
    for (; i3 < len; ++i3) {
      prevKind = curKind;
      curChar = nextChar2;
      curKind = nextKind;
      nextChar2 = input.charAt(i3 + 1);
      nextKind = charToKind(nextChar2);
      if (curKind === 0) {
        if (output.length > 0) {
          sep = true;
        }
      } else {
        if (!sep && output.length > 0 && curKind === 2) {
          sep = prevKind === 3 || nextKind === 3;
        }
        output += cb(curChar, sep);
        sep = false;
      }
    }
    return output;
  };
}();
const camelCase = /* @__PURE__ */ function() {
  const cache2 = createLookup$1();
  const callback = (char, sep) => {
    return sep ? char.toUpperCase() : char.toLowerCase();
  };
  return (input) => {
    let output = cache2[input];
    if (output === void 0) {
      output = cache2[input] = baseCase(input, callback);
    }
    return output;
  };
}();
const pascalCase = /* @__PURE__ */ function() {
  const cache2 = createLookup$1();
  return (input) => {
    let output = cache2[input];
    if (output === void 0) {
      output = camelCase(input);
      if (output.length > 0) {
        output = output[0].toUpperCase() + output.slice(1);
      }
      cache2[input] = output;
    }
    return output;
  };
}();
const kebabCase = /* @__PURE__ */ function() {
  const cache2 = createLookup$1();
  const callback = (char, sep) => {
    return sep ? `-${char.toLowerCase()}` : char.toLowerCase();
  };
  return (input) => {
    let output = cache2[input];
    if (output === void 0) {
      output = cache2[input] = baseCase(input, callback);
    }
    return output;
  };
}();
const toArray = (input) => {
  const length = input.length;
  const arr = Array(length);
  let i3 = 0;
  for (; i3 < length; ++i3) {
    arr[i3] = input[i3];
  }
  return arr;
};
const bound = (originalMethod, context) => {
  const methodName = context.name;
  context.addInitializer(function() {
    Reflect.defineProperty(this, methodName, {
      value: originalMethod.bind(this),
      writable: true,
      configurable: true,
      enumerable: false
    });
  });
};
const mergeArrays = (...arrays) => {
  const result = [];
  let k3 = 0;
  const arraysLen = arrays.length;
  let arrayLen = 0;
  let array;
  let i3 = 0;
  for (; i3 < arraysLen; ++i3) {
    array = arrays[i3];
    if (array !== void 0) {
      arrayLen = array.length;
      let j2 = 0;
      for (; j2 < arrayLen; ++j2) {
        result[k3++] = array[j2];
      }
    }
  }
  return result;
};
const firstDefined = (...values) => {
  const len = values.length;
  let value;
  let i3 = 0;
  for (; len > i3; ++i3) {
    value = values[i3];
    if (value !== void 0) {
      return value;
    }
  }
  throw createMappedError$6(
    20
    /* ErrorNames.first_defined_no_value */
  );
};
const getPrototypeChain = /* @__PURE__ */ function() {
  const functionPrototype = Function.prototype;
  const getPrototypeOf = Object.getPrototypeOf;
  const cache2 = /* @__PURE__ */ new WeakMap();
  let proto = functionPrototype;
  let i3 = 0;
  let chain = void 0;
  return function(Type) {
    chain = cache2.get(Type);
    if (chain === void 0) {
      cache2.set(Type, chain = [proto = Type]);
      i3 = 0;
      while ((proto = getPrototypeOf(proto)) !== functionPrototype) {
        chain[++i3] = proto;
      }
    }
    return chain;
  };
}();
function toLookup(...objs) {
  return objectAssign$1(createLookup$1(), ...objs);
}
const isNativeFunction = /* @__PURE__ */ (() => {
  const lookup2 = /* @__PURE__ */ new WeakMap();
  let isNative = false;
  let sourceText = "";
  let i3 = 0;
  return (fn2) => {
    isNative = lookup2.get(fn2);
    if (isNative == null) {
      i3 = (sourceText = fn2.toString()).length;
      isNative = i3 > 28 && sourceText.indexOf("[native code] }") === i3 - 15;
      lookup2.set(fn2, isNative);
    }
    return isNative;
  };
})();
const onResolve = (maybePromise, resolveCallback) => {
  if (isPromise(maybePromise)) {
    return maybePromise.then(resolveCallback);
  }
  return resolveCallback(maybePromise);
};
const onResolveAll = (...maybePromises) => {
  let maybePromise = void 0;
  let firstPromise = void 0;
  let promises = void 0;
  let i3 = 0;
  let ii = maybePromises.length;
  for (; i3 < ii; ++i3) {
    maybePromise = maybePromises[i3];
    if (isPromise(maybePromise = maybePromises[i3])) {
      if (firstPromise === void 0) {
        firstPromise = maybePromise;
      } else if (promises === void 0) {
        promises = [firstPromise, maybePromise];
      } else {
        promises.push(maybePromise);
      }
    }
  }
  if (promises === void 0) {
    return firstPromise;
  }
  return Promise.all(promises);
};
const instanceRegistration$1 = (key, value) => new Resolver(key, 0, value);
const singletonRegistration$2 = (key, value) => new Resolver(key, 1, value);
const transientRegistation = (key, value) => new Resolver(key, 2, value);
const callbackRegistration = (key, callback) => new Resolver(key, 3, callback);
const cachedCallbackRegistration = (key, callback) => new Resolver(key, 3, cacheCallbackResult(callback));
const aliasToRegistration = (originalKey, aliasKey) => new Resolver(aliasKey, 5, originalKey);
const deferRegistration = (key, ...params) => new ParameterizedRegistry(key, params);
const containerLookup = /* @__PURE__ */ new WeakMap();
const cacheCallbackResult = (fun) => {
  return (handler, requestor, resolver) => {
    let resolverLookup = containerLookup.get(handler);
    if (resolverLookup === void 0) {
      containerLookup.set(handler, resolverLookup = /* @__PURE__ */ new WeakMap());
    }
    if (resolverLookup.has(resolver)) {
      return resolverLookup.get(resolver);
    }
    const t2 = fun(handler, requestor, resolver);
    resolverLookup.set(resolver, t2);
    return t2;
  };
};
const Registration = {
  /**
   * allows you to pass an instance.
   * Every time you request this {@linkcode Key} you will get this instance back.
   * ```
   * Registration.instance(Foo, new Foo()));
   * ```
   *
   * @param key - key to register the instance with
   * @param value - the instance associated with the key
   */
  instance: instanceRegistration$1,
  /**
   * Creates an instance from the class.
   * Every time you request this {@linkcode Key} you will get the same one back.
   * ```
   * Registration.singleton(Foo, Foo);
   * ```
   *
   * @param key - key to register the singleton class with
   * @param value - the singleton class to instantiate when a container resolves the associated key
   */
  singleton: singletonRegistration$2,
  /**
   * Creates an instance from a class.
   * Every time you request this {@linkcode Key} you will get a new instance.
   * ```
   * Registration.instance(Foo, Foo);
   * ```
   *
   * @param key - key to register the transient class with
   * @param value - the class to instantiate when a container resolves the associated key
   */
  transient: transientRegistation,
  /**
   * Creates an instance from the method passed.
   * Every time you request this {@linkcode Key} you will get a new instance.
   * ```
   * Registration.callback(Foo, () => new Foo());
   * Registration.callback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key - key to register the callback with
   * @param callback - the callback to invoke when a container resolves the associated key
   */
  callback: callbackRegistration,
  /**
   * Creates an instance from the method passed.
   * On the first request for the {@linkcode Key} your callback is called and returns an instance.
   * subsequent requests for the {@linkcode Key}, the initial instance returned will be returned.
   * If you pass the same {@linkcode Registration} to another container the same cached value will be used.
   * Should all references to the resolver returned be removed, the cache will expire.
   * ```
   * Registration.cachedCallback(Foo, () => new Foo());
   * Registration.cachedCallback(Bar, (c: IContainer) => new Bar(c.get(Foo)));
   * ```
   *
   * @param key - key to register the cached callback with
   * @param callback - the cache callback to invoke when a container resolves the associated key
   */
  cachedCallback: cachedCallbackRegistration,
  /**
   * creates an alternate {@linkcode Key} to retrieve an instance by.
   * Returns the same scope as the original {@linkcode Key}.
   * ```
   * Register.singleton(Foo, Foo)
   * Register.aliasTo(Foo, MyFoos);
   *
   * container.getAll(MyFoos) // contains an instance of Foo
   * ```
   *
   * @param originalKey - the real key to resolve the get call from a container
   * @param aliasKey - the key that a container allows to resolve the real key associated
   */
  aliasTo: aliasToRegistration,
  /**
   * @internal
   * @param key - the key to register a defer registration
   * @param params - the parameters that should be passed to the resolution of the key
   */
  defer: deferRegistration
};
const createImplementationRegister = function(key) {
  return function register2(container) {
    container.register(singletonRegistration$2(this, this), aliasToRegistration(this, key));
  };
};
const annoBaseName = "au:annotation";
const getAnnotationKeyFor$1 = (name2, context) => {
  if (context === void 0) {
    return `${annoBaseName}:${name2}`;
  }
  return `${annoBaseName}:${name2}:${context}`;
};
const appendAnnotation = (target, key) => {
  const keys = getMetadata$2(annoBaseName, target);
  if (keys === void 0) {
    defineMetadata$2([key], target, annoBaseName);
  } else {
    keys.push(key);
  }
};
const annotation$1 = /* @__PURE__ */ objectFreeze$1({
  name: "au:annotation",
  appendTo: appendAnnotation,
  set(target, prop, value) {
    defineMetadata$2(value, target, getAnnotationKeyFor$1(prop));
  },
  get: (target, prop) => getMetadata$2(getAnnotationKeyFor$1(prop), target),
  getKeys(target) {
    let keys = getMetadata$2(annoBaseName, target);
    if (keys === void 0) {
      defineMetadata$2(keys = [], target, annoBaseName);
    }
    return keys;
  },
  isKey: (key) => key.startsWith(annoBaseName),
  keyFor: getAnnotationKeyFor$1
});
const resourceBaseName = "au:resource";
const getResourceKeyFor = (type, name2, context) => {
  {
    return `${resourceBaseName}:${type}`;
  }
};
const Protocol = {
  annotation: annotation$1
};
const hasOwn = Object.prototype.hasOwnProperty;
function fromAnnotationOrDefinitionOrTypeOrDefault(name2, def2, Type, getDefault) {
  let value = getMetadata$2(getAnnotationKeyFor$1(name2), Type);
  if (value === void 0) {
    value = def2[name2];
    if (value === void 0) {
      value = Type[name2];
      if (value === void 0 || !hasOwn.call(Type, name2)) {
        return getDefault();
      }
      return value;
    }
    return value;
  }
  return value;
}
function fromAnnotationOrTypeOrDefault(name2, Type, getDefault) {
  let value = getMetadata$2(getAnnotationKeyFor$1(name2), Type);
  if (value === void 0) {
    value = Type[name2];
    if (value === void 0 || !hasOwn.call(Type, name2)) {
      return getDefault();
    }
    return value;
  }
  return value;
}
function fromDefinitionOrDefault(name2, def2, getDefault) {
  const value = def2[name2];
  if (value === void 0) {
    return getDefault();
  }
  return value;
}
const registrableMetadataKey = Symbol.for("au:registrable");
const DefaultResolver = {
  none(key) {
    throw createMappedError$6(2, key);
  },
  singleton: (key) => new Resolver(key, 1, key),
  transient: (key) => new Resolver(key, 2, key)
};
class ContainerConfiguration {
  constructor(inheritParentResources, defaultResolver) {
    this.inheritParentResources = inheritParentResources;
    this.defaultResolver = defaultResolver;
  }
  static from(config) {
    if (config === void 0 || config === ContainerConfiguration.DEFAULT) {
      return ContainerConfiguration.DEFAULT;
    }
    return new ContainerConfiguration(config.inheritParentResources ?? false, config.defaultResolver ?? DefaultResolver.singleton);
  }
}
ContainerConfiguration.DEFAULT = ContainerConfiguration.from({});
const createContainer$1 = (config) => new Container(null, ContainerConfiguration.from(config));
const InstrinsicTypeNames = new Set("Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise RangeError ReferenceError RegExp Set SharedArrayBuffer String SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet".split(" "));
let containerId = 0;
let currentContainer = null;
class Container {
  get depth() {
    return this._parent === null ? 0 : this._parent.depth + 1;
  }
  get parent() {
    return this._parent;
  }
  constructor(parent, config) {
    this.id = ++containerId;
    this._registerDepth = 0;
    this._disposableResolvers = /* @__PURE__ */ new Map();
    this._parent = parent;
    this.config = config;
    this._resolvers = /* @__PURE__ */ new Map();
    this.res = {};
    if (parent === null) {
      this.root = this;
      this._factories = /* @__PURE__ */ new Map();
    } else {
      this.root = parent.root;
      this._factories = parent._factories;
      if (config.inheritParentResources) {
        for (const key in parent.res) {
          this.registerResolver(key, parent.res[key]);
        }
      }
    }
    this._resolvers.set(IContainer, containerResolver);
  }
  register(...params) {
    if (++this._registerDepth === 100) {
      throw createMappedError$6(6, ...params);
    }
    let current;
    let keys;
    let value;
    let j2;
    let jj;
    let i3 = 0;
    let ii = params.length;
    let def2;
    for (; i3 < ii; ++i3) {
      current = params[i3];
      if (!isObjectOrFunction(current)) {
        continue;
      }
      if (isRegistry(current)) {
        current.register(this);
      } else if ((def2 = getMetadata$2(resourceBaseName, current)) != null) {
        def2.register(this);
      } else if (isClass(current)) {
        const registrable = current[Symbol.metadata]?.[registrableMetadataKey];
        if (isRegistry(registrable)) {
          registrable.register(this);
        } else if (isString(current.$au?.type)) {
          const $au = current.$au;
          const aliases = (current.aliases ?? emptyArray).concat($au.aliases ?? emptyArray);
          let key = `${resourceBaseName}:${$au.type}:${$au.name}`;
          if (this.has(key, false)) {
            {
              globalThis.console?.warn(createMappedError$6(7, key));
            }
            continue;
          }
          aliasToRegistration(current, key).register(this);
          if (!this.has(current, false)) {
            singletonRegistration$2(current, current).register(this);
          }
          j2 = 0;
          jj = aliases.length;
          for (; j2 < jj; ++j2) {
            key = `${resourceBaseName}:${$au.type}:${aliases[j2]}`;
            if (this.has(key, false)) {
              {
                globalThis.console?.warn(createMappedError$6(7, key));
              }
              continue;
            }
            aliasToRegistration(current, key).register(this);
          }
        } else {
          singletonRegistration$2(current, current).register(this);
        }
      } else {
        keys = Object.keys(current);
        j2 = 0;
        jj = keys.length;
        for (; j2 < jj; ++j2) {
          value = current[keys[j2]];
          if (!isObjectOrFunction(value)) {
            continue;
          }
          if (isRegistry(value)) {
            value.register(this);
          } else {
            this.register(value);
          }
        }
      }
    }
    --this._registerDepth;
    return this;
  }
  registerResolver(key, resolver, isDisposable = false) {
    validateKey(key);
    const resolvers = this._resolvers;
    const result = resolvers.get(key);
    if (result == null) {
      resolvers.set(key, resolver);
      if (isResourceKey(key)) {
        if (this.res[key] !== void 0) {
          throw createMappedError$6(7, key);
        }
        this.res[key] = resolver;
      }
    } else if (result instanceof Resolver && result._strategy === 4) {
      result._state.push(resolver);
    } else {
      resolvers.set(key, new Resolver(key, 4, [result, resolver]));
    }
    if (isDisposable) {
      this._disposableResolvers.set(key, resolver);
    }
    return resolver;
  }
  deregister(key) {
    validateKey(key);
    const resolver = this._resolvers.get(key);
    if (resolver != null) {
      this._resolvers.delete(key);
      if (isResourceKey(key)) {
        delete this.res[key];
      }
      if (this._disposableResolvers.has(key)) {
        resolver.dispose();
        this._disposableResolvers.delete(key);
      }
    }
  }
  // public deregisterResolverFor<K extends Key>(key: K, searchAncestors: boolean): void {
  //   validateKey(key);
  //   // eslint-disable-next-line @typescript-eslint/no-this-alias
  //   let current: Container | null = this;
  //   let resolver: IResolver | undefined;
  //   while (current != null) {
  //     resolver = current._resolvers.get(key);
  //     if (resolver != null) {
  //       current._resolvers.delete(key);
  //       break;
  //     }
  //     if (current.parent == null) { return; }
  //     current = searchAncestors ? current.parent : null;
  //   }
  //   if (resolver == null) { return; }
  //   if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {
  //     throw createError('Cannot deregister a resolver with array strategy');
  //   }
  //   if (this._disposableResolvers.has(resolver as IDisposableResolver<K>)) {
  //     (resolver as IDisposableResolver<K>).dispose();
  //   }
  //   if (isResourceKey(key)) {
  //     // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
  //     delete this.res[key];
  //   }
  // }
  registerTransformer(key, transformer) {
    const resolver = this.getResolver(key);
    if (resolver == null) {
      return false;
    }
    if (resolver.getFactory) {
      const factory = resolver.getFactory(this);
      if (factory == null) {
        return false;
      }
      factory.registerTransformer(transformer);
      return true;
    }
    return false;
  }
  getResolver(key, autoRegister = true) {
    validateKey(key);
    if (key.resolve !== void 0) {
      return key;
    }
    const previousContainer = currentContainer;
    let current = currentContainer = this;
    let resolver;
    let handler;
    try {
      while (current != null) {
        resolver = current._resolvers.get(key);
        if (resolver == null) {
          if (current._parent == null) {
            handler = isRegisterInRequester(key) ? this : current;
            if (autoRegister) {
              return this._jitRegister(key, handler);
            }
            return null;
          }
          current = current._parent;
        } else {
          return resolver;
        }
      }
    } finally {
      currentContainer = previousContainer;
    }
    return null;
  }
  has(key, searchAncestors = false) {
    return this._resolvers.has(key) || isResourceKey(key) && key in this.res || ((searchAncestors && this._parent?.has(key, true)) ?? false);
  }
  get(key) {
    validateKey(key);
    if (key.$isResolver) {
      return key.resolve(this, this);
    }
    const previousContainer = currentContainer;
    let current = currentContainer = this;
    let resolver;
    let handler;
    try {
      while (current != null) {
        resolver = current._resolvers.get(key);
        if (resolver == null) {
          if (current._parent == null) {
            handler = isRegisterInRequester(key) ? this : current;
            resolver = this._jitRegister(key, handler);
            return resolver.resolve(current, this);
          }
          current = current._parent;
        } else {
          return resolver.resolve(current, this);
        }
      }
    } finally {
      currentContainer = previousContainer;
    }
    throw createMappedError$6(8, key);
  }
  getAll(key, searchAncestors = false) {
    validateKey(key);
    const previousContainer = currentContainer;
    const requestor = currentContainer = this;
    let current = requestor;
    let resolver;
    let resolutions = emptyArray;
    try {
      if (searchAncestors) {
        while (current != null) {
          resolver = current._resolvers.get(key);
          if (resolver != null) {
            resolutions = resolutions.concat(buildAllResponse(resolver, current, requestor));
          }
          current = current._parent;
        }
        return resolutions;
      }
      while (current != null) {
        resolver = current._resolvers.get(key);
        if (resolver == null) {
          current = current._parent;
          if (current == null) {
            return emptyArray;
          }
        } else {
          return buildAllResponse(resolver, current, requestor);
        }
      }
    } finally {
      currentContainer = previousContainer;
    }
    return emptyArray;
  }
  invoke(Type, dynamicDependencies) {
    if (isNativeFunction(Type)) {
      throw createMappedError$6(15, Type);
    }
    const previousContainer = currentContainer;
    currentContainer = this;
    {
      let resolvedDeps;
      let dep;
      try {
        resolvedDeps = getDependencies(Type).map((_2) => this.get(dep = _2));
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!Type.name ? `(Anonymous) ${String(Type)}` : Type.name}, caused by dependency: ${String(dep)}`);
        currentContainer = previousContainer;
        throw ex;
      }
      try {
        return dynamicDependencies === void 0 ? new Type(...resolvedDeps) : new Type(...resolvedDeps, ...dynamicDependencies);
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!Type.name ? `(Anonymous) ${String(Type)}` : Type.name}`);
        throw ex;
      } finally {
        currentContainer = previousContainer;
      }
    }
    try {
      return dynamicDependencies === void 0 ? new Type(...getDependencies(Type).map(containerGetKey, this)) : new Type(...getDependencies(Type).map(containerGetKey, this), ...dynamicDependencies);
    } finally {
      currentContainer = previousContainer;
    }
  }
  hasFactory(key) {
    return this._factories.has(key);
  }
  getFactory(Type) {
    let factory = this._factories.get(Type);
    if (factory === void 0) {
      if (isNativeFunction(Type)) {
        throw createMappedError$6(15, Type);
      }
      this._factories.set(Type, factory = new Factory(Type, getDependencies(Type)));
    }
    return factory;
  }
  registerFactory(key, factory) {
    this._factories.set(key, factory);
  }
  createChild(config) {
    if (config === void 0 && this.config.inheritParentResources) {
      if (this.config === ContainerConfiguration.DEFAULT) {
        return new Container(this, this.config);
      }
      return new Container(this, ContainerConfiguration.from({
        ...this.config,
        inheritParentResources: false
      }));
    }
    return new Container(this, ContainerConfiguration.from(config ?? this.config));
  }
  disposeResolvers() {
    const resolvers = this._resolvers;
    const disposableResolvers = this._disposableResolvers;
    let disposable;
    let key;
    for ([key, disposable] of disposableResolvers.entries()) {
      disposable.dispose?.();
      resolvers.delete(key);
    }
    disposableResolvers.clear();
  }
  useResources(container) {
    const res = container.res;
    for (const key in res) {
      this.registerResolver(key, res[key]);
    }
  }
  find(keyOrKind, name2) {
    const key = isString(name2) ? `${resourceBaseName}:${keyOrKind}:${name2}` : keyOrKind;
    let container = this;
    let resolver = container.res[key];
    if (resolver == null) {
      container = container.root;
      resolver = container.res[key];
    }
    if (resolver == null) {
      return null;
    }
    return resolver.getFactory?.(container)?.Type ?? null;
  }
  dispose() {
    if (this._disposableResolvers.size > 0) {
      this.disposeResolvers();
    }
    this._resolvers.clear();
    if (this.root === this) {
      this._factories.clear();
      this.res = {};
    }
  }
  /** @internal */
  _jitRegister(keyAsValue, handler) {
    const $isRegistry = isRegistry(keyAsValue);
    if (!isFunction(keyAsValue) && !$isRegistry) {
      throw createMappedError$6(9, keyAsValue);
    }
    if (InstrinsicTypeNames.has(keyAsValue.name)) {
      throw createMappedError$6(10, keyAsValue);
    }
    if ($isRegistry) {
      const registrationResolver = keyAsValue.register(handler, keyAsValue);
      if (!(registrationResolver instanceof Object) || registrationResolver.resolve == null) {
        const newResolver = handler._resolvers.get(keyAsValue);
        if (newResolver != null) {
          return newResolver;
        }
        throw createMappedError$6(11, keyAsValue);
      }
      return registrationResolver;
    }
    if (keyAsValue.$isInterface) {
      throw createMappedError$6(12, keyAsValue.friendlyName);
    }
    const resolver = this.config.defaultResolver(keyAsValue, handler);
    handler._resolvers.set(keyAsValue, resolver);
    return resolver;
  }
}
class Factory {
  constructor(Type, dependencies2) {
    this.Type = Type;
    this.dependencies = dependencies2;
    this.transformers = null;
  }
  construct(container, dynamicDependencies) {
    const previousContainer = currentContainer;
    currentContainer = container;
    let instance;
    {
      let resolvedDeps;
      let dep;
      try {
        resolvedDeps = this.dependencies.map((_2) => container.get(dep = _2));
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!this.Type.name ? `(Anonymous) ${String(this.Type)}` : this.Type.name}, caused by dependency: ${String(dep)}`);
        currentContainer = previousContainer;
        throw ex;
      }
      try {
        if (dynamicDependencies === void 0) {
          instance = new this.Type(...resolvedDeps);
        } else {
          instance = new this.Type(...resolvedDeps, ...dynamicDependencies);
        }
        if (this.transformers == null) {
          return instance;
        }
        return this.transformers.reduce(transformInstance, instance);
      } catch (ex) {
        logError(`[DEV:aurelia] Error during construction of ${!this.Type.name ? `(Anonymous) ${String(this.Type)}` : this.Type.name}`);
        throw ex;
      } finally {
        currentContainer = previousContainer;
      }
    }
    try {
      if (dynamicDependencies === void 0) {
        instance = new this.Type(...this.dependencies.map(containerGetKey, container));
      } else {
        instance = new this.Type(...this.dependencies.map(containerGetKey, container), ...dynamicDependencies);
      }
      if (this.transformers == null) {
        return instance;
      }
      return this.transformers.reduce(transformInstance, instance);
    } finally {
      currentContainer = previousContainer;
    }
  }
  registerTransformer(transformer) {
    (this.transformers ??= []).push(transformer);
  }
}
function transformInstance(inst, transform) {
  return transform(inst);
}
function validateKey(key) {
  if (key === null || key === void 0) {
    throw createMappedError$6(
      14
      /* ErrorNames.null_undefined_key */
    );
  }
}
function containerGetKey(d2) {
  return this.get(d2);
}
function resolve(...keys) {
  if (currentContainer == null) {
    throw createMappedError$6(16, ...keys);
  }
  {
    if (keys.length === 1) {
      try {
        return currentContainer.get(keys[0]);
      } catch (ex) {
        logError(`[DEV:aurelia] resolve() call error for: ${String(keys[0])}`);
        throw ex;
      }
    } else {
      let key;
      try {
        return keys.map((_2) => currentContainer.get(key = _2));
      } catch (ex) {
        logError(`[DEV:aurelia] resolve() call error for: ${String(key)}`);
        throw ex;
      }
    }
  }
  return keys.length === 1 ? currentContainer.get(keys[0]) : keys.map(containerGetKey, currentContainer);
}
const buildAllResponse = (resolver, handler, requestor) => {
  if (resolver instanceof Resolver && resolver._strategy === 4) {
    const state = resolver._state;
    const ii = state.length;
    const results = Array(ii);
    let i3 = 0;
    for (; i3 < ii; ++i3) {
      results[i3] = state[i3].resolve(handler, requestor);
    }
    return results;
  }
  return [resolver.resolve(handler, requestor)];
};
const containerResolver = {
  $isResolver: true,
  resolve(handler, requestor) {
    return requestor;
  }
};
const isRegistry = (obj) => isFunction(obj?.register);
const isSelfRegistry = (obj) => isRegistry(obj) && typeof obj.registerInRequestor === "boolean";
const isRegisterInRequester = (obj) => isSelfRegistry(obj) && obj.registerInRequestor;
const isClass = (obj) => obj.prototype !== void 0;
const isResourceKey = (key) => isString(key) && key.indexOf(":") > 0;
class ResolverBuilder {
  constructor(_container, _key) {
    this._container = _container;
    this._key = _key;
  }
  instance(value) {
    return this._registerResolver(0, value);
  }
  singleton(value) {
    return this._registerResolver(1, value);
  }
  transient(value) {
    return this._registerResolver(2, value);
  }
  callback(value) {
    return this._registerResolver(3, value);
  }
  cachedCallback(value) {
    return this._registerResolver(3, cacheCallbackResult(value));
  }
  aliasTo(destinationKey) {
    return this._registerResolver(5, destinationKey);
  }
  /** @internal */
  _registerResolver(strategy, state) {
    const { _container: container, _key: key } = this;
    this._container = this._key = void 0;
    return container.registerResolver(key, new Resolver(key, strategy, state));
  }
}
const cloneArrayWithPossibleProps = (source) => {
  const clone = source.slice();
  const keys = Object.keys(source);
  const len = keys.length;
  let key;
  for (let i3 = 0; i3 < len; ++i3) {
    key = keys[i3];
    if (!isArrayIndex(key)) {
      clone[key] = source[key];
    }
  }
  return clone;
};
const diParamTypesKeys = getAnnotationKeyFor$1("di:paramtypes");
const getAnnotationParamtypes = (Type) => {
  return getMetadata$2(diParamTypesKeys, Type);
};
const getDesignParamtypes = (Type) => getMetadata$2("design:paramtypes", Type);
const getOrCreateAnnotationParamTypes = (context) => {
  return context.metadata[diParamTypesKeys] ??= [];
};
const getDependencies = (Type) => {
  const key = getAnnotationKeyFor$1("di:dependencies");
  let dependencies2 = getMetadata$2(key, Type);
  if (dependencies2 === void 0) {
    const inject2 = Type.inject;
    if (inject2 === void 0) {
      const designParamtypes = getDesignParamtypes(Type);
      const annotationParamtypes = getAnnotationParamtypes(Type);
      if (designParamtypes === void 0) {
        if (annotationParamtypes === void 0) {
          const Proto = Object.getPrototypeOf(Type);
          if (isFunction(Proto) && Proto !== Function.prototype) {
            dependencies2 = cloneArrayWithPossibleProps(getDependencies(Proto));
          } else {
            dependencies2 = [];
          }
        } else {
          dependencies2 = cloneArrayWithPossibleProps(annotationParamtypes);
        }
      } else if (annotationParamtypes === void 0) {
        dependencies2 = cloneArrayWithPossibleProps(designParamtypes);
      } else {
        dependencies2 = cloneArrayWithPossibleProps(designParamtypes);
        let len = annotationParamtypes.length;
        let auAnnotationParamtype;
        let i3 = 0;
        for (; i3 < len; ++i3) {
          auAnnotationParamtype = annotationParamtypes[i3];
          if (auAnnotationParamtype !== void 0) {
            dependencies2[i3] = auAnnotationParamtype;
          }
        }
        const keys = Object.keys(annotationParamtypes);
        let key2;
        i3 = 0;
        len = keys.length;
        for (i3 = 0; i3 < len; ++i3) {
          key2 = keys[i3];
          if (!isArrayIndex(key2)) {
            dependencies2[key2] = annotationParamtypes[key2];
          }
        }
      }
    } else {
      dependencies2 = cloneArrayWithPossibleProps(inject2);
    }
    defineMetadata$2(dependencies2, Type, key);
  }
  return dependencies2;
};
const createInterface$1 = (configureOrName, configuror) => {
  const configure2 = isFunction(configureOrName) ? configureOrName : configuror;
  const friendlyName = (isString(configureOrName) ? configureOrName : void 0) ?? "(anonymous)";
  const Interface = {
    // Old code kept with the hope that the argument decorator proposal will be standardized by TC39 (https://github.com/tc39/proposal-class-method-parameter-decorators)
    // function(_target: Injectable | AbstractInjectable, _property: string | symbol | undefined, _index: number | undefined): void {
    //    if (target == null || new.target !== undefined) {
    //     throw createMappedError(ErrorNames.no_registration_for_interface, friendlyName);
    //    }
    //    const annotationParamtypes = getOrCreateAnnotationParamTypes(target as Injectable);
    //    annotationParamtypes[index!] = Interface;
    // },
    $isInterface: true,
    friendlyName,
    toString: () => `InterfaceSymbol<${friendlyName}>`,
    register: configure2 != null ? (container, key) => configure2(new ResolverBuilder(container, key ?? Interface)) : void 0
  };
  return Interface;
};
const inject = (...dependencies2) => {
  return (decorated, context) => {
    switch (context.kind) {
      case "class": {
        const annotationParamtypes = getOrCreateAnnotationParamTypes(context);
        let dep;
        let i3 = 0;
        for (; i3 < dependencies2.length; ++i3) {
          dep = dependencies2[i3];
          if (dep !== void 0) {
            annotationParamtypes[i3] = dep;
          }
        }
        break;
      }
      case "field": {
        const annotationParamtypes = getOrCreateAnnotationParamTypes(context);
        const dep = dependencies2[0];
        if (dep !== void 0) {
          annotationParamtypes[context.name] = dep;
        }
        break;
      }
      default:
        throw createMappedError$6(22, String(context.name), context.kind);
    }
  };
};
const DI = /* @__PURE__ */ (() => {
  initializeTC39Metadata();
  return {
    createContainer: createContainer$1,
    getDesignParamtypes,
    // getAnnotationParamtypes,
    // getOrCreateAnnotationParamTypes,
    getDependencies,
    /**
     * creates a decorator that also matches an interface and can be used as a {@linkcode Key}.
     * ```ts
     * const ILogger = DI.createInterface<Logger>('Logger');
     * container.register(Registration.singleton(ILogger, getSomeLogger()));
     * const log = container.get(ILogger);
     * log.info('hello world');
     * class Foo {
     *   constructor( @ILogger log: ILogger ) {
     *     log.info('hello world');
     *   }
     * }
     * ```
     * you can also build default registrations into your interface.
     * ```ts
     * export const ILogger = DI.createInterface<Logger>('Logger', builder => builder.cachedCallback(LoggerDefault));
     * const log = container.get(ILogger);
     * log.info('hello world');
     * class Foo {
     *   constructor( @ILogger log: ILogger ) {
     *     log.info('hello world');
     *   }
     * }
     * ```
     * but these default registrations won't work the same with other decorators that take keys, for example
     * ```ts
     * export const MyStr = DI.createInterface<string>('MyStr', builder => builder.instance('somestring'));
     * class Foo {
     *   constructor( @optional(MyStr) public readonly str: string ) {
     *   }
     * }
     * container.get(Foo).str; // returns undefined
     * ```
     * to fix this add this line somewhere before you do a `get`
     * ```ts
     * container.register(MyStr);
     * container.get(Foo).str; // returns 'somestring'
     * ```
     *
     * - @param configureOrName - supply a string to improve error messaging
     */
    createInterface: createInterface$1,
    inject,
    /**
     * Registers the `target` class as a transient dependency; each time the dependency is resolved
     * a new instance will be created.
     *
     * @param target - The class / constructor function to register as transient.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     *
     * @example ```ts
     * // On an existing class
     * class Foo { }
     * DI.transient(Foo);
     *
     * // Inline declaration
     * const Foo = DI.transient(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    transient(target) {
      target.register = function(container) {
        const registration = transientRegistation(target, target);
        return registration.register(container, target);
      };
      target.registerInRequestor = false;
      return target;
    },
    /**
     * Registers the `target` class as a singleton dependency; the class will only be created once. Each
     * consecutive time the dependency is resolved, the same instance will be returned.
     *
     * @param target - The class / constructor function to register as a singleton.
     * @returns The same class, with a static `register` method that takes a container and returns the appropriate resolver.
     * @example ```ts
     * // On an existing class
     * class Foo { }
     * DI.singleton(Foo);
     *
     * // Inline declaration
     * const Foo = DI.singleton(class { });
     * // Foo is now strongly typed with register
     * Foo.register(container);
     * ```
     */
    singleton(target, options = defaultSingletonOptions) {
      target.register = function(container) {
        const registration = singletonRegistration$2(target, target);
        return registration.register(container, target);
      };
      target.registerInRequestor = options.scoped;
      return target;
    }
  };
})();
const IContainer = /* @__PURE__ */ createInterface$1("IContainer");
const IServiceLocator = IContainer;
function transientDecorator(target, context) {
  return DI.transient(target);
}
function transient(target, context) {
  return target == null ? transientDecorator : transientDecorator(target);
}
const defaultSingletonOptions = { scoped: false };
class Resolver {
  get $isResolver() {
    return true;
  }
  constructor(key, strategy, state) {
    this._resolving = false;
    this._cachedFactory = null;
    this._key = key;
    this._strategy = strategy;
    this._state = state;
  }
  register(container, key) {
    return container.registerResolver(key || this._key, this);
  }
  resolve(handler, requestor) {
    switch (this._strategy) {
      case 0:
        return this._state;
      case 1: {
        if (this._resolving) {
          throw createMappedError$6(3, this._state.name);
        }
        this._resolving = true;
        this._state = (this._cachedFactory = handler.getFactory(this._state)).construct(requestor);
        this._strategy = 0;
        this._resolving = false;
        return this._state;
      }
      case 2: {
        const factory = handler.getFactory(this._state);
        if (factory === null) {
          throw createMappedError$6(4, this._key);
        }
        return factory.construct(requestor);
      }
      case 3:
        return this._state(handler, requestor, this);
      case 4:
        return this._state[0].resolve(handler, requestor);
      case 5:
        return requestor.get(this._state);
      default:
        throw createMappedError$6(5, this._strategy);
    }
  }
  getFactory(container) {
    switch (this._strategy) {
      case 1:
      case 2:
        return container.getFactory(this._state);
      case 5:
        return container.getResolver(this._state)?.getFactory?.(container) ?? null;
      case 0:
        return this._cachedFactory;
      default:
        return null;
    }
  }
}
class InstanceProvider {
  get friendlyName() {
    return this._name;
  }
  constructor(name2, instance = null, Type = null) {
    this._name = name2;
    this._instance = instance;
    this._Type = Type;
  }
  prepare(instance) {
    this._instance = instance;
  }
  get $isResolver() {
    return true;
  }
  resolve() {
    if (this._instance == null) {
      throw createMappedError$6(13, this._name);
    }
    return this._instance;
  }
  getFactory(container) {
    return this._Type == null ? null : container.getFactory(this._Type);
  }
  dispose() {
    this._instance = null;
  }
}
class ParameterizedRegistry {
  constructor(key, params) {
    this.key = key;
    this.params = params;
  }
  register(container) {
    if (container.has(this.key, true)) {
      const registry = container.get(this.key);
      registry.register(container, ...this.params);
    } else {
      container.register(...this.params.filter((x2) => typeof x2 === "object"));
    }
  }
}
const emptyArray = objectFreeze$1([]);
const emptyObject = objectFreeze$1({});
function noop$1() {
}
const IPlatform$1 = /* @__PURE__ */ createInterface$1("IPlatform");
function createResolver(getter) {
  return function(key) {
    function Resolver2(target, context) {
      inject(Resolver2)(target, context);
    }
    Resolver2.$isResolver = true;
    Resolver2.resolve = function(handler, requestor) {
      return getter(key, handler, requestor);
    };
    return Resolver2;
  };
}
const all = (key, searchAncestors = false) => {
  function resolver(decorated, context) {
    inject(resolver)(decorated, context);
  }
  resolver.$isResolver = true;
  resolver.resolve = (handler, requestor) => requestor.getAll(key, searchAncestors);
  return resolver;
};
const optional = /* @__PURE__ */ createResolver((key, handler, requestor) => {
  if (requestor.has(key, true)) {
    return requestor.get(key);
  } else {
    return void 0;
  }
});
const own = /* @__PURE__ */ createResolver((key, handler, requestor) => {
  return requestor.has(key, false) ? requestor.get(key) : void 0;
});
const resource = /* @__PURE__ */ createResolver((key, handler, requestor) => requestor.has(key, false) ? requestor.get(key) : requestor.root.get(key));
const optionalResource = /* @__PURE__ */ createResolver((key, handler, requestor) => requestor.has(key, false) ? requestor.get(key) : requestor.root.has(key, false) ? requestor.root.get(key) : void 0);
const allResources = /* @__PURE__ */ createResolver((key, handler, requestor) => (
  // prevent duplicate retrieval
  requestor === requestor.root ? requestor.getAll(key, false) : requestor.has(key, false) ? requestor.getAll(key, false).concat(requestor.root.getAll(key, false)) : requestor.root.getAll(key, false)
));
function __esDecorate$2(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function") throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {};
  var _2, done = false;
  for (var i3 = decorators.length - 1; i3 >= 0; i3--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f2) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i3])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_2 = accept(result.get)) descriptor.get = _2;
      if (_2 = accept(result.set)) descriptor.set = _2;
      if (_2 = accept(result.init)) initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field") initializers.unshift(_2);
      else descriptor[key] = _2;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers$3(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i3 = 0; i3 < initializers.length; i3++) {
    value = useValue ? initializers[i3].call(thisArg, value) : initializers[i3].call(thisArg);
  }
  return useValue ? value : void 0;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
const trace$1 = 0;
const debug$1 = 1;
const info = 2;
const warn$1 = 3;
const error$1 = 4;
const fatal = 5;
const none$1 = 6;
const LogLevel = objectFreeze$1({
  /**
   * The most detailed information about internal app state.
   *
   * Disabled by default and should never be enabled in a production environment.
   */
  trace: trace$1,
  /**
   * Information that is useful for debugging during development and has no long-term value.
   */
  debug: debug$1,
  /**
   * Information about the general flow of the application that has long-term value.
   */
  info,
  /**
   * Unexpected circumstances that require attention but do not otherwise cause the current flow of execution to stop.
   */
  warn: warn$1,
  /**
   * Unexpected circumstances that cause the flow of execution in the current activity to stop but do not cause an app-wide failure.
   */
  error: error$1,
  /**
   * Unexpected circumstances that cause an app-wide failure or otherwise require immediate attention.
   */
  fatal,
  /**
   * No messages should be written.
   */
  none: none$1
});
const ILogConfig = /* @__PURE__ */ createInterface$1("ILogConfig", (x2) => x2.instance(new LogConfig("no-colors", warn$1)));
const ISink = /* @__PURE__ */ createInterface$1("ISink");
const ILogEventFactory = /* @__PURE__ */ createInterface$1("ILogEventFactory", (x2) => x2.singleton(DefaultLogEventFactory));
const ILogger = /* @__PURE__ */ createInterface$1("ILogger", (x2) => x2.singleton(DefaultLogger));
const ILogScopes = /* @__PURE__ */ createInterface$1("ILogScope");
const LoggerSink = /* @__PURE__ */ objectFreeze$1({
  key: getAnnotationKeyFor$1("logger-sink-handles"),
  define(target, definition) {
    defineMetadata$2(definition.handles, target, this.key);
  },
  getHandles(target) {
    return getMetadata$2(this.key, target.constructor);
  }
});
const format = toLookup({
  red(str) {
    return `\x1B[31m${str}\x1B[39m`;
  },
  green(str) {
    return `\x1B[32m${str}\x1B[39m`;
  },
  yellow(str) {
    return `\x1B[33m${str}\x1B[39m`;
  },
  blue(str) {
    return `\x1B[34m${str}\x1B[39m`;
  },
  magenta(str) {
    return `\x1B[35m${str}\x1B[39m`;
  },
  cyan(str) {
    return `\x1B[36m${str}\x1B[39m`;
  },
  white(str) {
    return `\x1B[37m${str}\x1B[39m`;
  },
  grey(str) {
    return `\x1B[90m${str}\x1B[39m`;
  }
});
class LogConfig {
  constructor(colorOptions, level) {
    this.colorOptions = colorOptions;
    this.level = level;
  }
}
const getLogLevelString = function() {
  const logLevelString = {
    "no-colors": toLookup({
      TRC: "TRC",
      DBG: "DBG",
      INF: "INF",
      WRN: "WRN",
      ERR: "ERR",
      FTL: "FTL",
      QQQ: "???"
    }),
    "colors": toLookup({
      TRC: format.grey("TRC"),
      DBG: format.grey("DBG"),
      INF: format.white("INF"),
      WRN: format.yellow("WRN"),
      ERR: format.red("ERR"),
      FTL: format.red("FTL"),
      QQQ: format.grey("???")
    })
  };
  return (level, colorOptions) => {
    if (level <= trace$1) {
      return logLevelString[colorOptions].TRC;
    }
    if (level <= debug$1) {
      return logLevelString[colorOptions].DBG;
    }
    if (level <= info) {
      return logLevelString[colorOptions].INF;
    }
    if (level <= warn$1) {
      return logLevelString[colorOptions].WRN;
    }
    if (level <= error$1) {
      return logLevelString[colorOptions].ERR;
    }
    if (level <= fatal) {
      return logLevelString[colorOptions].FTL;
    }
    return logLevelString[colorOptions].QQQ;
  };
}();
const getScopeString = (scope, colorOptions) => {
  if (colorOptions === "no-colors") {
    return scope.join(".");
  }
  return scope.map(format.cyan).join(".");
};
const getIsoString = (timestamp, colorOptions) => {
  if (colorOptions === "no-colors") {
    return new Date(timestamp).toISOString();
  }
  return format.grey(new Date(timestamp).toISOString());
};
class DefaultLogEvent {
  constructor(severity, message, optionalParams, scope, colorOptions, timestamp) {
    this.severity = severity;
    this.message = message;
    this.optionalParams = optionalParams;
    this.scope = scope;
    this.colorOptions = colorOptions;
    this.timestamp = timestamp;
  }
  toString() {
    const { severity, message, scope, colorOptions, timestamp } = this;
    if (scope.length === 0) {
      return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}] ${message}`;
    }
    return `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)} ${getScopeString(scope, colorOptions)}] ${message}`;
  }
  getFormattedLogInfo(forConsole = false) {
    const { severity, message: messageOrError, scope, colorOptions, timestamp, optionalParams } = this;
    let error2 = null;
    let message = "";
    if (forConsole && messageOrError instanceof Error) {
      error2 = messageOrError;
    } else {
      message = messageOrError;
    }
    const scopeInfo = scope.length === 0 ? "" : ` ${getScopeString(scope, colorOptions)}`;
    let msg = `${getIsoString(timestamp, colorOptions)} [${getLogLevelString(severity, colorOptions)}${scopeInfo}] ${message}`;
    if (optionalParams === void 0 || optionalParams.length === 0) {
      return error2 === null ? [msg] : [msg, error2];
    }
    let offset2 = 0;
    while (msg.includes("%s")) {
      msg = msg.replace("%s", String(optionalParams[offset2++]));
    }
    return error2 !== null ? [msg, error2, ...optionalParams.slice(offset2)] : [msg, ...optionalParams.slice(offset2)];
  }
}
class DefaultLogEventFactory {
  constructor() {
    this.config = resolve(ILogConfig);
  }
  createLogEvent(logger, level, message, optionalParams) {
    return new DefaultLogEvent(level, message, optionalParams, logger.scope, this.config.colorOptions, Date.now());
  }
}
let DefaultLogger = (() => {
  var _a2;
  let _instanceExtraInitializers = [];
  let _trace_decorators;
  let _debug_decorators;
  let _info_decorators;
  let _warn_decorators;
  let _error_decorators;
  let _fatal_decorators;
  return _a2 = class DefaultLogger {
    /* eslint-disable default-param-last */
    constructor(config = resolve(ILogConfig), factory = resolve(ILogEventFactory), sinks = resolve(all(ISink)), scope = resolve(optional(ILogScopes)) ?? [], parent = null) {
      this.scope = (__runInitializers$3(this, _instanceExtraInitializers), scope);
      this._scopedLoggers = createLookup$1();
      let traceSinks;
      let debugSinks;
      let infoSinks;
      let warnSinks;
      let errorSinks;
      let fatalSinks;
      this.config = config;
      this._factory = factory;
      this.sinks = sinks;
      if (parent === null) {
        this.root = this;
        this.parent = this;
        traceSinks = this._traceSinks = [];
        debugSinks = this._debugSinks = [];
        infoSinks = this._infoSinks = [];
        warnSinks = this._warnSinks = [];
        errorSinks = this._errorSinks = [];
        fatalSinks = this._fatalSinks = [];
        for (const $sink of sinks) {
          const handles = LoggerSink.getHandles($sink);
          if (handles?.includes(trace$1) ?? true) {
            traceSinks.push($sink);
          }
          if (handles?.includes(debug$1) ?? true) {
            debugSinks.push($sink);
          }
          if (handles?.includes(info) ?? true) {
            infoSinks.push($sink);
          }
          if (handles?.includes(warn$1) ?? true) {
            warnSinks.push($sink);
          }
          if (handles?.includes(error$1) ?? true) {
            errorSinks.push($sink);
          }
          if (handles?.includes(fatal) ?? true) {
            fatalSinks.push($sink);
          }
        }
      } else {
        this.root = parent.root;
        this.parent = parent;
        traceSinks = this._traceSinks = parent._traceSinks;
        debugSinks = this._debugSinks = parent._debugSinks;
        infoSinks = this._infoSinks = parent._infoSinks;
        warnSinks = this._warnSinks = parent._warnSinks;
        errorSinks = this._errorSinks = parent._errorSinks;
        fatalSinks = this._fatalSinks = parent._fatalSinks;
      }
    }
    trace(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= trace$1) {
        this._emit(this._traceSinks, trace$1, messageOrGetMessage, optionalParams);
      }
    }
    debug(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= debug$1) {
        this._emit(this._debugSinks, debug$1, messageOrGetMessage, optionalParams);
      }
    }
    info(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= info) {
        this._emit(this._infoSinks, info, messageOrGetMessage, optionalParams);
      }
    }
    warn(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= warn$1) {
        this._emit(this._warnSinks, warn$1, messageOrGetMessage, optionalParams);
      }
    }
    error(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= error$1) {
        this._emit(this._errorSinks, error$1, messageOrGetMessage, optionalParams);
      }
    }
    fatal(messageOrGetMessage, ...optionalParams) {
      if (this.config.level <= fatal) {
        this._emit(this._fatalSinks, fatal, messageOrGetMessage, optionalParams);
      }
    }
    /**
     * Create a new logger with an additional permanent prefix added to the logging outputs.
     * When chained, multiple scopes are separated by a dot.
     *
     * This is preliminary API and subject to change before alpha release.
     *
     * @example
     *
     * ```ts
     * export class MyComponent {
     *   constructor(@ILogger private logger: ILogger) {
     *     this.logger.debug('before scoping');
     *     // console output: '[DBG] before scoping'
     *     this.logger = logger.scopeTo('MyComponent');
     *     this.logger.debug('after scoping');
     *     // console output: '[DBG MyComponent] after scoping'
     *   }
     *
     *   public doStuff(): void {
     *     const logger = this.logger.scopeTo('doStuff()');
     *     logger.debug('doing stuff');
     *     // console output: '[DBG MyComponent.doStuff()] doing stuff'
     *   }
     * }
     * ```
     */
    scopeTo(name2) {
      const scopedLoggers = this._scopedLoggers;
      let scopedLogger = scopedLoggers[name2];
      if (scopedLogger === void 0) {
        scopedLogger = scopedLoggers[name2] = new _a2(this.config, this._factory, null, this.scope.concat(name2), this);
      }
      return scopedLogger;
    }
    /** @internal */
    _emit(sinks, level, msgOrGetMsg, optionalParams) {
      const message = isFunction(msgOrGetMsg) ? msgOrGetMsg() : msgOrGetMsg;
      const event = this._factory.createLogEvent(this, level, message, optionalParams);
      for (let i3 = 0, ii = sinks.length; i3 < ii; ++i3) {
        sinks[i3].handleEvent(event);
      }
    }
  }, (() => {
    const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    _trace_decorators = [bound];
    _debug_decorators = [bound];
    _info_decorators = [bound];
    _warn_decorators = [bound];
    _error_decorators = [bound];
    _fatal_decorators = [bound];
    __esDecorate$2(_a2, null, _trace_decorators, { kind: "method", name: "trace", static: false, private: false, access: { has: (obj) => "trace" in obj, get: (obj) => obj.trace }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$2(_a2, null, _debug_decorators, { kind: "method", name: "debug", static: false, private: false, access: { has: (obj) => "debug" in obj, get: (obj) => obj.debug }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$2(_a2, null, _info_decorators, { kind: "method", name: "info", static: false, private: false, access: { has: (obj) => "info" in obj, get: (obj) => obj.info }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$2(_a2, null, _warn_decorators, { kind: "method", name: "warn", static: false, private: false, access: { has: (obj) => "warn" in obj, get: (obj) => obj.warn }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$2(_a2, null, _error_decorators, { kind: "method", name: "error", static: false, private: false, access: { has: (obj) => "error" in obj, get: (obj) => obj.error }, metadata: _metadata }, null, _instanceExtraInitializers);
    __esDecorate$2(_a2, null, _fatal_decorators, { kind: "method", name: "fatal", static: false, private: false, access: { has: (obj) => "fatal" in obj, get: (obj) => obj.fatal }, metadata: _metadata }, null, _instanceExtraInitializers);
    if (_metadata) Object.defineProperty(_a2, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
  })(), _a2;
})();
const IModuleLoader = /* @__PURE__ */ createInterface$1((x2) => x2.singleton(ModuleLoader));
const noTransform = (m2) => m2;
class ModuleTransformer {
  constructor(transform) {
    this._promiseCache = /* @__PURE__ */ new Map();
    this._objectCache = /* @__PURE__ */ new Map();
    this._transform = transform;
  }
  transform(objOrPromise) {
    if (objOrPromise instanceof Promise) {
      return this._transformPromise(objOrPromise);
    } else if (typeof objOrPromise === "object" && objOrPromise !== null) {
      return this._transformObject(objOrPromise);
    } else {
      throw createMappedError$6(21, objOrPromise);
    }
  }
  /** @internal */
  _transformPromise(promise) {
    if (this._promiseCache.has(promise)) {
      return this._promiseCache.get(promise);
    }
    const ret = promise.then((obj) => {
      return this._transformObject(obj);
    });
    this._promiseCache.set(promise, ret);
    void ret.then((value) => {
      this._promiseCache.set(promise, value);
    });
    return ret;
  }
  /** @internal */
  _transformObject(obj) {
    if (this._objectCache.has(obj)) {
      return this._objectCache.get(obj);
    }
    const ret = this._transform(this._analyze(obj));
    this._objectCache.set(obj, ret);
    if (ret instanceof Promise) {
      void ret.then((value) => {
        this._objectCache.set(obj, value);
      });
    }
    return ret;
  }
  /** @internal */
  _analyze(m2) {
    if (m2 == null)
      throw createMappedError$6(21, m2);
    if (typeof m2 !== "object")
      return new AnalyzedModule(m2, []);
    let value;
    let isRegistry2;
    let isConstructable;
    let definition;
    const items = [];
    for (const key in m2) {
      switch (typeof (value = m2[key])) {
        case "object":
          if (value === null) {
            continue;
          }
          isRegistry2 = isFunction(value.register);
          isConstructable = false;
          definition = null;
          break;
        case "function":
          isRegistry2 = isFunction(value.register);
          isConstructable = value.prototype !== void 0;
          definition = getMetadata$2(resourceBaseName, value) ?? null;
          break;
        default:
          continue;
      }
      items.push(new ModuleItem(key, value, isRegistry2, isConstructable, definition));
    }
    return new AnalyzedModule(m2, items);
  }
}
class ModuleLoader {
  constructor() {
    this.transformers = /* @__PURE__ */ new Map();
  }
  load(objOrPromise, transform = noTransform) {
    const transformers = this.transformers;
    let transformer = transformers.get(transform);
    if (transformer === void 0) {
      transformers.set(transform, transformer = new ModuleTransformer(transform));
    }
    return transformer.transform(objOrPromise);
  }
  dispose() {
    this.transformers.clear();
  }
}
class AnalyzedModule {
  constructor(raw, items) {
    this.raw = raw;
    this.items = items;
  }
}
class ModuleItem {
  constructor(key, value, isRegistry2, isConstructable, definition) {
    this.key = key;
    this.value = value;
    this.isRegistry = isRegistry2;
    this.isConstructable = isConstructable;
    this.definition = definition;
  }
}
class Handler {
  constructor(type, cb) {
    this.type = type;
    this.cb = cb;
  }
  handle(message) {
    if (message instanceof this.type) {
      this.cb.call(null, message);
    }
  }
}
const IEventAggregator = /* @__PURE__ */ createInterface$1("IEventAggregator", (x2) => x2.singleton(EventAggregator));
class EventAggregator {
  constructor() {
    this.eventLookup = {};
    this.messageHandlers = [];
  }
  publish(channelOrInstance, message) {
    if (!channelOrInstance) {
      throw createMappedError$6(18, channelOrInstance);
    }
    if (isString(channelOrInstance)) {
      let subscribers = this.eventLookup[channelOrInstance];
      if (subscribers !== void 0) {
        subscribers = subscribers.slice();
        let i3 = subscribers.length;
        while (i3-- > 0) {
          subscribers[i3](message, channelOrInstance);
        }
      }
    } else {
      const subscribers = this.messageHandlers.slice();
      let i3 = subscribers.length;
      while (i3-- > 0) {
        subscribers[i3].handle(channelOrInstance);
      }
    }
  }
  subscribe(channelOrType, callback) {
    if (!channelOrType) {
      throw createMappedError$6(19, channelOrType);
    }
    let handler;
    let subscribers;
    if (isString(channelOrType)) {
      if (this.eventLookup[channelOrType] === void 0) {
        this.eventLookup[channelOrType] = [];
      }
      handler = callback;
      subscribers = this.eventLookup[channelOrType];
    } else {
      handler = new Handler(channelOrType, callback);
      subscribers = this.messageHandlers;
    }
    subscribers.push(handler);
    return {
      dispose() {
        const idx = subscribers.indexOf(handler);
        if (idx !== -1) {
          subscribers.splice(idx, 1);
        }
      }
    };
  }
  subscribeOnce(channelOrType, callback) {
    const sub = this.subscribe(channelOrType, (message, event) => {
      sub.dispose();
      callback(message, event);
    });
    return sub;
  }
}
const ekAccessThis = "AccessThis";
const ekAccessBoundary = "AccessBoundary";
const ekAccessGlobal = "AccessGlobal";
const ekAccessScope = "AccessScope";
const ekArrayLiteral = "ArrayLiteral";
const ekObjectLiteral = "ObjectLiteral";
const ekPrimitiveLiteral = "PrimitiveLiteral";
const ekTemplate = "Template";
const ekUnary = "Unary";
const ekCallScope = "CallScope";
const ekCallMember = "CallMember";
const ekCallFunction = "CallFunction";
const ekCallGlobal = "CallGlobal";
const ekAccessMember = "AccessMember";
const ekAccessKeyed = "AccessKeyed";
const ekTaggedTemplate = "TaggedTemplate";
const ekBinary = "Binary";
const ekConditional = "Conditional";
const ekAssign = "Assign";
const ekArrowFunction = "ArrowFunction";
const ekValueConverter = "ValueConverter";
const ekBindingBehavior = "BindingBehavior";
const ekArrayBindingPattern = "ArrayBindingPattern";
const ekObjectBindingPattern = "ObjectBindingPattern";
const ekBindingIdentifier = "BindingIdentifier";
const ekForOfStatement = "ForOfStatement";
const ekInterpolation = "Interpolation";
const ekArrayDestructuring = "ArrayDestructuring";
const ekObjectDestructuring = "ObjectDestructuring";
const ekDestructuringAssignmentLeaf = "DestructuringAssignmentLeaf";
const ekCustom = "Custom";
class CustomExpression {
  constructor(value) {
    this.value = value;
    this.$kind = ekCustom;
  }
  evaluate(...params) {
    return this.value;
  }
  assign(...params) {
    return params;
  }
  bind(...params) {
  }
  unbind(...params) {
  }
  accept(_visitor) {
    return void 0;
  }
}
class BindingBehaviorExpression {
  constructor(expression, name2, args) {
    this.expression = expression;
    this.name = name2;
    this.args = args;
    this.$kind = ekBindingBehavior;
    this.key = `_bb_${name2}`;
  }
}
class ValueConverterExpression {
  constructor(expression, name2, args) {
    this.expression = expression;
    this.name = name2;
    this.args = args;
    this.$kind = ekValueConverter;
  }
}
class AssignExpression {
  constructor(target, value, op = "=") {
    this.target = target;
    this.value = value;
    this.op = op;
    this.$kind = ekAssign;
  }
}
class ConditionalExpression {
  constructor(condition, yes, no) {
    this.condition = condition;
    this.yes = yes;
    this.no = no;
    this.$kind = ekConditional;
  }
}
class AccessGlobalExpression {
  constructor(name2) {
    this.name = name2;
    this.$kind = ekAccessGlobal;
  }
}
class AccessThisExpression {
  constructor(ancestor = 0) {
    this.ancestor = ancestor;
    this.$kind = ekAccessThis;
  }
}
class AccessBoundaryExpression {
  constructor() {
    this.$kind = ekAccessBoundary;
  }
}
class AccessScopeExpression {
  constructor(name2, ancestor = 0) {
    this.name = name2;
    this.ancestor = ancestor;
    this.$kind = ekAccessScope;
  }
}
const isAccessGlobal = (ast) => ast.$kind === ekAccessGlobal || (ast.$kind === ekAccessMember || ast.$kind === ekAccessKeyed) && ast.accessGlobal;
class AccessMemberExpression {
  constructor(object, name2, optional2 = false) {
    this.object = object;
    this.name = name2;
    this.optional = optional2;
    this.$kind = ekAccessMember;
    this.accessGlobal = isAccessGlobal(object);
  }
}
class AccessKeyedExpression {
  constructor(object, key, optional2 = false) {
    this.object = object;
    this.key = key;
    this.optional = optional2;
    this.$kind = ekAccessKeyed;
    this.accessGlobal = isAccessGlobal(object);
  }
}
class CallScopeExpression {
  constructor(name2, args, ancestor = 0, optional2 = false) {
    this.name = name2;
    this.args = args;
    this.ancestor = ancestor;
    this.optional = optional2;
    this.$kind = ekCallScope;
  }
}
class CallMemberExpression {
  constructor(object, name2, args, optionalMember = false, optionalCall = false) {
    this.object = object;
    this.name = name2;
    this.args = args;
    this.optionalMember = optionalMember;
    this.optionalCall = optionalCall;
    this.$kind = ekCallMember;
  }
}
class CallFunctionExpression {
  constructor(func, args, optional2 = false) {
    this.func = func;
    this.args = args;
    this.optional = optional2;
    this.$kind = ekCallFunction;
  }
}
class CallGlobalExpression {
  constructor(name2, args) {
    this.name = name2;
    this.args = args;
    this.$kind = ekCallGlobal;
  }
}
class BinaryExpression {
  constructor(operation, left2, right2) {
    this.operation = operation;
    this.left = left2;
    this.right = right2;
    this.$kind = ekBinary;
  }
}
class UnaryExpression {
  constructor(operation, expression, pos = 0) {
    this.operation = operation;
    this.expression = expression;
    this.pos = pos;
    this.$kind = ekUnary;
  }
}
class PrimitiveLiteralExpression {
  constructor(value) {
    this.value = value;
    this.$kind = ekPrimitiveLiteral;
  }
}
PrimitiveLiteralExpression.$undefined = new PrimitiveLiteralExpression(void 0);
PrimitiveLiteralExpression.$null = new PrimitiveLiteralExpression(null);
PrimitiveLiteralExpression.$true = new PrimitiveLiteralExpression(true);
PrimitiveLiteralExpression.$false = new PrimitiveLiteralExpression(false);
PrimitiveLiteralExpression.$empty = new PrimitiveLiteralExpression("");
class ArrayLiteralExpression {
  constructor(elements2) {
    this.elements = elements2;
    this.$kind = ekArrayLiteral;
  }
}
ArrayLiteralExpression.$empty = new ArrayLiteralExpression(emptyArray);
class ObjectLiteralExpression {
  constructor(keys, values) {
    this.keys = keys;
    this.values = values;
    this.$kind = ekObjectLiteral;
  }
}
ObjectLiteralExpression.$empty = new ObjectLiteralExpression(emptyArray, emptyArray);
class TemplateExpression {
  constructor(cooked, expressions = emptyArray) {
    this.cooked = cooked;
    this.expressions = expressions;
    this.$kind = ekTemplate;
  }
}
TemplateExpression.$empty = new TemplateExpression([""]);
class TaggedTemplateExpression {
  constructor(cooked, raw, func, expressions = emptyArray) {
    this.cooked = cooked;
    this.func = func;
    this.expressions = expressions;
    this.$kind = ekTaggedTemplate;
    cooked.raw = raw;
  }
}
class ArrayBindingPattern {
  // We'll either have elements, or keys+values, but never all 3
  constructor(elements2) {
    this.elements = elements2;
    this.$kind = ekArrayBindingPattern;
  }
}
class ObjectBindingPattern {
  // We'll either have elements, or keys+values, but never all 3
  constructor(keys, values) {
    this.keys = keys;
    this.values = values;
    this.$kind = ekObjectBindingPattern;
  }
}
class BindingIdentifier {
  constructor(name2) {
    this.name = name2;
    this.$kind = ekBindingIdentifier;
  }
}
class ForOfStatement {
  constructor(declaration, iterable, semiIdx) {
    this.declaration = declaration;
    this.iterable = iterable;
    this.semiIdx = semiIdx;
    this.$kind = ekForOfStatement;
  }
}
class Interpolation {
  constructor(parts, expressions = emptyArray) {
    this.parts = parts;
    this.expressions = expressions;
    this.$kind = ekInterpolation;
    this.isMulti = expressions.length > 1;
    this.firstExpression = expressions[0];
  }
}
class DestructuringAssignmentExpression {
  constructor($kind, list, source, initializer) {
    this.$kind = $kind;
    this.list = list;
    this.source = source;
    this.initializer = initializer;
  }
}
class DestructuringAssignmentSingleExpression {
  constructor(target, source, initializer) {
    this.target = target;
    this.source = source;
    this.initializer = initializer;
    this.$kind = ekDestructuringAssignmentLeaf;
  }
}
class DestructuringAssignmentRestExpression {
  constructor(target, indexOrProperties) {
    this.target = target;
    this.indexOrProperties = indexOrProperties;
    this.$kind = ekDestructuringAssignmentLeaf;
  }
}
class ArrowFunction {
  constructor(args, body, rest = false) {
    this.args = args;
    this.body = body;
    this.rest = rest;
    this.$kind = ekArrowFunction;
  }
}
const safeString$1 = String;
const createLookup = () => /* @__PURE__ */ Object.create(null);
const createMappedError$5 = (code, ...details) => new Error(`AUR${safeString$1(code).padStart(4, "0")}: ${getMessageByCode$3(code, ...details)}`);
const errorsMap$3 = {
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    101
    /* ErrorNames.ast_behavior_not_found */
  ]: `Ast eval error: binding behavior "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    102
    /* ErrorNames.ast_behavior_duplicated */
  ]: `Ast eval error: binding behavior "{{0}}" already applied.`,
  [
    103
    /* ErrorNames.ast_converter_not_found */
  ]: `Ast eval error: value converter "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    105
    /* ErrorNames.ast_$host_not_found */
  ]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,
  [
    106
    /* ErrorNames.ast_no_assign_$host */
  ]: `Ast eval error: invalid assignment. "$host" is a reserved keyword.`,
  [
    107
    /* ErrorNames.ast_not_a_function */
  ]: `Ast eval error: expression is not a function.`,
  [
    109
    /* ErrorNames.ast_unknown_unary_operator */
  ]: `Ast eval error: unknown unary operator: "{{0}}"`,
  [
    108
    /* ErrorNames.ast_unknown_binary_operator */
  ]: `Ast eval error: unknown binary operator: "{{0}}"`,
  [
    110
    /* ErrorNames.ast_tagged_not_a_function */
  ]: `Ast eval error: left-hand side of tagged template expression is not a function.`,
  [
    111
    /* ErrorNames.ast_name_is_not_a_function */
  ]: `Ast eval error: expected "{{0}}" to be a function`,
  [
    112
    /* ErrorNames.ast_destruct_null */
  ]: `Ast eval error: cannot use non-object value for destructuring assignment.`,
  [
    151
    /* ErrorNames.parse_invalid_start */
  ]: `Expression error: invalid start: "{{0}}"`,
  [
    152
    /* ErrorNames.parse_no_spread */
  ]: `Expression error: spread operator is not supported: "{{0}}"`,
  [
    153
    /* ErrorNames.parse_expected_identifier */
  ]: `Expression error: expected identifier: "{{0}}"`,
  [
    154
    /* ErrorNames.parse_invalid_member_expr */
  ]: `Expression error: invalid member expression: "{{0}}"`,
  [
    155
    /* ErrorNames.parse_unexpected_end */
  ]: `Expression error: unexpected end of expression: "{{0}}"`,
  [
    156
    /* ErrorNames.parse_unconsumed_token */
  ]: `Expression error: unconsumed token: "{{0}}" at position {{1}} of "{{2}}"`,
  [
    157
    /* ErrorNames.parse_invalid_empty */
  ]: `Expression error: invalid empty expression. Empty expression is only valid in event bindings (trigger, delegate, capture etc...)`,
  [
    158
    /* ErrorNames.parse_left_hand_side_not_assignable */
  ]: `Expression error: left hand side of expression is not assignable: "{{0}}"`,
  [
    159
    /* ErrorNames.parse_expected_converter_identifier */
  ]: `Expression error: expected identifier to come after value converter operator: "{{0}}"`,
  [
    160
    /* ErrorNames.parse_expected_behavior_identifier */
  ]: `Expression error: expected identifier to come after binding behavior operator: {{0}}`,
  [
    161
    /* ErrorNames.parse_unexpected_keyword_of */
  ]: `Expression error: unexpected keyword "of": "{{0}}"`,
  [
    162
    /* ErrorNames.parse_unexpected_keyword_import */
  ]: `Expression error: unexpected keyword "import": "{{0}}"`,
  [
    163
    /* ErrorNames.parse_invalid_identifier_in_forof */
  ]: `Expression error: invalid BindingIdentifier at left hand side of "of": "{{0}}" | kind: {{1}}`,
  [
    164
    /* ErrorNames.parse_invalid_identifier_object_literal_key */
  ]: `Expression error: invalid or unsupported property definition in object literal: "{{0}}"`,
  [
    165
    /* ErrorNames.parse_unterminated_string */
  ]: `Expression error: unterminated quote in string literal: "{{0}}"`,
  [
    166
    /* ErrorNames.parse_unterminated_template_string */
  ]: `Expression error: unterminated template string: "{{0}}"`,
  [
    167
    /* ErrorNames.parse_missing_expected_token */
  ]: `Expression error: missing expected token "{{0}}" in "{{1}}"`,
  [
    168
    /* ErrorNames.parse_unexpected_character */
  ]: `Expression error: unexpected character: "{{0}}"`,
  [
    170
    /* ErrorNames.parse_unexpected_token_destructuring */
  ]: `Expression error: unexpected "{{0}}" at position "{{1}}" for destructuring assignment in "{{2}}"`,
  [
    171
    /* ErrorNames.parse_unexpected_token_optional_chain */
  ]: `Expression error: unexpected {{0}} at position "{{1}}" for optional chain in "{{2}}"`,
  [
    172
    /* ErrorNames.parse_invalid_tag_in_optional_chain */
  ]: `Expression error: invalid tagged template on optional chain in "{{1}}"`,
  [
    173
    /* ErrorNames.parse_invalid_arrow_params */
  ]: `Expression error: invalid arrow parameter list in "{{0}}"`,
  [
    174
    /* ErrorNames.parse_no_arrow_param_default_value */
  ]: `Expression error: arrow function with default parameters is not supported: "{{0}}"`,
  [
    175
    /* ErrorNames.parse_no_arrow_param_destructuring */
  ]: `Expression error: arrow function with destructuring parameters is not supported: "{{0}}"`,
  [
    176
    /* ErrorNames.parse_rest_must_be_last */
  ]: `Expression error: rest parameter must be last formal parameter in arrow function: "{{0}}"`,
  [
    178
    /* ErrorNames.parse_no_arrow_fn_body */
  ]: `Expression error: arrow function with function body is not supported: "{{0}}"`,
  [
    179
    /* ErrorNames.parse_unexpected_double_dot */
  ]: `Expression error: unexpected token '.' at position "{{1}}" in "{{0}}"`
};
const getMessageByCode$3 = (name2, ...details) => {
  let cooked = errorsMap$3[name2];
  for (let i3 = 0; i3 < details.length; ++i3) {
    const regex = new RegExp(`{{${i3}(:.*)?}}`, "g");
    let matches2 = regex.exec(cooked);
    while (matches2 != null) {
      const method = matches2[1]?.slice(1);
      let value = details[i3];
      if (value != null) {
        switch (method) {
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = safeString$1(value[method.slice(1)]);
            } else {
              value = safeString$1(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches2.index) + value + cooked.slice(regex.lastIndex);
      matches2 = regex.exec(cooked);
    }
  }
  return cooked;
};
const IExpressionParser = /* @__PURE__ */ DI.createInterface("IExpressionParser");
class ExpressionParser {
  constructor() {
    this._expressionLookup = createLookup();
    this._forOfLookup = createLookup();
    this._interpolationLookup = createLookup();
  }
  parse(expression, expressionType) {
    let found;
    switch (expressionType) {
      case etIsCustom:
        return new CustomExpression(expression);
      case etInterpolation$2:
        found = this._interpolationLookup[expression];
        if (found === void 0) {
          found = this._interpolationLookup[expression] = this.$parse(expression, expressionType);
        }
        return found;
      case etIsIterator$1:
        found = this._forOfLookup[expression];
        if (found === void 0) {
          found = this._forOfLookup[expression] = this.$parse(expression, expressionType);
        }
        return found;
      default: {
        if (expression.length === 0) {
          if (expressionType === etIsFunction$2 || expressionType === etIsProperty$2) {
            return PrimitiveLiteralExpression.$empty;
          }
          throw invalidEmptyExpression();
        }
        found = this._expressionLookup[expression];
        if (found === void 0) {
          found = this._expressionLookup[expression] = this.$parse(expression, expressionType);
        }
        return found;
      }
    }
  }
  /** @internal */
  $parse(expression, expressionType) {
    $input = expression;
    $index = 0;
    $length = expression.length;
    $scopeDepth = 0;
    $startIndex = 0;
    $currentToken = 6291456;
    $tokenValue = "";
    $currentChar = $charCodeAt(0);
    $assignable = true;
    $optional = false;
    $accessGlobal = true;
    $semicolonIndex = -1;
    return parse(61, expressionType === void 0 ? etIsProperty$2 : expressionType);
  }
}
ExpressionParser.register = createImplementationRegister(IExpressionParser);
function unescapeCode(code) {
  switch (code) {
    case 98:
      return 8;
    case 116:
      return 9;
    case 110:
      return 10;
    case 118:
      return 11;
    case 102:
      return 12;
    case 114:
      return 13;
    case 34:
      return 34;
    case 39:
      return 39;
    case 92:
      return 92;
    default:
      return code;
  }
}
const $false = PrimitiveLiteralExpression.$false;
const $true = PrimitiveLiteralExpression.$true;
const $null = PrimitiveLiteralExpression.$null;
const $undefined = PrimitiveLiteralExpression.$undefined;
const $this = new AccessThisExpression(0);
const $parent = new AccessThisExpression(1);
const boundary = new AccessBoundaryExpression();
const etNone = "None";
const etInterpolation$2 = "Interpolation";
const etIsIterator$1 = "IsIterator";
const etIsChainable = "IsChainable";
const etIsFunction$2 = "IsFunction";
const etIsProperty$2 = "IsProperty";
const etIsCustom = "IsCustom";
let $input = "";
let $index = 0;
let $length = 0;
let $scopeDepth = 0;
let $startIndex = 0;
let $currentToken = 6291456;
let $tokenValue = "";
let $currentChar;
let $assignable = true;
let $optional = false;
let $accessGlobal = true;
let $semicolonIndex = -1;
const stringFromCharCode = String.fromCharCode;
const $charCodeAt = (index) => $input.charCodeAt(index);
const $tokenRaw = () => $input.slice($startIndex, $index);
const globalNames = "Infinity NaN isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent Array BigInt Boolean Date Map Number Object RegExp Set String JSON Math Intl".split(" ");
function parse(minPrecedence, expressionType) {
  if (expressionType === etIsCustom) {
    return new CustomExpression($input);
  }
  if ($index === 0) {
    if (expressionType === etInterpolation$2) {
      return parseInterpolation();
    }
    nextToken();
    if ($currentToken & 4194304) {
      throw invalidStartOfExpression();
    }
  }
  $assignable = 513 > minPrecedence;
  $optional = false;
  $accessGlobal = 514 > minPrecedence;
  let optionalThisTail = false;
  let result = void 0;
  let ancestor = 0;
  if ($currentToken & 131072) {
    const op = TokenValues[
      $currentToken & 63
      /* Token.Type */
    ];
    nextToken();
    result = new UnaryExpression(op, parse(514, expressionType));
    $assignable = false;
  } else {
    primary: switch ($currentToken) {
      case 12295:
        ancestor = $scopeDepth;
        $assignable = false;
        $accessGlobal = false;
        do {
          nextToken();
          ++ancestor;
          switch ($currentToken) {
            case 65546:
              nextToken();
              if (($currentToken & 12288) === 0) {
                throw expectedIdentifier();
              }
              break;
            case 11:
            case 12:
              throw expectedIdentifier();
            case 2162701:
              $optional = true;
              nextToken();
              if (($currentToken & 12288) === 0) {
                result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);
                optionalThisTail = true;
                break primary;
              }
              break;
            default:
              if ($currentToken & 2097152) {
                result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThisExpression(ancestor);
                break primary;
              }
              throw invalidMemberExpression();
          }
        } while ($currentToken === 12295);
      case 4096: {
        const id2 = $tokenValue;
        if (expressionType === etIsIterator$1) {
          result = new BindingIdentifier(id2);
        } else if ($accessGlobal && globalNames.includes(id2)) {
          result = new AccessGlobalExpression(id2);
        } else if ($accessGlobal && id2 === "import") {
          throw unexpectedImportKeyword();
        } else {
          result = new AccessScopeExpression(id2, ancestor);
        }
        $assignable = !$optional;
        nextToken();
        if (consumeOpt(
          51
          /* Token.Arrow */
        )) {
          if ($currentToken === 524297) {
            throw functionBodyInArrowFn();
          }
          const _optional = $optional;
          const _scopeDepth = $scopeDepth;
          ++$scopeDepth;
          const body = parse(62, etNone);
          $optional = _optional;
          $scopeDepth = _scopeDepth;
          $assignable = false;
          result = new ArrowFunction([new BindingIdentifier(id2)], body);
        }
        break;
      }
      case 11:
        throw unexpectedDoubleDot();
      case 12:
        throw invalidSpreadOp();
      case 12292:
        $assignable = false;
        nextToken();
        switch ($scopeDepth) {
          case 0:
            result = $this;
            break;
          case 1:
            result = $parent;
            break;
          default:
            result = new AccessThisExpression($scopeDepth);
            break;
        }
        break;
      case 12293:
        $assignable = false;
        nextToken();
        result = boundary;
        break;
      case 2688008:
        result = parseCoverParenthesizedExpressionAndArrowParameterList(expressionType);
        break;
      case 2688019:
        result = $input.search(/\s+of\s+/) > $index ? parseArrayDestructuring() : parseArrayLiteralExpression(expressionType);
        break;
      case 524297:
        result = parseObjectLiteralExpression(expressionType);
        break;
      case 2163760:
        result = new TemplateExpression([$tokenValue]);
        $assignable = false;
        nextToken();
        break;
      case 2163761:
        result = parseTemplate(expressionType, result, false);
        break;
      case 16384:
      case 32768:
        result = new PrimitiveLiteralExpression($tokenValue);
        $assignable = false;
        nextToken();
        break;
      case 8194:
      case 8195:
      case 8193:
      case 8192:
        result = TokenValues[
          $currentToken & 63
          /* Token.Type */
        ];
        $assignable = false;
        nextToken();
        break;
      default:
        if ($index >= $length) {
          throw unexpectedEndOfExpression();
        } else {
          throw unconsumedToken();
        }
    }
    if (expressionType === etIsIterator$1) {
      return parseForOfStatement(result);
    }
    switch ($currentToken) {
      case 2228280:
      case 2228281:
        result = new UnaryExpression(TokenValues[
          $currentToken & 63
          /* Token.Type */
        ], result, 1);
        nextToken();
        $assignable = false;
        break;
    }
    if (514 < minPrecedence) {
      return result;
    }
    if ($currentToken === 11 || $currentToken === 12) {
      throw expectedIdentifier();
    }
    if (result.$kind === ekAccessThis) {
      switch ($currentToken) {
        case 2162701:
          $optional = true;
          $assignable = false;
          nextToken();
          if (($currentToken & 13312) === 0) {
            throw unexpectedTokenInOptionalChain();
          }
          if ($currentToken & 12288) {
            result = new AccessScopeExpression($tokenValue, result.ancestor);
            nextToken();
          } else if ($currentToken === 2688008) {
            result = new CallFunctionExpression(result, parseArguments(), true);
          } else if ($currentToken === 2688019) {
            result = parseKeyedExpression(result, true);
          } else {
            throw invalidTaggedTemplateOnOptionalChain();
          }
          break;
        case 65546:
          $assignable = !$optional;
          nextToken();
          if (($currentToken & 12288) === 0) {
            throw expectedIdentifier();
          }
          result = new AccessScopeExpression($tokenValue, result.ancestor);
          nextToken();
          break;
        case 11:
        case 12:
          throw expectedIdentifier();
        case 2688008:
          result = new CallFunctionExpression(result, parseArguments(), optionalThisTail);
          break;
        case 2688019:
          result = parseKeyedExpression(result, optionalThisTail);
          break;
        case 2163760:
          result = createTemplateTail(result);
          break;
        case 2163761:
          result = parseTemplate(expressionType, result, true);
          break;
      }
    }
    while (($currentToken & 65536) > 0) {
      switch ($currentToken) {
        case 2162701:
          result = parseOptionalChainLHS(result);
          break;
        case 65546:
          nextToken();
          if (($currentToken & 12288) === 0) {
            throw expectedIdentifier();
          }
          result = parseMemberExpressionLHS(result, false);
          break;
        case 11:
        case 12:
          throw expectedIdentifier();
        case 2688008:
          if (result.$kind === ekAccessScope) {
            result = new CallScopeExpression(result.name, parseArguments(), result.ancestor, false);
          } else if (result.$kind === ekAccessMember) {
            result = new CallMemberExpression(result.object, result.name, parseArguments(), result.optional, false);
          } else if (result.$kind === ekAccessGlobal) {
            result = new CallGlobalExpression(result.name, parseArguments());
          } else {
            result = new CallFunctionExpression(result, parseArguments(), false);
          }
          break;
        case 2688019:
          result = parseKeyedExpression(result, false);
          break;
        case 2163760:
          if ($optional) {
            throw invalidTaggedTemplateOnOptionalChain();
          }
          result = createTemplateTail(result);
          break;
        case 2163761:
          if ($optional) {
            throw invalidTaggedTemplateOnOptionalChain();
          }
          result = parseTemplate(expressionType, result, true);
          break;
      }
    }
  }
  if ($currentToken === 11 || $currentToken === 12) {
    throw expectedIdentifier();
  }
  if (513 < minPrecedence) {
    return result;
  }
  while (($currentToken & 262144) > 0) {
    const opToken = $currentToken;
    if ((opToken & 960) <= minPrecedence) {
      break;
    }
    nextToken();
    result = new BinaryExpression(TokenValues[
      opToken & 63
      /* Token.Type */
    ], result, parse(opToken & 960, expressionType));
    $assignable = false;
  }
  if (63 < minPrecedence) {
    return result;
  }
  if (consumeOpt(
    6291479
    /* Token.Question */
  )) {
    const yes = parse(62, expressionType);
    consume(
      6291477
      /* Token.Colon */
    );
    result = new ConditionalExpression(result, yes, parse(62, expressionType));
    $assignable = false;
  }
  if (62 < minPrecedence) {
    return result;
  }
  switch ($currentToken) {
    case 4194350:
    case 4194356:
    case 4194357:
    case 4194358:
    case 4194359: {
      if (!$assignable) {
        throw lhsNotAssignable();
      }
      const op = TokenValues[
        $currentToken & 63
        /* Token.Type */
      ];
      nextToken();
      result = new AssignExpression(result, parse(62, expressionType), op);
      break;
    }
  }
  if (61 < minPrecedence) {
    return result;
  }
  while (consumeOpt(
    6291481
    /* Token.Bar */
  )) {
    if ($currentToken === 6291456) {
      throw expectedValueConverterIdentifier();
    }
    const name2 = $tokenValue;
    nextToken();
    const args = new Array();
    while (consumeOpt(
      6291477
      /* Token.Colon */
    )) {
      args.push(parse(62, expressionType));
    }
    result = new ValueConverterExpression(result, name2, args);
  }
  while (consumeOpt(
    6291480
    /* Token.Ampersand */
  )) {
    if ($currentToken === 6291456) {
      throw expectedBindingBehaviorIdentifier();
    }
    const name2 = $tokenValue;
    nextToken();
    const args = new Array();
    while (consumeOpt(
      6291477
      /* Token.Colon */
    )) {
      args.push(parse(62, expressionType));
    }
    result = new BindingBehaviorExpression(result, name2, args);
  }
  if ($currentToken !== 6291456) {
    if (expressionType === etInterpolation$2 && $currentToken === 7340046) {
      return result;
    }
    if (expressionType === etIsChainable && $currentToken === 6291478) {
      if ($index === $length) {
        throw unconsumedToken();
      }
      $semicolonIndex = $index - 1;
      return result;
    }
    if ($tokenRaw() === "of") {
      throw unexpectedOfKeyword();
    }
    throw unconsumedToken();
  }
  return result;
}
function parseArrayDestructuring() {
  const items = [];
  const dae = new DestructuringAssignmentExpression(ekArrayDestructuring, items, void 0, void 0);
  let target = "";
  let $continue = true;
  let index = 0;
  while ($continue) {
    nextToken();
    switch ($currentToken) {
      case 7340052:
        $continue = false;
        addItem();
        break;
      case 6291472:
        addItem();
        break;
      case 4096:
        target = $tokenRaw();
        break;
      default:
        throw unexpectedTokenInDestructuring();
    }
  }
  consume(
    7340052
    /* Token.CloseBracket */
  );
  return dae;
  function addItem() {
    if (target !== "") {
      items.push(new DestructuringAssignmentSingleExpression(new AccessMemberExpression($this, target), new AccessKeyedExpression($this, new PrimitiveLiteralExpression(index++)), void 0));
      target = "";
    } else {
      index++;
    }
  }
}
function parseArguments() {
  const _optional = $optional;
  nextToken();
  const args = [];
  while ($currentToken !== 7340047) {
    args.push(parse(62, etNone));
    if (!consumeOpt(
      6291472
      /* Token.Comma */
    )) {
      break;
    }
  }
  consume(
    7340047
    /* Token.CloseParen */
  );
  $assignable = false;
  $optional = _optional;
  return args;
}
function parseKeyedExpression(result, optional2) {
  const _optional = $optional;
  nextToken();
  result = new AccessKeyedExpression(result, parse(62, etNone), optional2);
  consume(
    7340052
    /* Token.CloseBracket */
  );
  $assignable = !_optional;
  $optional = _optional;
  return result;
}
function parseOptionalChainLHS(lhs) {
  $optional = true;
  $assignable = false;
  nextToken();
  if (($currentToken & 13312) === 0) {
    throw unexpectedTokenInOptionalChain();
  }
  if ($currentToken & 12288) {
    return parseMemberExpressionLHS(lhs, true);
  }
  if ($currentToken === 2688008) {
    if (lhs.$kind === ekAccessScope) {
      return new CallScopeExpression(lhs.name, parseArguments(), lhs.ancestor, true);
    } else if (lhs.$kind === ekAccessMember) {
      return new CallMemberExpression(lhs.object, lhs.name, parseArguments(), lhs.optional, true);
    } else {
      return new CallFunctionExpression(lhs, parseArguments(), true);
    }
  }
  if ($currentToken === 2688019) {
    return parseKeyedExpression(lhs, true);
  }
  throw invalidTaggedTemplateOnOptionalChain();
}
function parseMemberExpressionLHS(lhs, optional2) {
  const rhs = $tokenValue;
  switch ($currentToken) {
    case 2162701: {
      $optional = true;
      $assignable = false;
      const indexSave = $index;
      const startIndexSave = $startIndex;
      const currentTokenSave = $currentToken;
      const currentCharSave = $currentChar;
      const tokenValueSave = $tokenValue;
      const assignableSave = $assignable;
      const optionalSave = $optional;
      nextToken();
      if (($currentToken & 13312) === 0) {
        throw unexpectedTokenInOptionalChain();
      }
      if ($currentToken === 2688008) {
        return new CallMemberExpression(lhs, rhs, parseArguments(), optional2, true);
      }
      $index = indexSave;
      $startIndex = startIndexSave;
      $currentToken = currentTokenSave;
      $currentChar = currentCharSave;
      $tokenValue = tokenValueSave;
      $assignable = assignableSave;
      $optional = optionalSave;
      return new AccessMemberExpression(lhs, rhs, optional2);
    }
    case 2688008: {
      $assignable = false;
      return new CallMemberExpression(lhs, rhs, parseArguments(), optional2, false);
    }
    default: {
      $assignable = !$optional;
      nextToken();
      return new AccessMemberExpression(lhs, rhs, optional2);
    }
  }
}
function parseCoverParenthesizedExpressionAndArrowParameterList(expressionType) {
  nextToken();
  const indexSave = $index;
  const startIndexSave = $startIndex;
  const currentTokenSave = $currentToken;
  const currentCharSave = $currentChar;
  const tokenValueSave = $tokenValue;
  const optionalSave = $optional;
  const arrowParams = [];
  let paramsState = 1;
  let isParamList = false;
  loop: while (true) {
    if ($currentToken === 12) {
      nextToken();
      if ($currentToken !== 4096) {
        throw expectedIdentifier();
      }
      arrowParams.push(new BindingIdentifier($tokenValue));
      nextToken();
      if ($currentToken === 6291472) {
        throw restParamsMustBeLastParam();
      }
      if ($currentToken !== 7340047) {
        throw invalidSpreadOp();
      }
      nextToken();
      if ($currentToken !== 51) {
        throw invalidSpreadOp();
      }
      nextToken();
      const _optional2 = $optional;
      const _scopeDepth = $scopeDepth;
      ++$scopeDepth;
      const body = parse(62, etNone);
      $optional = _optional2;
      $scopeDepth = _scopeDepth;
      $assignable = false;
      return new ArrowFunction(arrowParams, body, true);
    }
    switch ($currentToken) {
      case 4096:
        arrowParams.push(new BindingIdentifier($tokenValue));
        nextToken();
        break;
      case 7340047:
        nextToken();
        break loop;
      case 524297:
      case 2688019:
        nextToken();
        paramsState = 4;
        break;
      case 6291472:
        paramsState = 2;
        isParamList = true;
        break loop;
      case 2688008:
        paramsState = 2;
        break loop;
      default:
        nextToken();
        paramsState = 2;
        break;
    }
    switch ($currentToken) {
      case 6291472:
        nextToken();
        isParamList = true;
        if (paramsState === 1) {
          break;
        }
        break loop;
      case 7340047:
        nextToken();
        break loop;
      case 4194350:
        if (paramsState === 1) {
          paramsState = 3;
        }
        break loop;
      case 51:
        if (isParamList) {
          throw invalidArrowParameterList();
        }
        nextToken();
        paramsState = 2;
        break loop;
      default:
        if (paramsState === 1) {
          paramsState = 2;
        }
        break loop;
    }
  }
  if ($currentToken === 51) {
    if (paramsState === 1) {
      nextToken();
      if ($currentToken === 524297) {
        throw functionBodyInArrowFn();
      }
      const _optional2 = $optional;
      const _scopeDepth = $scopeDepth;
      ++$scopeDepth;
      const body = parse(62, etNone);
      $optional = _optional2;
      $scopeDepth = _scopeDepth;
      $assignable = false;
      return new ArrowFunction(arrowParams, body);
    }
    throw invalidArrowParameterList();
  } else if (paramsState === 1 && arrowParams.length === 0) {
    throw missingExpectedToken(
      51
      /* Token.Arrow */
    );
  }
  if (isParamList) {
    switch (paramsState) {
      case 2:
        throw invalidArrowParameterList();
      case 3:
        throw defaultParamsInArrowFn();
      case 4:
        throw destructuringParamsInArrowFn();
    }
  }
  $index = indexSave;
  $startIndex = startIndexSave;
  $currentToken = currentTokenSave;
  $currentChar = currentCharSave;
  $tokenValue = tokenValueSave;
  $optional = optionalSave;
  const _optional = $optional;
  const expr = parse(62, expressionType);
  $optional = _optional;
  consume(
    7340047
    /* Token.CloseParen */
  );
  if ($currentToken === 51) {
    switch (paramsState) {
      case 2:
        throw invalidArrowParameterList();
      case 3:
        throw defaultParamsInArrowFn();
      case 4:
        throw destructuringParamsInArrowFn();
    }
  }
  return expr;
}
function parseArrayLiteralExpression(expressionType) {
  const _optional = $optional;
  nextToken();
  const elements2 = new Array();
  while ($currentToken !== 7340052) {
    if (consumeOpt(
      6291472
      /* Token.Comma */
    )) {
      elements2.push($undefined);
      if ($currentToken === 7340052) {
        break;
      }
    } else {
      elements2.push(parse(62, expressionType === etIsIterator$1 ? etNone : expressionType));
      if (consumeOpt(
        6291472
        /* Token.Comma */
      )) {
        if ($currentToken === 7340052) {
          break;
        }
      } else {
        break;
      }
    }
  }
  $optional = _optional;
  consume(
    7340052
    /* Token.CloseBracket */
  );
  if (expressionType === etIsIterator$1) {
    return new ArrayBindingPattern(elements2);
  } else {
    $assignable = false;
    return new ArrayLiteralExpression(elements2);
  }
}
const allowedForExprKinds = [ekArrayBindingPattern, ekObjectBindingPattern, ekBindingIdentifier, ekArrayDestructuring, ekObjectDestructuring];
function parseForOfStatement(result) {
  if (!allowedForExprKinds.includes(result.$kind)) {
    throw invalidLHSBindingIdentifierInForOf(result.$kind);
  }
  if ($currentToken !== 4204594) {
    throw invalidLHSBindingIdentifierInForOf(result.$kind);
  }
  nextToken();
  const declaration = result;
  const statement = parse(61, etIsChainable);
  return new ForOfStatement(declaration, statement, $semicolonIndex);
}
function parseObjectLiteralExpression(expressionType) {
  const _optional = $optional;
  const keys = new Array();
  const values = new Array();
  nextToken();
  while ($currentToken !== 7340046) {
    keys.push($tokenValue);
    if ($currentToken & 49152) {
      nextToken();
      consume(
        6291477
        /* Token.Colon */
      );
      values.push(parse(62, expressionType === etIsIterator$1 ? etNone : expressionType));
    } else if ($currentToken & 12288) {
      const currentChar = $currentChar;
      const currentToken = $currentToken;
      const index = $index;
      nextToken();
      if (consumeOpt(
        6291477
        /* Token.Colon */
      )) {
        values.push(parse(62, expressionType === etIsIterator$1 ? etNone : expressionType));
      } else {
        $currentChar = currentChar;
        $currentToken = currentToken;
        $index = index;
        values.push(parse(515, expressionType === etIsIterator$1 ? etNone : expressionType));
      }
    } else {
      throw invalidPropDefInObjLiteral();
    }
    if ($currentToken !== 7340046) {
      consume(
        6291472
        /* Token.Comma */
      );
    }
  }
  $optional = _optional;
  consume(
    7340046
    /* Token.CloseBrace */
  );
  if (expressionType === etIsIterator$1) {
    return new ObjectBindingPattern(keys, values);
  } else {
    $assignable = false;
    return new ObjectLiteralExpression(keys, values);
  }
}
function parseInterpolation() {
  const parts = [];
  const expressions = [];
  const length = $length;
  let result = "";
  while ($index < length) {
    switch ($currentChar) {
      case 36:
        if ($charCodeAt($index + 1) === 123) {
          parts.push(result);
          result = "";
          $index += 2;
          $currentChar = $charCodeAt($index);
          nextToken();
          const expression = parse(61, etInterpolation$2);
          expressions.push(expression);
          continue;
        } else {
          result += "$";
        }
        break;
      case 92:
        result += stringFromCharCode(unescapeCode(nextChar()));
        break;
      default:
        result += stringFromCharCode($currentChar);
    }
    nextChar();
  }
  if (expressions.length) {
    parts.push(result);
    return new Interpolation(parts, expressions);
  }
  return null;
}
function parseTemplate(expressionType, result, tagged) {
  const _optional = $optional;
  const cooked = [$tokenValue];
  consume(
    2163761
    /* Token.TemplateContinuation */
  );
  const expressions = [parse(62, expressionType)];
  while (($currentToken = scanTemplateTail()) !== 2163760) {
    cooked.push($tokenValue);
    consume(
      2163761
      /* Token.TemplateContinuation */
    );
    expressions.push(parse(62, expressionType));
  }
  cooked.push($tokenValue);
  $assignable = false;
  $optional = _optional;
  if (tagged) {
    nextToken();
    return new TaggedTemplateExpression(cooked, cooked, result, expressions);
  } else {
    nextToken();
    return new TemplateExpression(cooked, expressions);
  }
}
function createTemplateTail(result) {
  $assignable = false;
  const strings2 = [$tokenValue];
  nextToken();
  return new TaggedTemplateExpression(strings2, strings2, result);
}
function nextToken() {
  while ($index < $length) {
    $startIndex = $index;
    if (($currentToken = CharScanners[$currentChar]()) != null) {
      return;
    }
  }
  $currentToken = 6291456;
}
function nextChar() {
  return $currentChar = $charCodeAt(++$index);
}
function scanIdentifier() {
  while (IdParts[nextChar()])
    ;
  const token = KeywordLookup[$tokenValue = $tokenRaw()];
  return token === void 0 ? 4096 : token;
}
function scanNumber(isFloat) {
  let char = $currentChar;
  if (isFloat === false) {
    do {
      char = nextChar();
    } while (char <= 57 && char >= 48);
    if (char !== 46) {
      $tokenValue = parseInt($tokenRaw(), 10);
      return 32768;
    }
    char = nextChar();
    if ($index >= $length) {
      $tokenValue = parseInt($tokenRaw().slice(0, -1), 10);
      return 32768;
    }
  }
  if (char <= 57 && char >= 48) {
    do {
      char = nextChar();
    } while (char <= 57 && char >= 48);
  } else {
    $currentChar = $charCodeAt(--$index);
  }
  $tokenValue = parseFloat($tokenRaw());
  return 32768;
}
function scanString() {
  const quote = $currentChar;
  nextChar();
  let unescaped = 0;
  const buffer = new Array();
  let marker = $index;
  while ($currentChar !== quote) {
    if ($currentChar === 92) {
      buffer.push($input.slice(marker, $index));
      nextChar();
      unescaped = unescapeCode($currentChar);
      nextChar();
      buffer.push(stringFromCharCode(unescaped));
      marker = $index;
    } else if ($index >= $length) {
      throw unterminatedStringLiteral();
    } else {
      nextChar();
    }
  }
  const last = $input.slice(marker, $index);
  nextChar();
  buffer.push(last);
  const unescapedStr = buffer.join("");
  $tokenValue = unescapedStr;
  return 16384;
}
function scanTemplate() {
  let tail = true;
  let result = "";
  while (nextChar() !== 96) {
    if ($currentChar === 36) {
      if ($index + 1 < $length && $charCodeAt($index + 1) === 123) {
        $index++;
        tail = false;
        break;
      } else {
        result += "$";
      }
    } else if ($currentChar === 92) {
      result += stringFromCharCode(unescapeCode(nextChar()));
    } else {
      if ($index >= $length) {
        throw unterminatedTemplateLiteral();
      }
      result += stringFromCharCode($currentChar);
    }
  }
  nextChar();
  $tokenValue = result;
  if (tail) {
    return 2163760;
  }
  return 2163761;
}
const scanTemplateTail = () => {
  if ($index >= $length) {
    throw unterminatedTemplateLiteral();
  }
  $index--;
  return scanTemplate();
};
const consumeOpt = (token) => {
  if ($currentToken === token) {
    nextToken();
    return true;
  }
  return false;
};
const consume = (token) => {
  if ($currentToken === token) {
    nextToken();
  } else {
    throw missingExpectedToken(token);
  }
};
const invalidStartOfExpression = () => createMappedError$5(151, $input);
const invalidSpreadOp = () => createMappedError$5(152, $input);
const expectedIdentifier = () => createMappedError$5(153, $input);
const invalidMemberExpression = () => createMappedError$5(154, $input);
const unexpectedEndOfExpression = () => createMappedError$5(155, $input);
const unconsumedToken = () => createMappedError$5(156, $tokenRaw(), $index, $input);
const invalidEmptyExpression = () => createMappedError$5(
  157
  /* ErrorNames.parse_invalid_empty */
);
const lhsNotAssignable = () => createMappedError$5(158, $input);
const expectedValueConverterIdentifier = () => createMappedError$5(159, $input);
const expectedBindingBehaviorIdentifier = () => createMappedError$5(160, $input);
const unexpectedOfKeyword = () => createMappedError$5(161, $input);
const unexpectedImportKeyword = () => createMappedError$5(162, $input);
const invalidLHSBindingIdentifierInForOf = (kind) => createMappedError$5(163, $input, kind);
const invalidPropDefInObjLiteral = () => createMappedError$5(164, $input);
const unterminatedStringLiteral = () => createMappedError$5(165, $input);
const unterminatedTemplateLiteral = () => createMappedError$5(166, $input);
const missingExpectedToken = (token) => createMappedError$5(167, TokenValues[
  token & 63
  /* Token.Type */
], $input);
const unexpectedTokenInDestructuring = () => createMappedError$5(170, $tokenRaw(), $index, $input);
const unexpectedTokenInOptionalChain = () => createMappedError$5(171, $tokenRaw(), $index - 1, $input);
const invalidTaggedTemplateOnOptionalChain = () => createMappedError$5(172, $input);
const invalidArrowParameterList = () => createMappedError$5(173, $input);
const defaultParamsInArrowFn = () => createMappedError$5(174, $input);
const destructuringParamsInArrowFn = () => createMappedError$5(175, $input);
const restParamsMustBeLastParam = () => createMappedError$5(176, $input);
const functionBodyInArrowFn = () => createMappedError$5(178, $input);
const unexpectedDoubleDot = () => createMappedError$5(179, $index - 1, $input);
const TokenValues = [
  $false,
  $true,
  $null,
  $undefined,
  "this",
  "$this",
  null,
  "$parent",
  "(",
  "{",
  ".",
  "..",
  "...",
  "?.",
  "}",
  ")",
  ",",
  "[",
  "]",
  ":",
  ";",
  "?",
  "'",
  '"',
  "&",
  "|",
  "??",
  "||",
  "&&",
  "==",
  "!=",
  "===",
  "!==",
  "<",
  ">",
  "<=",
  ">=",
  "in",
  "instanceof",
  "+",
  "-",
  "typeof",
  "void",
  "*",
  "%",
  "/",
  "=",
  "!",
  2163760,
  2163761,
  "of",
  "=>",
  "+=",
  "-=",
  "*=",
  "/=",
  "++",
  "--"
];
const KeywordLookup = /* @__PURE__ */ Object.assign(createLookup(), {
  true: 8193,
  null: 8194,
  false: 8192,
  undefined: 8195,
  this: 12293,
  $this: 12292,
  $parent: 12295,
  in: 6562213,
  instanceof: 6562214,
  typeof: 139305,
  void: 139306,
  of: 4204594
});
const { CharScanners, IdParts } = /* @__PURE__ */ (() => {
  const unexpectedCharacter = () => {
    throw createMappedError$5(168, $input);
  };
  unexpectedCharacter.notMapped = true;
  const codes = {
    /* [$0-9A-Za_a-z] */
    AsciiIdPart: [36, 0, 48, 58, 65, 91, 95, 0, 97, 123],
    IdStart: (
      /* IdentifierStart */
      [36, 0, 65, 91, 95, 0, 97, 123, 170, 0, 186, 0, 192, 215, 216, 247, 248, 697, 736, 741, 7424, 7462, 7468, 7517, 7522, 7526, 7531, 7544, 7545, 7615, 7680, 7936, 8305, 0, 8319, 0, 8336, 8349, 8490, 8492, 8498, 0, 8526, 0, 8544, 8585, 11360, 11392, 42786, 42888, 42891, 42927, 42928, 42936, 42999, 43008, 43824, 43867, 43868, 43877, 64256, 64263, 65313, 65339, 65345, 65371]
    ),
    Digit: (
      /* DecimalNumber */
      [48, 58]
    ),
    Skip: (
      /* Skippable */
      [0, 33, 127, 161]
    )
  };
  const decompress = (lookup2, $set, compressed, value) => {
    const rangeCount = compressed.length;
    for (let i3 = 0; i3 < rangeCount; i3 += 2) {
      const start2 = compressed[i3];
      let end2 = compressed[i3 + 1];
      end2 = end2 > 0 ? end2 : start2 + 1;
      if (lookup2) {
        lookup2.fill(value, start2, end2);
      }
    }
  };
  const IdParts2 = /* @__PURE__ */ ((IdParts3) => {
    decompress(IdParts3, null, codes.IdStart, 1);
    decompress(IdParts3, null, codes.Digit, 1);
    return IdParts3;
  })(new Uint8Array(65535));
  const returnToken = (token) => () => {
    nextChar();
    return token;
  };
  const CharScanners2 = new Array(65535);
  CharScanners2.fill(unexpectedCharacter, 0, 65535);
  decompress(CharScanners2, null, codes.Skip, () => {
    nextChar();
    return null;
  });
  decompress(CharScanners2, null, codes.IdStart, scanIdentifier);
  decompress(CharScanners2, null, codes.Digit, () => scanNumber(false));
  CharScanners2[
    34
    /* Char.DoubleQuote */
  ] = CharScanners2[
    39
    /* Char.SingleQuote */
  ] = () => {
    return scanString();
  };
  CharScanners2[
    96
    /* Char.Backtick */
  ] = () => {
    return scanTemplate();
  };
  CharScanners2[
    33
    /* Char.Exclamation */
  ] = () => {
    if (nextChar() !== 61) {
      return 131119;
    }
    if (nextChar() !== 61) {
      return 6553950;
    }
    nextChar();
    return 6553952;
  };
  CharScanners2[
    61
    /* Char.Equals */
  ] = () => {
    if (nextChar() === 62) {
      nextChar();
      return 51;
    }
    if ($currentChar !== 61) {
      return 4194350;
    }
    if (nextChar() !== 61) {
      return 6553949;
    }
    nextChar();
    return 6553951;
  };
  CharScanners2[
    38
    /* Char.Ampersand */
  ] = () => {
    if (nextChar() !== 38) {
      return 6291480;
    }
    nextChar();
    return 6553884;
  };
  CharScanners2[
    124
    /* Char.Bar */
  ] = () => {
    if (nextChar() !== 124) {
      return 6291481;
    }
    nextChar();
    return 6553819;
  };
  CharScanners2[
    63
    /* Char.Question */
  ] = () => {
    if (nextChar() === 46) {
      const peek = $charCodeAt($index + 1);
      if (peek <= 48 || peek >= 57) {
        nextChar();
        return 2162701;
      }
      return 6291479;
    }
    if ($currentChar !== 63) {
      return 6291479;
    }
    nextChar();
    return 6553754;
  };
  CharScanners2[
    46
    /* Char.Dot */
  ] = () => {
    if (nextChar() <= 57 && $currentChar >= 48) {
      return scanNumber(true);
    }
    if ($currentChar === 46) {
      if (nextChar() !== 46) {
        return 11;
      }
      nextChar();
      return 12;
    }
    return 65546;
  };
  CharScanners2[
    60
    /* Char.LessThan */
  ] = () => {
    if (nextChar() !== 61) {
      return 6554017;
    }
    nextChar();
    return 6554019;
  };
  CharScanners2[
    62
    /* Char.GreaterThan */
  ] = () => {
    if (nextChar() !== 61) {
      return 6554018;
    }
    nextChar();
    return 6554020;
  };
  CharScanners2[
    37
    /* Char.Percent */
  ] = returnToken(
    6554156
    /* Token.Percent */
  );
  CharScanners2[
    40
    /* Char.OpenParen */
  ] = returnToken(
    2688008
    /* Token.OpenParen */
  );
  CharScanners2[
    41
    /* Char.CloseParen */
  ] = returnToken(
    7340047
    /* Token.CloseParen */
  );
  CharScanners2[
    42
    /* Char.Asterisk */
  ] = () => {
    if (nextChar() !== 61) {
      return 6554155;
    }
    nextChar();
    return 4194358;
  };
  CharScanners2[
    43
    /* Char.Plus */
  ] = () => {
    if (nextChar() === 43) {
      nextChar();
      return 2228280;
    }
    if ($currentChar !== 61) {
      return 2490855;
    }
    nextChar();
    return 4194356;
  };
  CharScanners2[
    44
    /* Char.Comma */
  ] = returnToken(
    6291472
    /* Token.Comma */
  );
  CharScanners2[
    45
    /* Char.Minus */
  ] = () => {
    if (nextChar() === 45) {
      nextChar();
      return 2228281;
    }
    if ($currentChar !== 61) {
      return 2490856;
    }
    nextChar();
    return 4194357;
  };
  CharScanners2[
    47
    /* Char.Slash */
  ] = () => {
    if (nextChar() !== 61) {
      return 6554157;
    }
    nextChar();
    return 4194359;
  };
  CharScanners2[
    58
    /* Char.Colon */
  ] = returnToken(
    6291477
    /* Token.Colon */
  );
  CharScanners2[
    59
    /* Char.Semicolon */
  ] = returnToken(
    6291478
    /* Token.Semicolon */
  );
  CharScanners2[
    91
    /* Char.OpenBracket */
  ] = returnToken(
    2688019
    /* Token.OpenBracket */
  );
  CharScanners2[
    93
    /* Char.CloseBracket */
  ] = returnToken(
    7340052
    /* Token.CloseBracket */
  );
  CharScanners2[
    123
    /* Char.OpenBrace */
  ] = returnToken(
    524297
    /* Token.OpenBrace */
  );
  CharScanners2[
    125
    /* Char.CloseBrace */
  ] = returnToken(
    7340046
    /* Token.CloseBrace */
  );
  return { CharScanners: CharScanners2, IdParts: IdParts2 };
})();
const tcCreateInterface = DI.createInterface;
const tcObjectFreeze = Object.freeze;
const { aliasTo: aliasRegistration$1, singleton: singletonRegistration$1 } = Registration;
const etInterpolation$1 = "Interpolation";
const etIsFunction$1 = "IsFunction";
const etIsProperty$1 = "IsProperty";
const definitionTypeElement = "custom-element";
const BindingMode = /* @__PURE__ */ tcObjectFreeze({
  /**
   * Unspecified mode, bindings may act differently with this mode
   */
  default: 0,
  oneTime: 1,
  toView: 2,
  fromView: 4,
  twoWay: 6
});
const ITemplateCompiler = /* @__PURE__ */ tcCreateInterface("ITemplateCompiler");
const IAttrMapper = /* @__PURE__ */ tcCreateInterface("IAttrMapper");
const createMappedError$4 = (code, ...details) => new Error(`AUR${String(code).padStart(4, "0")}: ${getMessageByCode$2(code, ...details)}`);
const errorsMap$2 = {
  [
    88
    /* ErrorNames.attribute_pattern_already_initialized */
  ]: "AttributeParser is already initialized; cannot add patterns after initialization.",
  [
    89
    /* ErrorNames.attribute_pattern_duplicate */
  ]: 'Attribute pattern "{{0}}" has already been registered.',
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    157
    /* ErrorNames.binding_command_existed */
  ]: `Binding command {{0}} has already been registered.`,
  [
    701
    /* ErrorNames.compiler_root_is_local */
  ]: `Template compilation error in element "{{0:name}}": the root <template> cannot be a local element template.`,
  [
    702
    /* ErrorNames.compiler_invalid_surrogate_attr */
  ]: `Template compilation error: attribute "{{0}}" is invalid on element surrogate.`,
  [
    703
    /* ErrorNames.compiler_no_tc_on_surrogate */
  ]: `Template compilation error: template controller "{{0}}" is invalid on element surrogate.`,
  [
    704
    /* ErrorNames.compiler_invalid_let_command */
  ]: `Template compilation error: Invalid command "{{0:.command}}" for <let>. Only to-view/bind supported.`,
  [
    706
    /* ErrorNames.compiler_au_slot_on_non_element */
  ]: `Template compilation error: detected projection with [au-slot="{{0}}"] attempted on a non custom element {{1}}.`,
  [
    707
    /* ErrorNames.compiler_binding_to_non_bindable */
  ]: `Template compilation error: creating binding to non-bindable property {{0}} on {{1}}.`,
  [
    708
    /* ErrorNames.compiler_template_only_local_template */
  ]: `Template compilation error: the custom element "{{0}}" does not have any content other than local template(s).`,
  [
    709
    /* ErrorNames.compiler_local_el_not_under_root */
  ]: `Template compilation error: local element template needs to be defined directly under root of element "{{0}}".`,
  [
    710
    /* ErrorNames.compiler_local_el_bindable_not_under_root */
  ]: `Template compilation error: bindable properties of local element "{{0}}" template needs to be defined directly under <template>.`,
  [
    711
    /* ErrorNames.compiler_local_el_bindable_name_missing */
  ]: `Template compilation error: the attribute 'property' is missing in {{0:outerHTML}} in local element "{{1}}"`,
  [
    712
    /* ErrorNames.compiler_local_el_bindable_duplicate */
  ]: `Template compilation error: Bindable property and attribute needs to be unique; found property: {{0}}, attribute: {{1}}`,
  [
    713
    /* ErrorNames.compiler_unknown_binding_command */
  ]: `Template compilation error: unknown binding command: "{{0}}".{{0:bindingCommandHelp}}`,
  [
    714
    /* ErrorNames.compiler_primary_already_existed */
  ]: `Template compilation error: primary already exists on element/attribute "{{0}}"`,
  [
    715
    /* ErrorNames.compiler_local_name_empty */
  ]: `Template compilation error: the value of "as-custom-element" attribute cannot be empty for local element in element "{{0}}"`,
  [
    716
    /* ErrorNames.compiler_duplicate_local_name */
  ]: `Template compilation error: duplicate definition of the local template named "{{0}} in element {{1}}"`,
  [
    717
    /* ErrorNames.compiler_slot_without_shadowdom */
  ]: `Template compilation error: detected a usage of "<slot>" element without specifying shadow DOM options in element: {{0}}`,
  [
    718
    /* ErrorNames.compiler_no_spread_tc */
  ]: `Spreading template controller "{{0}}" is not supported.`,
  [
    719
    /* ErrorNames.compiler_attr_mapper_duplicate_mapping */
  ]: `Attribute {{0}} has been already registered for {{1:element}}`,
  [
    720
    /* ErrorNames.compiler_no_reserved_spread_syntax */
  ]: `Spreading syntax "...xxx" is reserved. Encountered "...{{0}}"`,
  [
    721
    /* ErrorNames.compiler_no_reserved_$bindable */
  ]: `Usage of $bindables is only allowed on custom element. Encountered: <{{0}} {{1}}="{{2}}">`,
  [
    722
    /* ErrorNames.compiler_no_dom_api */
  ]: "Invalid platform object provided to the compilation, no DOM API found.",
  [
    9998
    /* ErrorNames.no_spread_template_controller */
  ]: "Spread binding does not support spreading custom attributes/template controllers. Did you build the spread instruction manually?"
};
const getMessageByCode$2 = (name2, ...details) => {
  let cooked = errorsMap$2[name2];
  for (let i3 = 0; i3 < details.length; ++i3) {
    const regex = new RegExp(`{{${i3}(:.*)?}}`, "g");
    let matches2 = regex.exec(cooked);
    while (matches2 != null) {
      const method = matches2[1]?.slice(1);
      let value = details[i3];
      if (value != null) {
        switch (method) {
          case "nodeName":
            value = value.nodeName.toLowerCase();
            break;
          case "name":
            value = value.name;
            break;
          case "typeof":
            value = typeof value;
            break;
          case "ctor":
            value = value.constructor.name;
            break;
          case "controller":
            value = value.controller.name;
            break;
          case "target@property":
            value = `${value.target}@${value.targetProperty}`;
            break;
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "bindingCommandHelp":
            value = getBindingCommandHelp$1(value);
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = String(value[method.slice(1)]);
            } else {
              value = String(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches2.index) + value + cooked.slice(regex.lastIndex);
      matches2 = regex.exec(cooked);
    }
  }
  return cooked;
};
function getBindingCommandHelp$1(name2) {
  switch (name2) {
    case "delegate":
      return `
The ".delegate" binding command has been removed in v2. Binding command ".trigger" should be used instead. If you are migrating v1 application, install compat package to add back the ".delegate" binding command for ease of migration.`;
    case "call":
      return `
The ".call" binding command has been removed in v2. If you want to pass a callback that preserves the context of the function call, you can use lambda instead. Refer to lambda expression doc for more details.`;
    default:
      return "";
  }
}
var _a$5, _b$2, _c$1, _d, _e$1;
class CharSpec {
  constructor(chars, repeat, isSymbol, isInverted) {
    this.chars = chars;
    this.repeat = repeat;
    this.isSymbol = isSymbol;
    this.isInverted = isInverted;
    if (isInverted) {
      switch (chars.length) {
        case 0:
          this.has = this._hasOfNoneInverse;
          break;
        case 1:
          this.has = this._hasOfSingleInverse;
          break;
        default:
          this.has = this._hasOfMultipleInverse;
      }
    } else {
      switch (chars.length) {
        case 0:
          this.has = this._hasOfNone;
          break;
        case 1:
          this.has = this._hasOfSingle;
          break;
        default:
          this.has = this._hasOfMultiple;
      }
    }
  }
  equals(other) {
    return this.chars === other.chars && this.repeat === other.repeat && this.isSymbol === other.isSymbol && this.isInverted === other.isInverted;
  }
  /** @internal */
  _hasOfMultiple(char) {
    return this.chars.includes(char);
  }
  /** @internal */
  _hasOfSingle(char) {
    return this.chars === char;
  }
  /** @internal */
  _hasOfNone(_char) {
    return false;
  }
  /** @internal */
  _hasOfMultipleInverse(char) {
    return !this.chars.includes(char);
  }
  /** @internal */
  _hasOfSingleInverse(char) {
    return this.chars !== char;
  }
  /** @internal */
  _hasOfNoneInverse(_char) {
    return true;
  }
}
class Interpretation {
  constructor() {
    this.parts = emptyArray;
    this._pattern = "";
    this._currentRecord = {};
    this._partsRecord = {};
  }
  get pattern() {
    const value = this._pattern;
    if (value === "") {
      return null;
    } else {
      return value;
    }
  }
  set pattern(value) {
    if (value == null) {
      this._pattern = "";
      this.parts = emptyArray;
    } else {
      this._pattern = value;
      this.parts = this._partsRecord[value];
    }
  }
  append(pattern, ch) {
    const currentRecord = this._currentRecord;
    if (currentRecord[pattern] === void 0) {
      currentRecord[pattern] = ch;
    } else {
      currentRecord[pattern] += ch;
    }
  }
  next(pattern) {
    const currentRecord = this._currentRecord;
    let partsRecord;
    if (currentRecord[pattern] !== void 0) {
      partsRecord = this._partsRecord;
      if (partsRecord[pattern] === void 0) {
        partsRecord[pattern] = [currentRecord[pattern]];
      } else {
        partsRecord[pattern].push(currentRecord[pattern]);
      }
      currentRecord[pattern] = void 0;
    }
  }
}
class AttrParsingState {
  get _pattern() {
    return this._isEndpoint ? this._patterns[0] : null;
  }
  constructor(charSpec, ...patterns) {
    this.charSpec = charSpec;
    this._nextStates = [];
    this._types = null;
    this._isEndpoint = false;
    this._patterns = patterns;
  }
  findChild(charSpec) {
    const nextStates = this._nextStates;
    const len = nextStates.length;
    let child = null;
    let i3 = 0;
    for (; i3 < len; ++i3) {
      child = nextStates[i3];
      if (charSpec.equals(child.charSpec)) {
        return child;
      }
    }
    return null;
  }
  append(charSpec, pattern) {
    const patterns = this._patterns;
    if (!patterns.includes(pattern)) {
      patterns.push(pattern);
    }
    let state = this.findChild(charSpec);
    if (state == null) {
      state = new AttrParsingState(charSpec, pattern);
      this._nextStates.push(state);
      if (charSpec.repeat) {
        state._nextStates.push(state);
      }
    }
    return state;
  }
  findMatches(ch, interpretation) {
    const results = [];
    const nextStates = this._nextStates;
    const len = nextStates.length;
    let childLen = 0;
    let child = null;
    let i3 = 0;
    let j2 = 0;
    for (; i3 < len; ++i3) {
      child = nextStates[i3];
      if (child.charSpec.has(ch)) {
        results.push(child);
        childLen = child._patterns.length;
        j2 = 0;
        if (child.charSpec.isSymbol) {
          for (; j2 < childLen; ++j2) {
            interpretation.next(child._patterns[j2]);
          }
        } else {
          for (; j2 < childLen; ++j2) {
            interpretation.append(child._patterns[j2], ch);
          }
        }
      }
    }
    return results;
  }
}
let StaticSegment$1 = class StaticSegment {
  constructor(text) {
    this.text = text;
    const len = this._len = text.length;
    const specs = this._specs = [];
    let i3 = 0;
    for (; len > i3; ++i3) {
      specs.push(new CharSpec(text[i3], false, false, false));
    }
  }
  eachChar(callback) {
    const len = this._len;
    const specs = this._specs;
    let i3 = 0;
    for (; len > i3; ++i3) {
      callback(specs[i3]);
    }
  }
};
let DynamicSegment$1 = class DynamicSegment {
  constructor(symbols) {
    this.text = "PART";
    this._spec = new CharSpec(symbols, true, false, true);
  }
  eachChar(callback) {
    callback(this._spec);
  }
};
class SymbolSegment {
  constructor(text) {
    this.text = text;
    this._spec = new CharSpec(text, false, true, false);
  }
  eachChar(callback) {
    callback(this._spec);
  }
}
class SegmentTypes {
  constructor() {
    this.statics = 0;
    this.dynamics = 0;
    this.symbols = 0;
  }
}
const ISyntaxInterpreter = /* @__PURE__ */ tcCreateInterface("ISyntaxInterpreter", (x2) => x2.singleton(SyntaxInterpreter));
class SyntaxInterpreter {
  constructor() {
    this._rootState = new AttrParsingState(null);
    this._initialStates = [this._rootState];
  }
  // todo: this only works if this method is ever called only once
  add(defs) {
    defs = defs.slice(0).sort((d1, d2) => d1.pattern > d2.pattern ? 1 : -1);
    const ii = defs.length;
    let currentState;
    let def2;
    let pattern;
    let types;
    let segments;
    let len;
    let charSpecCb;
    let i3 = 0;
    let j2;
    while (ii > i3) {
      currentState = this._rootState;
      def2 = defs[i3];
      pattern = def2.pattern;
      types = new SegmentTypes();
      segments = this._parse(def2, types);
      len = segments.length;
      charSpecCb = (ch) => currentState = currentState.append(ch, pattern);
      for (j2 = 0; len > j2; ++j2) {
        segments[j2].eachChar(charSpecCb);
      }
      currentState._types = types;
      currentState._isEndpoint = true;
      ++i3;
    }
  }
  interpret(name2) {
    const interpretation = new Interpretation();
    const len = name2.length;
    let states = this._initialStates;
    let i3 = 0;
    let state;
    for (; i3 < len; ++i3) {
      states = this._getNextStates(states, name2.charAt(i3), interpretation);
      if (states.length === 0) {
        break;
      }
    }
    states = states.filter(isEndpoint);
    if (states.length > 0) {
      states.sort(sortEndpoint);
      state = states[0];
      if (!state.charSpec.isSymbol) {
        interpretation.next(state._pattern);
      }
      interpretation.pattern = state._pattern;
    }
    return interpretation;
  }
  /** @internal */
  _getNextStates(states, ch, interpretation) {
    const nextStates = [];
    let state = null;
    const len = states.length;
    let i3 = 0;
    for (; i3 < len; ++i3) {
      state = states[i3];
      nextStates.push(...state.findMatches(ch, interpretation));
    }
    return nextStates;
  }
  /** @internal */
  _parse(def2, types) {
    const result = [];
    const pattern = def2.pattern;
    const len = pattern.length;
    const symbols = def2.symbols;
    let i3 = 0;
    let start2 = 0;
    let c2 = "";
    while (i3 < len) {
      c2 = pattern.charAt(i3);
      if (symbols.length === 0 || !symbols.includes(c2)) {
        if (i3 === start2) {
          if (c2 === "P" && pattern.slice(i3, i3 + 4) === "PART") {
            start2 = i3 = i3 + 4;
            result.push(new DynamicSegment$1(symbols));
            ++types.dynamics;
          } else {
            ++i3;
          }
        } else {
          ++i3;
        }
      } else if (i3 !== start2) {
        result.push(new StaticSegment$1(pattern.slice(start2, i3)));
        ++types.statics;
        start2 = i3;
      } else {
        result.push(new SymbolSegment(pattern.slice(start2, i3 + 1)));
        ++types.symbols;
        start2 = ++i3;
      }
    }
    if (start2 !== i3) {
      result.push(new StaticSegment$1(pattern.slice(start2, i3)));
      ++types.statics;
    }
    return result;
  }
}
function isEndpoint(a2) {
  return a2._isEndpoint;
}
function sortEndpoint(a2, b3) {
  const aTypes = a2._types;
  const bTypes = b3._types;
  if (aTypes.statics !== bTypes.statics) {
    return bTypes.statics - aTypes.statics;
  }
  if (aTypes.dynamics !== bTypes.dynamics) {
    return bTypes.dynamics - aTypes.dynamics;
  }
  if (aTypes.symbols !== bTypes.symbols) {
    return bTypes.symbols - aTypes.symbols;
  }
  return 0;
}
class AttrSyntax {
  constructor(rawName, rawValue, target, command, parts = null) {
    this.rawName = rawName;
    this.rawValue = rawValue;
    this.target = target;
    this.command = command;
    this.parts = parts;
  }
}
const IAttributePattern = /* @__PURE__ */ tcCreateInterface("IAttributePattern");
const IAttributeParser = /* @__PURE__ */ tcCreateInterface("IAttributeParser", (x2) => x2.singleton(AttributeParser));
class AttributeParser {
  constructor() {
    this._cache = {};
    this._patterns = {};
    this._initialized = false;
    this._allDefinitions = [];
    this._interpreter = resolve(ISyntaxInterpreter);
    this._container = resolve(IContainer);
  }
  registerPattern(patterns, Type) {
    if (this._initialized)
      throw createMappedError$4(
        88
        /* ErrorNames.attribute_pattern_already_initialized */
      );
    const $patterns = this._patterns;
    for (const { pattern } of patterns) {
      if ($patterns[pattern] != null)
        throw createMappedError$4(89, pattern);
      $patterns[pattern] = { patternType: Type };
    }
    this._allDefinitions.push(...patterns);
  }
  /** @internal */
  _initialize() {
    this._interpreter.add(this._allDefinitions);
    const _container = this._container;
    for (const [, value] of Object.entries(this._patterns)) {
      value.pattern = _container.get(value.patternType);
    }
  }
  parse(name2, value) {
    if (!this._initialized) {
      this._initialize();
      this._initialized = true;
    }
    let interpretation = this._cache[name2];
    if (interpretation == null) {
      interpretation = this._cache[name2] = this._interpreter.interpret(name2);
    }
    const pattern = interpretation.pattern;
    if (pattern == null) {
      return new AttrSyntax(name2, value, name2, null, null);
    } else {
      return this._patterns[pattern].pattern[pattern](name2, value, interpretation.parts);
    }
  }
}
const AttributePattern = /* @__PURE__ */ tcObjectFreeze({
  name: getResourceKeyFor("attribute-pattern"),
  create(patternDefs, Type) {
    return {
      register(container) {
        container.get(IAttributeParser).registerPattern(patternDefs, Type);
        singletonRegistration$1(IAttributePattern, Type).register(container);
      }
    };
  }
});
class DotSeparatedAttributePattern {
  "PART.PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], parts[1]);
  }
  "PART.PART.PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, `${parts[0]}.${parts[1]}`, parts[2]);
  }
}
_a$5 = Symbol.metadata;
DotSeparatedAttributePattern[_a$5] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "PART.PART", symbols: "." },
    { pattern: "PART.PART.PART", symbols: "." }
  ], DotSeparatedAttributePattern)
};
class RefAttributePattern {
  "ref"(rawName, rawValue, _parts) {
    return new AttrSyntax(rawName, rawValue, "element", "ref");
  }
  "PART.ref"(rawName, rawValue, parts) {
    let target = parts[0];
    if (target === "view-model") {
      target = "component";
      {
        console.warn(`[aurelia] Detected view-model.ref usage: "${rawName}=${rawValue}". This is deprecated and component.ref should be used instead`);
      }
    }
    return new AttrSyntax(rawName, rawValue, target, "ref");
  }
}
_b$2 = Symbol.metadata;
RefAttributePattern[_b$2] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "ref", symbols: "" },
    { pattern: "PART.ref", symbols: "." }
  ], RefAttributePattern)
};
class EventAttributePattern {
  "PART.trigger:PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "trigger", parts);
  }
  "PART.capture:PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "capture", parts);
  }
}
_c$1 = Symbol.metadata;
EventAttributePattern[_c$1] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "PART.trigger:PART", symbols: ".:" },
    { pattern: "PART.capture:PART", symbols: ".:" }
  ], EventAttributePattern)
};
class ColonPrefixedBindAttributePattern {
  ":PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "bind");
  }
}
_d = Symbol.metadata;
ColonPrefixedBindAttributePattern[_d] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([{ pattern: ":PART", symbols: ":" }], ColonPrefixedBindAttributePattern)
};
class AtPrefixedTriggerAttributePattern {
  "@PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "trigger");
  }
  "@PART:PART"(rawName, rawValue, parts) {
    return new AttrSyntax(rawName, rawValue, parts[0], "trigger", [parts[0], "trigger", ...parts.slice(1)]);
  }
}
_e$1 = Symbol.metadata;
AtPrefixedTriggerAttributePattern[_e$1] = {
  [registrableMetadataKey]: /* @__PURE__ */ AttributePattern.create([
    { pattern: "@PART", symbols: "@" },
    { pattern: "@PART:PART", symbols: "@:" }
  ], AtPrefixedTriggerAttributePattern)
};
const getMetadata$1 = Metadata.get;
const defineMetadata$1 = Metadata.define;
const hydrateElement = "ra";
const hydrateAttribute = "rb";
const hydrateTemplateController = "rc";
const hydrateLetElement = "rd";
const setProperty = "re";
const interpolation = "rf";
const propertyBinding = "rg";
const letBinding = "ri";
const refBinding = "rj";
const iteratorBinding = "rk";
const multiAttr = "rl";
const textBinding = "ha";
const listenerBinding = "hb";
const attributeBinding = "hc";
const stylePropertyBinding = "hd";
const setAttribute = "he";
const setClassAttribute = "hf";
const setStyleAttribute = "hg";
const spreadTransferedBinding = "hs";
const spreadElementProp = "hp";
const spreadValueBinding = "svb";
const InstructionType = /* @__PURE__ */ tcObjectFreeze({
  hydrateElement,
  hydrateAttribute,
  hydrateTemplateController,
  hydrateLetElement,
  setProperty,
  interpolation,
  propertyBinding,
  letBinding,
  refBinding,
  iteratorBinding,
  multiAttr,
  textBinding,
  listenerBinding,
  attributeBinding,
  stylePropertyBinding,
  setAttribute,
  setClassAttribute,
  setStyleAttribute,
  spreadTransferedBinding,
  spreadElementProp,
  spreadValueBinding
});
const IInstruction = /* @__PURE__ */ tcCreateInterface("Instruction");
class InterpolationInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
    this.type = interpolation;
  }
}
class PropertyBindingInstruction {
  constructor(from, to, mode) {
    this.from = from;
    this.to = to;
    this.mode = mode;
    this.type = propertyBinding;
  }
}
class IteratorBindingInstruction {
  constructor(forOf, to, props2) {
    this.forOf = forOf;
    this.to = to;
    this.props = props2;
    this.type = iteratorBinding;
  }
}
class RefBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
    this.type = refBinding;
  }
}
class SetPropertyInstruction {
  constructor(value, to) {
    this.value = value;
    this.to = to;
    this.type = setProperty;
  }
}
class MultiAttrInstruction {
  constructor(value, to, command) {
    this.value = value;
    this.to = to;
    this.command = command;
    this.type = multiAttr;
  }
}
class HydrateElementInstruction {
  constructor(res, props2, projections, containerless, captures, data) {
    this.res = res;
    this.props = props2;
    this.projections = projections;
    this.containerless = containerless;
    this.captures = captures;
    this.data = data;
    this.type = hydrateElement;
  }
}
class HydrateAttributeInstruction {
  constructor(res, alias, props2) {
    this.res = res;
    this.alias = alias;
    this.props = props2;
    this.type = hydrateAttribute;
  }
}
class HydrateTemplateController {
  constructor(def2, res, alias, props2) {
    this.def = def2;
    this.res = res;
    this.alias = alias;
    this.props = props2;
    this.type = hydrateTemplateController;
  }
}
class HydrateLetElementInstruction {
  constructor(instructions, toBindingContext) {
    this.instructions = instructions;
    this.toBindingContext = toBindingContext;
    this.type = hydrateLetElement;
  }
}
class LetBindingInstruction {
  constructor(from, to) {
    this.from = from;
    this.to = to;
    this.type = letBinding;
  }
}
class TextBindingInstruction {
  constructor(from) {
    this.from = from;
    this.type = textBinding;
  }
}
class ListenerBindingInstruction {
  constructor(from, to, capture, modifier) {
    this.from = from;
    this.to = to;
    this.capture = capture;
    this.modifier = modifier;
    this.type = listenerBinding;
  }
}
class SetAttributeInstruction {
  constructor(value, to) {
    this.value = value;
    this.to = to;
    this.type = setAttribute;
  }
}
class SetClassAttributeInstruction {
  constructor(value) {
    this.value = value;
    this.type = setClassAttribute;
  }
}
class SetStyleAttributeInstruction {
  constructor(value) {
    this.value = value;
    this.type = setStyleAttribute;
  }
}
class AttributeBindingInstruction {
  constructor(attr, from, to) {
    this.attr = attr;
    this.from = from;
    this.to = to;
    this.type = attributeBinding;
  }
}
class SpreadTransferedBindingInstruction {
  constructor() {
    this.type = spreadTransferedBinding;
  }
}
class SpreadElementPropBindingInstruction {
  constructor(instruction) {
    this.instruction = instruction;
    this.type = spreadElementProp;
  }
}
class SpreadValueBindingInstruction {
  constructor(target, from) {
    this.target = target;
    this.from = from;
    this.type = spreadValueBinding;
  }
}
class BindingCommandDefinition {
  constructor(Type, name2, aliases, key) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    return new BindingCommandDefinition(Type, firstDefined(getCommandAnnotation(Type, "name"), name2), mergeArrays(getCommandAnnotation(Type, "aliases"), def2.aliases, Type.aliases), getCommandKeyFrom(name2));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getCommandKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration$1($Type, $Type), aliasRegistration$1($Type, key), ...aliases.map((alias) => aliasRegistration$1($Type, getCommandKeyFrom(alias))));
    } else {
      console.warn(`[DEV:aurelia] ${createMappedError$4(157, this.name)}`);
    }
  }
}
const bindingCommandTypeName = "binding-command";
const cmdBaseName = /* @__PURE__ */ getResourceKeyFor(bindingCommandTypeName);
const getCommandKeyFrom = (name2) => `${cmdBaseName}:${name2}`;
const getCommandAnnotation = (Type, prop) => getMetadata$1(Protocol.annotation.keyFor(prop), Type);
const BindingCommand = /* @__PURE__ */ (() => {
  const staticResourceDefinitionMetadataKey = "__au_static_resource__";
  const getDefinitionFromStaticAu2 = (Type, typeName, createDef) => {
    let def2 = getMetadata$1(staticResourceDefinitionMetadataKey, Type);
    if (def2 == null) {
      if (Type.$au?.type === typeName) {
        def2 = createDef(Type.$au, Type);
        defineMetadata$1(def2, Type, staticResourceDefinitionMetadataKey);
      }
    }
    return def2;
  };
  return tcObjectFreeze({
    name: cmdBaseName,
    keyFrom: getCommandKeyFrom,
    // isType<T>(value: T): value is (T extends Constructable ? BindingCommandType<T> : never) {
    //   return isFunction(value) && hasOwnMetadata(cmdBaseName, value);
    // },
    define(nameOrDef, Type) {
      const definition = BindingCommandDefinition.create(nameOrDef, Type);
      const $Type = definition.Type;
      defineMetadata$1(definition, $Type, cmdBaseName, resourceBaseName);
      return $Type;
    },
    getAnnotation: getCommandAnnotation,
    find(container, name2) {
      const Type = container.find(bindingCommandTypeName, name2);
      return Type == null ? null : getMetadata$1(cmdBaseName, Type) ?? getDefinitionFromStaticAu2(Type, bindingCommandTypeName, BindingCommandDefinition.create) ?? null;
    },
    get(container, name2) {
      {
        try {
          return container.get(resource(getCommandKeyFrom(name2)));
        } catch (ex) {
          console.log(`


[DEV:aurelia] Cannot retrieve binding command with name




`, name2);
          throw ex;
        }
      }
      return container.get(resource(getCommandKeyFrom(name2)));
    }
  });
})();
class OneTimeBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = info2.attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      1
      /* InternalBindingMode.oneTime */
    );
  }
}
OneTimeBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "one-time"
};
class ToViewBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = info2.attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      2
      /* InternalBindingMode.toView */
    );
  }
}
ToViewBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "to-view"
};
class FromViewBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      4
      /* InternalBindingMode.fromView */
    );
  }
}
FromViewBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "from-view"
};
class TwoWayBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    let target = attr.target;
    let value = attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    if (info2.bindable == null) {
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      target = info2.bindable.name;
    }
    return new PropertyBindingInstruction(
      exprParser.parse(value, etIsProperty$1),
      target,
      6
      /* InternalBindingMode.twoWay */
    );
  }
}
TwoWayBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "two-way"
};
class DefaultBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser, attrMapper) {
    const attr = info2.attr;
    const bindable2 = info2.bindable;
    let value = attr.rawValue;
    let target = attr.target;
    let defDefaultMode;
    let mode;
    value = value === "" ? camelCase(target) : value;
    if (bindable2 == null) {
      mode = attrMapper.isTwoWay(info2.node, target) ? 6 : 2;
      target = attrMapper.map(info2.node, target) ?? camelCase(target);
    } else {
      defDefaultMode = info2.def.defaultBindingMode ?? 0;
      mode = bindable2.mode === 0 || bindable2.mode == null ? defDefaultMode == null || defDefaultMode === 0 ? 2 : defDefaultMode : bindable2.mode;
      target = bindable2.name;
    }
    return new PropertyBindingInstruction(exprParser.parse(value, etIsProperty$1), target, isString(mode) ? BindingMode[mode] ?? 0 : mode);
  }
}
DefaultBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "bind"
};
class ForBindingCommand {
  constructor() {
    this._attrParser = resolve(IAttributeParser);
  }
  get ignoreAttr() {
    return false;
  }
  build(info2, exprParser) {
    const target = info2.bindable === null ? camelCase(info2.attr.target) : info2.bindable.name;
    const forOf = exprParser.parse(info2.attr.rawValue, "IsIterator");
    let props2 = emptyArray;
    if (forOf.semiIdx > -1) {
      const attr = info2.attr.rawValue.slice(forOf.semiIdx + 1);
      const i3 = attr.indexOf(":");
      if (i3 > -1) {
        const attrName = attr.slice(0, i3).trim();
        const attrValue = attr.slice(i3 + 1).trim();
        const attrSyntax = this._attrParser.parse(attrName, attrValue);
        props2 = [new MultiAttrInstruction(attrValue, attrSyntax.target, attrSyntax.command)];
      }
    }
    return new IteratorBindingInstruction(forOf, target, props2);
  }
}
ForBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "for"
};
class TriggerBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new ListenerBindingInstruction(exprParser.parse(info2.attr.rawValue, etIsFunction$1), info2.attr.target, false, info2.attr.parts?.[2] ?? null);
  }
}
TriggerBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "trigger"
};
class CaptureBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new ListenerBindingInstruction(exprParser.parse(info2.attr.rawValue, etIsFunction$1), info2.attr.target, true, info2.attr.parts?.[2] ?? null);
  }
}
CaptureBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "capture"
};
class AttrBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    const attr = info2.attr;
    const target = attr.target;
    let value = attr.rawValue;
    value = value === "" ? camelCase(target) : value;
    return new AttributeBindingInstruction(target, exprParser.parse(value, etIsProperty$1), target);
  }
}
AttrBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "attr"
};
class StyleBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new AttributeBindingInstruction("style", exprParser.parse(info2.attr.rawValue, etIsProperty$1), info2.attr.target);
  }
}
StyleBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "style"
};
class ClassBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new AttributeBindingInstruction("class", exprParser.parse(info2.attr.rawValue, etIsProperty$1), info2.attr.target);
  }
}
ClassBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "class"
};
class RefBindingCommand {
  get ignoreAttr() {
    return true;
  }
  build(info2, exprParser) {
    return new RefBindingInstruction(exprParser.parse(info2.attr.rawValue, etIsProperty$1), info2.attr.target);
  }
}
RefBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "ref"
};
class SpreadValueBindingCommand {
  get ignoreAttr() {
    return false;
  }
  build(info2) {
    return new SpreadValueBindingInstruction(info2.attr.target, info2.attr.rawValue);
  }
}
SpreadValueBindingCommand.$au = {
  type: bindingCommandTypeName,
  name: "spread"
};
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
const ITemplateElementFactory = /* @__PURE__ */ tcCreateInterface("ITemplateElementFactory", (x2) => x2.singleton(TemplateElementFactory));
const markupCache = {};
class TemplateElementFactory {
  constructor() {
    this.p = resolve(IPlatform$1);
    this._template = this.t();
  }
  t() {
    return this.p.document.createElement("template");
  }
  createTemplate(input) {
    if (isString(input)) {
      let result = markupCache[input];
      if (result === void 0) {
        const template2 = this._template;
        template2.innerHTML = input;
        const node = template2.content.firstElementChild;
        if (needsWrapping(node)) {
          this._template = this.t();
          result = template2;
        } else {
          template2.content.removeChild(node);
          result = node;
        }
        markupCache[input] = result;
      }
      return result.cloneNode(true);
    }
    if (input.nodeName !== "TEMPLATE") {
      const template2 = this.t();
      template2.content.appendChild(input);
      return template2;
    }
    input.parentNode?.removeChild(input);
    return input.cloneNode(true);
    function needsWrapping(node) {
      if (node == null)
        return true;
      if (node.nodeName !== "TEMPLATE")
        return true;
      const nextElementSibling = node.nextElementSibling;
      if (nextElementSibling != null)
        return true;
      const prevSibling = node.previousSibling;
      if (prevSibling != null) {
        switch (prevSibling.nodeType) {
          case 3:
            return prevSibling.textContent.trim().length > 0;
        }
      }
      const nextSibling = node.nextSibling;
      if (nextSibling != null) {
        switch (nextSibling.nodeType) {
          case 3:
            return nextSibling.textContent.trim().length > 0;
        }
      }
      return false;
    }
  }
}
const auLocationStart = "au-start";
const auLocationEnd = "au-end";
const insertBefore = (parent, newChildNode, target) => {
  return parent.insertBefore(newChildNode, target);
};
const insertManyBefore$1 = (parent, target, newChildNodes) => {
  if (parent === null) {
    return;
  }
  const ii = newChildNodes.length;
  let i3 = 0;
  while (ii > i3) {
    parent.insertBefore(newChildNodes[i3], target);
    ++i3;
  }
};
const appendToTemplate = (parent, child) => {
  return parent.content.appendChild(child);
};
const appendManyToTemplate = (parent, children) => {
  const ii = children.length;
  let i3 = 0;
  while (ii > i3) {
    parent.content.appendChild(children[i3]);
    ++i3;
  }
};
const isElement$3 = (node) => node.nodeType === 1;
const isTextNode = (node) => node.nodeType === 3;
const auslotAttr$1 = "au-slot";
const defaultSlotName$1 = "default";
const generateElementName$1 = /* @__PURE__ */ ((id2) => () => `anonymous-${++id2}`)(0);
class TemplateCompiler {
  constructor() {
    this.debug = false;
    this.resolveResources = true;
  }
  compile(definition, container) {
    if (definition.template == null || definition.needsCompile === false) {
      return definition;
    }
    const context = new CompilationContext(definition, container, null, null, void 0);
    const template2 = isString(definition.template) || !definition.enhance ? context._templateFactory.createTemplate(definition.template) : definition.template;
    const isTemplateElement = template2.nodeName === TEMPLATE_NODE_NAME && template2.content != null;
    const content = isTemplateElement ? template2.content : template2;
    const hooks = TemplateCompilerHooks.findAll(container);
    const ii = hooks.length;
    let i3 = 0;
    if (ii > 0) {
      while (ii > i3) {
        hooks[i3].compiling?.(template2);
        ++i3;
      }
    }
    if (template2.hasAttribute(localTemplateIdentifier)) {
      throw createMappedError$4(701, definition);
    }
    this._compileLocalElement(content, context);
    this._compileNode(content, context);
    const compiledDef = {
      ...definition,
      name: definition.name || generateElementName$1(),
      dependencies: (definition.dependencies ?? emptyArray).concat(context.deps ?? emptyArray),
      instructions: context.rows,
      surrogates: isTemplateElement ? this._compileSurrogate(template2, context) : emptyArray,
      template: template2,
      hasSlots: context.hasSlot,
      needsCompile: false
    };
    return compiledDef;
  }
  compileSpread(requestor, attrSyntaxs, container, target, targetDef) {
    const context = new CompilationContext(requestor, container, null, null, void 0);
    const instructions = [];
    const elDef = targetDef ?? context._findElement(target.nodeName.toLowerCase());
    const isCustomElement = elDef !== null;
    const exprParser = context._exprParser;
    const ii = attrSyntaxs.length;
    let i3 = 0;
    let attrSyntax;
    let attrDef = null;
    let attrInstructions;
    let attrBindableInstructions;
    let bindablesInfo;
    let bindable2;
    let primaryBindable;
    let bindingCommand = null;
    let expr;
    let isMultiBindings;
    let attrTarget;
    let attrValue;
    for (; ii > i3; ++i3) {
      attrSyntax = attrSyntaxs[i3];
      attrTarget = attrSyntax.target;
      attrValue = attrSyntax.rawValue;
      if (attrTarget === "...$attrs") {
        instructions.push(new SpreadTransferedBindingInstruction());
        continue;
      }
      bindingCommand = context._getCommand(attrSyntax);
      if (bindingCommand !== null && bindingCommand.ignoreAttr) {
        commandBuildInfo.node = target;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
        continue;
      }
      if (isCustomElement) {
        bindablesInfo = context._getBindables(elDef);
        bindable2 = bindablesInfo.attrs[attrTarget];
        if (bindable2 !== void 0) {
          if (bindingCommand == null) {
            expr = exprParser.parse(attrValue, etInterpolation$1);
            instructions.push(new SpreadElementPropBindingInstruction(expr == null ? new SetPropertyInstruction(attrValue, bindable2.name) : new InterpolationInstruction(expr, bindable2.name)));
          } else {
            commandBuildInfo.node = target;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = bindable2;
            commandBuildInfo.def = elDef;
            instructions.push(new SpreadElementPropBindingInstruction(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)));
          }
          continue;
        }
      }
      attrDef = context._findAttr(attrTarget);
      if (attrDef !== null) {
        if (attrDef.isTemplateController) {
          throw createMappedError$4(9998, attrTarget);
        }
        bindablesInfo = context._getBindables(attrDef);
        isMultiBindings = attrDef.noMultiBindings === false && bindingCommand === null && hasInlineBindings(attrValue);
        if (isMultiBindings) {
          attrBindableInstructions = this._compileMultiBindings(target, attrValue, attrDef, context);
        } else {
          primaryBindable = bindablesInfo.primary;
          if (bindingCommand === null) {
            expr = exprParser.parse(attrValue, etInterpolation$1);
            attrBindableInstructions = [
              expr === null ? new SetPropertyInstruction(attrValue, primaryBindable.name) : new InterpolationInstruction(expr, primaryBindable.name)
            ];
          } else {
            commandBuildInfo.node = target;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = primaryBindable;
            commandBuildInfo.def = attrDef;
            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];
          }
        }
        (attrInstructions ??= []).push(new HydrateAttributeInstruction(
          // todo: def/ def.Type or def.name should be configurable
          //       example: AOT/runtime can use def.Type, but there are situation
          //       where instructions need to be serialized, def.name should be used
          this.resolveResources ? attrDef : attrDef.name,
          attrDef.aliases != null && attrDef.aliases.includes(attrTarget) ? attrTarget : void 0,
          attrBindableInstructions
        ));
        continue;
      }
      if (bindingCommand == null) {
        expr = exprParser.parse(attrValue, etInterpolation$1);
        if (expr != null) {
          instructions.push(new InterpolationInstruction(
            expr,
            // if not a bindable, then ensure plain attribute are mapped correctly:
            // e.g: colspan -> colSpan
            //      innerhtml -> innerHTML
            //      minlength -> minLength etc...
            context._attrMapper.map(target, attrTarget) ?? camelCase(attrTarget)
          ));
        } else {
          switch (attrTarget) {
            case "class":
              instructions.push(new SetClassAttributeInstruction(attrValue));
              break;
            case "style":
              instructions.push(new SetStyleAttributeInstruction(attrValue));
              break;
            default:
              instructions.push(new SetAttributeInstruction(attrValue, attrTarget));
          }
        }
      } else {
        commandBuildInfo.node = target;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
      }
    }
    resetCommandBuildInfo();
    if (attrInstructions != null) {
      return attrInstructions.concat(instructions);
    }
    return instructions;
  }
  /** @internal */
  _compileSurrogate(el, context) {
    const instructions = [];
    const attrs = el.attributes;
    const exprParser = context._exprParser;
    let ii = attrs.length;
    let i3 = 0;
    let attr;
    let attrName;
    let attrValue;
    let attrSyntax;
    let attrDef = null;
    let attrInstructions;
    let attrBindableInstructions;
    let bindableInfo;
    let primaryBindable;
    let bindingCommand = null;
    let expr;
    let isMultiBindings;
    let realAttrTarget;
    let realAttrValue;
    for (; ii > i3; ++i3) {
      attr = attrs[i3];
      attrName = attr.name;
      attrValue = attr.value;
      attrSyntax = context._attrParser.parse(attrName, attrValue);
      realAttrTarget = attrSyntax.target;
      realAttrValue = attrSyntax.rawValue;
      if (invalidSurrogateAttribute[realAttrTarget]) {
        throw createMappedError$4(702, attrName);
      }
      bindingCommand = context._getCommand(attrSyntax);
      if (bindingCommand !== null && bindingCommand.ignoreAttr) {
        commandBuildInfo.node = el;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
        continue;
      }
      attrDef = context._findAttr(realAttrTarget);
      if (attrDef !== null) {
        if (attrDef.isTemplateController) {
          throw createMappedError$4(703, realAttrTarget);
        }
        bindableInfo = context._getBindables(attrDef);
        isMultiBindings = attrDef.noMultiBindings === false && bindingCommand === null && hasInlineBindings(realAttrValue);
        if (isMultiBindings) {
          attrBindableInstructions = this._compileMultiBindings(el, realAttrValue, attrDef, context);
        } else {
          primaryBindable = bindableInfo.primary;
          if (bindingCommand === null) {
            expr = exprParser.parse(realAttrValue, etInterpolation$1);
            attrBindableInstructions = expr === null ? realAttrValue === "" ? [] : [new SetPropertyInstruction(realAttrValue, primaryBindable.name)] : [new InterpolationInstruction(expr, primaryBindable.name)];
          } else {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = primaryBindable;
            commandBuildInfo.def = attrDef;
            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];
          }
        }
        el.removeAttribute(attrName);
        --i3;
        --ii;
        (attrInstructions ??= []).push(new HydrateAttributeInstruction(
          // todo: def/ def.Type or def.name should be configurable
          //       example: AOT/runtime can use def.Type, but there are situation
          //       where instructions need to be serialized, def.name should be used
          this.resolveResources ? attrDef : attrDef.name,
          attrDef.aliases != null && attrDef.aliases.includes(realAttrTarget) ? realAttrTarget : void 0,
          attrBindableInstructions
        ));
        continue;
      }
      if (bindingCommand === null) {
        expr = exprParser.parse(realAttrValue, etInterpolation$1);
        if (expr != null) {
          el.removeAttribute(attrName);
          --i3;
          --ii;
          instructions.push(new InterpolationInstruction(
            expr,
            // if not a bindable, then ensure plain attribute are mapped correctly:
            // e.g: colspan -> colSpan
            //      innerhtml -> innerHTML
            //      minlength -> minLength etc...
            context._attrMapper.map(el, realAttrTarget) ?? camelCase(realAttrTarget)
          ));
        } else {
          switch (attrName) {
            case "class":
              instructions.push(new SetClassAttributeInstruction(realAttrValue));
              break;
            case "style":
              instructions.push(new SetStyleAttributeInstruction(realAttrValue));
              break;
            default:
              instructions.push(new SetAttributeInstruction(realAttrValue, attrName));
          }
        }
      } else {
        commandBuildInfo.node = el;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        instructions.push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
      }
    }
    resetCommandBuildInfo();
    if (attrInstructions != null) {
      return attrInstructions.concat(instructions);
    }
    return instructions;
  }
  // overall flow:
  // each of the method will be responsible for compiling its corresponding node type
  // and it should return the next node to be compiled
  /** @internal */
  _compileNode(node, context) {
    switch (node.nodeType) {
      case 1:
        switch (node.nodeName) {
          case "LET":
            return this._compileLet(node, context);
          default:
            return this._compileElement(node, context);
        }
      case 3:
        return this._compileText(node, context);
      case 11: {
        let current = node.firstChild;
        while (current !== null) {
          current = this._compileNode(current, context);
        }
        break;
      }
    }
    return node.nextSibling;
  }
  /** @internal */
  _compileLet(el, context) {
    const attrs = el.attributes;
    const ii = attrs.length;
    const letInstructions = [];
    const exprParser = context._exprParser;
    let toBindingContext = false;
    let i3 = 0;
    let attr;
    let attrSyntax;
    let attrName;
    let attrValue;
    let bindingCommand;
    let realAttrTarget;
    let realAttrValue;
    let expr;
    for (; ii > i3; ++i3) {
      attr = attrs[i3];
      attrName = attr.name;
      attrValue = attr.value;
      if (attrName === "to-binding-context") {
        toBindingContext = true;
        continue;
      }
      attrSyntax = context._attrParser.parse(attrName, attrValue);
      realAttrTarget = attrSyntax.target;
      realAttrValue = attrSyntax.rawValue;
      bindingCommand = context._getCommand(attrSyntax);
      if (bindingCommand !== null) {
        if (attrSyntax.command === "bind") {
          letInstructions.push(new LetBindingInstruction(exprParser.parse(realAttrValue, etIsProperty$1), camelCase(realAttrTarget)));
        } else {
          throw createMappedError$4(704, attrSyntax);
        }
        continue;
      }
      expr = exprParser.parse(realAttrValue, etInterpolation$1);
      if (expr === null) {
        {
          console.warn(`[DEV:aurelia] Property "${realAttrTarget}" is declared with literal string ${realAttrValue}. Did you mean ${realAttrTarget}.bind="${realAttrValue}"?`);
        }
      }
      letInstructions.push(new LetBindingInstruction(expr === null ? new PrimitiveLiteralExpression(realAttrValue) : expr, camelCase(realAttrTarget)));
    }
    context.rows.push([new HydrateLetElementInstruction(letInstructions, toBindingContext)]);
    return this._markAsTarget(el, context).nextSibling;
  }
  /** @internal */
  // eslint-disable-next-line
  _compileElement(el, context) {
    const nextSibling = el.nextSibling;
    const elName = (el.getAttribute("as-element") ?? el.nodeName).toLowerCase();
    const elDef = context._findElement(elName);
    const isCustomElement = elDef !== null;
    const isShadowDom = isCustomElement && elDef.shadowOptions != null;
    const capture = elDef?.capture;
    const hasCaptureFilter = capture != null && typeof capture !== "boolean";
    const captures = capture ? [] : emptyArray;
    const exprParser = context._exprParser;
    const removeAttr = this.debug ? noop$1 : () => {
      el.removeAttribute(attrName);
      --i3;
      --ii;
    };
    let attrs = el.attributes;
    let instructions;
    let ii = attrs.length;
    let i3 = 0;
    let attr;
    let attrName;
    let attrValue;
    let attrSyntax;
    let plainAttrInstructions;
    let elBindableInstructions;
    let attrDef = null;
    let isMultiBindings = false;
    let bindable2;
    let attrInstructions;
    let attrBindableInstructions;
    let tcInstructions;
    let tcInstruction;
    let expr;
    let elementInstruction;
    let bindingCommand = null;
    let bindablesInfo;
    let primaryBindable;
    let realAttrTarget;
    let realAttrValue;
    let processContentResult = true;
    let hasContainerless = false;
    let canCapture = false;
    let needsMarker = false;
    let elementMetadata;
    let spreadIndex = 0;
    if (elName === "slot") {
      if (context.root.def.shadowOptions == null) {
        throw createMappedError$4(717, context.root.def.name);
      }
      context.root.hasSlot = true;
    }
    if (isCustomElement) {
      elementMetadata = {};
      processContentResult = elDef.processContent?.call(elDef.Type, el, context.p, elementMetadata);
      attrs = el.attributes;
      ii = attrs.length;
    }
    for (; ii > i3; ++i3) {
      attr = attrs[i3];
      attrName = attr.name;
      attrValue = attr.value;
      switch (attrName) {
        case "as-element":
        case "containerless":
          removeAttr();
          hasContainerless = hasContainerless || attrName === "containerless";
          continue;
      }
      attrSyntax = context._attrParser.parse(attrName, attrValue);
      bindingCommand = context._getCommand(attrSyntax);
      realAttrTarget = attrSyntax.target;
      realAttrValue = attrSyntax.rawValue;
      if (capture && (!hasCaptureFilter || hasCaptureFilter && capture(realAttrTarget))) {
        if (bindingCommand != null && bindingCommand.ignoreAttr) {
          removeAttr();
          captures.push(attrSyntax);
          continue;
        }
        canCapture = realAttrTarget !== auslotAttr$1 && realAttrTarget !== "slot" && ((spreadIndex = realAttrTarget.indexOf("...")) === -1 || spreadIndex === 0 && realAttrTarget === "...$attrs");
        if (canCapture) {
          bindablesInfo = context._getBindables(elDef);
          if (bindablesInfo.attrs[realAttrTarget] == null && !context._findAttr(realAttrTarget)?.isTemplateController) {
            removeAttr();
            captures.push(attrSyntax);
            continue;
          }
        }
      }
      if (realAttrTarget === "...$attrs") {
        (plainAttrInstructions ??= []).push(new SpreadTransferedBindingInstruction());
        removeAttr();
        continue;
      }
      if (bindingCommand?.ignoreAttr) {
        commandBuildInfo.node = el;
        commandBuildInfo.attr = attrSyntax;
        commandBuildInfo.bindable = null;
        commandBuildInfo.def = null;
        (plainAttrInstructions ??= []).push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
        removeAttr();
        continue;
      }
      if (realAttrTarget.indexOf("...") === 0) {
        if (isCustomElement && (realAttrTarget = realAttrTarget.slice(3)) !== "$element") {
          (elBindableInstructions ??= []).push(new SpreadValueBindingInstruction("$bindables", realAttrTarget === "$bindables" ? realAttrValue : realAttrTarget));
          removeAttr();
          continue;
        }
        {
          if (realAttrTarget === "$bindable" || realAttrTarget === "bindables") {
            console.warn(`[DEV:aurelia] Detected usage of ${realAttrTarget} on <${el.nodeName}>, did you mean "$bindables"?`);
          }
        }
        throw createMappedError$4(720, realAttrTarget);
      }
      if (isCustomElement) {
        bindablesInfo = context._getBindables(elDef);
        bindable2 = bindablesInfo.attrs[realAttrTarget];
        if (bindable2 !== void 0) {
          if (bindingCommand === null) {
            expr = exprParser.parse(realAttrValue, etInterpolation$1);
            (elBindableInstructions ??= []).push(expr == null ? new SetPropertyInstruction(realAttrValue, bindable2.name) : new InterpolationInstruction(expr, bindable2.name));
          } else {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = bindable2;
            commandBuildInfo.def = elDef;
            (elBindableInstructions ??= []).push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
          }
          removeAttr();
          {
            attrDef = context._findAttr(realAttrTarget);
            if (attrDef !== null) {
              console.warn(`[DEV:aurelia] Binding with bindable "${realAttrTarget}" on custom element "${elDef.name}" is ambiguous.There is a custom attribute with the same name.`);
            }
          }
          continue;
        }
        if (realAttrTarget === "$bindables") {
          if (bindingCommand != null) {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = null;
            commandBuildInfo.def = elDef;
            {
              const instruction = bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper);
              if (!(instruction instanceof SpreadValueBindingInstruction)) {
                console.warn(`[DEV:aurelia] Binding with "$bindables" on custom element "${elDef.name}" with command ${attrSyntax.command}  did not result in a spread binding instruction. This likely won't work as expected.`);
              }
              (elBindableInstructions ??= []).push(instruction);
            }
          } else {
            console.warn(`[DEV:aurelia] Usage of "$bindables" on custom element "<${elDef.name}>" is ignored.`);
          }
          removeAttr();
          continue;
        }
      }
      if (realAttrTarget === "$bindables") {
        throw createMappedError$4(721, el.nodeName, realAttrTarget, realAttrValue);
      }
      attrDef = context._findAttr(realAttrTarget);
      if (attrDef !== null) {
        bindablesInfo = context._getBindables(attrDef);
        isMultiBindings = attrDef.noMultiBindings === false && bindingCommand === null && hasInlineBindings(realAttrValue);
        if (isMultiBindings) {
          attrBindableInstructions = this._compileMultiBindings(el, realAttrValue, attrDef, context);
        } else {
          primaryBindable = bindablesInfo.primary;
          if (bindingCommand === null) {
            expr = exprParser.parse(realAttrValue, etInterpolation$1);
            attrBindableInstructions = expr === null ? realAttrValue === "" ? [] : [new SetPropertyInstruction(realAttrValue, primaryBindable.name)] : [new InterpolationInstruction(expr, primaryBindable.name)];
          } else {
            commandBuildInfo.node = el;
            commandBuildInfo.attr = attrSyntax;
            commandBuildInfo.bindable = primaryBindable;
            commandBuildInfo.def = attrDef;
            attrBindableInstructions = [bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper)];
          }
        }
        removeAttr();
        if (attrDef.isTemplateController) {
          (tcInstructions ??= []).push(new HydrateTemplateController(
            voidDefinition,
            // todo: def/ def.Type or def.name should be configurable
            //       example: AOT/runtime can use def.Type, but there are situation
            //       where instructions need to be serialized, def.name should be used
            this.resolveResources ? attrDef : attrDef.name,
            void 0,
            attrBindableInstructions
          ));
        } else {
          (attrInstructions ??= []).push(new HydrateAttributeInstruction(
            // todo: def/ def.Type or def.name should be configurable
            //       example: AOT/runtime can use def.Type, but there are situation
            //       where instructions need to be serialized, def.name should be used
            this.resolveResources ? attrDef : attrDef.name,
            attrDef.aliases != null && attrDef.aliases.includes(realAttrTarget) ? realAttrTarget : void 0,
            attrBindableInstructions
          ));
        }
        continue;
      }
      if (bindingCommand === null) {
        expr = exprParser.parse(realAttrValue, etInterpolation$1);
        if (expr != null) {
          removeAttr();
          (plainAttrInstructions ??= []).push(new InterpolationInstruction(
            expr,
            // if not a bindable, then ensure plain attribute are mapped correctly:
            // e.g: colspan -> colSpan
            //      innerhtml -> innerHTML
            //      minlength -> minLength etc...
            context._attrMapper.map(el, realAttrTarget) ?? camelCase(realAttrTarget)
          ));
        }
        continue;
      }
      commandBuildInfo.node = el;
      commandBuildInfo.attr = attrSyntax;
      commandBuildInfo.bindable = null;
      commandBuildInfo.def = null;
      (plainAttrInstructions ??= []).push(bindingCommand.build(commandBuildInfo, context._exprParser, context._attrMapper));
      removeAttr();
    }
    resetCommandBuildInfo();
    if (this._shouldReorderAttrs(el, plainAttrInstructions) && plainAttrInstructions != null && plainAttrInstructions.length > 1) {
      this._reorder(el, plainAttrInstructions);
    }
    if (isCustomElement) {
      elementInstruction = new HydrateElementInstruction(
        // todo: def/ def.Type or def.name should be configurable
        //       example: AOT/runtime can use def.Type, but there are situation
        //       where instructions need to be serialized, def.name should be used
        this.resolveResources ? elDef : elDef.name,
        elBindableInstructions ?? emptyArray,
        null,
        hasContainerless,
        captures,
        elementMetadata
      );
    }
    if (plainAttrInstructions != null || elementInstruction != null || attrInstructions != null) {
      instructions = emptyArray.concat(elementInstruction ?? emptyArray, attrInstructions ?? emptyArray, plainAttrInstructions ?? emptyArray);
      needsMarker = true;
    }
    let shouldCompileContent;
    if (tcInstructions != null) {
      ii = tcInstructions.length - 1;
      i3 = ii;
      tcInstruction = tcInstructions[i3];
      let template2;
      if (isMarker(el)) {
        template2 = context.t();
        appendManyToTemplate(template2, [
          // context.h(MARKER_NODE_NAME),
          context._marker(),
          context._comment(auLocationStart),
          context._comment(auLocationEnd)
        ]);
      } else {
        this._replaceByMarker(el, context);
        if (el.nodeName === "TEMPLATE") {
          template2 = el;
        } else {
          template2 = context.t();
          appendToTemplate(template2, el);
        }
      }
      const mostInnerTemplate = template2;
      const childContext = context._createChild(instructions == null ? [] : [instructions]);
      let childEl;
      let targetSlot;
      let hasAuSlot = false;
      let projections;
      let slotTemplateRecord;
      let slotTemplates;
      let slotTemplate;
      let marker;
      let projectionCompilationContext;
      let j2 = 0, jj = 0;
      let child = el.firstChild;
      let isEmptyTextNode = false;
      if (processContentResult !== false) {
        while (child !== null) {
          targetSlot = isElement$3(child) ? child.getAttribute(auslotAttr$1) : null;
          hasAuSlot = targetSlot !== null || isCustomElement && !isShadowDom;
          childEl = child.nextSibling;
          if (hasAuSlot) {
            if (!isCustomElement) {
              throw createMappedError$4(706, targetSlot, elName);
            }
            child.removeAttribute?.(auslotAttr$1);
            isEmptyTextNode = isTextNode(child) && child.textContent.trim() === "";
            if (!isEmptyTextNode) {
              ((slotTemplateRecord ??= {})[targetSlot || defaultSlotName$1] ??= []).push(child);
            }
            el.removeChild(child);
          }
          child = childEl;
        }
      }
      if (slotTemplateRecord != null) {
        projections = {};
        for (targetSlot in slotTemplateRecord) {
          template2 = context.t();
          slotTemplates = slotTemplateRecord[targetSlot];
          for (j2 = 0, jj = slotTemplates.length; jj > j2; ++j2) {
            slotTemplate = slotTemplates[j2];
            if (slotTemplate.nodeName === "TEMPLATE") {
              if (slotTemplate.attributes.length > 0) {
                appendToTemplate(template2, slotTemplate);
              } else {
                appendToTemplate(template2, slotTemplate.content);
              }
            } else {
              appendToTemplate(template2, slotTemplate);
            }
          }
          projectionCompilationContext = context._createChild();
          this._compileNode(template2.content, projectionCompilationContext);
          projections[targetSlot] = {
            name: generateElementName$1(),
            type: definitionTypeElement,
            template: template2,
            instructions: projectionCompilationContext.rows,
            needsCompile: false
          };
        }
        elementInstruction.projections = projections;
      }
      if (needsMarker) {
        if (isCustomElement && (hasContainerless || elDef.containerless)) {
          this._replaceByMarker(el, context);
        } else {
          this._markAsTarget(el, context);
        }
      }
      shouldCompileContent = !isCustomElement || !elDef.containerless && !hasContainerless && processContentResult !== false;
      if (shouldCompileContent) {
        if (el.nodeName === TEMPLATE_NODE_NAME) {
          this._compileNode(el.content, childContext);
        } else {
          child = el.firstChild;
          while (child !== null) {
            child = this._compileNode(child, childContext);
          }
        }
      }
      tcInstruction.def = {
        name: generateElementName$1(),
        type: definitionTypeElement,
        template: mostInnerTemplate,
        instructions: childContext.rows,
        needsCompile: false
      };
      while (i3-- > 0) {
        tcInstruction = tcInstructions[i3];
        template2 = context.t();
        marker = context._marker();
        appendManyToTemplate(template2, [
          marker,
          context._comment(auLocationStart),
          context._comment(auLocationEnd)
        ]);
        tcInstruction.def = {
          name: generateElementName$1(),
          type: definitionTypeElement,
          template: template2,
          needsCompile: false,
          instructions: [[tcInstructions[i3 + 1]]]
        };
      }
      context.rows.push([tcInstruction]);
    } else {
      if (instructions != null) {
        context.rows.push(instructions);
      }
      let child = el.firstChild;
      let childEl;
      let targetSlot;
      let hasAuSlot = false;
      let projections = null;
      let slotTemplateRecord;
      let slotTemplates;
      let slotTemplate;
      let template2;
      let projectionCompilationContext;
      let isEmptyTextNode = false;
      let j2 = 0, jj = 0;
      if (processContentResult !== false) {
        while (child !== null) {
          targetSlot = isElement$3(child) ? child.getAttribute(auslotAttr$1) : null;
          hasAuSlot = targetSlot !== null || isCustomElement && !isShadowDom;
          childEl = child.nextSibling;
          if (hasAuSlot) {
            if (!isCustomElement) {
              throw createMappedError$4(706, targetSlot, elName);
            }
            child.removeAttribute?.(auslotAttr$1);
            isEmptyTextNode = isTextNode(child) && child.textContent.trim() === "";
            if (!isEmptyTextNode) {
              ((slotTemplateRecord ??= {})[targetSlot || defaultSlotName$1] ??= []).push(child);
            }
            el.removeChild(child);
          }
          child = childEl;
        }
      }
      if (slotTemplateRecord != null) {
        projections = {};
        for (targetSlot in slotTemplateRecord) {
          template2 = context.t();
          slotTemplates = slotTemplateRecord[targetSlot];
          for (j2 = 0, jj = slotTemplates.length; jj > j2; ++j2) {
            slotTemplate = slotTemplates[j2];
            if (slotTemplate.nodeName === TEMPLATE_NODE_NAME) {
              if (slotTemplate.attributes.length > 0) {
                appendToTemplate(template2, slotTemplate);
              } else {
                appendToTemplate(template2, slotTemplate.content);
              }
            } else {
              appendToTemplate(template2, slotTemplate);
            }
          }
          projectionCompilationContext = context._createChild();
          this._compileNode(template2.content, projectionCompilationContext);
          projections[targetSlot] = {
            name: generateElementName$1(),
            type: definitionTypeElement,
            template: template2,
            instructions: projectionCompilationContext.rows,
            needsCompile: false
          };
        }
        elementInstruction.projections = projections;
      }
      if (needsMarker) {
        if (isCustomElement && (hasContainerless || elDef.containerless)) {
          this._replaceByMarker(el, context);
        } else {
          this._markAsTarget(el, context);
        }
      }
      shouldCompileContent = !isCustomElement || !elDef.containerless && !hasContainerless && processContentResult !== false;
      if (shouldCompileContent && el.childNodes.length > 0) {
        child = el.firstChild;
        while (child !== null) {
          child = this._compileNode(child, context);
        }
      }
    }
    return nextSibling;
  }
  /** @internal */
  _compileText(node, context) {
    const parent = node.parentNode;
    const expr = context._exprParser.parse(node.textContent, etInterpolation$1);
    const next = node.nextSibling;
    let parts;
    let expressions;
    let i3;
    let ii;
    let part;
    if (expr !== null) {
      ({ parts, expressions } = expr);
      if (part = parts[0]) {
        insertBefore(parent, context._text(part), node);
      }
      for (i3 = 0, ii = expressions.length; ii > i3; ++i3) {
        insertManyBefore$1(parent, node, [
          // context.h(MARKER_NODE_NAME),
          context._marker(),
          // empty text node will not be cloned when doing fragment.cloneNode()
          // so give it an empty space instead
          context._text(" ")
        ]);
        if (part = parts[i3 + 1]) {
          insertBefore(parent, context._text(part), node);
        }
        context.rows.push([new TextBindingInstruction(expressions[i3])]);
      }
      parent.removeChild(node);
    }
    return next;
  }
  /** @internal */
  _compileMultiBindings(node, attrRawValue, attrDef, context) {
    const bindableAttrsInfo = context._getBindables(attrDef);
    const valueLength = attrRawValue.length;
    const instructions = [];
    let attrName = void 0;
    let attrValue = void 0;
    let start2 = 0;
    let ch = 0;
    let expr;
    let attrSyntax;
    let command;
    let bindable2;
    for (let i3 = 0; i3 < valueLength; ++i3) {
      ch = attrRawValue.charCodeAt(i3);
      if (ch === 92) {
        ++i3;
      } else if (ch === 58) {
        attrName = attrRawValue.slice(start2, i3);
        while (attrRawValue.charCodeAt(++i3) <= 32)
          ;
        start2 = i3;
        for (; i3 < valueLength; ++i3) {
          ch = attrRawValue.charCodeAt(i3);
          if (ch === 92) {
            ++i3;
          } else if (ch === 59) {
            attrValue = attrRawValue.slice(start2, i3);
            break;
          }
        }
        if (attrValue === void 0) {
          attrValue = attrRawValue.slice(start2);
        }
        attrSyntax = context._attrParser.parse(attrName, attrValue);
        command = context._getCommand(attrSyntax);
        bindable2 = bindableAttrsInfo.attrs[attrSyntax.target];
        if (bindable2 == null) {
          throw createMappedError$4(707, attrSyntax.target, attrDef.name);
        }
        if (command === null) {
          expr = context._exprParser.parse(attrValue, etInterpolation$1);
          instructions.push(expr === null ? new SetPropertyInstruction(attrValue, bindable2.name) : new InterpolationInstruction(expr, bindable2.name));
        } else {
          commandBuildInfo.node = node;
          commandBuildInfo.attr = attrSyntax;
          commandBuildInfo.bindable = bindable2;
          commandBuildInfo.def = attrDef;
          instructions.push(command.build(commandBuildInfo, context._exprParser, context._attrMapper));
        }
        while (i3 < valueLength && attrRawValue.charCodeAt(++i3) <= 32)
          ;
        start2 = i3;
        attrName = void 0;
        attrValue = void 0;
      }
    }
    resetCommandBuildInfo();
    return instructions;
  }
  /** @internal */
  _compileLocalElement(template2, context) {
    const elName = context.root.def.name;
    const root = template2;
    const localTemplates = toArray(root.querySelectorAll("template[as-custom-element]"));
    const numLocalTemplates = localTemplates.length;
    if (numLocalTemplates === 0) {
      return;
    }
    if (numLocalTemplates === root.childElementCount) {
      throw createMappedError$4(708, elName);
    }
    const localTemplateNames = /* @__PURE__ */ new Set();
    const localElementTypes = [];
    for (const localTemplate of localTemplates) {
      if (localTemplate.parentNode !== root) {
        throw createMappedError$4(709, elName);
      }
      const name2 = processTemplateName(elName, localTemplate, localTemplateNames);
      const content = localTemplate.content;
      const bindableEls = toArray(content.querySelectorAll("bindable"));
      const properties = /* @__PURE__ */ new Set();
      const attributes2 = /* @__PURE__ */ new Set();
      const bindables2 = bindableEls.reduce((allBindables, bindableEl) => {
        if (bindableEl.parentNode !== content) {
          throw createMappedError$4(710, name2);
        }
        const property = bindableEl.getAttribute(
          "name"
          /* LocalTemplateBindableAttributes.name */
        );
        if (property === null) {
          throw createMappedError$4(711, bindableEl, name2);
        }
        const attribute = bindableEl.getAttribute(
          "attribute"
          /* LocalTemplateBindableAttributes.attribute */
        );
        if (attribute !== null && attributes2.has(attribute) || properties.has(property)) {
          throw createMappedError$4(712, properties, attribute);
        } else {
          if (attribute !== null) {
            attributes2.add(attribute);
          }
          properties.add(property);
        }
        const ignoredAttributes = toArray(bindableEl.attributes).filter((attr) => !allowedLocalTemplateBindableAttributes.includes(attr.name));
        if (ignoredAttributes.length > 0) {
          console.warn(`[DEV:aurelia] The attribute(s) ${ignoredAttributes.map((attr) => attr.name).join(", ")} will be ignored for ${bindableEl.outerHTML}. Only ${allowedLocalTemplateBindableAttributes.join(", ")} are processed.`);
        }
        bindableEl.remove();
        allBindables[property] = {
          name: property,
          attribute: attribute ?? void 0,
          mode: bindableEl.getAttribute(
            "mode"
            /* LocalTemplateBindableAttributes.mode */
          ) ?? "default"
        };
        return allBindables;
      }, {});
      class LocalDepType {
      }
      LocalDepType.$au = {
        type: definitionTypeElement,
        name: name2,
        template: localTemplate,
        bindables: bindables2
      };
      Reflect.defineProperty(LocalDepType, "name", { value: pascalCase(name2) });
      localElementTypes.push(LocalDepType);
      root.removeChild(localTemplate);
    }
    const compilationDeps = (context.root.def.dependencies ?? []).concat(context.root.def.Type == null ? emptyArray : [context.root.def.Type]);
    for (const localElementType of localElementTypes) {
      localElementType.dependencies = compilationDeps.concat(localElementTypes.filter((d2) => d2 !== localElementType));
      context._addLocalDep(localElementType);
    }
  }
  /** @internal */
  _shouldReorderAttrs(el, instructions) {
    const nodeName = el.nodeName;
    return nodeName === "INPUT" && orderSensitiveInputType[el.type] === 1 || nodeName === "SELECT" && (el.hasAttribute("multiple") || instructions?.some((i3) => i3.type === propertyBinding && i3.to === "multiple"));
  }
  /** @internal */
  _reorder(el, instructions) {
    switch (el.nodeName) {
      case "INPUT": {
        const _instructions = instructions;
        let modelOrValueOrMatcherIndex = void 0;
        let checkedIndex = void 0;
        let found = 0;
        let instruction;
        for (let i3 = 0; i3 < _instructions.length && found < 3; i3++) {
          instruction = _instructions[i3];
          switch (instruction.to) {
            case "model":
            case "value":
            case "matcher":
              modelOrValueOrMatcherIndex = i3;
              found++;
              break;
            case "checked":
              checkedIndex = i3;
              found++;
              break;
          }
        }
        if (checkedIndex !== void 0 && modelOrValueOrMatcherIndex !== void 0 && checkedIndex < modelOrValueOrMatcherIndex) {
          [_instructions[modelOrValueOrMatcherIndex], _instructions[checkedIndex]] = [_instructions[checkedIndex], _instructions[modelOrValueOrMatcherIndex]];
        }
        break;
      }
      case "SELECT": {
        const _instructions = instructions;
        let valueIndex = 0;
        let multipleIndex = 0;
        let found = 0;
        let instruction;
        for (let i3 = 0; i3 < _instructions.length && found < 2; ++i3) {
          instruction = _instructions[i3];
          switch (instruction.to) {
            case "multiple":
              multipleIndex = i3;
              found++;
              break;
            case "value":
              valueIndex = i3;
              found++;
              break;
          }
          if (found === 2 && valueIndex < multipleIndex) {
            [_instructions[multipleIndex], _instructions[valueIndex]] = [_instructions[valueIndex], _instructions[multipleIndex]];
          }
        }
      }
    }
  }
  /**
   * Mark an element as target with a special css class
   * and return it
   *
   * @internal
   */
  _markAsTarget(el, context) {
    insertBefore(el.parentNode, context._comment("au*"), el);
    return el;
  }
  /**
   * Replace an element with a marker, and return the marker
   *
   * @internal
   */
  _replaceByMarker(node, context) {
    if (isMarker(node)) {
      return node;
    }
    const parent = node.parentNode;
    const marker = context._marker();
    insertManyBefore$1(parent, node, [
      marker,
      context._comment(auLocationStart),
      context._comment(auLocationEnd)
    ]);
    parent.removeChild(node);
    return marker;
  }
}
TemplateCompiler.register = createImplementationRegister(ITemplateCompiler);
const TEMPLATE_NODE_NAME = "TEMPLATE";
const isMarker = (el) => el.nodeValue === "au*";
class CompilationContext {
  constructor(def2, container, parent, root, instructions) {
    this.hasSlot = false;
    this.deps = null;
    const hasParent = parent !== null;
    this.c = container;
    this.root = root === null ? this : root;
    this.def = def2;
    this.parent = parent;
    this._resourceResolver = hasParent ? parent._resourceResolver : container.get(IResourceResolver);
    this._commandResolver = hasParent ? parent._commandResolver : container.get(IBindingCommandResolver);
    this._templateFactory = hasParent ? parent._templateFactory : container.get(ITemplateElementFactory);
    this._attrParser = hasParent ? parent._attrParser : container.get(IAttributeParser);
    this._exprParser = hasParent ? parent._exprParser : container.get(IExpressionParser);
    this._attrMapper = hasParent ? parent._attrMapper : container.get(IAttrMapper);
    this._logger = hasParent ? parent._logger : container.get(ILogger);
    if (typeof (this.p = hasParent ? parent.p : container.get(IPlatform$1)).document?.nodeType !== "number") {
      throw createMappedError$4(
        722
        /* ErrorNames.compiler_no_dom_api */
      );
    }
    this.localEls = hasParent ? parent.localEls : /* @__PURE__ */ new Set();
    this.rows = instructions ?? [];
  }
  _addLocalDep(Type) {
    (this.root.deps ??= []).push(Type);
    this.root.c.register(Type);
    return this;
  }
  _text(text) {
    return this.p.document.createTextNode(text);
  }
  _comment(text) {
    return this.p.document.createComment(text);
  }
  _marker() {
    return this._comment("au*");
  }
  h(name2) {
    const el = this.p.document.createElement(name2);
    if (name2 === "template") {
      this.p.document.adoptNode(el.content);
    }
    return el;
  }
  t() {
    return this.h("template");
  }
  /**
   * Find the custom element definition of a given name
   */
  _findElement(name2) {
    return this._resourceResolver.el(this.c, name2);
  }
  /**
   * Find the custom attribute definition of a given name
   */
  _findAttr(name2) {
    return this._resourceResolver.attr(this.c, name2);
  }
  _getBindables(def2) {
    return this._resourceResolver.bindables(def2);
  }
  /**
   * Create a new child compilation context
   */
  _createChild(instructions) {
    return new CompilationContext(this.def, this.c, this, this.root, instructions);
  }
  /**
   * Retrieve a binding command resource instance.
   *
   * @param name - The parsed `AttrSyntax`
   *
   * @returns An instance of the command if it exists, or `null` if it does not exist.
   */
  _getCommand(syntax) {
    const name2 = syntax.command;
    if (name2 === null) {
      return null;
    }
    return this._commandResolver.get(this.c, name2);
  }
}
const hasInlineBindings = (rawValue) => {
  const len = rawValue.length;
  let ch = 0;
  let i3 = 0;
  while (len > i3) {
    ch = rawValue.charCodeAt(i3);
    if (ch === 92) {
      ++i3;
    } else if (ch === 58) {
      return true;
    } else if (ch === 36 && rawValue.charCodeAt(i3 + 1) === 123) {
      return false;
    }
    ++i3;
  }
  return false;
};
const resetCommandBuildInfo = () => {
  commandBuildInfo.node = commandBuildInfo.attr = commandBuildInfo.bindable = commandBuildInfo.def = null;
};
const voidDefinition = { name: "unnamed", type: definitionTypeElement };
const commandBuildInfo = {
  node: null,
  attr: null,
  bindable: null,
  def: null
};
const invalidSurrogateAttribute = {
  "id": true,
  "name": true,
  "au-slot": true,
  "as-element": true
};
const orderSensitiveInputType = {
  checkbox: 1,
  radio: 1
  // todo: range is also sensitive to order, for min/max
};
const IResourceResolver = /* @__PURE__ */ tcCreateInterface("IResourceResolver");
const IBindingCommandResolver = /* @__PURE__ */ tcCreateInterface("IBindingCommandResolver", (x2) => {
  class DefaultBindingCommandResolver {
    constructor() {
      this._cache = /* @__PURE__ */ new WeakMap();
    }
    get(c2, name2) {
      let record = this._cache.get(c2);
      if (!record) {
        this._cache.set(c2, record = {});
      }
      return name2 in record ? record[name2] : record[name2] = BindingCommand.get(c2, name2);
    }
  }
  return x2.singleton(DefaultBindingCommandResolver);
});
const allowedLocalTemplateBindableAttributes = tcObjectFreeze([
  "name",
  "attribute",
  "mode"
  /* LocalTemplateBindableAttributes.mode */
]);
const localTemplateIdentifier = "as-custom-element";
const processTemplateName = (owningElementName, localTemplate, localTemplateNames) => {
  const name2 = localTemplate.getAttribute(localTemplateIdentifier);
  if (name2 === null || name2 === "") {
    throw createMappedError$4(715, owningElementName);
  }
  if (localTemplateNames.has(name2)) {
    throw createMappedError$4(716, name2, owningElementName);
  } else {
    localTemplateNames.add(name2);
    localTemplate.removeAttribute(localTemplateIdentifier);
  }
  return name2;
};
const ITemplateCompilerHooks = /* @__PURE__ */ tcCreateInterface("ITemplateCompilerHooks");
const TemplateCompilerHooks = tcObjectFreeze({
  name: /* @__PURE__ */ getResourceKeyFor("compiler-hooks"),
  define(Type) {
    return {
      register(container) {
        singletonRegistration$1(ITemplateCompilerHooks, Type).register(container);
      }
    };
  },
  findAll(container) {
    return container.get(allResources(ITemplateCompilerHooks));
  }
});
const hasOwnProp = Object.prototype.hasOwnProperty;
const rtDef = Reflect.defineProperty;
function rtDefineHiddenProp(obj, key, value) {
  rtDef(obj, key, {
    enumerable: false,
    configurable: true,
    writable: true,
    value
  });
  return value;
}
function ensureProto(proto, key, defaultValue) {
  if (!(key in proto)) {
    rtDefineHiddenProp(proto, key, defaultValue);
  }
}
const rtObjectAssign = Object.assign;
const rtObjectFreeze = Object.freeze;
const rtSafeString = String;
const rtCreateInterface = DI.createInterface;
const rtGetMetadata = Metadata.get;
const rtDefineMetadata = Metadata.define;
const createMappedError$3 = (code, ...details) => new Error(`AUR${rtSafeString(code).padStart(4, "0")}: ${getMessageByCode$1(code, ...details)}`);
const errorsMap$1 = {
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    101
    /* ErrorNames.ast_behavior_not_found */
  ]: `Ast eval error: binding behavior "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    102
    /* ErrorNames.ast_behavior_duplicated */
  ]: `Ast eval error: binding behavior "{{0}}" already applied.`,
  [
    103
    /* ErrorNames.ast_converter_not_found */
  ]: `Ast eval error: value converter "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    105
    /* ErrorNames.ast_$host_not_found */
  ]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,
  [
    106
    /* ErrorNames.ast_no_assign_$host */
  ]: `Ast eval error: invalid assignment. "$host" is a reserved keyword.`,
  [
    107
    /* ErrorNames.ast_not_a_function */
  ]: `Ast eval error: expression is not a function.`,
  [
    109
    /* ErrorNames.ast_unknown_unary_operator */
  ]: `Ast eval error: unknown unary operator: "{{0}}"`,
  [
    108
    /* ErrorNames.ast_unknown_binary_operator */
  ]: `Ast eval error: unknown binary operator: "{{0}}"`,
  [
    110
    /* ErrorNames.ast_tagged_not_a_function */
  ]: `Ast eval error: left-hand side of tagged template expression is not a function.`,
  [
    111
    /* ErrorNames.ast_name_is_not_a_function */
  ]: `Ast eval error: expected "{{0}}" to be a function`,
  [
    112
    /* ErrorNames.ast_destruct_null */
  ]: `Ast eval error: cannot use non-object value for destructuring assignment.`,
  [
    113
    /* ErrorNames.ast_increment_infinite_loop */
  ]: `Ast eval error: infinite loop detected. Increment operators should only be used in event handlers.`,
  [
    114
    /* ErrorNames.ast_nullish_member_access */
  ]: `Ast eval error: cannot access property "{{0}}" of {{1}}.`,
  [
    115
    /* ErrorNames.ast_nullish_keyed_access */
  ]: `Ast eval error: cannot access key "{{0}}" of {{1}}.`,
  [
    116
    /* ErrorNames.ast_nullish_assignment */
  ]: `Ast eval error: cannot assign value to property "{{0}}" of null/undefined.`,
  [
    151
    /* ErrorNames.parse_invalid_start */
  ]: `Expression error: invalid start: "{{0}}"`,
  [
    152
    /* ErrorNames.parse_no_spread */
  ]: `Expression error: spread operator is not supported: "{{0}}"`,
  [
    153
    /* ErrorNames.parse_expected_identifier */
  ]: `Expression error: expected identifier: "{{0}}"`,
  [
    154
    /* ErrorNames.parse_invalid_member_expr */
  ]: `Expression error: invalid member expression: "{{0}}"`,
  [
    155
    /* ErrorNames.parse_unexpected_end */
  ]: `Expression error: unexpected end of expression: "{{0}}"`,
  [
    156
    /* ErrorNames.parse_unconsumed_token */
  ]: `Expression error: unconsumed token: "{{0}}" at position {{1}} of "{{2}}"`,
  [
    157
    /* ErrorNames.parse_invalid_empty */
  ]: `Expression error: invalid empty expression. Empty expression is only valid in event bindings (trigger, delegate, capture etc...)`,
  [
    158
    /* ErrorNames.parse_left_hand_side_not_assignable */
  ]: `Expression error: left hand side of expression is not assignable: "{{0}}"`,
  [
    159
    /* ErrorNames.parse_expected_converter_identifier */
  ]: `Expression error: expected identifier to come after value converter operator: "{{0}}"`,
  [
    160
    /* ErrorNames.parse_expected_behavior_identifier */
  ]: `Expression error: expected identifier to come after binding behavior operator: {{0}}`,
  [
    161
    /* ErrorNames.parse_unexpected_keyword_of */
  ]: `Expression error: unexpected keyword "of": "{{0}}"`,
  [
    162
    /* ErrorNames.parse_unexpected_keyword_import */
  ]: `Expression error: unexpected keyword "import": "{{0}}"`,
  [
    163
    /* ErrorNames.parse_invalid_identifier_in_forof */
  ]: `Expression error: invalid BindingIdentifier at left hand side of "of": "{{0}}" | kind: {{1}}`,
  [
    164
    /* ErrorNames.parse_invalid_identifier_object_literal_key */
  ]: `Expression error: invalid or unsupported property definition in object literal: "{{0}}"`,
  [
    165
    /* ErrorNames.parse_unterminated_string */
  ]: `Expression error: unterminated quote in string literal: "{{0}}"`,
  [
    166
    /* ErrorNames.parse_unterminated_template_string */
  ]: `Expression error: unterminated template string: "{{0}}"`,
  [
    167
    /* ErrorNames.parse_missing_expected_token */
  ]: `Expression error: missing expected token "{{0}}" in "{{1}}"`,
  [
    168
    /* ErrorNames.parse_unexpected_character */
  ]: `Expression error: unexpected character: "{{0}}"`,
  [
    170
    /* ErrorNames.parse_unexpected_token_destructuring */
  ]: `Expression error: unexpected "{{0}}" at position "{{1}}" for destructuring assignment in "{{2}}"`,
  [
    171
    /* ErrorNames.parse_unexpected_token_optional_chain */
  ]: `Expression error: unexpected {{0}} at position "{{1}}" for optional chain in "{{2}}"`,
  [
    172
    /* ErrorNames.parse_invalid_tag_in_optional_chain */
  ]: `Expression error: invalid tagged template on optional chain in "{{1}}"`,
  [
    173
    /* ErrorNames.parse_invalid_arrow_params */
  ]: `Expression error: invalid arrow parameter list in "{{0}}"`,
  [
    174
    /* ErrorNames.parse_no_arrow_param_default_value */
  ]: `Expression error: arrow function with default parameters is not supported: "{{0}}"`,
  [
    175
    /* ErrorNames.parse_no_arrow_param_destructuring */
  ]: `Expression error: arrow function with destructuring parameters is not supported: "{{0}}"`,
  [
    176
    /* ErrorNames.parse_rest_must_be_last */
  ]: `Expression error: rest parameter must be last formal parameter in arrow function: "{{0}}"`,
  [
    178
    /* ErrorNames.parse_no_arrow_fn_body */
  ]: `Expression error: arrow function with function body is not supported: "{{0}}"`,
  [
    179
    /* ErrorNames.parse_unexpected_double_dot */
  ]: `Expression error: unexpected token '.' at position "{{1}}" in "{{0}}"`,
  [
    199
    /* ErrorNames.observing_null_undefined */
  ]: `Trying to observe property {{0}} on null/undefined`,
  [
    203
    /* ErrorNames.null_scope */
  ]: `Trying to retrieve a property or build a scope from a null/undefined scope`,
  [
    204
    /* ErrorNames.create_scope_with_null_context */
  ]: "Trying to create a scope with null/undefined binding context",
  [
    206
    /* ErrorNames.switch_on_null_connectable */
  ]: `Trying to switch to a null/undefined connectable`,
  [
    207
    /* ErrorNames.switch_active_connectable */
  ]: `Trying to enter an active connectable`,
  [
    208
    /* ErrorNames.switch_off_null_connectable */
  ]: `Trying to pop a null/undefined connectable`,
  [
    209
    /* ErrorNames.switch_off_inactive_connectable */
  ]: `Trying to exit an inactive connectable`,
  [
    210
    /* ErrorNames.non_recognisable_collection_type */
  ]: `Unrecognised collection type {{0:toString}}.`,
  [
    217
    /* ErrorNames.dirty_check_no_handler */
  ]: "There is no registration for IDirtyChecker interface. If you want to use your own dirty checker, make sure you register it.",
  [
    218
    /* ErrorNames.dirty_check_not_allowed */
  ]: `Dirty checked is not permitted in this application. Property key {{0}} is being dirty checked.`,
  [
    219
    /* ErrorNames.dirty_check_setter_not_allowed */
  ]: `Trying to set value for property {{0}} in dirty checker`,
  [
    220
    /* ErrorNames.assign_readonly_size */
  ]: `Map/Set "size" is a readonly property`,
  [
    221
    /* ErrorNames.assign_readonly_readonly_property_from_computed */
  ]: `Trying to assign value to readonly property "{{0}}" through computed observer.`,
  [
    224
    /* ErrorNames.invalid_observable_decorator_usage */
  ]: `Invalid @observable decorator usage, cannot determine property name`,
  [
    225
    /* ErrorNames.stopping_a_stopped_effect */
  ]: `Trying to stop an effect that has already been stopped`,
  [
    226
    /* ErrorNames.effect_maximum_recursion_reached */
  ]: `Maximum number of recursive effect run reached. Consider handle effect dependencies differently.`
};
const getMessageByCode$1 = (name2, ...details) => {
  let cooked = errorsMap$1[name2];
  for (let i3 = 0; i3 < details.length; ++i3) {
    const regex = new RegExp(`{{${i3}(:.*)?}}`, "g");
    let matches2 = regex.exec(cooked);
    while (matches2 != null) {
      const method = matches2[1]?.slice(1);
      let value = details[i3];
      if (value != null) {
        switch (method) {
          case "typeof":
            value = typeof value;
            break;
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = rtSafeString(value[method.slice(1)]);
            } else {
              value = rtSafeString(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches2.index) + value + cooked.slice(regex.lastIndex);
      matches2 = regex.exec(cooked);
    }
  }
  return cooked;
};
class Scope {
  constructor(parent, bindingContext, overrideContext, isBoundary) {
    this.parent = parent;
    this.bindingContext = bindingContext;
    this.overrideContext = overrideContext;
    this.isBoundary = isBoundary;
  }
  static getContext(scope, name2, ancestor) {
    if (scope == null) {
      throw createMappedError$3(
        203
        /* ErrorNames.null_scope */
      );
    }
    let overrideContext = scope.overrideContext;
    let currentScope = scope;
    if (ancestor > 0) {
      while (ancestor > 0) {
        ancestor--;
        currentScope = currentScope.parent;
        if (currentScope == null) {
          return void 0;
        }
      }
      overrideContext = currentScope.overrideContext;
      return name2 in overrideContext ? overrideContext : currentScope.bindingContext;
    }
    while (currentScope != null && !currentScope.isBoundary && !(name2 in currentScope.overrideContext) && !(name2 in currentScope.bindingContext)) {
      currentScope = currentScope.parent;
    }
    if (currentScope == null) {
      return scope.bindingContext;
    }
    overrideContext = currentScope.overrideContext;
    return name2 in overrideContext ? overrideContext : currentScope.bindingContext;
  }
  static create(bc, oc, isBoundary) {
    if (bc == null) {
      throw createMappedError$3(
        204
        /* ErrorNames.create_scope_with_null_context */
      );
    }
    return new Scope(null, bc, oc ?? new OverrideContext(), isBoundary ?? false);
  }
  static fromParent(ps, bc, oc = new OverrideContext()) {
    if (ps == null) {
      throw createMappedError$3(
        203
        /* ErrorNames.null_scope */
      );
    }
    return new Scope(ps, bc, oc, false);
  }
}
class BindingContext {
  constructor(key, value) {
    if (key !== void 0) {
      this[key] = value;
    }
  }
}
class OverrideContext {
}
const { astAssign, astEvaluate, astBind, astUnbind } = /* @__PURE__ */ (() => {
  const ekAccessThis2 = "AccessThis";
  const ekAccessBoundary2 = "AccessBoundary";
  const ekAccessGlobal2 = "AccessGlobal";
  const ekAccessScope2 = "AccessScope";
  const ekArrayLiteral2 = "ArrayLiteral";
  const ekObjectLiteral2 = "ObjectLiteral";
  const ekPrimitiveLiteral2 = "PrimitiveLiteral";
  const ekTemplate2 = "Template";
  const ekUnary2 = "Unary";
  const ekCallScope2 = "CallScope";
  const ekCallMember2 = "CallMember";
  const ekCallFunction2 = "CallFunction";
  const ekCallGlobal2 = "CallGlobal";
  const ekAccessMember2 = "AccessMember";
  const ekAccessKeyed2 = "AccessKeyed";
  const ekTaggedTemplate2 = "TaggedTemplate";
  const ekBinary2 = "Binary";
  const ekConditional2 = "Conditional";
  const ekAssign2 = "Assign";
  const ekArrowFunction2 = "ArrowFunction";
  const ekValueConverter2 = "ValueConverter";
  const ekBindingBehavior2 = "BindingBehavior";
  const ekArrayBindingPattern2 = "ArrayBindingPattern";
  const ekObjectBindingPattern2 = "ObjectBindingPattern";
  const ekBindingIdentifier2 = "BindingIdentifier";
  const ekForOfStatement2 = "ForOfStatement";
  const ekInterpolation2 = "Interpolation";
  const ekArrayDestructuring2 = "ArrayDestructuring";
  const ekObjectDestructuring2 = "ObjectDestructuring";
  const ekDestructuringAssignmentLeaf2 = "DestructuringAssignmentLeaf";
  const ekCustom2 = "Custom";
  const getContext = Scope.getContext;
  function astEvaluate2(ast, s3, e2, c2) {
    switch (ast.$kind) {
      case ekAccessThis2: {
        let oc = s3.overrideContext;
        let currentScope = s3;
        let i3 = ast.ancestor;
        while (i3-- && oc) {
          currentScope = currentScope.parent;
          oc = currentScope?.overrideContext ?? null;
        }
        return i3 < 1 && currentScope ? currentScope.bindingContext : void 0;
      }
      case ekAccessBoundary2: {
        let currentScope = s3;
        while (currentScope != null && !currentScope.isBoundary) {
          currentScope = currentScope.parent;
        }
        return currentScope ? currentScope.bindingContext : void 0;
      }
      case ekAccessScope2: {
        const obj = getContext(s3, ast.name, ast.ancestor);
        if (c2 !== null) {
          c2.observe(obj, ast.name);
        }
        const evaluatedValue = obj[ast.name];
        if (evaluatedValue == null) {
          if (ast.name === "$host") {
            throw createMappedError$3(
              105
              /* ErrorNames.ast_$host_not_found */
            );
          }
          return evaluatedValue;
        }
        return e2?.boundFn && isFunction(evaluatedValue) ? evaluatedValue.bind(obj) : evaluatedValue;
      }
      case ekAccessGlobal2:
        return globalThis[ast.name];
      case ekCallGlobal2: {
        const func = globalThis[ast.name];
        if (isFunction(func)) {
          return func(...ast.args.map((a2) => astEvaluate2(a2, s3, e2, c2)));
        }
        if (!e2?.strict && func == null) {
          return void 0;
        }
        throw createMappedError$3(
          107
          /* ErrorNames.ast_not_a_function */
        );
      }
      case ekArrayLiteral2:
        return ast.elements.map((expr) => astEvaluate2(expr, s3, e2, c2));
      case ekObjectLiteral2: {
        const instance = {};
        for (let i3 = 0; i3 < ast.keys.length; ++i3) {
          instance[ast.keys[i3]] = astEvaluate2(ast.values[i3], s3, e2, c2);
        }
        return instance;
      }
      case ekPrimitiveLiteral2:
        return ast.value;
      case ekTemplate2: {
        let result = ast.cooked[0];
        for (let i3 = 0; i3 < ast.expressions.length; ++i3) {
          result += rtSafeString(astEvaluate2(ast.expressions[i3], s3, e2, c2));
          result += ast.cooked[i3 + 1];
        }
        return result;
      }
      case ekUnary2: {
        const value = astEvaluate2(ast.expression, s3, e2, c2);
        switch (ast.operation) {
          case "void":
            return void 0;
          case "typeof":
            return typeof value;
          case "!":
            return !value;
          case "-":
            return -value;
          case "+":
            return +value;
          case "--":
            if (c2 != null)
              throw createMappedError$3(
                113
                /* ErrorNames.ast_increment_infinite_loop */
              );
            return astAssign2(ast.expression, s3, e2, value - 1) + ast.pos;
          case "++":
            if (c2 != null)
              throw createMappedError$3(
                113
                /* ErrorNames.ast_increment_infinite_loop */
              );
            return astAssign2(ast.expression, s3, e2, value + 1) - ast.pos;
          default:
            throw createMappedError$3(109, ast.operation);
        }
      }
      case ekCallScope2: {
        const context = getContext(s3, ast.name, ast.ancestor);
        if (context == null) {
          if (e2?.strict) {
            throw createMappedError$3(114, ast.name, context);
          }
          return void 0;
        }
        const fn2 = context[ast.name];
        if (isFunction(fn2)) {
          return fn2.apply(context, ast.args.map((a2) => astEvaluate2(a2, s3, e2, c2)));
        }
        if (fn2 == null) {
          if (e2?.strict && !ast.optional) {
            throw createMappedError$3(111, ast.name);
          }
          return void 0;
        }
        throw createMappedError$3(111, ast.name);
      }
      case ekCallMember2: {
        const instance = astEvaluate2(ast.object, s3, e2, c2);
        if (instance == null) {
          if (e2?.strict && !ast.optionalMember) {
            throw createMappedError$3(114, ast.name, instance);
          }
        }
        const fn2 = instance?.[ast.name];
        if (fn2 == null) {
          if (!ast.optionalCall && e2?.strict) {
            throw createMappedError$3(111, ast.name);
          }
          return void 0;
        }
        if (!isFunction(fn2)) {
          throw createMappedError$3(111, ast.name);
        }
        const ret = fn2.apply(instance, ast.args.map((a2) => astEvaluate2(a2, s3, e2, c2)));
        if (isArray(instance) && autoObserveArrayMethods.includes(ast.name)) {
          c2?.observeCollection(instance);
        }
        return ret;
      }
      case ekCallFunction2: {
        const func = astEvaluate2(ast.func, s3, e2, c2);
        if (isFunction(func)) {
          return func(...ast.args.map((a2) => astEvaluate2(a2, s3, e2, c2)));
        }
        if (func == null) {
          if (!ast.optional && e2?.strict) {
            throw createMappedError$3(
              107
              /* ErrorNames.ast_not_a_function */
            );
          }
          return void 0;
        }
        throw createMappedError$3(
          107
          /* ErrorNames.ast_not_a_function */
        );
      }
      case ekArrowFunction2: {
        const func = (...args) => {
          const params = ast.args;
          const rest = ast.rest;
          const lastIdx = params.length - 1;
          const context = params.reduce((map, param, i3) => {
            if (rest && i3 === lastIdx) {
              map[param.name] = args.slice(i3);
            } else {
              map[param.name] = args[i3];
            }
            return map;
          }, {});
          const functionScope = Scope.fromParent(s3, context);
          return astEvaluate2(ast.body, functionScope, e2, c2);
        };
        return func;
      }
      case ekAccessMember2: {
        const instance = astEvaluate2(ast.object, s3, e2, c2);
        if (instance == null) {
          if (!ast.optional && e2?.strict) {
            throw createMappedError$3(114, ast.name, instance);
          }
          return void 0;
        }
        if (c2 !== null && !ast.accessGlobal) {
          c2.observe(instance, ast.name);
        }
        const ret = instance[ast.name];
        return e2?.boundFn && isFunction(ret) ? ret.bind(instance) : ret;
      }
      case ekAccessKeyed2: {
        const instance = astEvaluate2(ast.object, s3, e2, c2);
        const key = astEvaluate2(ast.key, s3, e2, c2);
        if (instance == null) {
          if (!ast.optional && e2?.strict) {
            throw createMappedError$3(115, key, instance);
          }
          return void 0;
        }
        if (c2 !== null && !ast.accessGlobal) {
          c2.observe(instance, key);
        }
        return instance[key];
      }
      case ekTaggedTemplate2: {
        const results = ast.expressions.map((expr) => astEvaluate2(expr, s3, e2, c2));
        const func = astEvaluate2(ast.func, s3, e2, c2);
        if (!isFunction(func)) {
          throw createMappedError$3(
            110
            /* ErrorNames.ast_tagged_not_a_function */
          );
        }
        return func(ast.cooked, ...results);
      }
      case ekBinary2: {
        const left2 = ast.left;
        const right2 = ast.right;
        switch (ast.operation) {
          case "&&":
            return astEvaluate2(left2, s3, e2, c2) && astEvaluate2(right2, s3, e2, c2);
          case "||":
            return astEvaluate2(left2, s3, e2, c2) || astEvaluate2(right2, s3, e2, c2);
          case "??":
            return astEvaluate2(left2, s3, e2, c2) ?? astEvaluate2(right2, s3, e2, c2);
          case "==":
            return astEvaluate2(left2, s3, e2, c2) == astEvaluate2(right2, s3, e2, c2);
          case "===":
            return astEvaluate2(left2, s3, e2, c2) === astEvaluate2(right2, s3, e2, c2);
          case "!=":
            return astEvaluate2(left2, s3, e2, c2) != astEvaluate2(right2, s3, e2, c2);
          case "!==":
            return astEvaluate2(left2, s3, e2, c2) !== astEvaluate2(right2, s3, e2, c2);
          case "instanceof": {
            const $right = astEvaluate2(right2, s3, e2, c2);
            if (isFunction($right)) {
              return astEvaluate2(left2, s3, e2, c2) instanceof $right;
            }
            return false;
          }
          case "in": {
            const $right = astEvaluate2(right2, s3, e2, c2);
            if (isObjectOrFunction($right)) {
              return astEvaluate2(left2, s3, e2, c2) in $right;
            }
            return false;
          }
          case "+":
            return astEvaluate2(left2, s3, e2, c2) + astEvaluate2(right2, s3, e2, c2);
          case "-":
            return astEvaluate2(left2, s3, e2, c2) - astEvaluate2(right2, s3, e2, c2);
          case "*":
            return astEvaluate2(left2, s3, e2, c2) * astEvaluate2(right2, s3, e2, c2);
          case "/":
            return astEvaluate2(left2, s3, e2, c2) / astEvaluate2(right2, s3, e2, c2);
          case "%":
            return astEvaluate2(left2, s3, e2, c2) % astEvaluate2(right2, s3, e2, c2);
          case "<":
            return astEvaluate2(left2, s3, e2, c2) < astEvaluate2(right2, s3, e2, c2);
          case ">":
            return astEvaluate2(left2, s3, e2, c2) > astEvaluate2(right2, s3, e2, c2);
          case "<=":
            return astEvaluate2(left2, s3, e2, c2) <= astEvaluate2(right2, s3, e2, c2);
          case ">=":
            return astEvaluate2(left2, s3, e2, c2) >= astEvaluate2(right2, s3, e2, c2);
          default:
            throw createMappedError$3(108, ast.operation);
        }
      }
      case ekConditional2:
        return astEvaluate2(ast.condition, s3, e2, c2) ? astEvaluate2(ast.yes, s3, e2, c2) : astEvaluate2(ast.no, s3, e2, c2);
      case ekAssign2: {
        let value = astEvaluate2(ast.value, s3, e2, c2);
        if (ast.op !== "=") {
          if (c2 != null) {
            throw createMappedError$3(
              113
              /* ErrorNames.ast_increment_infinite_loop */
            );
          }
          const target = astEvaluate2(ast.target, s3, e2, c2);
          switch (ast.op) {
            case "/=":
              value = target / value;
              break;
            case "*=":
              value = target * value;
              break;
            case "+=":
              value = target + value;
              break;
            case "-=":
              value = target - value;
              break;
            default:
              throw createMappedError$3(108, ast.op);
          }
        }
        return astAssign2(ast.target, s3, e2, value);
      }
      case ekValueConverter2: {
        return e2?.useConverter?.(ast.name, "toView", astEvaluate2(ast.expression, s3, e2, c2), ast.args.map((a2) => astEvaluate2(a2, s3, e2, c2)));
      }
      case ekBindingBehavior2:
        return astEvaluate2(ast.expression, s3, e2, c2);
      case ekBindingIdentifier2:
        return ast.name;
      case ekForOfStatement2:
        return astEvaluate2(ast.iterable, s3, e2, c2);
      case ekInterpolation2:
        if (ast.isMulti) {
          let result = ast.parts[0];
          let i3 = 0;
          for (; i3 < ast.expressions.length; ++i3) {
            result += rtSafeString(astEvaluate2(ast.expressions[i3], s3, e2, c2));
            result += ast.parts[i3 + 1];
          }
          return result;
        } else {
          return `${ast.parts[0]}${astEvaluate2(ast.firstExpression, s3, e2, c2)}${ast.parts[1]}`;
        }
      case ekDestructuringAssignmentLeaf2:
        return astEvaluate2(ast.target, s3, e2, c2);
      case ekArrayDestructuring2: {
        return ast.list.map((x2) => astEvaluate2(x2, s3, e2, c2));
      }
      case ekArrayBindingPattern2:
      case ekObjectBindingPattern2:
      case ekObjectDestructuring2:
      default:
        return void 0;
      case ekCustom2:
        return ast.evaluate(s3, e2, c2);
    }
  }
  function astAssign2(ast, s3, e2, val) {
    switch (ast.$kind) {
      case ekAccessScope2: {
        if (ast.name === "$host") {
          throw createMappedError$3(
            106
            /* ErrorNames.ast_no_assign_$host */
          );
        }
        const obj = getContext(s3, ast.name, ast.ancestor);
        return obj[ast.name] = val;
      }
      case ekAccessMember2: {
        const obj = astEvaluate2(ast.object, s3, e2, null);
        if (obj == null) {
          if (e2?.strict) {
            throw createMappedError$3(116, ast.name);
          }
          astAssign2(ast.object, s3, e2, { [ast.name]: val });
        } else if (isObjectOrFunction(obj)) {
          if (ast.name === "length" && isArray(obj) && !isNaN(val)) {
            obj.splice(val);
          } else {
            obj[ast.name] = val;
          }
        } else ;
        return val;
      }
      case ekAccessKeyed2: {
        const instance = astEvaluate2(ast.object, s3, e2, null);
        const key = astEvaluate2(ast.key, s3, e2, null);
        if (instance == null) {
          if (e2?.strict) {
            throw createMappedError$3(116, key);
          }
          astAssign2(ast.object, s3, e2, { [key]: val });
          return val;
        }
        if (isArray(instance)) {
          if (key === "length" && !isNaN(val)) {
            instance.splice(val);
            return val;
          }
          if (isArrayIndex(key)) {
            instance.splice(key, 1, val);
            return val;
          }
        }
        return instance[key] = val;
      }
      case ekAssign2:
        astAssign2(ast.value, s3, e2, val);
        return astAssign2(ast.target, s3, e2, val);
      case ekValueConverter2: {
        val = e2?.useConverter?.(ast.name, "fromView", val, ast.args.map((a2) => astEvaluate2(a2, s3, e2, null)));
        return astAssign2(ast.expression, s3, e2, val);
      }
      case ekBindingBehavior2:
        return astAssign2(ast.expression, s3, e2, val);
      case ekArrayDestructuring2:
      case ekObjectDestructuring2: {
        const list = ast.list;
        const len = list.length;
        let i3;
        let item;
        for (i3 = 0; i3 < len; i3++) {
          item = list[i3];
          switch (item.$kind) {
            case ekDestructuringAssignmentLeaf2:
              astAssign2(item, s3, e2, val);
              break;
            case ekArrayDestructuring2:
            case ekObjectDestructuring2: {
              if (typeof val !== "object" || val === null) {
                throw createMappedError$3(
                  112
                  /* ErrorNames.ast_destruct_null */
                );
              }
              let source = astEvaluate2(item.source, Scope.create(val), e2, null);
              if (source === void 0 && item.initializer) {
                source = astEvaluate2(item.initializer, s3, e2, null);
              }
              astAssign2(item, s3, e2, source);
              break;
            }
          }
        }
        break;
      }
      case ekDestructuringAssignmentLeaf2: {
        if (ast instanceof DestructuringAssignmentSingleExpression) {
          if (val == null) {
            return;
          }
          if (typeof val !== "object") {
            throw createMappedError$3(
              112
              /* ErrorNames.ast_destruct_null */
            );
          }
          let source = astEvaluate2(ast.source, Scope.create(val), e2, null);
          if (source === void 0 && ast.initializer) {
            source = astEvaluate2(ast.initializer, s3, e2, null);
          }
          astAssign2(ast.target, s3, e2, source);
        } else {
          if (val == null) {
            return;
          }
          if (typeof val !== "object") {
            throw createMappedError$3(
              112
              /* ErrorNames.ast_destruct_null */
            );
          }
          const indexOrProperties = ast.indexOrProperties;
          let restValue;
          if (isArrayIndex(indexOrProperties)) {
            if (!Array.isArray(val)) {
              throw createMappedError$3(
                112
                /* ErrorNames.ast_destruct_null */
              );
            }
            restValue = val.slice(indexOrProperties);
          } else {
            restValue = Object.entries(val).reduce((acc, [k3, v2]) => {
              if (!indexOrProperties.includes(k3)) {
                acc[k3] = v2;
              }
              return acc;
            }, {});
          }
          astAssign2(ast.target, s3, e2, restValue);
        }
        break;
      }
      case ekCustom2:
        return ast.assign(s3, e2, val);
      default:
        return void 0;
    }
  }
  function astBind2(ast, s3, b3) {
    switch (ast.$kind) {
      case ekBindingBehavior2: {
        b3.bindBehavior?.(ast.name, s3, ast.args.map((a2) => astEvaluate2(a2, s3, b3, null)));
        astBind2(ast.expression, s3, b3);
        break;
      }
      case ekValueConverter2: {
        b3.bindConverter?.(ast.name);
        astBind2(ast.expression, s3, b3);
        break;
      }
      case ekForOfStatement2: {
        astBind2(ast.iterable, s3, b3);
        break;
      }
      case ekCustom2: {
        ast.bind?.(s3, b3);
      }
    }
  }
  function astUnbind2(ast, s3, b3) {
    switch (ast.$kind) {
      case ekBindingBehavior2: {
        b3.unbindBehavior?.(ast.name, s3);
        astUnbind2(ast.expression, s3, b3);
        break;
      }
      case ekValueConverter2: {
        b3.unbindConverter?.(ast.name);
        astUnbind2(ast.expression, s3, b3);
        break;
      }
      case ekForOfStatement2: {
        astUnbind2(ast.iterable, s3, b3);
        break;
      }
      case ekCustom2: {
        ast.unbind?.(s3, b3);
      }
    }
  }
  const autoObserveArrayMethods = "at map filter includes indexOf lastIndexOf findIndex find flat flatMap join reduce reduceRight slice every some sort".split(" ");
  return {
    astEvaluate: astEvaluate2,
    astAssign: astAssign2,
    astBind: astBind2,
    astUnbind: astUnbind2
  };
})();
const mixinNoopAstEvaluator = /* @__PURE__ */ (() => (target) => {
  const proto = target.prototype;
  ["bindBehavior", "unbindBehavior", "bindConverter", "unbindConverter", "useConverter"].forEach((name2) => {
    rtDefineHiddenProp(proto, name2, () => {
      throw createMappedError$3(99, name2);
    });
  });
})();
const ICoercionConfiguration = /* @__PURE__ */ DI.createInterface("ICoercionConfiguration");
const atNone = 0;
const atObserver$1 = 1;
const atNode$1 = 2;
const atLayout$1 = 4;
const AccessorType = /* @__PURE__ */ rtObjectFreeze({
  None: atNone,
  Observer: atObserver$1,
  Node: atNode$1,
  // misc characteristic of accessors/observers when update
  //
  // by default, everything is synchronous
  // except changes that are supposed to cause reflow/heavy computation
  // an observer can use this flag to signal binding that don't carelessly tell it to update
  // queue it instead
  // todo: https://gist.github.com/paulirish/5d52fb081b3570c81e3a
  // todo: https://csstriggers.com/
  Layout: atLayout$1
});
function createIndexMap(length = 0) {
  const arr = Array(length);
  let i3 = 0;
  while (i3 < length) {
    arr[i3] = i3++;
  }
  arr.deletedIndices = [];
  arr.deletedItems = [];
  arr.isIndexMap = true;
  return arr;
}
let batching = false;
const subscriberCollection = /* @__PURE__ */ (() => {
  function subscriberCollection2(target, context) {
    return target == null ? subscriberCollectionDeco : subscriberCollectionDeco(target);
  }
  function getSubscriberRecord() {
    return rtDefineHiddenProp(this, "subs", new SubscriberRecord());
  }
  function addSubscriber(subscriber) {
    return this.subs.add(subscriber);
  }
  function removeSubscriber(subscriber) {
    return this.subs.remove(subscriber);
  }
  const decoratedTarget = /* @__PURE__ */ new WeakSet();
  function subscriberCollectionDeco(target, context) {
    if (!decoratedTarget.has(target)) {
      decoratedTarget.add(target);
      const proto = target.prototype;
      rtDef(proto, "subs", { get: getSubscriberRecord });
      ensureProto(proto, "subscribe", addSubscriber);
      ensureProto(proto, "unsubscribe", removeSubscriber);
    }
    return target;
  }
  class SubscriberRecord {
    constructor() {
      this.count = 0;
      this._subs = [];
      this._requestDirtySubs = [];
      this._hasDirtySubs = false;
    }
    add(subscriber) {
      if (this._subs.includes(subscriber)) {
        return false;
      }
      this._subs[this._subs.length] = subscriber;
      if ("handleDirty" in subscriber) {
        this._requestDirtySubs[this._requestDirtySubs.length] = subscriber;
        this._hasDirtySubs = true;
      }
      ++this.count;
      return true;
    }
    remove(subscriber) {
      let idx = this._subs.indexOf(subscriber);
      if (idx !== -1) {
        this._subs.splice(idx, 1);
        idx = this._requestDirtySubs.indexOf(subscriber);
        if (idx !== -1) {
          this._requestDirtySubs.splice(idx, 1);
          this._hasDirtySubs = this._requestDirtySubs.length > 0;
        }
        --this.count;
        return true;
      }
      return false;
    }
    notify(val, oldVal) {
      for (const sub of this._subs.slice(0)) {
        sub.handleChange(val, oldVal);
      }
    }
    notifyCollection(collection, indexMap) {
      const _subs = this._subs.slice(0);
      const len = _subs.length;
      let i3 = 0;
      for (; i3 < len; ++i3) {
        _subs[i3].handleCollectionChange(collection, indexMap);
      }
      return;
    }
    notifyDirty() {
      if (this._hasDirtySubs) {
        for (const dirtySub of this._requestDirtySubs.slice(0)) {
          dirtySub.handleDirty();
        }
      }
    }
  }
  return subscriberCollection2;
})();
class CollectionLengthObserver {
  constructor(owner) {
    this.owner = owner;
    this.type = atObserver$1;
    this._value = (this._obj = owner.collection).length;
  }
  getValue() {
    return this._obj.length;
  }
  setValue(newValue) {
    if (newValue !== this._value) {
      if (!Number.isNaN(newValue)) {
        this._obj.splice(newValue);
        this._value = this._obj.length;
      } else {
        console.warn(`Invalid value "${newValue}" for array length`);
      }
    }
  }
  handleDirty() {
    if (this._value !== this._obj.length) {
      this.subs.notifyDirty();
    }
  }
  handleCollectionChange(_arr, _2) {
    const oldValue = this._value;
    const value = this._obj.length;
    if ((this._value = value) !== oldValue) {
      this.subs.notifyDirty();
      this.subs.notify(this._value, oldValue);
    }
  }
}
(() => {
  implementLengthObserver(CollectionLengthObserver);
})();
class CollectionSizeObserver {
  constructor(owner) {
    this.owner = owner;
    this.type = atObserver$1;
    this._value = (this._obj = owner.collection).size;
  }
  getValue() {
    return this._obj.size;
  }
  setValue() {
    throw createMappedError$3(
      220
      /* ErrorNames.assign_readonly_size */
    );
  }
  handleDirty() {
    if (this._value !== this._obj.size) {
      this.subs.notifyDirty();
    }
  }
  handleCollectionChange(_collection, _2) {
    const oldValue = this._value;
    const value = this._obj.size;
    if ((this._value = value) !== oldValue) {
      this.subs.notify(this._value, oldValue);
    }
  }
}
(() => {
  implementLengthObserver(CollectionSizeObserver);
})();
function implementLengthObserver(klass) {
  const proto = klass.prototype;
  ensureProto(proto, "subscribe", subscribe);
  ensureProto(proto, "unsubscribe", unsubscribe);
  return subscriberCollection(klass, null);
}
function subscribe(subscriber) {
  if (this.subs.add(subscriber) && this.subs.count === 1) {
    this.owner.subscribe(this);
  }
}
function unsubscribe(subscriber) {
  if (this.subs.remove(subscriber) && this.subs.count === 0) {
    this.owner.subscribe(this);
  }
}
const getArrayObserver = /* @__PURE__ */ (() => {
  const lookupMetadataKey = Symbol.for("__au_arr_obs__");
  const observerLookup = Array[lookupMetadataKey] ?? rtDefineHiddenProp(Array, lookupMetadataKey, /* @__PURE__ */ new WeakMap());
  function sortCompare(x2, y2) {
    if (x2 === y2) {
      return 0;
    }
    x2 = x2 === null ? "null" : x2.toString();
    y2 = y2 === null ? "null" : y2.toString();
    return x2 < y2 ? -1 : 1;
  }
  function preSortCompare(x2, y2) {
    if (x2 === void 0) {
      if (y2 === void 0) {
        return 0;
      } else {
        return 1;
      }
    }
    if (y2 === void 0) {
      return -1;
    }
    return 0;
  }
  function insertionSort(arr, indexMap, from, to, compareFn) {
    let velement, ielement, vtmp, itmp, order2;
    let i3, j2;
    for (i3 = from + 1; i3 < to; i3++) {
      velement = arr[i3];
      ielement = indexMap[i3];
      for (j2 = i3 - 1; j2 >= from; j2--) {
        vtmp = arr[j2];
        itmp = indexMap[j2];
        order2 = compareFn(vtmp, velement);
        if (order2 > 0) {
          arr[j2 + 1] = vtmp;
          indexMap[j2 + 1] = itmp;
        } else {
          break;
        }
      }
      arr[j2 + 1] = velement;
      indexMap[j2 + 1] = ielement;
    }
  }
  function quickSort(arr, indexMap, from, to, compareFn) {
    let thirdIndex = 0, i3 = 0;
    let v0, v1, v2;
    let i0, i1, i22;
    let c01, c02, c12;
    let vtmp, itmp;
    let vpivot, ipivot, lowEnd, highStart;
    let velement, ielement, order2, vtopElement;
    while (true) {
      if (to - from <= 10) {
        insertionSort(arr, indexMap, from, to, compareFn);
        return;
      }
      thirdIndex = from + (to - from >> 1);
      v0 = arr[from];
      i0 = indexMap[from];
      v1 = arr[to - 1];
      i1 = indexMap[to - 1];
      v2 = arr[thirdIndex];
      i22 = indexMap[thirdIndex];
      c01 = compareFn(v0, v1);
      if (c01 > 0) {
        vtmp = v0;
        itmp = i0;
        v0 = v1;
        i0 = i1;
        v1 = vtmp;
        i1 = itmp;
      }
      c02 = compareFn(v0, v2);
      if (c02 >= 0) {
        vtmp = v0;
        itmp = i0;
        v0 = v2;
        i0 = i22;
        v2 = v1;
        i22 = i1;
        v1 = vtmp;
        i1 = itmp;
      } else {
        c12 = compareFn(v1, v2);
        if (c12 > 0) {
          vtmp = v1;
          itmp = i1;
          v1 = v2;
          i1 = i22;
          v2 = vtmp;
          i22 = itmp;
        }
      }
      arr[from] = v0;
      indexMap[from] = i0;
      arr[to - 1] = v2;
      indexMap[to - 1] = i22;
      vpivot = v1;
      ipivot = i1;
      lowEnd = from + 1;
      highStart = to - 1;
      arr[thirdIndex] = arr[lowEnd];
      indexMap[thirdIndex] = indexMap[lowEnd];
      arr[lowEnd] = vpivot;
      indexMap[lowEnd] = ipivot;
      partition: for (i3 = lowEnd + 1; i3 < highStart; i3++) {
        velement = arr[i3];
        ielement = indexMap[i3];
        order2 = compareFn(velement, vpivot);
        if (order2 < 0) {
          arr[i3] = arr[lowEnd];
          indexMap[i3] = indexMap[lowEnd];
          arr[lowEnd] = velement;
          indexMap[lowEnd] = ielement;
          lowEnd++;
        } else if (order2 > 0) {
          do {
            highStart--;
            if (highStart == i3) {
              break partition;
            }
            vtopElement = arr[highStart];
            order2 = compareFn(vtopElement, vpivot);
          } while (order2 > 0);
          arr[i3] = arr[highStart];
          indexMap[i3] = indexMap[highStart];
          arr[highStart] = velement;
          indexMap[highStart] = ielement;
          if (order2 < 0) {
            velement = arr[i3];
            ielement = indexMap[i3];
            arr[i3] = arr[lowEnd];
            indexMap[i3] = indexMap[lowEnd];
            arr[lowEnd] = velement;
            indexMap[lowEnd] = ielement;
            lowEnd++;
          }
        }
      }
      if (to - highStart < lowEnd - from) {
        quickSort(arr, indexMap, highStart, to, compareFn);
        to = lowEnd;
      } else {
        quickSort(arr, indexMap, from, lowEnd, compareFn);
        from = highStart;
      }
    }
  }
  const proto = Array.prototype;
  const methods = ["push", "unshift", "pop", "shift", "splice", "reverse", "sort"];
  let observe;
  function overrideArrayPrototypes() {
    const $push = proto.push;
    const $unshift = proto.unshift;
    const $pop = proto.pop;
    const $shift = proto.shift;
    const $splice = proto.splice;
    const $reverse = proto.reverse;
    const $sort = proto.sort;
    observe = {
      // https://tc39.github.io/ecma262/#sec-array.prototype.push
      push: function(...args) {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          return $push.apply(this, args);
        }
        const len = this.length;
        const argCount = args.length;
        if (argCount === 0) {
          return len;
        }
        this.length = o2.indexMap.length = len + argCount;
        let i3 = len;
        while (i3 < this.length) {
          this[i3] = args[i3 - len];
          o2.indexMap[i3] = -2;
          i3++;
        }
        o2.notify();
        return this.length;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.unshift
      unshift: function(...args) {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          return $unshift.apply(this, args);
        }
        const argCount = args.length;
        const inserts = new Array(argCount);
        let i3 = 0;
        while (i3 < argCount) {
          inserts[i3++] = -2;
        }
        $unshift.apply(o2.indexMap, inserts);
        const len = $unshift.apply(this, args);
        o2.notify();
        return len;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.pop
      pop: function() {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          return $pop.call(this);
        }
        const indexMap = o2.indexMap;
        const element = $pop.call(this);
        const index = indexMap.length - 1;
        if (indexMap[index] > -1) {
          indexMap.deletedIndices.push(indexMap[index]);
          indexMap.deletedItems.push(element);
        }
        $pop.call(indexMap);
        o2.notify();
        return element;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.shift
      shift: function() {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          return $shift.call(this);
        }
        const indexMap = o2.indexMap;
        const element = $shift.call(this);
        if (indexMap[0] > -1) {
          indexMap.deletedIndices.push(indexMap[0]);
          indexMap.deletedItems.push(element);
        }
        $shift.call(indexMap);
        o2.notify();
        return element;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.splice
      splice: function(...args) {
        const start2 = args[0];
        const deleteCount = args[1];
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          return $splice.apply(this, args);
        }
        const len = this.length;
        const relativeStart = start2 | 0;
        const actualStart = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
        const indexMap = o2.indexMap;
        const argCount = args.length;
        const actualDeleteCount = argCount === 0 ? 0 : argCount === 1 ? len - actualStart : deleteCount;
        let i3 = actualStart;
        if (actualDeleteCount > 0) {
          const to = i3 + actualDeleteCount;
          while (i3 < to) {
            if (indexMap[i3] > -1) {
              indexMap.deletedIndices.push(indexMap[i3]);
              indexMap.deletedItems.push(this[i3]);
            }
            i3++;
          }
        }
        i3 = 0;
        if (argCount > 2) {
          const itemCount = argCount - 2;
          const inserts = new Array(itemCount);
          while (i3 < itemCount) {
            inserts[i3++] = -2;
          }
          $splice.call(indexMap, start2, deleteCount, ...inserts);
        } else {
          $splice.apply(indexMap, args);
        }
        const deleted = $splice.apply(this, args);
        if (actualDeleteCount > 0 || i3 > 0) {
          o2.notify();
        }
        return deleted;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.reverse
      reverse: function() {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          $reverse.call(this);
          return this;
        }
        const len = this.length;
        const middle = len / 2 | 0;
        let lower = 0;
        while (lower !== middle) {
          const upper = len - lower - 1;
          const lowerValue = this[lower];
          const lowerIndex = o2.indexMap[lower];
          const upperValue = this[upper];
          const upperIndex = o2.indexMap[upper];
          this[lower] = upperValue;
          o2.indexMap[lower] = upperIndex;
          this[upper] = lowerValue;
          o2.indexMap[upper] = lowerIndex;
          lower++;
        }
        o2.notify();
        return this;
      },
      // https://tc39.github.io/ecma262/#sec-array.prototype.sort
      // https://github.com/v8/v8/blob/master/src/js/array.js
      sort: function(compareFn) {
        const o2 = observerLookup.get(this);
        if (o2 === void 0) {
          $sort.call(this, compareFn);
          return this;
        }
        let len = this.length;
        if (len < 2) {
          return this;
        }
        quickSort(this, o2.indexMap, 0, len, preSortCompare);
        let i3 = 0;
        while (i3 < len) {
          if (this[i3] === void 0) {
            break;
          }
          i3++;
        }
        if (compareFn === void 0 || !isFunction(compareFn)) {
          compareFn = sortCompare;
        }
        quickSort(this, o2.indexMap, 0, i3, compareFn);
        let shouldNotify = false;
        for (i3 = 0, len = o2.indexMap.length; len > i3; ++i3) {
          if (o2.indexMap[i3] !== i3) {
            shouldNotify = true;
            break;
          }
        }
        if (shouldNotify || batching) {
          o2.notify();
        }
        return this;
      }
    };
    for (const method of methods) {
      rtDef(observe[method], "observing", { value: true, writable: false, configurable: false, enumerable: false });
    }
  }
  let enableArrayObservationCalled = false;
  const observationEnabledKey = "__au_arr_on__";
  function enableArrayObservation() {
    if (observe === void 0) {
      overrideArrayPrototypes();
    }
    if (!(rtGetMetadata(observationEnabledKey, Array) ?? false)) {
      rtDefineMetadata(true, Array, observationEnabledKey);
      for (const method of methods) {
        if (proto[method].observing !== true) {
          rtDefineHiddenProp(proto, method, observe[method]);
        }
      }
    }
  }
  class ArrayObserverImpl {
    constructor(array) {
      this.type = atObserver$1;
      if (!enableArrayObservationCalled) {
        enableArrayObservationCalled = true;
        enableArrayObservation();
      }
      this.indexObservers = {};
      this.collection = array;
      this.indexMap = createIndexMap(array.length);
      this.lenObs = void 0;
      observerLookup.set(array, this);
    }
    notify() {
      const subs = this.subs;
      subs.notifyDirty();
      const indexMap = this.indexMap;
      const arr = this.collection;
      const length = arr.length;
      this.indexMap = createIndexMap(length);
      subs.notifyCollection(arr, indexMap);
    }
    getLengthObserver() {
      return this.lenObs ??= new CollectionLengthObserver(this);
    }
    getIndexObserver(index) {
      return this.indexObservers[index] ??= new ArrayIndexObserverImpl(this, index);
    }
  }
  (() => {
    subscriberCollection(ArrayObserverImpl, null);
  })();
  class ArrayIndexObserverImpl {
    constructor(owner, index) {
      this.owner = owner;
      this.index = index;
      this.doNotCache = true;
      this.value = this.getValue();
    }
    getValue() {
      return this.owner.collection[this.index];
    }
    setValue(newValue) {
      if (newValue === this.getValue()) {
        return;
      }
      const arrayObserver = this.owner;
      const index = this.index;
      const indexMap = arrayObserver.indexMap;
      if (indexMap[index] > -1) {
        indexMap.deletedIndices.push(indexMap[index]);
      }
      indexMap[index] = -2;
      arrayObserver.collection[index] = newValue;
      arrayObserver.notify();
    }
    handleDirty() {
      if (this.value !== this.getValue()) {
        this.subs.notifyDirty();
      }
    }
    /**
     * From interface `ICollectionSubscriber`
     */
    handleCollectionChange(_arr, indexMap) {
      const index = this.index;
      const noChange = indexMap[index] === index;
      if (noChange) {
        return;
      }
      const prevValue = this.value;
      const currValue = this.value = this.getValue();
      if (prevValue !== currValue) {
        this.subs.notify(currValue, prevValue);
      }
    }
    subscribe(subscriber) {
      if (this.subs.add(subscriber) && this.subs.count === 1) {
        this.owner.subscribe(this);
      }
    }
    unsubscribe(subscriber) {
      if (this.subs.remove(subscriber) && this.subs.count === 0) {
        this.owner.unsubscribe(this);
      }
    }
  }
  (() => {
    subscriberCollection(ArrayIndexObserverImpl, null);
  })();
  return function getArrayObserver2(array) {
    let observer = observerLookup.get(array);
    if (observer === void 0) {
      observerLookup.set(array, observer = new ArrayObserverImpl(array));
      enableArrayObservation();
    }
    return observer;
  };
})();
const getSetObserver = /* @__PURE__ */ (() => {
  const lookupMetadataKey = Symbol.for("__au_set_obs__");
  const observerLookup = Set[lookupMetadataKey] ?? rtDefineHiddenProp(Set, lookupMetadataKey, /* @__PURE__ */ new WeakMap());
  const { add: $add, clear: $clear, delete: $delete } = Set.prototype;
  const methods = ["add", "clear", "delete"];
  const observe = {
    // https://tc39.github.io/ecma262/#sec-set.prototype.add
    add: function(value) {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        $add.call(this, value);
        return this;
      }
      const oldSize = this.size;
      $add.call(this, value);
      const newSize = this.size;
      if (newSize === oldSize) {
        return this;
      }
      o2.indexMap[oldSize] = -2;
      o2.notify();
      return this;
    },
    // https://tc39.github.io/ecma262/#sec-set.prototype.clear
    clear: function() {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        return $clear.call(this);
      }
      const size = this.size;
      if (size > 0) {
        const indexMap = o2.indexMap;
        let i3 = 0;
        for (const key of this.keys()) {
          if (indexMap[i3] > -1) {
            indexMap.deletedIndices.push(indexMap[i3]);
            indexMap.deletedItems.push(key);
          }
          i3++;
        }
        $clear.call(this);
        indexMap.length = 0;
        o2.notify();
      }
      return void 0;
    },
    // https://tc39.github.io/ecma262/#sec-set.prototype.delete
    delete: function(value) {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        return $delete.call(this, value);
      }
      const size = this.size;
      if (size === 0) {
        return false;
      }
      let i3 = 0;
      const indexMap = o2.indexMap;
      for (const entry of this.keys()) {
        if (entry === value) {
          if (indexMap[i3] > -1) {
            indexMap.deletedIndices.push(indexMap[i3]);
            indexMap.deletedItems.push(entry);
          }
          indexMap.splice(i3, 1);
          const deleteResult = $delete.call(this, value);
          if (deleteResult === true) {
            o2.notify();
          }
          return deleteResult;
        }
        i3++;
      }
      return false;
    }
  };
  function enableSetObservation(set) {
    for (const method of methods) {
      rtDefineHiddenProp(set, method, observe[method]);
    }
  }
  class SetObserverImpl {
    constructor(observedSet) {
      this.type = atObserver$1;
      this.collection = observedSet;
      this.indexMap = createIndexMap(observedSet.size);
      this.lenObs = void 0;
    }
    notify() {
      const subs = this.subs;
      subs.notifyDirty();
      const indexMap = this.indexMap;
      const set = this.collection;
      const size = set.size;
      this.indexMap = createIndexMap(size);
      subs.notifyCollection(set, indexMap);
    }
    getLengthObserver() {
      return this.lenObs ??= new CollectionSizeObserver(this);
    }
  }
  subscriberCollection(SetObserverImpl, null);
  return function getSetObserver2(set) {
    let observer = observerLookup.get(set);
    if (observer === void 0) {
      observerLookup.set(set, observer = new SetObserverImpl(set));
      enableSetObservation(set);
    }
    return observer;
  };
})();
const getMapObserver = /* @__PURE__ */ (() => {
  const lookupMetadataKey = Symbol.for("__au_map_obs__");
  const observerLookup = Map[lookupMetadataKey] ?? rtDefineHiddenProp(Map, lookupMetadataKey, /* @__PURE__ */ new WeakMap());
  const { set: $set, clear: $clear, delete: $delete } = Map.prototype;
  const methods = ["set", "clear", "delete"];
  const observe = {
    // https://tc39.github.io/ecma262/#sec-map.prototype.map
    set: function(key, value) {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        $set.call(this, key, value);
        return this;
      }
      const oldValue = this.get(key);
      const oldSize = this.size;
      $set.call(this, key, value);
      const newSize = this.size;
      if (newSize === oldSize) {
        let i3 = 0;
        for (const entry of this.entries()) {
          if (entry[0] === key) {
            if (entry[1] !== oldValue) {
              o2.indexMap.deletedIndices.push(o2.indexMap[i3]);
              o2.indexMap.deletedItems.push(entry);
              o2.indexMap[i3] = -2;
              o2.notify();
            }
            return this;
          }
          i3++;
        }
        return this;
      }
      o2.indexMap[oldSize] = -2;
      o2.notify();
      return this;
    },
    // https://tc39.github.io/ecma262/#sec-map.prototype.clear
    clear: function() {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        return $clear.call(this);
      }
      const size = this.size;
      if (size > 0) {
        const indexMap = o2.indexMap;
        let i3 = 0;
        for (const key of this.keys()) {
          if (indexMap[i3] > -1) {
            indexMap.deletedIndices.push(indexMap[i3]);
            indexMap.deletedItems.push(key);
          }
          i3++;
        }
        $clear.call(this);
        indexMap.length = 0;
        o2.notify();
      }
      return void 0;
    },
    // https://tc39.github.io/ecma262/#sec-map.prototype.delete
    delete: function(value) {
      const o2 = observerLookup.get(this);
      if (o2 === void 0) {
        return $delete.call(this, value);
      }
      const size = this.size;
      if (size === 0) {
        return false;
      }
      let i3 = 0;
      const indexMap = o2.indexMap;
      for (const entry of this.keys()) {
        if (entry === value) {
          if (indexMap[i3] > -1) {
            indexMap.deletedIndices.push(indexMap[i3]);
            indexMap.deletedItems.push(entry);
          }
          indexMap.splice(i3, 1);
          const deleteResult = $delete.call(this, value);
          if (deleteResult === true) {
            o2.notify();
          }
          return deleteResult;
        }
        ++i3;
      }
      return false;
    }
  };
  function enableMapObservation(map) {
    for (const method of methods) {
      rtDefineHiddenProp(map, method, observe[method]);
    }
  }
  class MapObserverImpl {
    constructor(map) {
      this.type = atObserver$1;
      this.collection = map;
      this.indexMap = createIndexMap(map.size);
      this.lenObs = void 0;
    }
    notify() {
      const subs = this.subs;
      subs.notifyDirty();
      const indexMap = this.indexMap;
      const map = this.collection;
      const size = map.size;
      this.indexMap = createIndexMap(size);
      subs.notifyCollection(map, indexMap);
    }
    getLengthObserver() {
      return this.lenObs ??= new CollectionSizeObserver(this);
    }
  }
  subscriberCollection(MapObserverImpl, null);
  return function getMapObserver2(map) {
    let observer = observerLookup.get(map);
    if (observer === void 0) {
      observerLookup.set(map, observer = new MapObserverImpl(map));
      enableMapObservation(map);
    }
    return observer;
  };
})();
const connectableDecorator = /* @__PURE__ */ (() => {
  class BindingObserverRecord {
    constructor(b3) {
      this.version = 0;
      this.count = 0;
      this.o = /* @__PURE__ */ new Map();
      this.b = b3;
    }
    /**
     * Add, and subscribe to a given observer
     */
    add(observer) {
      if (!this.o.has(observer)) {
        observer.subscribe(this.b);
        ++this.count;
      }
      this.o.set(observer, this.version);
    }
    /**
     * Unsubscribe the observers that are not up to date with the record version
     */
    clear() {
      this.o.forEach(unsubscribeStale, this);
      this.count = this.o.size;
    }
    clearAll() {
      this.o.forEach(unsubscribeAll, this);
      this.o.clear();
      this.count = 0;
    }
  }
  function unsubscribeAll(version, subscribable) {
    subscribable.unsubscribe(this.b);
  }
  function unsubscribeStale(version, subscribable) {
    if (this.version !== version) {
      subscribable.unsubscribe(this.b);
      this.o.delete(subscribable);
    }
  }
  function getObserverRecord() {
    return rtDefineHiddenProp(this, "obs", new BindingObserverRecord(this));
  }
  function observe(obj, key) {
    this.obs.add(this.oL.getObserver(obj, key));
  }
  function observeCollection2(collection) {
    let observer;
    if (isArray(collection)) {
      observer = getArrayObserver(collection);
    } else if (isSet(collection)) {
      observer = getSetObserver(collection);
    } else if (isMap(collection)) {
      observer = getMapObserver(collection);
    } else {
      throw createMappedError$3(210, collection);
    }
    this.obs.add(observer);
  }
  function subscribeTo(subscribable) {
    this.obs.add(subscribable);
  }
  function noopHandleChange() {
    throw createMappedError$3(99, "handleChange");
  }
  function noopHandleCollectionChange() {
    throw createMappedError$3(99, "handleCollectionChange");
  }
  return function connectableDecorator2(target, context) {
    const proto = target.prototype;
    ensureProto(proto, "observe", observe);
    ensureProto(proto, "observeCollection", observeCollection2);
    ensureProto(proto, "subscribeTo", subscribeTo);
    rtDef(proto, "obs", { get: getObserverRecord });
    ensureProto(proto, "handleChange", noopHandleChange);
    ensureProto(proto, "handleCollectionChange", noopHandleCollectionChange);
    return target;
  };
})();
function connectable(target, context) {
  return target == null ? connectableDecorator : connectableDecorator(target, context);
}
let _connectable = null;
const connectables = [];
let connecting = false;
function pauseConnecting() {
  connecting = false;
}
function resumeConnecting() {
  connecting = true;
}
function currentConnectable() {
  return _connectable;
}
function enterConnectable(connectable2) {
  if (connectable2 == null) {
    throw createMappedError$3(
      206
      /* ErrorNames.switch_on_null_connectable */
    );
  }
  if (_connectable == null) {
    _connectable = connectable2;
    connectables[0] = _connectable;
    connecting = true;
    return;
  }
  if (_connectable === connectable2) {
    throw createMappedError$3(
      207
      /* ErrorNames.switch_active_connectable */
    );
  }
  connectables.push(connectable2);
  _connectable = connectable2;
  connecting = true;
}
function exitConnectable(connectable2) {
  if (connectable2 == null) {
    throw createMappedError$3(
      208
      /* ErrorNames.switch_off_null_connectable */
    );
  }
  if (_connectable !== connectable2) {
    throw createMappedError$3(
      209
      /* ErrorNames.switch_off_inactive_connectable */
    );
  }
  connectables.pop();
  _connectable = connectables.length > 0 ? connectables[connectables.length - 1] : null;
  connecting = _connectable != null;
}
const ConnectableSwitcher = /* @__PURE__ */ rtObjectFreeze({
  get current() {
    return _connectable;
  },
  get connecting() {
    return connecting;
  },
  enter: enterConnectable,
  exit: exitConnectable,
  pause: pauseConnecting,
  resume: resumeConnecting
});
const R$get = Reflect.get;
const toStringTag = Object.prototype.toString;
const proxyMap = /* @__PURE__ */ new WeakMap();
const nowrapClassKey = "__au_nw__";
const nowrapPropKey = "__au_nw";
function canWrap(obj) {
  switch (toStringTag.call(obj)) {
    case "[object Object]":
      return obj.constructor[nowrapClassKey] !== true;
    case "[object Array]":
    case "[object Map]":
    case "[object Set]":
      return true;
    default:
      return false;
  }
}
const rawKey = "__raw__";
function wrap$1(v2) {
  return canWrap(v2) ? getProxy(v2) : v2;
}
function getProxy(obj) {
  return proxyMap.get(obj) ?? createProxy(obj);
}
function getRaw(obj) {
  return obj[rawKey] ?? obj;
}
function unwrap$1(v2) {
  return canWrap(v2) && v2[rawKey] || v2;
}
function doNotCollect(object, key) {
  return key === "constructor" || key === "__proto__" || key === "$observers" || key === Symbol.toPrimitive || key === Symbol.toStringTag || object.constructor[`${nowrapPropKey}_${rtSafeString(key)}__`] === true;
}
function createProxy(obj) {
  const handler = isArray(obj) ? arrayHandler : isMap(obj) || isSet(obj) ? collectionHandler : objectHandler;
  const proxiedObj = new Proxy(obj, handler);
  proxyMap.set(obj, proxiedObj);
  proxyMap.set(proxiedObj, proxiedObj);
  return proxiedObj;
}
const objectHandler = {
  get(target, key, receiver) {
    if (key === rawKey) {
      return target;
    }
    const connectable2 = currentConnectable();
    if (!connecting || doNotCollect(target, key) || connectable2 == null) {
      return R$get(target, key, receiver);
    }
    connectable2.observe(target, key);
    return wrap$1(R$get(target, key, receiver));
  }
};
const arrayHandler = {
  get(target, key, receiver) {
    if (key === rawKey) {
      return target;
    }
    if (!connecting || doNotCollect(target, key) || _connectable == null) {
      return R$get(target, key, receiver);
    }
    switch (key) {
      case "length":
        _connectable.observe(target, "length");
        return target.length;
      case "map":
        return wrappedArrayMap;
      case "includes":
        return wrappedArrayIncludes;
      case "indexOf":
        return wrappedArrayIndexOf;
      case "lastIndexOf":
        return wrappedArrayLastIndexOf;
      case "every":
        return wrappedArrayEvery;
      case "filter":
        return wrappedArrayFilter;
      case "find":
        return wrappedArrayFind;
      case "findIndex":
        return wrappedArrayFindIndex;
      case "flat":
        return wrappedArrayFlat;
      case "flatMap":
        return wrappedArrayFlatMap;
      case "join":
        return wrappedArrayJoin;
      case "push":
        return wrappedArrayPush;
      case "pop":
        return wrappedArrayPop;
      case "reduce":
        return wrappedReduce;
      case "reduceRight":
        return wrappedReduceRight;
      case "reverse":
        return wrappedArrayReverse;
      case "shift":
        return wrappedArrayShift;
      case "unshift":
        return wrappedArrayUnshift;
      case "slice":
        return wrappedArraySlice;
      case "splice":
        return wrappedArraySplice;
      case "some":
        return wrappedArraySome;
      case "sort":
        return wrappedArraySort;
      case "keys":
        return wrappedKeys;
      case "values":
      case Symbol.iterator:
        return wrappedValues;
      case "entries":
        return wrappedEntries;
    }
    _connectable.observe(target, key);
    return wrap$1(R$get(target, key, receiver));
  },
  // for (let i in array) ...
  ownKeys(target) {
    currentConnectable()?.observe(target, "length");
    return Reflect.ownKeys(target);
  }
};
function wrappedArrayMap(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.map((v2, i3) => (
    // do we wrap `thisArg`?
    unwrap$1(cb.call(thisArg, wrap$1(v2), i3, this))
  ));
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArrayEvery(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.every((v2, i3) => cb.call(thisArg, wrap$1(v2), i3, this));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayFilter(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.filter((v2, i3) => (
    // do we wrap `thisArg`?
    unwrap$1(cb.call(thisArg, wrap$1(v2), i3, this))
  ));
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArrayIncludes(v2) {
  const raw = getRaw(this);
  const res = raw.includes(unwrap$1(v2));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayIndexOf(v2) {
  const raw = getRaw(this);
  const res = raw.indexOf(unwrap$1(v2));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayLastIndexOf(v2) {
  const raw = getRaw(this);
  const res = raw.lastIndexOf(unwrap$1(v2));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayFindIndex(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.findIndex((v2, i3) => unwrap$1(cb.call(thisArg, wrap$1(v2), i3, this)));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArrayFind(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.find((v2, i3) => cb(wrap$1(v2), i3, this), thisArg);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArrayFlat() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return wrap$1(raw.flat());
}
function wrappedArrayFlatMap(cb, thisArg) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return getProxy(raw.flatMap((v2, i3) => wrap$1(cb.call(thisArg, wrap$1(v2), i3, this))));
}
function wrappedArrayJoin(separator) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return raw.join(separator);
}
function wrappedArrayPop() {
  return wrap$1(getRaw(this).pop());
}
function wrappedArrayPush(...args) {
  return getRaw(this).push(...args);
}
function wrappedArrayShift() {
  return wrap$1(getRaw(this).shift());
}
function wrappedArrayUnshift(...args) {
  return getRaw(this).unshift(...args);
}
function wrappedArraySplice(...args) {
  return wrap$1(getRaw(this).splice(...args));
}
function wrappedArrayReverse(..._args) {
  const raw = getRaw(this);
  const res = raw.reverse();
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArraySome(cb, thisArg) {
  const raw = getRaw(this);
  const res = raw.some((v2, i3) => unwrap$1(cb.call(thisArg, wrap$1(v2), i3, this)));
  observeCollection(_connectable, raw);
  return res;
}
function wrappedArraySort(cb) {
  const raw = getRaw(this);
  const res = raw.sort(cb);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedArraySlice(start2, end2) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return getProxy(raw.slice(start2, end2));
}
function wrappedReduce(cb, initValue) {
  const raw = getRaw(this);
  const res = raw.reduce((curr, v2, i3) => cb(curr, wrap$1(v2), i3, this), initValue);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
function wrappedReduceRight(cb, initValue) {
  const raw = getRaw(this);
  const res = raw.reduceRight((curr, v2, i3) => cb(curr, wrap$1(v2), i3, this), initValue);
  observeCollection(_connectable, raw);
  return wrap$1(res);
}
const collectionHandler = {
  get(target, key, receiver) {
    if (key === rawKey) {
      return target;
    }
    const connectable2 = currentConnectable();
    if (!connecting || doNotCollect(target, key) || connectable2 == null) {
      return R$get(target, key, receiver);
    }
    switch (key) {
      case "size":
        connectable2.observe(target, "size");
        return target.size;
      case "clear":
        return wrappedClear;
      case "delete":
        return wrappedDelete;
      case "forEach":
        return wrappedForEach;
      case "add":
        if (isSet(target)) {
          return wrappedAdd;
        }
        break;
      case "get":
        if (isMap(target)) {
          return wrappedGet;
        }
        break;
      case "set":
        if (isMap(target)) {
          return wrappedSet;
        }
        break;
      case "has":
        return wrappedHas;
      case "keys":
        return wrappedKeys;
      case "values":
        return wrappedValues;
      case "entries":
        return wrappedEntries;
      case Symbol.iterator:
        return isMap(target) ? wrappedEntries : wrappedValues;
    }
    return wrap$1(R$get(target, key, receiver));
  }
};
function wrappedForEach(cb, thisArg) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return raw.forEach((v2, key) => {
    cb.call(
      /* should wrap or not?? */
      thisArg,
      wrap$1(v2),
      wrap$1(key),
      this
    );
  });
}
function wrappedHas(v2) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return raw.has(unwrap$1(v2));
}
function wrappedGet(k3) {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  return wrap$1(raw.get(unwrap$1(k3)));
}
function wrappedSet(k3, v2) {
  return wrap$1(getRaw(this).set(unwrap$1(k3), unwrap$1(v2)));
}
function wrappedAdd(v2) {
  return wrap$1(getRaw(this).add(unwrap$1(v2)));
}
function wrappedClear() {
  return wrap$1(getRaw(this).clear());
}
function wrappedDelete(k3) {
  return wrap$1(getRaw(this).delete(unwrap$1(k3)));
}
function wrappedKeys() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  const iterator = raw.keys();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? { value: void 0, done } : { value: wrap$1(value), done };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function wrappedValues() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  const iterator = raw.values();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? { value: void 0, done } : { value: wrap$1(value), done };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function wrappedEntries() {
  const raw = getRaw(this);
  observeCollection(_connectable, raw);
  const iterator = raw.entries();
  return {
    next() {
      const next = iterator.next();
      const value = next.value;
      const done = next.done;
      return done ? { value: void 0, done } : { value: [wrap$1(value[0]), wrap$1(value[1])], done };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
const observeCollection = (connectable2, collection) => connectable2?.observeCollection(collection);
const ProxyObservable = /* @__PURE__ */ rtObjectFreeze({
  getProxy,
  getRaw,
  wrap: wrap$1,
  unwrap: unwrap$1,
  rawKey
});
class ComputedObserver {
  constructor(obj, get, set, observerLocator, useProxy) {
    this.type = atObserver$1;
    this._value = void 0;
    this._isRunning = false;
    this._isDirty = false;
    this._callback = void 0;
    this._coercer = void 0;
    this._coercionConfig = void 0;
    this._obj = obj;
    this._wrapped = useProxy ? wrap$1(obj) : obj;
    this.$get = get;
    this.$set = set;
    this.oL = observerLocator;
  }
  init(value) {
    this._value = value;
    this._isDirty = false;
  }
  getValue() {
    if (this.subs.count === 0) {
      return this.$get.call(this._obj, this._obj, this);
    }
    if (this._isDirty) {
      this.compute();
      this._isDirty = false;
    }
    return this._value;
  }
  // deepscan-disable-next-line
  setValue(v2) {
    if (isFunction(this.$set)) {
      if (this._coercer !== void 0) {
        v2 = this._coercer.call(null, v2, this._coercionConfig);
      }
      if (!areEqual(v2, this._value)) {
        this._isRunning = true;
        this.$set.call(this._obj, v2);
        this._isRunning = false;
        this.run();
      }
    } else {
      throw createMappedError$3(
        221
        /* ErrorNames.assign_readonly_readonly_property_from_computed */
      );
    }
  }
  useCoercer(coercer, coercionConfig) {
    this._coercer = coercer;
    this._coercionConfig = coercionConfig;
    return true;
  }
  useCallback(callback) {
    this._callback = callback;
    return true;
  }
  handleDirty() {
    if (!this._isDirty) {
      this._isDirty = true;
      this.subs.notifyDirty();
    }
  }
  handleChange() {
    this._isDirty = true;
    if (this.subs.count > 0) {
      this.run();
    }
  }
  handleCollectionChange() {
    this._isDirty = true;
    if (this.subs.count > 0) {
      this.run();
    }
  }
  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this.compute();
      this._isDirty = false;
    }
  }
  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this._isDirty = true;
      this.obs.clearAll();
    }
  }
  run() {
    if (this._isRunning) {
      return;
    }
    const oldValue = this._value;
    const newValue = this.compute();
    this._isDirty = false;
    if (!areEqual(newValue, oldValue)) {
      this._callback?.(newValue, oldValue);
      this.subs.notify(this._value, oldValue);
    }
  }
  compute() {
    this._isRunning = true;
    this.obs.version++;
    try {
      enterConnectable(this);
      return this._value = unwrap$1(this.$get.call(this._wrapped, this._wrapped, this));
    } finally {
      this.obs.clear();
      this._isRunning = false;
      exitConnectable(this);
    }
  }
}
(() => {
  connectable(ComputedObserver, null);
  subscriberCollection(ComputedObserver, null);
})();
const IDirtyChecker = /* @__PURE__ */ rtCreateInterface(
  "IDirtyChecker",
  (x2) => x2.callback(() => {
    throw createMappedError$3(
      217
      /* ErrorNames.dirty_check_no_handler */
    );
  })
);
const DirtyCheckSettings = {
  /**
   * Default: `6`
   *
   * Adjust the global dirty check frequency.
   * Measures in "timeouts per check", such that (given a default of 250 timeouts per second in modern browsers):
   * - A value of 1 will result in 250 dirty checks per second (or 1 dirty check per second for an inactive tab)
   * - A value of 25 will result in 10 dirty checks per second (or 1 dirty check per 25 seconds for an inactive tab)
   */
  timeoutsPerCheck: 25,
  /**
   * Default: `false`
   *
   * Disable dirty-checking entirely. Properties that cannot be observed without dirty checking
   * or an adapter, will simply not be observed.
   */
  disabled: false,
  /**
   * Default: `false`
   *
   * Throw an error if a property is being dirty-checked.
   */
  throw: false,
  /**
   * Resets all dirty checking settings to the framework's defaults.
   */
  resetToDefault() {
    this.timeoutsPerCheck = 6;
    this.disabled = false;
    this.throw = false;
  }
};
class DirtyChecker {
  static register(c2) {
    c2.register(Registration.singleton(this, this), Registration.aliasTo(this, IDirtyChecker));
  }
  constructor() {
    this.tracked = [];
    this._task = null;
    this._elapsedFrames = 0;
    this.p = resolve(IPlatform$1);
    this.check = () => {
      if (++this._elapsedFrames < DirtyCheckSettings.timeoutsPerCheck) {
        return;
      }
      this._elapsedFrames = 0;
      const tracked = this.tracked;
      const len = tracked.length;
      let current;
      let i3 = 0;
      for (; i3 < len; ++i3) {
        current = tracked[i3];
        if (current.isDirty()) {
          current.flush();
        }
      }
    };
    subscriberCollection(DirtyCheckProperty, null);
  }
  createProperty(obj, key) {
    return new DirtyCheckProperty(this, obj, key);
  }
  addProperty(property) {
    this.tracked.push(property);
    if (this.tracked.length === 1) {
      this._task = this.p.taskQueue.queueTask(this.check, { persistent: true });
    }
  }
  removeProperty(property) {
    this.tracked.splice(this.tracked.indexOf(property), 1);
    if (this.tracked.length === 0) {
      this._task.cancel();
      this._task = null;
    }
  }
}
class DirtyCheckProperty {
  constructor(dirtyChecker, obj, key) {
    this.obj = obj;
    this.key = key;
    this.type = atNone;
    this._oldValue = void 0;
    this._dirtyChecker = dirtyChecker;
  }
  getValue() {
    return this.obj[this.key];
  }
  setValue(_v) {
    throw createMappedError$3(219, this.key);
  }
  isDirty() {
    return this._oldValue !== this.obj[this.key];
  }
  flush() {
    const oldValue = this._oldValue;
    const newValue = this.getValue();
    this._oldValue = newValue;
    this.subs.notify(newValue, oldValue);
  }
  subscribe(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      this._oldValue = this.obj[this.key];
      this._dirtyChecker.addProperty(this);
    }
  }
  unsubscribe(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      this._dirtyChecker.removeProperty(this);
    }
  }
}
class PrimitiveObserver {
  get doNotCache() {
    return true;
  }
  constructor(obj, key) {
    this.type = atNone;
    this._obj = obj;
    this._key = key;
  }
  getValue() {
    return this._obj[this._key];
  }
  setValue() {
  }
  subscribe() {
  }
  unsubscribe() {
  }
}
class PropertyAccessor {
  constructor() {
    this.type = atNone;
  }
  getValue(obj, key) {
    return obj[key];
  }
  setValue(value, obj, key) {
    obj[key] = value;
  }
}
class SetterObserver {
  constructor(obj, key) {
    this.type = atObserver$1;
    this._value = void 0;
    this._observing = false;
    this._callback = void 0;
    this._coercer = void 0;
    this._coercionConfig = void 0;
    this._obj = obj;
    this._key = key;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    if (this._coercer !== void 0) {
      newValue = this._coercer.call(void 0, newValue, this._coercionConfig);
    }
    if (this._observing) {
      if (areEqual(newValue, this._value)) {
        return;
      }
      oV$1 = this._value;
      this._value = newValue;
      this.subs.notifyDirty();
      this.subs.notify(newValue, oV$1);
      if (areEqual(newValue, this._value)) {
        this._callback?.(newValue, oV$1);
      }
    } else {
      this._value = this._obj[this._key] = newValue;
      this._callback?.(newValue, oV$1);
    }
  }
  useCallback(callback) {
    this._callback = callback;
    this.start();
    return true;
  }
  useCoercer(coercer, coercionConfig) {
    this._coercer = coercer;
    this._coercionConfig = coercionConfig;
    this.start();
    return true;
  }
  subscribe(subscriber) {
    if (this._observing === false) {
      this.start();
    }
    this.subs.add(subscriber);
  }
  start() {
    if (this._observing === false) {
      this._observing = true;
      this._value = this._obj[this._key];
      rtDef(this._obj, this._key, {
        enumerable: true,
        configurable: true,
        get: rtObjectAssign(() => this.getValue(), { getObserver: () => this }),
        set: (value) => {
          this.setValue(value);
        }
      });
    }
    return this;
  }
  stop() {
    if (this._observing) {
      rtDef(this._obj, this._key, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: this._value
      });
      this._observing = false;
    }
    return this;
  }
}
(() => {
  subscriberCollection(SetterObserver, null);
})();
let oV$1 = void 0;
const propertyAccessor = new PropertyAccessor();
const IObserverLocator = /* @__PURE__ */ rtCreateInterface("IObserverLocator", (x2) => x2.singleton(ObserverLocator));
const INodeObserverLocator = /* @__PURE__ */ rtCreateInterface("INodeObserverLocator", (x2) => x2.cachedCallback((handler) => {
  {
    handler.getAll(ILogger).forEach((logger) => {
      logger.error("Using default INodeObserverLocator implementation. Will not be able to observe nodes (HTML etc...).");
    });
  }
  return new DefaultNodeObserverLocator();
}));
class DefaultNodeObserverLocator {
  handles() {
    return false;
  }
  getObserver() {
    return propertyAccessor;
  }
  getAccessor() {
    return propertyAccessor;
  }
}
const IComputedObserverLocator = /* @__PURE__ */ rtCreateInterface("IComputedObserverLocator", (x2) => x2.singleton(class DefaultLocator {
  getObserver(obj, key, pd, requestor) {
    const observer = new ComputedObserver(obj, pd.get, pd.set, requestor, true);
    rtDef(obj, key, {
      enumerable: pd.enumerable,
      configurable: true,
      get: rtObjectAssign(() => observer.getValue(), { getObserver: () => observer }),
      set: (v2) => {
        observer.setValue(v2);
      }
    });
    return observer;
  }
}));
class ObserverLocator {
  constructor() {
    this._adapters = [];
    this._dirtyChecker = resolve(IDirtyChecker);
    this._nodeObserverLocator = resolve(INodeObserverLocator);
    this._computedObserverLocator = resolve(IComputedObserverLocator);
  }
  addAdapter(adapter) {
    this._adapters.push(adapter);
  }
  getObserver(obj, key) {
    if (obj == null) {
      throw createMappedError$3(199, key);
    }
    if (!isObject(obj)) {
      return new PrimitiveObserver(obj, isFunction(key) ? "" : key);
    }
    if (isFunction(key)) {
      return new ComputedObserver(obj, key, void 0, this, true);
    }
    const lookup2 = getObserverLookup(obj);
    let observer = lookup2[key];
    if (observer === void 0) {
      observer = this.createObserver(obj, key);
      if (!observer.doNotCache) {
        lookup2[key] = observer;
      }
    }
    return observer;
  }
  getAccessor(obj, key) {
    const cached = obj.$observers?.[key];
    if (cached !== void 0) {
      return cached;
    }
    if (this._nodeObserverLocator.handles(obj, key, this)) {
      return this._nodeObserverLocator.getAccessor(obj, key, this);
    }
    return propertyAccessor;
  }
  getArrayObserver(observedArray) {
    return getArrayObserver(observedArray);
  }
  getMapObserver(observedMap) {
    return getMapObserver(observedMap);
  }
  getSetObserver(observedSet) {
    return getSetObserver(observedSet);
  }
  createObserver(obj, key) {
    if (this._nodeObserverLocator.handles(obj, key, this)) {
      return this._nodeObserverLocator.getObserver(obj, key, this);
    }
    switch (key) {
      case "length":
        if (isArray(obj)) {
          return getArrayObserver(obj).getLengthObserver();
        }
        break;
      case "size":
        if (isMap(obj)) {
          return getMapObserver(obj).getLengthObserver();
        } else if (isSet(obj)) {
          return getSetObserver(obj).getLengthObserver();
        }
        break;
      default:
        if (isArray(obj) && isArrayIndex(key)) {
          return getArrayObserver(obj).getIndexObserver(Number(key));
        }
        break;
    }
    let pd = getOwnPropDesc(obj, key);
    if (pd === void 0) {
      let proto = getProto(obj);
      while (proto !== null) {
        pd = getOwnPropDesc(proto, key);
        if (pd === void 0) {
          proto = getProto(proto);
        } else {
          break;
        }
      }
    }
    if (pd !== void 0 && !hasOwnProp.call(pd, "value")) {
      let obs = this._getAdapterObserver(obj, key, pd);
      if (obs == null) {
        obs = pd.get?.getObserver?.(obj);
      }
      return obs == null ? pd.configurable ? this._computedObserverLocator.getObserver(obj, key, pd, this) : this._dirtyChecker.createProperty(obj, key) : obs;
    }
    return new SetterObserver(obj, key);
  }
  // /** @internal */
  // private _createComputedObserver(obj: object, key: PropertyKey, pd: PropertyDescriptor, useProxy?: boolean) {
  //   const observer = new ComputedObserver(obj, pd.get!, pd.set, this, !!useProxy);
  //   def(obj, key, {
  //     enumerable: pd.enumerable,
  //     configurable: true,
  //     get: objectAssign(((/* Computed Observer */) => observer.getValue()) as ObservableGetter, { getObserver: () => observer }),
  //     set: (/* Computed Observer */v) => {
  //       observer.setValue(v);
  //     },
  //   });
  //   return observer;
  // }
  /** @internal */
  _getAdapterObserver(obj, key, pd) {
    if (this._adapters.length > 0) {
      for (const adapter of this._adapters) {
        const observer = adapter.getObserver(obj, key, pd, this);
        if (observer != null) {
          return observer;
        }
      }
    }
    return null;
  }
}
const getCollectionObserver$1 = (collection) => {
  let obs;
  if (isArray(collection)) {
    obs = getArrayObserver(collection);
  } else if (isMap(collection)) {
    obs = getMapObserver(collection);
  } else if (isSet(collection)) {
    obs = getSetObserver(collection);
  }
  return obs;
};
const getProto = Object.getPrototypeOf;
const getOwnPropDesc = Object.getOwnPropertyDescriptor;
const getObserverLookup = (instance) => {
  let lookup2 = instance.$observers;
  if (lookup2 === void 0) {
    rtDef(instance, "$observers", {
      enumerable: false,
      value: lookup2 = createLookup$1()
    });
  }
  return lookup2;
};
class RunEffect {
  constructor(oL, fn2) {
    this.oL = oL;
    this.fn = fn2;
    this.maxRunCount = 10;
    this.queued = false;
    this.running = false;
    this.runCount = 0;
    this.stopped = false;
    this._cleanupTask = void 0;
    this.run = () => {
      if (this.stopped) {
        throw createMappedError$3(
          225
          /* ErrorNames.stopping_a_stopped_effect */
        );
      }
      if (this.running) {
        return;
      }
      ++this.runCount;
      this.running = true;
      this.queued = false;
      ++this.obs.version;
      try {
        this._cleanupTask?.call(void 0);
        enterConnectable(this);
        this._cleanupTask = this.fn(this);
      } finally {
        this.obs.clear();
        this.running = false;
        exitConnectable(this);
      }
      if (this.queued) {
        if (this.runCount > this.maxRunCount) {
          this.runCount = 0;
          throw createMappedError$3(
            226
            /* ErrorNames.effect_maximum_recursion_reached */
          );
        }
        this.run();
      } else {
        this.runCount = 0;
      }
    };
    this.stop = () => {
      this._cleanupTask?.call(void 0);
      this._cleanupTask = void 0;
      this.stopped = true;
      this.obs.clearAll();
    };
  }
  handleChange() {
    this.queued = true;
    this.run();
  }
  handleCollectionChange() {
    this.queued = true;
    this.run();
  }
}
(() => {
  connectable(RunEffect, null);
})();
class ExpressionObserver {
  constructor(scope, oL, expression, callback) {
    this.oL = oL;
    this._value = void 0;
    this.boundFn = false;
    this._scope = scope;
    this.ast = expression;
    this._callback = callback;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  run() {
    this.obs.version++;
    const oldValue = this._value;
    const value = astEvaluate(this.ast, this._scope, this, this);
    this.obs.clear();
    if (!areEqual(value, oldValue)) {
      this._value = value;
      this._callback.call(void 0, value, oldValue);
    }
  }
  stop() {
    this.obs.clearAll();
    this._value = void 0;
  }
}
(() => {
  connectable(ExpressionObserver, null);
  mixinNoopAstEvaluator(ExpressionObserver);
})();
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
const tsPending$1 = "pending";
const tsRunning$1 = "running";
const tsCompleted = "completed";
const tsCanceled = "canceled";
const lookup = /* @__PURE__ */ new Map();
const notImplemented = (name2) => {
  return () => {
    throw createError$2(`AUR1005: The PLATFORM did not receive a valid reference to the global function '${name2}'.`);
  };
};
class Platform {
  constructor(g2, overrides = {}) {
    this.macroTaskRequested = false;
    this.macroTaskHandle = -1;
    this.globalThis = g2;
    "decodeURI decodeURIComponent encodeURI encodeURIComponent Date Reflect console".split(" ").forEach((prop) => {
      this[prop] = prop in overrides ? overrides[prop] : g2[prop];
    });
    "clearInterval clearTimeout queueMicrotask setInterval setTimeout".split(" ").forEach((method) => {
      this[method] = method in overrides ? overrides[method] : g2[method]?.bind(g2) ?? notImplemented(method);
    });
    this.performanceNow = "performanceNow" in overrides ? overrides.performanceNow : g2.performance?.now?.bind(g2.performance) ?? notImplemented("performance.now");
    this.flushMacroTask = this.flushMacroTask.bind(this);
    this.taskQueue = new TaskQueue(this, this.requestMacroTask.bind(this), this.cancelMacroTask.bind(this));
  }
  static getOrCreate(g2, overrides = {}) {
    let platform = lookup.get(g2);
    if (platform === void 0) {
      lookup.set(g2, platform = new Platform(g2, overrides));
    }
    return platform;
  }
  static set(g2, platform) {
    lookup.set(g2, platform);
  }
  requestMacroTask() {
    this.macroTaskRequested = true;
    if (this.macroTaskHandle === -1) {
      this.macroTaskHandle = this.setTimeout(this.flushMacroTask, 0);
    }
  }
  cancelMacroTask() {
    this.macroTaskRequested = false;
    if (this.macroTaskHandle > -1) {
      this.clearTimeout(this.macroTaskHandle);
      this.macroTaskHandle = -1;
    }
  }
  flushMacroTask() {
    this.macroTaskHandle = -1;
    if (this.macroTaskRequested === true) {
      this.macroTaskRequested = false;
      this.taskQueue.flush();
    }
  }
}
class TaskQueue {
  get isEmpty() {
    return this._pendingAsyncCount === 0 && this._processing.length === 0 && this._pending.length === 0 && this._delayed.length === 0;
  }
  /**
   * Persistent tasks will re-queue themselves indefinitely until they are explicitly canceled,
   * so we consider them 'infinite work' whereas non-persistent (one-off) tasks are 'finite work'.
   *
   * This `hasNoMoreFiniteWork` getters returns true if either all remaining tasks are persistent, or if there are no more tasks.
   *
   * If that is the case, we can resolve the promise that was created when `yield()` is called.
   *
   * @internal
   */
  get _hasNoMoreFiniteWork() {
    return this._pendingAsyncCount === 0 && this._processing.every(isPersistent) && this._pending.every(isPersistent) && this._delayed.every(isPersistent);
  }
  constructor(platform, $request, $cancel) {
    this.platform = platform;
    this.$request = $request;
    this.$cancel = $cancel;
    this._suspenderTask = void 0;
    this._pendingAsyncCount = 0;
    this._processing = [];
    this._pending = [];
    this._delayed = [];
    this._flushRequested = false;
    this._yieldPromise = void 0;
    this._lastRequest = 0;
    this._lastFlush = 0;
    this._requestFlush = () => {
      if (this._tracer.enabled) {
        this._tracer.enter(this, "requestFlush");
      }
      if (!this._flushRequested) {
        this._flushRequested = true;
        this._lastRequest = this._now();
        this.$request();
      }
      if (this._tracer.enabled) {
        this._tracer.leave(this, "requestFlush");
      }
    };
    this._now = platform.performanceNow;
    this._tracer = new Tracer(platform.console);
  }
  flush(now = this._now()) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "flush");
    }
    this._flushRequested = false;
    this._lastFlush = now;
    if (this._suspenderTask === void 0) {
      let curr;
      if (this._pending.length > 0) {
        this._processing.push(...this._pending);
        this._pending.length = 0;
      }
      if (this._delayed.length > 0) {
        for (let i3 = 0; i3 < this._delayed.length; ++i3) {
          curr = this._delayed[i3];
          if (curr.queueTime <= now) {
            this._processing.push(curr);
            this._delayed.splice(i3--, 1);
          }
        }
      }
      let cur;
      while (this._processing.length > 0) {
        (cur = this._processing.shift()).run();
        if (cur.status === tsRunning$1) {
          if (cur.suspend === true) {
            this._suspenderTask = cur;
            this._requestFlush();
            if (this._tracer.enabled) {
              this._tracer.leave(this, "flush early async");
            }
            return;
          } else {
            ++this._pendingAsyncCount;
          }
        }
      }
      if (this._pending.length > 0) {
        this._processing.push(...this._pending);
        this._pending.length = 0;
      }
      if (this._delayed.length > 0) {
        for (let i3 = 0; i3 < this._delayed.length; ++i3) {
          curr = this._delayed[i3];
          if (curr.queueTime <= now) {
            this._processing.push(curr);
            this._delayed.splice(i3--, 1);
          }
        }
      }
      if (this._processing.length > 0 || this._delayed.length > 0 || this._pendingAsyncCount > 0) {
        this._requestFlush();
      }
      if (this._yieldPromise !== void 0 && this._hasNoMoreFiniteWork) {
        const p2 = this._yieldPromise;
        this._yieldPromise = void 0;
        p2.resolve();
      }
    } else {
      this._requestFlush();
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "flush full");
    }
  }
  /**
   * Cancel the next flush cycle (and/or the macrotask that schedules the next flush cycle, in case this is a microtask queue), if it was requested.
   *
   * This operation is idempotent and will do nothing if no flush is scheduled.
   */
  cancel() {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "cancel");
    }
    if (this._flushRequested) {
      this.$cancel();
      this._flushRequested = false;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "cancel");
    }
  }
  /**
   * Returns a promise that, when awaited, resolves when:
   * - all *non*-persistent (including async) tasks have finished;
   * - the last-added persistent task has run exactly once;
   *
   * This operation is idempotent: the same promise will be returned until it resolves.
   *
   * If `yield()` is called multiple times in a row when there are one or more persistent tasks in the queue, each call will await exactly one cycle of those tasks.
   */
  async yield() {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "yield");
    }
    if (this.isEmpty) {
      if (this._tracer.enabled) {
        this._tracer.leave(this, "yield empty");
      }
    } else {
      if (this._yieldPromise === void 0) {
        if (this._tracer.enabled) {
          this._tracer.trace(this, "yield - creating promise");
        }
        this._yieldPromise = createExposedPromise();
      }
      await this._yieldPromise;
      if (this._tracer.enabled) {
        this._tracer.leave(this, "yield task");
      }
    }
  }
  queueTask(callback, opts) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "queueTask");
    }
    const { delay, preempt, persistent, suspend } = { ...defaultQueueTaskOptions, ...opts };
    if (preempt) {
      if (delay > 0) {
        throw preemptDelayComboError();
      }
      if (persistent) {
        throw preemptyPersistentComboError();
      }
    }
    if (this._processing.length === 0) {
      this._requestFlush();
    }
    const time = this._now();
    const task2 = new Task(this._tracer, this, time, time + delay, preempt, persistent, suspend, callback);
    if (preempt) {
      this._processing[this._processing.length] = task2;
    } else if (delay === 0) {
      this._pending[this._pending.length] = task2;
    } else {
      this._delayed[this._delayed.length] = task2;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "queueTask");
    }
    return task2;
  }
  /**
   * Remove the task from this queue.
   */
  remove(task2) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "remove");
    }
    let idx = this._processing.indexOf(task2);
    if (idx > -1) {
      this._processing.splice(idx, 1);
      if (this._tracer.enabled) {
        this._tracer.leave(this, "remove processing");
      }
      return;
    }
    idx = this._pending.indexOf(task2);
    if (idx > -1) {
      this._pending.splice(idx, 1);
      if (this._tracer.enabled) {
        this._tracer.leave(this, "remove pending");
      }
      return;
    }
    idx = this._delayed.indexOf(task2);
    if (idx > -1) {
      this._delayed.splice(idx, 1);
      if (this._tracer.enabled) {
        this._tracer.leave(this, "remove delayed");
      }
      return;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "remove error");
    }
    throw createError$2(`Task #${task2.id} could not be found`);
  }
  /**
   * Reset the persistent task back to its pending state, preparing it for being invoked again on the next flush.
   *
   * @internal
   */
  _resetPersistentTask(task2) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "resetPersistentTask");
    }
    task2.reset(this._now());
    if (task2.createdTime === task2.queueTime) {
      this._pending[this._pending.length] = task2;
    } else {
      this._delayed[this._delayed.length] = task2;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "resetPersistentTask");
    }
  }
  /**
   * Notify the queue that this async task has had its promise resolved, so that the queue can proceed with consecutive tasks on the next flush.
   *
   * @internal
   */
  _completeAsyncTask(task2) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "completeAsyncTask");
    }
    if (task2.suspend === true) {
      if (this._suspenderTask !== task2) {
        if (this._tracer.enabled) {
          this._tracer.leave(this, "completeAsyncTask error");
        }
        throw createError$2(`Async task completion mismatch: suspenderTask=${this._suspenderTask?.id}, task=${task2.id}`);
      }
      this._suspenderTask = void 0;
    } else {
      --this._pendingAsyncCount;
    }
    if (this._yieldPromise !== void 0 && this._hasNoMoreFiniteWork) {
      const p2 = this._yieldPromise;
      this._yieldPromise = void 0;
      p2.resolve();
    }
    if (this.isEmpty) {
      this.cancel();
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "completeAsyncTask");
    }
  }
}
class TaskAbortError extends Error {
  constructor(task2) {
    super("Task was canceled.");
    this.task = task2;
  }
}
let id = 0;
class Task {
  get result() {
    const result = this._result;
    if (result === void 0) {
      switch (this._status) {
        case tsPending$1: {
          const promise = this._result = createExposedPromise();
          this._resolve = promise.resolve;
          this._reject = promise.reject;
          return promise;
        }
        case tsRunning$1:
          throw createError$2("Trying to await task from within task will cause a deadlock.");
        case tsCompleted:
          return this._result = Promise.resolve();
        case tsCanceled:
          return this._result = Promise.reject(new TaskAbortError(this));
      }
    }
    return result;
  }
  get status() {
    return this._status;
  }
  constructor(tracer, taskQueue, createdTime, queueTime, preempt, persistent, suspend, callback) {
    this.taskQueue = taskQueue;
    this.createdTime = createdTime;
    this.queueTime = queueTime;
    this.preempt = preempt;
    this.persistent = persistent;
    this.suspend = suspend;
    this.callback = callback;
    this.id = ++id;
    this._resolve = void 0;
    this._reject = void 0;
    this._result = void 0;
    this._status = tsPending$1;
    this._tracer = tracer;
  }
  run(time = this.taskQueue.platform.performanceNow()) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "run");
    }
    if (this._status !== tsPending$1) {
      if (this._tracer.enabled) {
        this._tracer.leave(this, "run error");
      }
      throw createError$2(`Cannot run task in ${this._status} state`);
    }
    const { persistent, taskQueue, callback, _resolve: resolve2, _reject: reject, createdTime } = this;
    let ret;
    this._status = tsRunning$1;
    try {
      ret = callback(time - createdTime);
      if (ret instanceof Promise) {
        ret.then(($ret) => {
          if (this.persistent) {
            taskQueue._resetPersistentTask(this);
          } else {
            if (persistent) {
              this._status = tsCanceled;
            } else {
              this._status = tsCompleted;
            }
            this.dispose();
          }
          taskQueue._completeAsyncTask(this);
          if (this._tracer.enabled) {
            this._tracer.leave(this, "run async then");
          }
          if (resolve2 !== void 0) {
            resolve2($ret);
          }
        }).catch((err) => {
          if (!this.persistent) {
            this.dispose();
          }
          taskQueue._completeAsyncTask(this);
          if (this._tracer.enabled) {
            this._tracer.leave(this, "run async catch");
          }
          if (reject !== void 0) {
            reject(err);
          } else {
            throw err;
          }
        });
      } else {
        if (this.persistent) {
          taskQueue._resetPersistentTask(this);
        } else {
          if (persistent) {
            this._status = tsCanceled;
          } else {
            this._status = tsCompleted;
          }
          this.dispose();
        }
        if (this._tracer.enabled) {
          this._tracer.leave(this, "run sync success");
        }
        if (resolve2 !== void 0) {
          resolve2(ret);
        }
      }
    } catch (err) {
      if (!this.persistent) {
        this.dispose();
      }
      if (this._tracer.enabled) {
        this._tracer.leave(this, "run sync error");
      }
      if (reject !== void 0) {
        reject(err);
      } else {
        throw err;
      }
    }
  }
  cancel() {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "cancel");
    }
    if (this._status === tsPending$1) {
      const taskQueue = this.taskQueue;
      const reject = this._reject;
      taskQueue.remove(this);
      if (taskQueue.isEmpty) {
        taskQueue.cancel();
      }
      this._status = tsCanceled;
      this.dispose();
      if (reject !== void 0) {
        reject(new TaskAbortError(this));
      }
      if (this._tracer.enabled) {
        this._tracer.leave(this, "cancel true =pending");
      }
      return true;
    } else if (this._status === tsRunning$1 && this.persistent) {
      this.persistent = false;
      if (this._tracer.enabled) {
        this._tracer.leave(this, "cancel true =running+persistent");
      }
      return true;
    }
    if (this._tracer.enabled) {
      this._tracer.leave(this, "cancel false");
    }
    return false;
  }
  reset(time) {
    if (this._tracer.enabled) {
      this._tracer.enter(this, "reset");
    }
    const delay = this.queueTime - this.createdTime;
    this.createdTime = time;
    this.queueTime = time + delay;
    this._status = tsPending$1;
    this._resolve = void 0;
    this._reject = void 0;
    this._result = void 0;
    if (this._tracer.enabled) {
      this._tracer.leave(this, "reset");
    }
  }
  dispose() {
    if (this._tracer.enabled) {
      this._tracer.trace(this, "dispose");
    }
    this.callback = void 0;
    this._resolve = void 0;
    this._reject = void 0;
    this._result = void 0;
  }
}
class Tracer {
  constructor(console2) {
    this.console = console2;
    this.enabled = false;
    this.depth = 0;
  }
  enter(obj, method) {
    this.log(`${"  ".repeat(this.depth++)}> `, obj, method);
  }
  leave(obj, method) {
    this.log(`${"  ".repeat(--this.depth)}< `, obj, method);
  }
  trace(obj, method) {
    this.log(`${"  ".repeat(this.depth)}- `, obj, method);
  }
  log(prefix, obj, method) {
    if (obj instanceof TaskQueue) {
      const processing = obj._processing.length;
      const pending = obj._pending.length;
      const delayed = obj._delayed.length;
      const flushReq = obj._flushRequested;
      const susTask = !!obj._suspenderTask;
      const info2 = `processing=${processing} pending=${pending} delayed=${delayed} flushReq=${flushReq} susTask=${susTask}`;
      this.console.log(`${prefix}[Q.${method}] ${info2}`);
    } else {
      const id2 = obj["id"];
      const created = Math.round(obj["createdTime"] * 10) / 10;
      const queue = Math.round(obj["queueTime"] * 10) / 10;
      const preempt = obj["preempt"];
      const persistent = obj["persistent"];
      const suspend = obj["suspend"];
      const status = obj["_status"];
      const info2 = `id=${id2} created=${created} queue=${queue} preempt=${preempt} persistent=${persistent} status=${status} suspend=${suspend}`;
      this.console.log(`${prefix}[T.${method}] ${info2}`);
    }
  }
}
const defaultQueueTaskOptions = {
  delay: 0,
  preempt: false,
  persistent: false,
  suspend: false
};
let $resolve;
let $reject;
const executor = (resolve2, reject) => {
  $resolve = resolve2;
  $reject = reject;
};
const createExposedPromise = () => {
  const p2 = new Promise(executor);
  p2.resolve = $resolve;
  p2.reject = $reject;
  return p2;
};
const isPersistent = (task2) => task2.persistent;
const preemptDelayComboError = () => createError$2(`AUR1006: Invalid arguments: preempt cannot be combined with a greater-than-zero delay`);
const preemptyPersistentComboError = () => createError$2(`AUR1007: Invalid arguments: preempt cannot be combined with persistent`);
const createError$2 = (msg) => new Error(msg);
class BrowserPlatform extends Platform {
  static getOrCreate(g2, overrides = {}) {
    let platform = BrowserPlatform._lookup.get(g2);
    if (platform === void 0) {
      BrowserPlatform._lookup.set(g2, platform = new BrowserPlatform(g2, overrides));
    }
    return platform;
  }
  static set(g2, platform) {
    BrowserPlatform._lookup.set(g2, platform);
  }
  /**
   * @deprecated Use `platform.domQueue` instead.
   */
  get domWriteQueue() {
    {
      this.console.log("[DEV:aurelia] platform.domQueue is deprecated, please use platform.domQueue instead.");
    }
    return this.domQueue;
  }
  /**
   * @deprecated Use `platform.domQueue` instead.
   */
  get domReadQueue() {
    {
      this.console.log("[DEV:aurelia] platform.domReadQueue has been removed, please use platform.domQueue instead.");
    }
    return this.domQueue;
  }
  constructor(g2, overrides = {}) {
    super(g2, overrides);
    const notImplemented2 = (name2) => () => {
      throw new Error(`The PLATFORM did not receive a valid reference to the global function '${name2}'.`);
    };
    "Node Element HTMLElement CustomEvent CSSStyleSheet ShadowRoot MutationObserver window document customElements".split(" ").forEach((prop) => this[prop] = prop in overrides ? overrides[prop] : g2[prop]);
    "fetch requestAnimationFrame cancelAnimationFrame".split(" ").forEach((prop) => (
      // eslint-disable-next-line
      this[prop] = prop in overrides ? overrides[prop] : g2[prop]?.bind(g2) ?? notImplemented2(prop)
    ));
    this.domQueue = (() => {
      let domRequested = false;
      let domHandle = -1;
      const requestDomFlush = () => {
        domRequested = true;
        if (domHandle === -1) {
          domHandle = this.requestAnimationFrame(flushDomQueue);
        }
      };
      const cancelDomFlush = () => {
        domRequested = false;
        if (domHandle > -1) {
          this.cancelAnimationFrame(domHandle);
          domHandle = -1;
        }
      };
      const flushDomQueue = () => {
        domHandle = -1;
        if (domRequested === true) {
          domRequested = false;
          domQueue.flush();
        }
      };
      const domQueue = new TaskQueue(this, requestDomFlush, cancelDomFlush);
      return domQueue;
    })();
  }
}
BrowserPlatform._lookup = /* @__PURE__ */ new WeakMap();
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
const { default: defaultMode, oneTime, toView, fromView, twoWay } = BindingMode;
const getMetadata = Metadata.get;
const hasMetadata = Metadata.has;
const defineMetadata = Metadata.define;
const { annotation } = Protocol;
const getAnnotationKeyFor = annotation.keyFor;
const O$1 = Object;
const safeString = String;
const baseObjectPrototype = O$1.prototype;
const hasOwnProperty = baseObjectPrototype.hasOwnProperty;
const objectFreeze = O$1.freeze;
const objectAssign = O$1.assign;
const getOwnPropertyNames = O$1.getOwnPropertyNames;
const objectKeys = O$1.keys;
const IsDataAttribute = /* @__PURE__ */ createLookup$1();
const isDataAttribute = (obj, key, svgAnalyzer) => {
  if (IsDataAttribute[key] === true) {
    return true;
  }
  if (!isString(key)) {
    return false;
  }
  const prefix = key.slice(0, 5);
  return IsDataAttribute[key] = prefix === "aria-" || prefix === "data-" || svgAnalyzer.isStandardSvgAttribute(obj, key);
};
const rethrow = (err) => {
  throw err;
};
const def = Reflect.defineProperty;
const defineHiddenProp = (obj, key, value) => {
  def(obj, key, {
    enumerable: false,
    configurable: true,
    writable: true,
    value
  });
  return value;
};
const addSignalListener = (signaler, signal, listener) => signaler.addSignalListener(signal, listener);
const removeSignalListener = (signaler, signal, listener) => signaler.removeSignalListener(signal, listener);
const etInterpolation = "Interpolation";
const etIsIterator = "IsIterator";
const etIsFunction = "IsFunction";
const etIsProperty = "IsProperty";
const tsPending = "pending";
const tsRunning = "running";
const atObserver = AccessorType.Observer;
const atNode = AccessorType.Node;
const atLayout = AccessorType.Layout;
const createMappedError$2 = (code, ...details) => new Error(`AUR${safeString(code).padStart(4, "0")}: ${getMessageByCode(code, ...details)}`);
const errorsMap = {
  [
    99
    /* ErrorNames.method_not_implemented */
  ]: "Method {{0}} not implemented",
  [
    101
    /* ErrorNames.ast_behavior_not_found */
  ]: `Ast eval error: binding behavior "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    102
    /* ErrorNames.ast_behavior_duplicated */
  ]: `Ast eval error: binding behavior "{{0}}" already applied.`,
  [
    103
    /* ErrorNames.ast_converter_not_found */
  ]: `Ast eval error: value converter "{{0}}" could not be found. Did you forget to register it as a dependency?`,
  [
    105
    /* ErrorNames.ast_$host_not_found */
  ]: `Ast eval error: unable to find $host context. Did you forget [au-slot] attribute?`,
  [
    106
    /* ErrorNames.ast_no_assign_$host */
  ]: `Ast eval error: invalid assignment. "$host" is a reserved keyword.`,
  [
    107
    /* ErrorNames.ast_not_a_function */
  ]: `Ast eval error: expression is not a function.`,
  [
    109
    /* ErrorNames.ast_unknown_unary_operator */
  ]: `Ast eval error: unknown unary operator: "{{0}}"`,
  [
    108
    /* ErrorNames.ast_unknown_binary_operator */
  ]: `Ast eval error: unknown binary operator: "{{0}}"`,
  [
    110
    /* ErrorNames.ast_tagged_not_a_function */
  ]: `Ast eval error: left-hand side of tagged template expression is not a function.`,
  [
    111
    /* ErrorNames.ast_name_is_not_a_function */
  ]: `Ast eval error: expected "{{0}}" to be a function`,
  [
    112
    /* ErrorNames.ast_destruct_null */
  ]: `Ast eval error: cannot use non-object value for destructuring assignment.`,
  [
    113
    /* ErrorNames.ast_increment_infinite_loop */
  ]: `Ast eval error: infinite loop detected. Increment operators should only be used in event handlers.`,
  [
    114
    /* ErrorNames.ast_nullish_member_access */
  ]: `Ast eval error: cannot access property "{{0}}" of {{1}}.`,
  [
    115
    /* ErrorNames.ast_nullish_keyed_access */
  ]: `Ast eval error: cannot access key "{{0}}" of {{1}}.`,
  [
    116
    /* ErrorNames.ast_nullish_assignment */
  ]: `Ast eval error: cannot assign value to property "{{0}}" of null/undefined.`,
  [
    151
    /* ErrorNames.binding_behavior_def_not_found */
  ]: `No binding behavior definition found for type {{0:name}}`,
  [
    152
    /* ErrorNames.value_converter_def_not_found */
  ]: `No value converter definition found for type {{0:name}}`,
  [
    153
    /* ErrorNames.element_existed */
  ]: `Element "{{0}}" has already been registered.`,
  [
    154
    /* ErrorNames.attribute_existed */
  ]: `Attribute "{{0}}" has already been registered.`,
  [
    155
    /* ErrorNames.value_converter_existed */
  ]: `Value converter {{0}} has already been registered.`,
  [
    156
    /* ErrorNames.binding_behavior_existed */
  ]: `Binding behavior {{0}} has already been registered.`,
  [
    157
    /* ErrorNames.binding_command_existed */
  ]: `Binding command {{0}} has already been registered.`,
  [
    203
    /* ErrorNames.null_scope */
  ]: `Trying to retrieve a property or build a scope from a null/undefined scope`,
  [
    204
    /* ErrorNames.create_scope_with_null_context */
  ]: "Trying to create a scope with null/undefined binding context",
  [
    227
    /* ErrorNames.invalid_bindable_decorator_usage_symbol */
  ]: `@bindable is not supported for properties that uses a symbol for name. Use a string for the property name instead.`,
  [
    228
    /* ErrorNames.invalid_bindable_decorator_usage_class_without_configuration */
  ]: `@bindable cannot be used as a class decorator when no configuration object is supplied.`,
  [
    229
    /* ErrorNames.invalid_bindable_decorator_usage_class_without_property_name_configuration */
  ]: `@bindable cannot be used as a class decorator when no property name is supplied in the configuration object.`,
  [
    500
    /* ErrorNames.controller_cached_not_found */
  ]: `There is no cached controller for the provided ViewModel: {{0}}`,
  [
    501
    /* ErrorNames.controller_no_shadow_on_containerless */
  ]: `Invalid combination: cannot combine the containerless custom element option with Shadow DOM.`,
  [
    502
    /* ErrorNames.controller_activating_disposed */
  ]: `Trying to activate a disposed controller: {{0}}.`,
  [
    503
    /* ErrorNames.controller_activation_unexpected_state */
  ]: `Controller at {{0}} is in an unexpected state: {{1}} during activation.`,
  [
    504
    /* ErrorNames.controller_activation_synthetic_no_scope */
  ]: `Synthetic view at {{0}} is being activated with null/undefined scope.`,
  [
    505
    /* ErrorNames.controller_deactivation_unexpected_state */
  ]: `Controller at {{0}} is in an unexpected state: {{1}} during deactivation.`,
  [
    506
    /* ErrorNames.controller_watch_invalid_callback */
  ]: `Invalid callback for @watch decorator: {{0}}`,
  [
    507
    /* ErrorNames.controller_property_not_coercible */
  ]: `Observer for bindable property {{0}} does not support coercion.`,
  [
    508
    /* ErrorNames.controller_property_no_change_handler */
  ]: `Observer for property {{0}} does not support change handler.`,
  [
    759
    /* ErrorNames.attribute_def_not_found */
  ]: `No attribute definition found for type {{0:name}}`,
  [
    760
    /* ErrorNames.element_def_not_found */
  ]: `No element definition found for type {{0:name}}`,
  [
    761
    /* ErrorNames.element_only_name */
  ]: `Cannot create a custom element definition with only a name and no type: {{0}}`,
  [
    762
    /* ErrorNames.node_is_not_a_host */
  ]: `Trying to retrieve a custom element controller from a node, but the provided node <{{0:nodeName}} /> is not a custom element or containerless host.`,
  [
    763
    /* ErrorNames.node_is_not_a_host2 */
  ]: `Trying to retrieve a custom element controller from a node, but the provided node <{{0:nodeName}} /> is not a custom element or containerless host.`,
  [
    764
    /* ErrorNames.node_is_not_part_of_aurelia_app */
  ]: `Trying to retrieve a custom element controller from a node. But the provided node <{{0:nodeName}} /> does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`,
  [
    765
    /* ErrorNames.node_is_not_part_of_aurelia_app2 */
  ]: `Trying to retrieve a custom element controller from a node. But the provided node <{{0:nodeName}} /> does not appear to be part of an Aurelia app DOM tree, or it was added to the DOM in a way that Aurelia cannot properly resolve its position in the component tree.`,
  [
    766
    /* ErrorNames.invalid_process_content_hook */
  ]: `Invalid @processContent hook. Expected the hook to be a function (when defined in a class, it needs to be a static function) but got a {{0:typeof}}.`,
  [
    652
    /* ErrorNames.node_observer_strategy_not_found */
  ]: `Aurelia is unable to observe property {{0}}. Register observation mapping with .useConfig().`,
  [
    653
    /* ErrorNames.node_observer_mapping_existed */
  ]: `Mapping for property {{0}} of <{{1}} /> already exists`,
  [
    654
    /* ErrorNames.select_observer_array_on_non_multi_select */
  ]: `Array values can only be bound to a multi-select.`,
  [
    714
    /* ErrorNames.compiler_primary_already_existed */
  ]: `Template compilation error: primary already exists on element/attribute "{{0}}"`,
  [
    719
    /* ErrorNames.compiler_attr_mapper_duplicate_mapping */
  ]: `Attribute {{0}} has been already registered for {{1:element}}`,
  [
    767
    /* ErrorNames.root_not_found */
  ]: `Aurelia.root was accessed without a valid root.`,
  [
    768
    /* ErrorNames.aurelia_instance_existed_in_container */
  ]: `An instance of Aurelia is already registered with the container or an ancestor of it.`,
  [
    769
    /* ErrorNames.invalid_platform_impl */
  ]: `Failed to initialize the platform object. The host element's ownerDocument does not have a defaultView, did you create the host from a DOMParser and forget to call adoptNode()?`,
  [
    770
    /* ErrorNames.no_composition_root */
  ]: `Aurelia.start() was called without a composition root`,
  [
    771
    /* ErrorNames.invalid_dispose_call */
  ]: `The aurelia instance must be fully stopped before it can be disposed`,
  [
    750
    /* ErrorNames.not_supported_view_ref_api */
  ]: `view.ref is not supported. If you are migrating from v1, this can be understood as the controller.`,
  [
    751
    /* ErrorNames.ref_not_found */
  ]: `Attempted to reference "{{0}}", but it was not found amongst the target's API.`,
  [
    752
    /* ErrorNames.element_res_not_found */
  ]: `Element {{0:.res}} is not registered in {{1:name}}.`,
  [
    753
    /* ErrorNames.attribute_res_not_found */
  ]: `Attribute {{0:.res}} is not registered in {{1:name}}.`,
  [
    754
    /* ErrorNames.attribute_tc_res_not_found */
  ]: `Attribute {{0:.res}} is not registered in {{1:name}}.`,
  [
    755
    /* ErrorNames.view_factory_provider_not_ready */
  ]: `Cannot resolve ViewFactory before the provider was prepared.`,
  [
    756
    /* ErrorNames.view_factory_invalid_name */
  ]: `Cannot resolve ViewFactory without a (valid) name.`,
  [
    757
    /* ErrorNames.rendering_mismatch_length */
  ]: `AUR0757: The compiled template is not aligned with the render instructions. There are {{0}} targets and {{1}} instructions.`,
  [
    772
    /* ErrorNames.watch_null_config */
  ]: `Invalid @watch decorator config. Expected an expression or a fn but received null/undefined.`,
  [
    773
    /* ErrorNames.watch_invalid_change_handler */
  ]: `Invalid @watch decorator change handler config.Method "{{0}}" not found in class {{1}}`,
  [
    774
    /* ErrorNames.watch_non_method_decorator_usage */
  ]: `Invalid @watch decorator usage: decorated target {{0}} is not a class method.`,
  [
    775
    /* ErrorNames.repeat_invalid_key_binding_command */
  ]: `Invalid command "{{0}}" usage with [repeat]`,
  [
    776
    /* ErrorNames.repeat_extraneous_binding */
  ]: `Invalid [repeat] usage, found extraneous target "{{0}}"`,
  [
    777
    /* ErrorNames.repeat_non_iterable */
  ]: `Unsupported: [repeat] cannot iterate over {{0:toString}}`,
  [
    778
    /* ErrorNames.repeat_non_countable */
  ]: `Unsupported: [repeat] cannot count {{0:toString}}`,
  [
    814
    /* ErrorNames.repeat_mismatch_length */
  ]: `[repeat] encountered an error: number of views != number of items {{0:join(!=)}}`,
  [
    779
    /* ErrorNames.portal_invalid_insert_position */
  ]: "Invalid portal insertion position: {{0}}",
  [
    801
    /* ErrorNames.self_behavior_invalid_usage */
  ]: `"& self" binding behavior only supports listener binding via trigger/capture command.`,
  [
    802
    /* ErrorNames.update_trigger_behavior_no_triggers */
  ]: `"& updateTrigger" invalid usage. This binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:'blur'">`,
  [
    803
    /* ErrorNames.update_trigger_invalid_usage */
  ]: `"& updateTrigger" invalid usage. This binding behavior can only be applied to two-way/ from-view bindings.`,
  [
    805
    /* ErrorNames.au_compose_invalid_scope_behavior */
  ]: `Invalid scope behavior "{{0}}" on <au-compose />. Only "scoped" or "auto" allowed.`,
  // originally not supported
  [
    806
    /* ErrorNames.au_compose_component_name_not_found */
  ]: `<au-compose /> couldn't find a custom element with name "{{0}}", did you forget to register it locally or globally?`,
  [
    807
    /* ErrorNames.au_compose_invalid_run */
  ]: `Composition has already been activated/deactivated. Id: {{0:controller}}`,
  [
    808
    /* ErrorNames.au_compose_duplicate_deactivate */
  ]: `Composition has already been deactivated.`,
  [
    810
    /* ErrorNames.else_without_if */
  ]: `Invalid [else] usage, it should follow an [if]`,
  [
    811
    /* ErrorNames.portal_query_empty */
  ]: `Invalid portal strict target query, empty query.`,
  [
    812
    /* ErrorNames.portal_no_target */
  ]: `Invalid portal strict target resolution, target not found.`,
  [
    813
    /* ErrorNames.promise_invalid_usage */
  ]: `Invalid [pending]/[then]/[catch] usage. The parent [promise].resolve not found; only "*[promise.resolve] > *[pending|then|catch]" relation is supported.`,
  [
    815
    /* ErrorNames.switch_invalid_usage */
  ]: `Invalid [case/default-case] usage. The parent [switch] not found; only "*[switch] > *[case|default-case]" relation is supported.`,
  [
    816
    /* ErrorNames.switch_no_multiple_default */
  ]: `Invalid [default-case] usage. Multiple 'default-case's are not allowed.`,
  [
    817
    /* ErrorNames.signal_behavior_invalid_usage */
  ]: `"& signal" binding behavior can only be used with bindings that have a "handleChange" method`,
  [
    818
    /* ErrorNames.signal_behavior_no_signals */
  ]: `"& signal" invalid usage. At least one signal name must be passed to the signal behavior, e.g. "expr & signal:'my-signal'"`,
  [
    819
    /* ErrorNames.spreading_bindable_onto_non_component */
  ]: "Spreading to bindables onto non custom element",
  [
    820
    /* ErrorNames.spreading_invalid_target */
  ]: `Invalid spread target {{0}}`,
  [
    9999
    /* ErrorNames.no_spread_scope_context_found */
  ]: "No scope context for spread binding.",
  [
    9998
    /* ErrorNames.no_spread_template_controller */
  ]: "Spread binding does not support spreading custom attributes/template controllers. Did you build the spread instruction manually?",
  [
    9997
    /* ErrorNames.marker_malformed */
  ]: `Marker is malformed. This likely happens when a compiled template has been modified. Did you accidentally modified some compiled template? You can modify template before compilation with compiling Template compiler hook.`,
  [
    9996
    /* ErrorNames.binding_already_has_rate_limited */
  ]: `Invalid usage, a rate limit has already been applied. Did you have both throttle and debounce on the same binding?`,
  [
    9995
    /* ErrorNames.binding_already_has_target_subscriber */
  ]: `The binding already has a target subscriber.`,
  [
    9994
    /* ErrorNames.attr_behavior_invalid_binding */
  ]: `"& attr" can be only used on property binding. It's used on {{0:ctor}}`,
  [
    9993
    /* ErrorNames.update_trigger_behavior_not_supported */
  ]: '"& updateTrigger" binding behavior only works with the default implementation of Aurelia HTML observation. Implement your own node observation + updateTrigger',
  [
    9992
    /* ErrorNames.update_trigger_behavior_node_property_not_observable */
  ]: `"& updateTrigger" uses node observer to observe, but it does not know how to use events to observe property <{{0:target@property}} />`,
  [
    9991
    /* ErrorNames.children_decorator_invalid_usage */
  ]: `Invalid @children usage. @children decorator can only be used on a field`,
  [
    9990
    /* ErrorNames.slotted_decorator_invalid_usage */
  ]: `Invalid @slotted usage. @slotted decorator can only be used on a field`,
  [
    9989
    /* ErrorNames.children_invalid_query */
  ]: `Invalid query selector. Only selectors with alpha-numeric characters, or $all are allowed. Got {{0}} instead.`
};
const getMessageByCode = (name2, ...details) => {
  let cooked = errorsMap[name2];
  for (let i3 = 0; i3 < details.length; ++i3) {
    const regex = new RegExp(`{{${i3}(:.*)?}}`, "g");
    let matches2 = regex.exec(cooked);
    while (matches2 != null) {
      const method = matches2[1]?.slice(1);
      let value = details[i3];
      if (value != null) {
        switch (method) {
          case "nodeName":
            value = value.nodeName.toLowerCase();
            break;
          case "name":
            value = value.name;
            break;
          case "typeof":
            value = typeof value;
            break;
          case "ctor":
            value = value.constructor.name;
            break;
          case "controller":
            value = value.controller.name;
            break;
          case "target@property":
            value = `${value.target}@${value.targetProperty}`;
            break;
          case "toString":
            value = Object.prototype.toString.call(value);
            break;
          case "join(!=)":
            value = value.join("!=");
            break;
          case "bindingCommandHelp":
            value = getBindingCommandHelp(value);
            break;
          case "element":
            value = value === "*" ? "all elements" : `<${value} />`;
            break;
          default: {
            if (method?.startsWith(".")) {
              value = safeString(value[method.slice(1)]);
            } else {
              value = safeString(value);
            }
          }
        }
      }
      cooked = cooked.slice(0, matches2.index) + value + cooked.slice(regex.lastIndex);
      matches2 = regex.exec(cooked);
    }
  }
  return cooked;
};
function getBindingCommandHelp(name2) {
  switch (name2) {
    case "delegate":
      return `
The ".delegate" binding command has been removed in v2. Binding command ".trigger" should be used instead. If you are migrating v1 application, install compat package to add back the ".delegate" binding command for ease of migration.`;
    case "call":
      return `
The ".call" binding command has been removed in v2. If you want to pass a callback that preserves the context of the function call, you can use lambda instead. Refer to lambda expression doc for more details.`;
    default:
      return "";
  }
}
function bindable(configOrPropOrTarget, context) {
  let configOrProp = void 0;
  function decorator(_target, context2) {
    let $prop;
    switch (context2.kind) {
      case "getter":
      case "field": {
        const prop = context2.name;
        if (typeof prop !== "string")
          throw createMappedError$2(
            227
            /* ErrorNames.invalid_bindable_decorator_usage_symbol */
          );
        $prop = prop;
        break;
      }
      case "class":
        if (configOrProp == null)
          throw createMappedError$2(
            228
            /* ErrorNames.invalid_bindable_decorator_usage_class_without_configuration */
          );
        if (typeof configOrProp == "string") {
          $prop = configOrProp;
        } else {
          const prop = configOrProp.name;
          if (!prop)
            throw createMappedError$2(
              229
              /* ErrorNames.invalid_bindable_decorator_usage_class_without_property_name_configuration */
            );
          if (typeof prop !== "string")
            throw createMappedError$2(
              227
              /* ErrorNames.invalid_bindable_decorator_usage_symbol */
            );
          $prop = prop;
        }
        break;
    }
    const config = configOrProp == null || typeof configOrProp === "string" ? { name: $prop } : configOrProp;
    const metadata = context2.metadata[baseName] ??= createLookup$1();
    metadata[$prop] = BindableDefinition.create($prop, config);
  }
  if (arguments.length > 1) {
    configOrProp = {};
    decorator(configOrPropOrTarget, context);
    return;
  } else if (isString(configOrPropOrTarget)) {
    configOrProp = configOrPropOrTarget;
    return decorator;
  }
  configOrProp = configOrPropOrTarget === void 0 ? {} : configOrPropOrTarget;
  return decorator;
}
const baseName = /* @__PURE__ */ getAnnotationKeyFor("bindables");
const Bindable = objectFreeze({
  name: baseName,
  keyFrom: (name2) => `${baseName}:${name2}`,
  from(...bindableLists) {
    const bindables2 = {};
    const isArray2 = Array.isArray;
    function addName(name2) {
      bindables2[name2] = BindableDefinition.create(name2);
    }
    function addDescription(name2, def2) {
      bindables2[name2] = def2 instanceof BindableDefinition ? def2 : BindableDefinition.create(name2, def2 === true ? {} : def2);
    }
    function addList(maybeList) {
      if (isArray2(maybeList)) {
        maybeList.forEach((nameOrDef) => isString(nameOrDef) ? addName(nameOrDef) : addDescription(nameOrDef.name, nameOrDef));
      } else if (maybeList instanceof BindableDefinition) {
        bindables2[maybeList.name] = maybeList;
      } else if (maybeList !== void 0) {
        objectKeys(maybeList).forEach((name2) => addDescription(name2, maybeList[name2]));
      }
    }
    bindableLists.forEach(addList);
    return bindables2;
  },
  getAll(Type) {
    const defs = [];
    const prototypeChain = getPrototypeChain(Type);
    let iProto = prototypeChain.length;
    let Class;
    while (--iProto >= 0) {
      Class = prototypeChain[iProto];
      const bindableMetadata = getMetadata(baseName, Class);
      if (bindableMetadata == null)
        continue;
      defs.push(...Object.values(bindableMetadata));
    }
    return defs;
  },
  /** @internal */
  _add(bindable2, Type) {
    let bindables2 = getMetadata(baseName, Type);
    if (bindables2 == null) {
      defineMetadata(bindables2 = createLookup$1(), Type, baseName);
    }
    bindables2[bindable2.name] = bindable2;
  }
});
class BindableDefinition {
  constructor(attribute, callback, mode, primary, name2, set) {
    this.attribute = attribute;
    this.callback = callback;
    this.mode = mode;
    this.primary = primary;
    this.name = name2;
    this.set = set;
  }
  static create(prop, def2 = {}) {
    const mode = def2.mode ?? toView;
    return new BindableDefinition(def2.attribute ?? kebabCase(prop), def2.callback ?? `${prop}Changed`, isString(mode) ? BindingMode[mode] ?? defaultMode : mode, def2.primary ?? false, def2.name ?? prop, def2.set ?? getInterceptor(def2));
  }
}
const Coercer = {
  key: /* @__PURE__ */ getAnnotationKeyFor("coercer"),
  define(target, property) {
    defineMetadata(target[property].bind(target), target, Coercer.key);
  },
  for(target) {
    return getMetadata(Coercer.key, target);
  }
};
function getInterceptor(def2 = {}) {
  const type = def2.type ?? null;
  if (type == null) {
    return noop$1;
  }
  let coercer;
  switch (type) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
      coercer = type;
      break;
    default: {
      const $coercer = type.coerce;
      coercer = typeof $coercer === "function" ? $coercer.bind(type) : Coercer.for(type) ?? noop$1;
      break;
    }
  }
  return coercer === noop$1 ? coercer : createCoercer(coercer, def2.nullable);
}
function createCoercer(coercer, nullable) {
  return function(value, coercionConfiguration) {
    if (!coercionConfiguration?.enableCoercion)
      return value;
    return (nullable ?? (coercionConfiguration?.coerceNullish ?? false ? false : true)) && value == null ? value : coercer(value, coercionConfiguration);
  };
}
const createInterface = DI.createInterface;
const singletonRegistration = Registration.singleton;
const aliasRegistration = Registration.aliasTo;
const instanceRegistration = Registration.instance;
const registerResolver = (ctn, key, resolver) => ctn.registerResolver(key, resolver);
const dtElement = "custom-element";
const dtAttribute = "custom-attribute";
const getDefinitionFromStaticAu = (Type, typeName, createDef, metadataKey = "__au_static_resource__") => {
  let def2 = getMetadata(metadataKey, Type);
  if (def2 == null) {
    if (Type.$au?.type === typeName) {
      def2 = createDef(Type.$au, Type);
      defineMetadata(def2, Type, metadataKey);
    }
  }
  return def2;
};
class BindingBehaviorDefinition {
  constructor(Type, name2, aliases, key) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    return new BindingBehaviorDefinition(Type, firstDefined(getBehaviorAnnotation(Type, "name"), name2), mergeArrays(getBehaviorAnnotation(Type, "aliases"), def2.aliases, Type.aliases), BindingBehavior.keyFrom(name2));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getBindingBehaviorKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getBindingBehaviorKeyFrom(alias))));
    } else {
      console.warn(`[DEV:aurelia] ${createMappedError$2(156, this.name)}`);
    }
  }
}
const behaviorTypeName = "binding-behavior";
const bbBaseName = /* @__PURE__ */ getResourceKeyFor(behaviorTypeName);
const getBehaviorAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const getBindingBehaviorKeyFrom = (name2) => `${bbBaseName}:${name2}`;
const BindingBehavior = /* @__PURE__ */ objectFreeze({
  name: bbBaseName,
  keyFrom: getBindingBehaviorKeyFrom,
  isType(value) {
    return isFunction(value) && (hasMetadata(bbBaseName, value) || value.$au?.type === behaviorTypeName);
  },
  define(nameOrDef, Type) {
    const definition = BindingBehaviorDefinition.create(nameOrDef, Type);
    const $Type = definition.Type;
    defineMetadata(definition, $Type, bbBaseName, resourceBaseName);
    return $Type;
  },
  getDefinition(Type) {
    const def2 = getMetadata(bbBaseName, Type) ?? getDefinitionFromStaticAu(Type, behaviorTypeName, BindingBehaviorDefinition.create);
    if (def2 === void 0) {
      throw createMappedError$2(151, Type);
    }
    return def2;
  },
  find(container, name2) {
    const Type = container.find(behaviorTypeName, name2);
    return Type == null ? null : getMetadata(bbBaseName, Type) ?? getDefinitionFromStaticAu(Type, behaviorTypeName, BindingBehaviorDefinition.create) ?? null;
  },
  get(container, name2) {
    {
      try {
        return container.get(resource(getBindingBehaviorKeyFrom(name2)));
      } catch (ex) {
        console.error("[DEV:aurelia] Cannot retrieve binding behavior with name", name2);
        throw ex;
      }
    }
    return container.get(resource(getBindingBehaviorKeyFrom(name2)));
  }
});
const originalModesMap = /* @__PURE__ */ new Map();
const createConfig = (name2) => ({ type: behaviorTypeName, name: name2 });
class BindingModeBehavior {
  bind(scope, binding) {
    originalModesMap.set(binding, binding.mode);
    binding.mode = this.mode;
  }
  unbind(scope, binding) {
    binding.mode = originalModesMap.get(binding);
    originalModesMap.delete(binding);
  }
}
class OneTimeBindingBehavior extends BindingModeBehavior {
  get mode() {
    return oneTime;
  }
}
OneTimeBindingBehavior.$au = createConfig("oneTime");
class ToViewBindingBehavior extends BindingModeBehavior {
  get mode() {
    return toView;
  }
}
ToViewBindingBehavior.$au = createConfig("toView");
class FromViewBindingBehavior extends BindingModeBehavior {
  get mode() {
    return fromView;
  }
}
FromViewBindingBehavior.$au = createConfig("fromView");
class TwoWayBindingBehavior extends BindingModeBehavior {
  get mode() {
    return twoWay;
  }
}
TwoWayBindingBehavior.$au = createConfig("twoWay");
const bindingHandlerMap$1 = /* @__PURE__ */ new WeakMap();
const defaultDelay$1 = 200;
class DebounceBindingBehavior {
  constructor() {
    this._platform = resolve(IPlatform$1);
  }
  bind(scope, binding, delay, signals) {
    const opts = {
      type: "debounce",
      delay: delay ?? defaultDelay$1,
      now: this._platform.performanceNow,
      queue: this._platform.taskQueue,
      signals: isString(signals) ? [signals] : signals ?? emptyArray
    };
    const handler = binding.limit?.(opts);
    if (handler == null) {
      {
        console.warn(`Binding ${binding.constructor.name} does not support debounce rate limiting`);
      }
    } else {
      bindingHandlerMap$1.set(binding, handler);
    }
  }
  unbind(scope, binding) {
    bindingHandlerMap$1.get(binding)?.dispose();
    bindingHandlerMap$1.delete(binding);
  }
}
DebounceBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "debounce"
};
const ISignaler = /* @__PURE__ */ createInterface("ISignaler", (x2) => x2.singleton(Signaler));
class Signaler {
  constructor() {
    this.signals = createLookup$1();
  }
  dispatchSignal(name2) {
    const listeners = this.signals[name2];
    if (listeners === void 0) {
      return;
    }
    let listener;
    for (listener of listeners.keys()) {
      listener.handleChange(void 0, void 0);
    }
  }
  addSignalListener(name2, listener) {
    (this.signals[name2] ??= /* @__PURE__ */ new Set()).add(listener);
  }
  removeSignalListener(name2, listener) {
    this.signals[name2]?.delete(listener);
  }
}
class SignalBindingBehavior {
  constructor() {
    this._lookup = /* @__PURE__ */ new Map();
    this._signaler = resolve(ISignaler);
  }
  bind(scope, binding, ...names) {
    if (!("handleChange" in binding)) {
      throw createMappedError$2(
        817
        /* ErrorNames.signal_behavior_invalid_usage */
      );
    }
    if (names.length === 0) {
      throw createMappedError$2(
        818
        /* ErrorNames.signal_behavior_no_signals */
      );
    }
    this._lookup.set(binding, names);
    let name2;
    for (name2 of names) {
      addSignalListener(this._signaler, name2, binding);
    }
  }
  unbind(scope, binding) {
    const names = this._lookup.get(binding);
    this._lookup.delete(binding);
    let name2;
    for (name2 of names) {
      removeSignalListener(this._signaler, name2, binding);
    }
  }
}
SignalBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "signal"
};
const bindingHandlerMap = /* @__PURE__ */ new WeakMap();
const defaultDelay = 200;
class ThrottleBindingBehavior {
  constructor() {
    ({ performanceNow: this._now, taskQueue: this._taskQueue } = resolve(IPlatform$1));
  }
  bind(scope, binding, delay, signals) {
    const opts = {
      type: "throttle",
      delay: delay ?? defaultDelay,
      now: this._now,
      queue: this._taskQueue,
      signals: isString(signals) ? [signals] : signals ?? emptyArray
    };
    const handler = binding.limit?.(opts);
    if (handler == null) {
      {
        console.warn(`Binding ${binding.constructor.name} does not support debounce rate limiting`);
      }
    } else {
      bindingHandlerMap.set(binding, handler);
    }
  }
  unbind(scope, binding) {
    bindingHandlerMap.get(binding)?.dispose();
    bindingHandlerMap.delete(binding);
  }
}
ThrottleBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "throttle"
};
const IAppTask = /* @__PURE__ */ createInterface("IAppTask");
class $AppTask {
  constructor(slot, key, cb) {
    this.c = void 0;
    this.slot = slot;
    this.k = key;
    this.cb = cb;
  }
  register(container) {
    return this.c = container.register(instanceRegistration(IAppTask, this));
  }
  run() {
    const key = this.k;
    const cb = this.cb;
    return key === null ? cb() : cb(this.c.get(key));
  }
}
const AppTask = objectFreeze({
  /**
   * Returns a task that will run just before the root component is created by DI
   */
  creating: createAppTaskSlotHook("creating"),
  /**
   * Returns a task that will run after instantiating the root controller,
   * but before compiling its view (thus means before instantiating the child elements inside it)
   *
   * good chance for a router to do some initial work, or initial routing related in general
   */
  hydrating: createAppTaskSlotHook("hydrating"),
  /**
   * Return a task that will run after the hydration of the root controller,
   * but before hydrating the child element inside
   *
   * good chance for a router to do some initial work, or initial routing related in general
   */
  hydrated: createAppTaskSlotHook("hydrated"),
  /**
   * Return a task that will run right before the root component is activated.
   * In this phase, scope hierarchy is formed, and bindings are getting bound
   */
  activating: createAppTaskSlotHook("activating"),
  /**
   * Return a task that will run right after the root component is activated - the app is now running
   */
  activated: createAppTaskSlotHook("activated"),
  /**
   * Return a task that will runs right before the root component is deactivated.
   * In this phase, scope hierarchy is unlinked, and bindings are getting unbound
   */
  deactivating: createAppTaskSlotHook("deactivating"),
  /**
   * Return a task that will run right after the root component is deactivated
   */
  deactivated: createAppTaskSlotHook("deactivated")
});
function createAppTaskSlotHook(slotName) {
  function appTaskFactory(keyOrCallback, callback) {
    if (isFunction(callback)) {
      return new $AppTask(slotName, keyOrCallback, callback);
    }
    return new $AppTask(slotName, null, keyOrCallback);
  }
  return appTaskFactory;
}
const IPlatform = IPlatform$1;
function watch(expressionOrPropertyAccessFn, changeHandlerOrCallback) {
  if (expressionOrPropertyAccessFn == null) {
    throw createMappedError$2(
      772
      /* ErrorNames.watch_null_config */
    );
  }
  return function decorator(target, context) {
    const isClassDecorator = context.kind === "class";
    if (isClassDecorator) {
      if (!isFunction(changeHandlerOrCallback) && changeHandlerOrCallback == null) {
        throw createMappedError$2(773, `${safeString(changeHandlerOrCallback)}@${target.name}}`);
      }
    } else if (!isFunction(target) || context.static) {
      throw createMappedError$2(774, context.name);
    }
    const watchDef = new WatchDefinition(expressionOrPropertyAccessFn, isClassDecorator ? changeHandlerOrCallback : target);
    if (isClassDecorator) {
      addDefinition(target);
    } else {
      let added = false;
      context.addInitializer(function() {
        if (!added) {
          added = true;
          addDefinition(this.constructor);
        }
      });
    }
    function addDefinition(type) {
      Watch.add(type, watchDef);
      if (isAttributeType(type)) {
        getAttributeDefinition(type).watches.push(watchDef);
      }
      if (isElementType(type)) {
        getElementDefinition(type).watches.push(watchDef);
      }
    }
  };
}
class WatchDefinition {
  constructor(expression, callback) {
    this.expression = expression;
    this.callback = callback;
  }
}
const Watch = /* @__PURE__ */ (() => {
  const watches = /* @__PURE__ */ new WeakMap();
  return objectFreeze({
    add(Type, definition) {
      let defs = watches.get(Type);
      if (defs == null) {
        watches.set(Type, defs = []);
      }
      defs.push(definition);
    },
    getDefinitions(Type) {
      return watches.get(Type) ?? emptyArray;
    }
  });
})();
function customAttribute(nameOrDef) {
  return function(target, context) {
    context.addInitializer(function() {
      defineAttribute(nameOrDef, this);
    });
    return target;
  };
}
class CustomAttributeDefinition {
  // a simple marker to distinguish between Custom Element definition & Custom attribute definition
  get type() {
    return dtAttribute;
  }
  constructor(Type, name2, aliases, key, defaultBindingMode, isTemplateController, bindables2, noMultiBindings, watches, dependencies2, containerStrategy) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
    this.defaultBindingMode = defaultBindingMode;
    this.isTemplateController = isTemplateController;
    this.bindables = bindables2;
    this.noMultiBindings = noMultiBindings;
    this.watches = watches;
    this.dependencies = dependencies2;
    this.containerStrategy = containerStrategy;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    const mode = firstDefined(getAttributeAnnotation(Type, "defaultBindingMode"), def2.defaultBindingMode, Type.defaultBindingMode, toView);
    for (const bindable2 of Object.values(Bindable.from(def2.bindables))) {
      Bindable._add(bindable2, Type);
    }
    return new CustomAttributeDefinition(Type, firstDefined(getAttributeAnnotation(Type, "name"), name2), mergeArrays(getAttributeAnnotation(Type, "aliases"), def2.aliases, Type.aliases), getAttributeKeyFrom(name2), isString(mode) ? BindingMode[mode] ?? defaultMode : mode, firstDefined(getAttributeAnnotation(Type, "isTemplateController"), def2.isTemplateController, Type.isTemplateController, false), Bindable.from(...Bindable.getAll(Type), getAttributeAnnotation(Type, "bindables"), Type.bindables, def2.bindables), firstDefined(getAttributeAnnotation(Type, "noMultiBindings"), def2.noMultiBindings, Type.noMultiBindings, false), mergeArrays(Watch.getDefinitions(Type), Type.watches), mergeArrays(getAttributeAnnotation(Type, "dependencies"), def2.dependencies, Type.dependencies), firstDefined(getAttributeAnnotation(Type, "containerStrategy"), def2.containerStrategy, Type.containerStrategy, "reuse"));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getAttributeKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getAttributeKeyFrom(alias))));
    } else {
      if (CustomAttributeDefinition.warnDuplicate) {
        container.get(ILogger).warn(createMappedError$2(154, this.name));
      }
      {
        console.warn(`[DEV:aurelia] ${createMappedError$2(154, this.name)}`);
      }
    }
  }
  toString() {
    return `au:ca:${this.name}`;
  }
}
CustomAttributeDefinition.warnDuplicate = true;
const attrTypeName = "custom-attribute";
const attributeBaseName = /* @__PURE__ */ getResourceKeyFor(attrTypeName);
const getAttributeKeyFrom = (name2) => `${attributeBaseName}:${name2}`;
const getAttributeAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const isAttributeType = (value) => {
  return isFunction(value) && (hasMetadata(attributeBaseName, value) || value.$au?.type === attrTypeName);
};
const findAttributeControllerFor = (node, name2) => {
  return getRef(node, getAttributeKeyFrom(name2)) ?? void 0;
};
const defineAttribute = (nameOrDef, Type) => {
  const definition = CustomAttributeDefinition.create(nameOrDef, Type);
  const $Type = definition.Type;
  defineMetadata(definition, $Type, attributeBaseName, resourceBaseName);
  return $Type;
};
const getAttributeDefinition = (Type) => {
  const def2 = getMetadata(attributeBaseName, Type) ?? getDefinitionFromStaticAu(Type, attrTypeName, CustomAttributeDefinition.create);
  if (def2 === void 0) {
    throw createMappedError$2(759, Type);
  }
  return def2;
};
const findClosestControllerByName = (node, attrNameOrType) => {
  let key = "";
  let attrName = "";
  if (isString(attrNameOrType)) {
    key = getAttributeKeyFrom(attrNameOrType);
    attrName = attrNameOrType;
  } else {
    const definition = getAttributeDefinition(attrNameOrType);
    key = definition.key;
    attrName = definition.name;
  }
  let cur = node;
  while (cur !== null) {
    const controller = getRef(cur, key);
    if (controller?.is(attrName)) {
      return controller;
    }
    cur = getEffectiveParentNode(cur);
  }
  return null;
};
const CustomAttribute = /* @__PURE__ */ objectFreeze({
  name: attributeBaseName,
  keyFrom: getAttributeKeyFrom,
  isType: isAttributeType,
  for: findAttributeControllerFor,
  closest: findClosestControllerByName,
  define: defineAttribute,
  getDefinition: getAttributeDefinition,
  annotate(Type, prop, value) {
    defineMetadata(value, Type, getAnnotationKeyFor(prop));
  },
  getAnnotation: getAttributeAnnotation,
  find(c2, name2) {
    const Type = c2.find(attrTypeName, name2);
    return Type === null ? null : getMetadata(attributeBaseName, Type) ?? getDefinitionFromStaticAu(Type, attrTypeName, CustomAttributeDefinition.create) ?? null;
  }
});
const ILifecycleHooks = /* @__PURE__ */ createInterface("ILifecycleHooks");
class LifecycleHooksEntry {
  constructor(definition, instance) {
    this.definition = definition;
    this.instance = instance;
  }
}
class LifecycleHooksDefinition {
  constructor(Type, propertyNames) {
    this.Type = Type;
    this.propertyNames = propertyNames;
  }
  /**
   * @param def - Placeholder for future extensions. Currently always an empty object.
   */
  static create(def2, Type) {
    const propertyNames = /* @__PURE__ */ new Set();
    let proto = Type.prototype;
    while (proto !== baseObjectPrototype) {
      for (const name2 of getOwnPropertyNames(proto)) {
        if (name2 !== "constructor" && !name2.startsWith("_")) {
          propertyNames.add(name2);
        }
      }
      proto = Object.getPrototypeOf(proto);
    }
    return new LifecycleHooksDefinition(Type, propertyNames);
  }
}
const LifecycleHooks = /* @__PURE__ */ (() => {
  const containerLookup2 = /* @__PURE__ */ new WeakMap();
  const definitionMap = /* @__PURE__ */ new WeakMap();
  return objectFreeze({
    // name: lhBaseName,
    /**
     * @param def - Placeholder for future extensions. Currently always an empty object.
     */
    define(def2, Type) {
      const definition = LifecycleHooksDefinition.create(def2, Type);
      const $Type = definition.Type;
      definitionMap.set($Type, definition);
      return {
        register(container) {
          singletonRegistration(ILifecycleHooks, $Type).register(container);
        }
      };
    },
    /**
     * @param ctx - The container where the resolution starts
     * @param Type - The constructor of the Custom element/ Custom attribute with lifecycle metadata
     */
    resolve(ctx) {
      let lookup2 = containerLookup2.get(ctx);
      if (lookup2 === void 0) {
        containerLookup2.set(ctx, lookup2 = new LifecycleHooksLookupImpl());
        const root = ctx.root;
        const instances = root === ctx ? ctx.getAll(ILifecycleHooks) : ctx.has(ILifecycleHooks, false) ? root.getAll(ILifecycleHooks).concat(ctx.getAll(ILifecycleHooks)) : root.getAll(ILifecycleHooks);
        let instance;
        let definition;
        let entry;
        let name2;
        let entries;
        for (instance of instances) {
          definition = definitionMap.get(instance.constructor);
          entry = new LifecycleHooksEntry(definition, instance);
          for (name2 of definition.propertyNames) {
            entries = lookup2[name2];
            if (entries === void 0) {
              lookup2[name2] = [entry];
            } else {
              entries.push(entry);
            }
          }
        }
      }
      return lookup2;
    }
  });
})();
class LifecycleHooksLookupImpl {
}
function valueConverter(nameOrDef) {
  return function(target, context) {
    context.addInitializer(function() {
      ValueConverter.define(nameOrDef, this);
    });
    return target;
  };
}
class ValueConverterDefinition {
  constructor(Type, name2, aliases, key) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
  }
  static create(nameOrDef, Type) {
    let name2;
    let def2;
    if (isString(nameOrDef)) {
      name2 = nameOrDef;
      def2 = { name: name2 };
    } else {
      name2 = nameOrDef.name;
      def2 = nameOrDef;
    }
    return new ValueConverterDefinition(Type, firstDefined(getConverterAnnotation(Type, "name"), name2), mergeArrays(getConverterAnnotation(Type, "aliases"), def2.aliases, Type.aliases), ValueConverter.keyFrom(name2));
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getValueConverterKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (!container.has(key, false)) {
      container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getValueConverterKeyFrom(alias))));
    } else {
      console.warn(`[DEV:aurelia] ${createMappedError$2(155, this.name)}`);
    }
  }
}
const converterTypeName = "value-converter";
const vcBaseName = /* @__PURE__ */ getResourceKeyFor(converterTypeName);
const getConverterAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const getValueConverterKeyFrom = (name2) => `${vcBaseName}:${name2}`;
const ValueConverter = objectFreeze({
  name: vcBaseName,
  keyFrom: getValueConverterKeyFrom,
  isType(value) {
    return isFunction(value) && (hasMetadata(vcBaseName, value) || value.$au?.type === converterTypeName);
  },
  define(nameOrDef, Type) {
    const definition = ValueConverterDefinition.create(nameOrDef, Type);
    const $Type = definition.Type;
    defineMetadata(definition, $Type, vcBaseName, resourceBaseName);
    return $Type;
  },
  getDefinition(Type) {
    const def2 = getMetadata(vcBaseName, Type) ?? getDefinitionFromStaticAu(Type, converterTypeName, ValueConverterDefinition.create);
    if (def2 === void 0) {
      throw createMappedError$2(152, Type);
    }
    return def2;
  },
  annotate(Type, prop, value) {
    defineMetadata(value, Type, getAnnotationKeyFor(prop));
  },
  getAnnotation: getConverterAnnotation,
  find(container, name2) {
    const Type = container.find(converterTypeName, name2);
    return Type == null ? null : getMetadata(vcBaseName, Type) ?? getDefinitionFromStaticAu(Type, converterTypeName, ValueConverterDefinition.create) ?? null;
  },
  get(container, name2) {
    {
      try {
        return container.get(resource(getValueConverterKeyFrom(name2)));
      } catch (ex) {
        console.error("[DEV:aurelia] Cannot retrieve value converter with name", name2);
        throw ex;
      }
    }
    return container.get(resource(getValueConverterKeyFrom(name2)));
  }
});
class BindingTargetSubscriber {
  constructor(b3, flushQueue) {
    this._value = void 0;
    this.b = b3;
    this._flushQueue = flushQueue;
  }
  flush() {
    this.b.updateSource(this._value);
  }
  // deepscan-disable-next-line
  handleChange(value, _2) {
    const b3 = this.b;
    if (value !== astEvaluate(b3.ast, b3._scope, b3, null)) {
      this._value = value;
      this._flushQueue.add(this);
    }
  }
}
const mixinUseScope = /* @__PURE__ */ (() => {
  function useScope(scope) {
    this._scope = scope;
  }
  return (target) => {
    defineHiddenProp(target.prototype, "useScope", useScope);
  };
})();
const mixinAstEvaluator = /* @__PURE__ */ (() => {
  class ResourceLookup {
  }
  const converterResourceLookupCache = /* @__PURE__ */ new WeakMap();
  const behaviorResourceLookupCache = /* @__PURE__ */ new WeakMap();
  const appliedBehaviors = /* @__PURE__ */ new WeakMap();
  function evaluatorGet(key) {
    return this.l.get(key);
  }
  function evaluatorGetBehavior(b3, name2) {
    let resourceLookup = behaviorResourceLookupCache.get(b3);
    if (resourceLookup == null) {
      behaviorResourceLookupCache.set(b3, resourceLookup = new ResourceLookup());
    }
    return resourceLookup[name2] ??= BindingBehavior.get(b3.l, name2);
  }
  function evaluatorBindBehavior(name2, scope, args) {
    const behavior = evaluatorGetBehavior(this, name2);
    if (behavior == null) {
      throw createMappedError$2(101, name2);
    }
    let applied = appliedBehaviors.get(this);
    if (applied == null) {
      appliedBehaviors.set(this, applied = {});
    }
    if (applied[name2]) {
      throw createMappedError$2(102, name2);
    }
    behavior.bind?.(scope, this, ...args);
  }
  function evaluatorUnbindBehavior(name2, scope) {
    const behavior = evaluatorGetBehavior(this, name2);
    const applied = appliedBehaviors.get(this);
    behavior?.unbind?.(scope, this);
    if (applied != null) {
      applied[name2] = false;
    }
  }
  function evaluatorGetConverter(b3, name2) {
    let resourceLookup = converterResourceLookupCache.get(b3);
    if (resourceLookup == null) {
      converterResourceLookupCache.set(b3, resourceLookup = new ResourceLookup());
    }
    return resourceLookup[name2] ??= ValueConverter.get(b3.l, name2);
  }
  function evaluatorBindConverter(name2) {
    const vc = evaluatorGetConverter(this, name2);
    if (vc == null) {
      throw createMappedError$2(103, name2);
    }
    const signals = vc.signals;
    if (signals != null) {
      const signaler = this.l.get(ISignaler);
      const ii = signals.length;
      let i3 = 0;
      for (; i3 < ii; ++i3) {
        signaler.addSignalListener(signals[i3], this);
      }
    }
  }
  function evaluatorUnbindConverter(name2) {
    const vc = evaluatorGetConverter(this, name2);
    if (vc?.signals === void 0) {
      return;
    }
    const signaler = this.l.get(ISignaler);
    let i3 = 0;
    for (; i3 < vc.signals.length; ++i3) {
      signaler.removeSignalListener(vc.signals[i3], this);
    }
  }
  function evaluatorUseConverter(name2, mode, value, args) {
    const vc = evaluatorGetConverter(this, name2);
    if (vc == null) {
      throw createMappedError$2(103, name2);
    }
    switch (mode) {
      case "toView":
        return "toView" in vc ? vc.toView(value, ...args) : value;
      case "fromView":
        return "fromView" in vc ? vc.fromView?.(value, ...args) : value;
    }
  }
  return (target) => {
    const proto = target.prototype;
    defineHiddenProp(proto, "get", evaluatorGet);
    defineHiddenProp(proto, "bindBehavior", evaluatorBindBehavior);
    defineHiddenProp(proto, "unbindBehavior", evaluatorUnbindBehavior);
    defineHiddenProp(proto, "bindConverter", evaluatorBindConverter);
    defineHiddenProp(proto, "unbindConverter", evaluatorUnbindConverter);
    defineHiddenProp(proto, "useConverter", evaluatorUseConverter);
  };
})();
const IFlushQueue = /* @__PURE__ */ createInterface("IFlushQueue", (x2) => x2.singleton(FlushQueue));
class FlushQueue {
  constructor() {
    this._flushing = false;
    this._items = /* @__PURE__ */ new Set();
  }
  get count() {
    return this._items.size;
  }
  add(flushable) {
    this._items.add(flushable);
    if (this._flushing) {
      return;
    }
    this._flushing = true;
    try {
      this._items.forEach(flushItem);
    } finally {
      this._flushing = false;
    }
  }
  clear() {
    this._items.clear();
    this._flushing = false;
  }
}
const flushItem = function(item, _2, items) {
  items.delete(item);
  item.flush();
};
const mixingBindingLimited = /* @__PURE__ */ (() => {
  const withLimitationBindings = /* @__PURE__ */ new WeakSet();
  const debounced = (opts, callOriginal, binding) => {
    let limiterTask;
    let task2;
    let latestValue;
    let isPending = false;
    const taskQueue = opts.queue;
    const callOriginalCallback = () => callOriginal(latestValue);
    const fn2 = (v2) => {
      latestValue = v2;
      if (binding.isBound) {
        task2 = limiterTask;
        limiterTask = taskQueue.queueTask(callOriginalCallback, { delay: opts.delay });
        task2?.cancel();
      } else {
        callOriginalCallback();
      }
    };
    const dispose2 = fn2.dispose = () => {
      task2?.cancel();
      limiterTask?.cancel();
      task2 = limiterTask = void 0;
    };
    fn2.flush = () => {
      isPending = limiterTask?.status === tsPending;
      dispose2();
      if (isPending) {
        callOriginalCallback();
      }
    };
    return fn2;
  };
  const throttled = (opts, callOriginal, binding) => {
    let limiterTask;
    let task2;
    let last = 0;
    let elapsed = 0;
    let latestValue;
    let isPending = false;
    const taskQueue = opts.queue;
    const now = () => opts.now();
    const callOriginalCallback = () => callOriginal(latestValue);
    const fn2 = (v2) => {
      latestValue = v2;
      if (binding.isBound) {
        elapsed = now() - last;
        task2 = limiterTask;
        if (elapsed > opts.delay) {
          last = now();
          callOriginalCallback();
        } else {
          limiterTask = taskQueue.queueTask(() => {
            last = now();
            callOriginalCallback();
          }, { delay: opts.delay - elapsed });
        }
        task2?.cancel();
      } else {
        callOriginalCallback();
      }
    };
    const dispose2 = fn2.dispose = () => {
      task2?.cancel();
      limiterTask?.cancel();
      task2 = limiterTask = void 0;
    };
    fn2.flush = () => {
      isPending = limiterTask?.status === tsPending;
      dispose2();
      if (isPending) {
        callOriginalCallback();
      }
    };
    return fn2;
  };
  return (target, getMethodName) => {
    defineHiddenProp(target.prototype, "limit", function(opts) {
      if (withLimitationBindings.has(this)) {
        throw createMappedError$2(
          9996
          /* ErrorNames.binding_already_has_rate_limited */
        );
      }
      withLimitationBindings.add(this);
      const prop = getMethodName(this, opts);
      const signals = opts.signals;
      const signaler = signals.length > 0 ? this.get(ISignaler) : null;
      const originalFn = this[prop];
      const callOriginal = (...args) => originalFn.call(this, ...args);
      const limitedFn = opts.type === "debounce" ? debounced(opts, callOriginal, this) : throttled(opts, callOriginal, this);
      const signalListener = signaler ? { handleChange: limitedFn.flush } : null;
      this[prop] = limitedFn;
      if (signaler) {
        signals.forEach((s3) => addSignalListener(signaler, s3, signalListener));
      }
      return {
        dispose: () => {
          if (signaler) {
            signals.forEach((s3) => removeSignalListener(signaler, s3, signalListener));
          }
          withLimitationBindings.delete(this);
          limitedFn.dispose();
          delete this[prop];
        }
      };
    });
  };
})();
const createPrototypeMixer = /* @__PURE__ */ ((mixed = /* @__PURE__ */ new WeakSet()) => {
  return (mixer) => {
    return function() {
      if (!mixed.has(this)) {
        mixed.add(this);
        mixer.call(this);
      }
    };
  };
})();
const taskOptions = {
  preempt: true
};
class AttributeBinding {
  constructor(controller, locator, observerLocator, taskQueue, ast, target, targetAttribute, targetProperty, mode, strict) {
    this.targetAttribute = targetAttribute;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this._task = null;
    this._value = void 0;
    this.boundFn = false;
    this.l = locator;
    this.ast = ast;
    this._controller = controller;
    this.target = target;
    this.oL = observerLocator;
    this._taskQueue = taskQueue;
  }
  updateTarget(value) {
    const target = this.target;
    const targetAttribute = this.targetAttribute;
    const targetProperty = this.targetProperty;
    switch (targetAttribute) {
      case "class":
        target.classList.toggle(targetProperty, !!value);
        break;
      case "style": {
        let priority = "";
        let newValue = safeString(value);
        if (isString(newValue) && newValue.includes("!important")) {
          priority = "important";
          newValue = newValue.replace("!important", "");
        }
        target.style.setProperty(targetProperty, newValue, priority);
        break;
      }
      default: {
        if (value == null) {
          target.removeAttribute(targetAttribute);
        } else {
          target.setAttribute(targetAttribute, safeString(value));
        }
      }
    }
  }
  handleChange() {
    if (!this.isBound) {
      return;
    }
    let task2;
    this.obs.version++;
    const newValue = astEvaluate(
      this.ast,
      this._scope,
      this,
      // should observe?
      (this.mode & toView) > 0 ? this : null
    );
    this.obs.clear();
    if (newValue !== this._value) {
      this._value = newValue;
      const shouldQueueFlush = this._controller.state !== activating;
      if (shouldQueueFlush) {
        task2 = this._task;
        this._task = this._taskQueue.queueTask(() => {
          this._task = null;
          this.updateTarget(newValue);
        }, taskOptions);
        task2?.cancel();
      } else {
        this.updateTarget(newValue);
      }
    }
  }
  // todo: based off collection and handle update accordingly instead off always start
  handleCollectionChange() {
    this.handleChange();
  }
  bind(_scope) {
    if (this.isBound) {
      if (this._scope === _scope) {
        return;
      }
      this.unbind();
    }
    this._scope = _scope;
    astBind(this.ast, _scope, this);
    if (this.mode & (toView | oneTime)) {
      this.updateTarget(this._value = astEvaluate(
        this.ast,
        _scope,
        this,
        /* should connect? */
        (this.mode & toView) > 0 ? this : null
      ));
    }
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this._value = void 0;
    this._task?.cancel();
    this._task = null;
    this.obs.clearAll();
  }
}
AttributeBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(AttributeBinding);
  mixingBindingLimited(AttributeBinding, () => "updateTarget");
  connectable(AttributeBinding, null);
  mixinAstEvaluator(AttributeBinding);
});
const queueTaskOptions$1 = {
  preempt: true
};
class InterpolationBinding {
  constructor(controller, locator, observerLocator, taskQueue, ast, target, targetProperty, mode, strict) {
    this.ast = ast;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this._task = null;
    this._controller = controller;
    this.oL = observerLocator;
    this._taskQueue = taskQueue;
    this._targetObserver = observerLocator.getAccessor(target, targetProperty);
    const expressions = ast.expressions;
    const partBindings = this.partBindings = Array(expressions.length);
    const ii = expressions.length;
    let i3 = 0;
    for (; ii > i3; ++i3) {
      partBindings[i3] = new InterpolationPartBinding(expressions[i3], target, targetProperty, locator, observerLocator, strict, this);
    }
  }
  /** @internal */
  _handlePartChange() {
    this.updateTarget();
  }
  updateTarget() {
    const partBindings = this.partBindings;
    const staticParts = this.ast.parts;
    const ii = partBindings.length;
    let result = "";
    let i3 = 0;
    if (ii === 1) {
      result = staticParts[0] + partBindings[0]._value + staticParts[1];
    } else {
      result = staticParts[0];
      for (; ii > i3; ++i3) {
        result += partBindings[i3]._value + staticParts[i3 + 1];
      }
    }
    const targetObserver = this._targetObserver;
    const shouldQueueFlush = this._controller.state !== activating && (targetObserver.type & atLayout) > 0;
    let task2;
    if (shouldQueueFlush) {
      task2 = this._task;
      this._task = this._taskQueue.queueTask(() => {
        this._task = null;
        targetObserver.setValue(result, this.target, this.targetProperty);
      }, queueTaskOptions$1);
      task2?.cancel();
      task2 = null;
    } else {
      targetObserver.setValue(result, this.target, this.targetProperty);
    }
  }
  bind(_scope) {
    if (this.isBound) {
      if (this._scope === _scope) {
        return;
      }
      this.unbind();
    }
    this._scope = _scope;
    const partBindings = this.partBindings;
    const ii = partBindings.length;
    let i3 = 0;
    for (; ii > i3; ++i3) {
      partBindings[i3].bind(_scope);
    }
    this.updateTarget();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    this._scope = void 0;
    const partBindings = this.partBindings;
    const ii = partBindings.length;
    let i3 = 0;
    for (; ii > i3; ++i3) {
      partBindings[i3].unbind();
    }
    this._task?.cancel();
    this._task = null;
  }
  /**
   * Start using a given observer to update the target
   */
  useAccessor(accessor) {
    this._targetObserver = accessor;
  }
}
class InterpolationPartBinding {
  constructor(ast, target, targetProperty, locator, observerLocator, strict, owner) {
    this.ast = ast;
    this.target = target;
    this.targetProperty = targetProperty;
    this.strict = strict;
    this.owner = owner;
    this.mode = toView;
    this.task = null;
    this.isBound = false;
    this._value = "";
    this.boundFn = false;
    this.l = locator;
    this.oL = observerLocator;
  }
  updateTarget() {
    this.owner._handlePartChange();
  }
  handleChange() {
    if (!this.isBound) {
      return;
    }
    this.obs.version++;
    const newValue = astEvaluate(
      this.ast,
      this._scope,
      this,
      // should observe?
      (this.mode & toView) > 0 ? this : null
    );
    this.obs.clear();
    if (newValue != this._value) {
      this._value = newValue;
      if (isArray(newValue)) {
        this.observeCollection(newValue);
      }
      this.updateTarget();
    }
  }
  handleCollectionChange() {
    this.updateTarget();
  }
  bind(_scope) {
    if (this.isBound) {
      if (this._scope === _scope) {
        return;
      }
      this.unbind();
    }
    this._scope = _scope;
    astBind(this.ast, _scope, this);
    this._value = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    if (isArray(this._value)) {
      this.observeCollection(this._value);
    }
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.obs.clearAll();
  }
}
InterpolationPartBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(InterpolationPartBinding);
  mixingBindingLimited(InterpolationPartBinding, () => "updateTarget");
  connectable(InterpolationPartBinding, null);
  mixinAstEvaluator(InterpolationPartBinding);
});
const queueTaskOptions = {
  preempt: true
};
class ContentBinding {
  constructor(controller, locator, observerLocator, taskQueue, p2, ast, target, strict) {
    this.p = p2;
    this.ast = ast;
    this.target = target;
    this.strict = strict;
    this.isBound = false;
    this.mode = toView;
    this._task = null;
    this._value = "";
    this._needsRemoveNode = false;
    this.boundFn = false;
    this.l = locator;
    this._controller = controller;
    this.oL = observerLocator;
    this._taskQueue = taskQueue;
  }
  updateTarget(value) {
    const target = this.target;
    const oldValue = this._value;
    this._value = value;
    if (this._needsRemoveNode) {
      oldValue.parentNode?.removeChild(oldValue);
      this._needsRemoveNode = false;
    }
    if (value instanceof this.p.Node) {
      target.parentNode?.insertBefore(value, target);
      value = "";
      this._needsRemoveNode = true;
    }
    target.textContent = safeString(value ?? "");
  }
  handleChange() {
    if (!this.isBound) {
      return;
    }
    this.obs.version++;
    const newValue = astEvaluate(
      this.ast,
      this._scope,
      this,
      // should observe?
      (this.mode & toView) > 0 ? this : null
    );
    this.obs.clear();
    if (newValue === this._value) {
      this._task?.cancel();
      this._task = null;
      return;
    }
    const shouldQueueFlush = this._controller.state !== activating;
    if (shouldQueueFlush) {
      this._queueUpdate(newValue);
    } else {
      this.updateTarget(newValue);
    }
  }
  handleCollectionChange() {
    if (!this.isBound) {
      return;
    }
    this.obs.version++;
    const v2 = this._value = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    this.obs.clear();
    if (isArray(v2)) {
      this.observeCollection(v2);
    }
    const shouldQueueFlush = this._controller.state !== activating;
    if (shouldQueueFlush) {
      this._queueUpdate(v2);
    } else {
      this.updateTarget(v2);
    }
  }
  bind(_scope) {
    if (this.isBound) {
      if (this._scope === _scope) {
        return;
      }
      this.unbind();
    }
    this._scope = _scope;
    astBind(this.ast, _scope, this);
    const v2 = this._value = astEvaluate(this.ast, this._scope, this, (this.mode & toView) > 0 ? this : null);
    if (isArray(v2)) {
      this.observeCollection(v2);
    }
    this.updateTarget(v2);
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    if (this._needsRemoveNode) {
      this._value.parentNode?.removeChild(this._value);
    }
    this._scope = void 0;
    this.obs.clearAll();
    this._task?.cancel();
    this._task = null;
  }
  // queue a force update
  /** @internal */
  _queueUpdate(newValue) {
    const task2 = this._task;
    this._task = this._taskQueue.queueTask(() => {
      this._task = null;
      this.updateTarget(newValue);
    }, queueTaskOptions);
    task2?.cancel();
  }
}
ContentBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(ContentBinding);
  mixingBindingLimited(ContentBinding, () => "updateTarget");
  connectable(ContentBinding, null);
  mixinAstEvaluator(ContentBinding);
});
class LetBinding {
  constructor(locator, observerLocator, ast, targetProperty, toBindingContext, strict) {
    this.ast = ast;
    this.targetProperty = targetProperty;
    this.isBound = false;
    this._scope = void 0;
    this.target = null;
    this.boundFn = false;
    this.l = locator;
    this.oL = observerLocator;
    this.strict = strict;
    this._toBindingContext = toBindingContext;
  }
  updateTarget() {
    this.target[this.targetProperty] = this._value;
  }
  handleChange() {
    if (!this.isBound) {
      return;
    }
    this.obs.version++;
    this._value = astEvaluate(this.ast, this._scope, this, this);
    this.obs.clear();
    this.updateTarget();
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(_scope) {
    if (this.isBound) {
      if (this._scope === _scope) {
        return;
      }
      this.unbind();
    }
    this._scope = _scope;
    this.target = this._toBindingContext ? _scope.bindingContext : _scope.overrideContext;
    astBind(this.ast, _scope, this);
    this._value = astEvaluate(this.ast, this._scope, this, this);
    this.updateTarget();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.obs.clearAll();
  }
}
LetBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(LetBinding);
  mixingBindingLimited(LetBinding, () => "updateTarget");
  connectable(LetBinding, null);
  mixinAstEvaluator(LetBinding);
});
class PropertyBinding {
  constructor(controller, locator, observerLocator, taskQueue, ast, target, targetProperty, mode, strict) {
    this.ast = ast;
    this.target = target;
    this.targetProperty = targetProperty;
    this.mode = mode;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this._targetObserver = void 0;
    this._task = null;
    this._targetSubscriber = null;
    this.boundFn = false;
    this.l = locator;
    this._controller = controller;
    this._taskQueue = taskQueue;
    this.oL = observerLocator;
  }
  updateTarget(value) {
    this._targetObserver.setValue(value, this.target, this.targetProperty);
  }
  updateSource(value) {
    astAssign(this.ast, this._scope, this, value);
  }
  handleChange() {
    if (!this.isBound) {
      return;
    }
    this.obs.version++;
    const newValue = astEvaluate(
      this.ast,
      this._scope,
      this,
      // should observe?
      (this.mode & toView) > 0 ? this : null
    );
    this.obs.clear();
    const shouldQueueFlush = this._controller.state !== activating && (this._targetObserver.type & atLayout) > 0;
    if (shouldQueueFlush) {
      task = this._task;
      this._task = this._taskQueue.queueTask(() => {
        this.updateTarget(newValue);
        this._task = null;
      }, updateTaskOpts);
      task?.cancel();
      task = null;
    } else {
      this.updateTarget(newValue);
    }
  }
  // todo: based off collection and handle update accordingly instead off always start
  handleCollectionChange() {
    this.handleChange();
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope) {
        return;
      }
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    const observerLocator = this.oL;
    const $mode = this.mode;
    let targetObserver = this._targetObserver;
    if (!targetObserver) {
      if ($mode & fromView) {
        targetObserver = observerLocator.getObserver(this.target, this.targetProperty);
      } else {
        targetObserver = observerLocator.getAccessor(this.target, this.targetProperty);
      }
      this._targetObserver = targetObserver;
    }
    const shouldConnect = ($mode & toView) > 0;
    if ($mode & (toView | oneTime)) {
      this.updateTarget(astEvaluate(this.ast, this._scope, this, shouldConnect ? this : null));
    }
    if ($mode & fromView) {
      targetObserver.subscribe(this._targetSubscriber ??= new BindingTargetSubscriber(this, this.l.get(IFlushQueue)));
      if (!shouldConnect) {
        this.updateSource(targetObserver.getValue(this.target, this.targetProperty));
      }
    }
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    if (this._targetSubscriber) {
      this._targetObserver.unsubscribe(this._targetSubscriber);
      this._targetSubscriber = null;
    }
    this._task?.cancel();
    this._task = null;
    this.obs.clearAll();
  }
  /**
   * Start using a given observer to listen to changes on the target of this binding
   */
  useTargetObserver(observer) {
    this._targetObserver?.unsubscribe(this);
    (this._targetObserver = observer).subscribe(this);
  }
  /**
   * Provide a subscriber for target change observation.
   *
   * Binding behaviors can use this to setup custom observation handling during bind lifecycle
   * to alter the update source behavior during bind phase of this binding.
   */
  useTargetSubscriber(subscriber) {
    if (this._targetSubscriber != null) {
      throw createMappedError$2(
        9995
        /* ErrorNames.binding_already_has_target_subscriber */
      );
    }
    this._targetSubscriber = subscriber;
  }
}
PropertyBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(PropertyBinding);
  mixingBindingLimited(PropertyBinding, (propBinding) => propBinding.mode & fromView ? "updateSource" : "updateTarget");
  connectable(PropertyBinding, null);
  mixinAstEvaluator(PropertyBinding);
});
let task = null;
const updateTaskOpts = {
  preempt: true
};
class RefBinding {
  constructor(locator, ast, target, strict) {
    this.ast = ast;
    this.target = target;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this.l = locator;
  }
  bind(_scope) {
    if (this.isBound) {
      if (this._scope === _scope) {
        return;
      }
      this.unbind();
    }
    this._scope = _scope;
    astBind(this.ast, _scope, this);
    astAssign(this.ast, this._scope, this, this.target);
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    if (astEvaluate(this.ast, this._scope, this, null) === this.target) {
      astAssign(this.ast, this._scope, this, null);
    }
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
  }
}
RefBinding.mix = createPrototypeMixer(() => {
  mixinAstEvaluator(RefBinding);
});
class ListenerBindingOptions {
  constructor(prevent, capture = false, onError) {
    this.prevent = prevent;
    this.capture = capture;
    this.onError = onError;
  }
}
class ListenerBinding {
  constructor(locator, ast, target, targetEvent, options, modifiedEventHandler, strict) {
    this.ast = ast;
    this.target = target;
    this.targetEvent = targetEvent;
    this.strict = strict;
    this.isBound = false;
    this.self = false;
    this.boundFn = true;
    this._modifiedEventHandler = null;
    this.l = locator;
    this._options = options;
    this._modifiedEventHandler = modifiedEventHandler;
  }
  callSource(event) {
    const overrideContext = this._scope.overrideContext;
    overrideContext.$event = event;
    let result = astEvaluate(this.ast, this._scope, this, null);
    delete overrideContext.$event;
    if (isFunction(result)) {
      result = result(event);
    }
    if (result !== true && this._options.prevent) {
      event.preventDefault();
    }
  }
  handleEvent(event) {
    if (this.self) {
      if (this.target !== event.composedPath()[0]) {
        return;
      }
    }
    if (this._modifiedEventHandler?.(event) !== false) {
      try {
        this.callSource(event);
      } catch (ex) {
        this._options.onError(event, ex);
      }
    }
  }
  bind(scope) {
    if (this.isBound) {
      if (this._scope === scope) {
        return;
      }
      this.unbind();
    }
    this._scope = scope;
    astBind(this.ast, scope, this);
    this.target.addEventListener(this.targetEvent, this, this._options);
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    this.target.removeEventListener(this.targetEvent, this, this._options);
  }
}
ListenerBinding.mix = createPrototypeMixer(function() {
  mixinUseScope(ListenerBinding);
  mixingBindingLimited(ListenerBinding, () => "callSource");
  mixinAstEvaluator(ListenerBinding);
});
const IModifiedEventHandlerCreator = /* @__PURE__ */ createInterface("IEventModifier");
const IKeyMapping = /* @__PURE__ */ createInterface("IKeyMapping", (x2) => x2.instance({
  meta: objectFreeze(["ctrl", "alt", "shift", "meta"]),
  keys: {
    escape: "Escape",
    enter: "Enter",
    space: "Space",
    tab: "tab",
    // by default, maps the key a-z and A-Z to their respective keycodes
    ...Array.from({ length: 25 }).reduce((acc, _2, idx) => {
      let char = String.fromCharCode(idx + 65);
      acc[idx + 65] = char;
      char = String.fromCharCode(idx + 97);
      acc[idx + 97] = acc[char] = char;
      return acc;
    }, {})
  }
}));
class ModifiedMouseEventHandler {
  constructor() {
    this.type = ["click", "mousedown", "mousemove", "mouseup", "dblclick", "contextmenu"];
    this._mapping = resolve(IKeyMapping);
    this._mouseButtons = ["left", "middle", "right"];
  }
  static register(c2) {
    c2.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedMouseEventHandler));
  }
  getHandler(modifier) {
    const modifiers = modifier.split(/[:+.]/);
    return (event) => {
      let prevent = false;
      let stop = false;
      let m2;
      for (m2 of modifiers) {
        switch (m2) {
          case "prevent":
            prevent = true;
            continue;
          case "stop":
            stop = true;
            continue;
          case "left":
          case "middle":
          case "right":
            if (event.button !== this._mouseButtons.indexOf(m2))
              return false;
            continue;
        }
        if (this._mapping.meta.includes(m2) && event[`${m2}Key`] !== true) {
          return false;
        }
        {
          console.warn(`Modifier '${m2}' is not supported for mouse events.`);
        }
      }
      if (prevent)
        event.preventDefault();
      if (stop)
        event.stopPropagation();
      return true;
    };
  }
}
class ModifiedKeyboardEventHandler {
  constructor() {
    this._mapping = resolve(IKeyMapping);
    this.type = ["keydown", "keyup"];
  }
  static register(c2) {
    c2.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedKeyboardEventHandler));
  }
  getHandler(modifier) {
    const modifiers = modifier.split(/[:+.]/);
    return (event) => {
      let prevent = false;
      let stop = false;
      let mod;
      for (mod of modifiers) {
        switch (mod) {
          case "prevent":
            prevent = true;
            continue;
          case "stop":
            stop = true;
            continue;
        }
        if (this._mapping.meta.includes(mod)) {
          if (event[`${mod}Key`] !== true) {
            return false;
          }
          continue;
        }
        const mappedKey = this._mapping.keys[mod];
        if (mappedKey !== event.key) {
          return false;
        }
        {
          console.warn(`Modifier '${mod}' is not supported for keyboard event with key "${event.key}".`);
        }
      }
      if (prevent)
        event.preventDefault();
      if (stop)
        event.stopPropagation();
      return true;
    };
  }
}
class ModifiedEventHandler {
  constructor() {
    this.type = ["$ALL"];
  }
  static register(c2) {
    c2.register(singletonRegistration(IModifiedEventHandlerCreator, ModifiedEventHandler));
  }
  getHandler(modifier) {
    const modifiers = modifier.split(/[:+.]/);
    return (event) => {
      let prevent = false;
      let stop = false;
      let mod;
      for (mod of modifiers) {
        switch (mod) {
          case "prevent":
            prevent = true;
            continue;
          case "stop":
            stop = true;
            continue;
        }
        {
          console.warn(`Modifier '${mod}' is not supported for event "${event.type}".`);
        }
      }
      if (prevent)
        event.preventDefault();
      if (stop)
        event.stopPropagation();
      return true;
    };
  }
}
const IEventModifier = /* @__PURE__ */ createInterface("IEventModifierHandler", (x2) => x2.instance({
  getHandler: () => {
    {
      console.warn("No event modifier handler registered");
    }
    return null;
  }
}));
class EventModifier {
  constructor() {
    this._reg = resolve(all(IModifiedEventHandlerCreator)).reduce((acc, cur) => {
      const types = isArray(cur.type) ? cur.type : [cur.type];
      types.forEach((t2) => acc[t2] = cur);
      return acc;
    }, {});
  }
  static register(c2) {
    c2.register(singletonRegistration(IEventModifier, EventModifier));
  }
  getHandler(type, modifier) {
    return isString(modifier) ? (this._reg[type] ?? this._reg.$ALL)?.getHandler(modifier) ?? null : null;
  }
}
const EventModifierRegistration = {
  register(c2) {
    c2.register(EventModifier, ModifiedMouseEventHandler, ModifiedKeyboardEventHandler, ModifiedEventHandler);
  }
};
const IViewFactory = /* @__PURE__ */ createInterface("IViewFactory");
class ViewFactory {
  constructor(container, def2) {
    this.isCaching = false;
    this._cache = null;
    this._cacheSize = -1;
    this.name = def2.name;
    this.container = container;
    this.def = def2;
  }
  setCacheSize(size, doNotOverrideIfAlreadySet) {
    if (size) {
      if (size === "*") {
        size = ViewFactory.maxCacheSize;
      } else if (isString(size)) {
        size = parseInt(size, 10);
      }
      if (this._cacheSize === -1 || !doNotOverrideIfAlreadySet) {
        this._cacheSize = size;
      }
    }
    if (this._cacheSize > 0) {
      this._cache = [];
    } else {
      this._cache = null;
    }
    this.isCaching = this._cacheSize > 0;
  }
  canReturnToCache(_controller) {
    return this._cache != null && this._cache.length < this._cacheSize;
  }
  tryReturnToCache(controller) {
    if (this.canReturnToCache(controller)) {
      this._cache.push(controller);
      return true;
    }
    return false;
  }
  create(parentController) {
    const cache2 = this._cache;
    let controller;
    if (cache2 != null && cache2.length > 0) {
      controller = cache2.pop();
      return controller;
    }
    controller = Controller.$view(this, parentController);
    return controller;
  }
}
ViewFactory.maxCacheSize = 65535;
const createLocation = /* @__PURE__ */ (() => {
  const createComment = (p2, text) => p2.document.createComment(text);
  return (p2) => {
    const locationEnd = createComment(p2, "au-end");
    locationEnd.$start = createComment(p2, "au-start");
    return locationEnd;
  };
})();
const insertManyBefore = (parent, target, newChildNodes) => {
  if (parent === null) {
    return;
  }
  const ii = newChildNodes.length;
  let i3 = 0;
  while (ii > i3) {
    parent.insertBefore(newChildNodes[i3], target);
    ++i3;
  }
};
const createMutationObserver = (node, callback) => new node.ownerDocument.defaultView.MutationObserver(callback);
const isElement$2 = (node) => node.nodeType === 1;
const defaultSlotName = "default";
const auslotAttr = "au-slot";
const IAuSlotsInfo = /* @__PURE__ */ createInterface("IAuSlotsInfo");
class AuSlotsInfo {
  constructor(projectedSlots) {
    this.projectedSlots = projectedSlots;
  }
}
const IAuSlotWatcher = /* @__PURE__ */ createInterface("IAuSlotWatcher");
class SpreadBinding {
  /**
   * Create a list of SpreadBinding by searching for captured attributes in HydrationContexts
   * from a container
   */
  static create(hydrationContext, target, targetDef, rendering, compiler, platform, exprParser, observerLocator) {
    const bindings = [];
    const renderers = rendering.renderers;
    const getHydrationContext = (ancestor) => {
      let currentLevel = ancestor;
      let currentContext = hydrationContext;
      while (currentContext != null && currentLevel > 0) {
        currentContext = currentContext.parent;
        --currentLevel;
      }
      if (currentContext == null) {
        throw createMappedError$2(
          9999
          /* ErrorNames.no_spread_scope_context_found */
        );
      }
      return currentContext;
    };
    const renderSpreadInstruction = (ancestor) => {
      const context = getHydrationContext(ancestor);
      const spreadBinding = new SpreadBinding(context);
      const instructions = compiler.compileSpread(context.controller.definition, context.instruction?.captures ?? emptyArray, context.controller.container, target, targetDef);
      let inst;
      for (inst of instructions) {
        switch (inst.type) {
          case InstructionType.spreadTransferedBinding:
            renderSpreadInstruction(ancestor + 1);
            break;
          case InstructionType.spreadElementProp:
            renderers[inst.instruction.type].render(spreadBinding, findElementControllerFor(target), inst.instruction, platform, exprParser, observerLocator);
            break;
          default:
            renderers[inst.type].render(spreadBinding, target, inst, platform, exprParser, observerLocator);
        }
      }
      bindings.push(spreadBinding);
    };
    renderSpreadInstruction(0);
    return bindings;
  }
  get container() {
    return this.locator;
  }
  get definition() {
    return this.$controller.definition;
  }
  get state() {
    return this.$controller.state;
  }
  constructor(hydrationContext) {
    this.isBound = false;
    this._innerBindings = [];
    this.locator = (this.$controller = (this._hydrationContext = hydrationContext).controller).container;
  }
  get(key) {
    return this.locator.get(key);
  }
  bind(_scope) {
    if (this.isBound) {
      return;
    }
    this.isBound = true;
    const innerScope = this.scope = this._hydrationContext.controller.scope.parent ?? void 0;
    if (innerScope == null) {
      throw createMappedError$2(
        9999
        /* ErrorNames.no_spread_scope_context_found */
      );
    }
    this._innerBindings.forEach((b3) => b3.bind(innerScope));
  }
  unbind() {
    this._innerBindings.forEach((b3) => b3.unbind());
    this.isBound = false;
  }
  addBinding(binding) {
    this._innerBindings.push(binding);
  }
  addChild(controller) {
    if (controller.vmKind !== vmkCa) {
      throw createMappedError$2(
        9998
        /* ErrorNames.no_spread_template_controller */
      );
    }
    this.$controller.addChild(controller);
  }
}
class SpreadValueBinding {
  constructor(controller, target, targetKeys, ast, ol, l2, taskQueue, strict) {
    this.target = target;
    this.targetKeys = targetKeys;
    this.ast = ast;
    this.strict = strict;
    this.isBound = false;
    this._scope = void 0;
    this.boundFn = false;
    this._bindingCache = {};
    this._scopeCache = /* @__PURE__ */ new WeakMap();
    this._controller = controller;
    this.oL = ol;
    this.l = l2;
    this._taskQueue = taskQueue;
  }
  updateTarget() {
    this.obs.version++;
    const newValue = astEvaluate(this.ast, this._scope, this, this);
    this.obs.clear();
    this._createBindings(newValue, true);
  }
  handleChange() {
    if (!this.isBound) {
      return;
    }
    this.updateTarget();
  }
  handleCollectionChange() {
    if (!this.isBound) {
      return;
    }
    this.updateTarget();
  }
  bind(scope) {
    if (this.isBound) {
      if (scope === this._scope) {
        return;
      }
      this.unbind();
    }
    this.isBound = true;
    this._scope = scope;
    astBind(this.ast, scope, this);
    const value = astEvaluate(this.ast, scope, this, this);
    this._createBindings(value, false);
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    astUnbind(this.ast, this._scope, this);
    this._scope = void 0;
    let key;
    for (key in this._bindingCache) {
      this._bindingCache[key].unbind();
    }
  }
  /**
   * @internal
   */
  _createBindings(value, unbind) {
    let key;
    if (!isObject(value)) {
      {
        console.warn(`[DEV:aurelia] $bindable spread is given a non object for properties: "${this.targetKeys.join(", ")}" of ${this.target.constructor.name}`);
      }
      for (key in this._bindingCache) {
        this._bindingCache[key]?.unbind();
      }
      return;
    }
    let binding;
    let scope = this._scopeCache.get(value);
    if (scope == null) {
      this._scopeCache.set(value, scope = Scope.fromParent(this._scope, value));
    }
    for (key of this.targetKeys) {
      binding = this._bindingCache[key];
      if (key in value) {
        if (binding == null) {
          binding = this._bindingCache[key] = new PropertyBinding(this._controller, this.l, this.oL, this._taskQueue, SpreadValueBinding._astCache[key] ??= new AccessScopeExpression(key, 0), this.target, key, BindingMode.toView, this.strict);
        }
        binding.bind(scope);
      } else if (unbind) {
        binding?.unbind();
      }
    }
  }
}
SpreadValueBinding.mix = createPrototypeMixer(() => {
  mixinUseScope(SpreadValueBinding);
  mixingBindingLimited(SpreadValueBinding, () => "updateTarget");
  connectable(SpreadValueBinding, null);
  mixinAstEvaluator(SpreadValueBinding);
});
SpreadValueBinding._astCache = {};
const addListener = (target, name2, handler, options) => {
  target.addEventListener(name2, handler, options);
};
const removeListener = (target, name2, handler, options) => {
  target.removeEventListener(name2, handler, options);
};
const mixinNodeObserverUseConfig = (target) => {
  let event;
  const prototype = target.prototype;
  defineHiddenProp(prototype, "subscribe", function(subscriber) {
    if (this.subs.add(subscriber) && this.subs.count === 1) {
      for (event of this._config.events) {
        addListener(this._el, event, this);
      }
      this._listened = true;
      this._start?.();
    }
  });
  defineHiddenProp(prototype, "unsubscribe", function(subscriber) {
    if (this.subs.remove(subscriber) && this.subs.count === 0) {
      for (event of this._config.events) {
        removeListener(this._el, event, this);
      }
      this._listened = false;
      this._stop?.();
    }
  });
  defineHiddenProp(prototype, "useConfig", function(config) {
    this._config = config;
    if (this._listened) {
      for (event of this._config.events) {
        removeListener(this._el, event, this);
      }
      for (event of this._config.events) {
        addListener(this._el, event, this);
      }
    }
  });
};
const mixinNoopSubscribable = (target) => {
  defineHiddenProp(target.prototype, "subscribe", noop$1);
  defineHiddenProp(target.prototype, "unsubscribe", noop$1);
};
class ClassAttributeAccessor {
  get doNotCache() {
    return true;
  }
  constructor(obj, mapping = {}) {
    this.obj = obj;
    this.mapping = mapping;
    this.type = atNode | atLayout;
    this._value = "";
    this._nameIndex = {};
    this._version = 0;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    if (newValue !== this._value) {
      this._value = newValue;
      this._flushChanges();
    }
  }
  /** @internal */
  _flushChanges() {
    const nameIndex = this._nameIndex;
    const version = ++this._version;
    const classList = this.obj.classList;
    const classesToAdd = getClassesToAdd(this._value);
    const ii = classesToAdd.length;
    let i3 = 0;
    let name2;
    if (ii > 0) {
      for (; i3 < ii; i3++) {
        name2 = classesToAdd[i3];
        name2 = this.mapping[name2] || name2;
        if (name2.length === 0) {
          continue;
        }
        nameIndex[name2] = this._version;
        classList.add(name2);
      }
    }
    if (version === 1) {
      return;
    }
    for (name2 in nameIndex) {
      name2 = this.mapping[name2] || name2;
      if (nameIndex[name2] === version) {
        continue;
      }
      classList.remove(name2);
    }
  }
}
(() => {
  mixinNoopSubscribable(ClassAttributeAccessor);
})();
function getClassesToAdd(object) {
  if (isString(object)) {
    return splitClassString(object);
  }
  if (typeof object !== "object") {
    return emptyArray;
  }
  if (isArray(object)) {
    const len = object.length;
    if (len > 0) {
      const classes2 = [];
      let i3 = 0;
      for (; len > i3; ++i3) {
        classes2.push(...getClassesToAdd(object[i3]));
      }
      return classes2;
    } else {
      return emptyArray;
    }
  }
  const classes = [];
  let property;
  for (property in object) {
    if (Boolean(object[property])) {
      if (property.includes(" ")) {
        classes.push(...splitClassString(property));
      } else {
        classes.push(property);
      }
    }
  }
  return classes;
}
function splitClassString(classString) {
  const matches2 = classString.match(/\S+/g);
  if (matches2 === null) {
    return emptyArray;
  }
  return matches2;
}
const fromHydrationContext = (key) => ({
  $isResolver: true,
  resolve(_2, requestor) {
    return requestor.get(IHydrationContext).controller.container.get(own(key));
  }
});
const IRenderer = /* @__PURE__ */ createInterface("IRenderer");
function renderer(target, context) {
  const metadata = target[Symbol.metadata] ??= /* @__PURE__ */ Object.create(null);
  metadata[registrableMetadataKey] = {
    register(container) {
      singletonRegistration(IRenderer, target).register(container);
    }
  };
  return target;
}
function ensureExpression(parser, srcOrExpr, expressionType) {
  if (isString(srcOrExpr)) {
    return parser.parse(srcOrExpr, expressionType);
  }
  return srcOrExpr;
}
function getTarget(potentialTarget) {
  if (potentialTarget.viewModel != null) {
    return potentialTarget.viewModel;
  }
  return potentialTarget;
}
function getRefTarget(refHost, refTargetName) {
  if (refTargetName === "element") {
    return refHost;
  }
  switch (refTargetName) {
    case "controller":
      return findElementControllerFor(refHost);
    case "view":
      throw createMappedError$2(
        750
        /* ErrorNames.not_supported_view_ref_api */
      );
    case "component":
      return findElementControllerFor(refHost).viewModel;
    default: {
      const caController = findAttributeControllerFor(refHost, refTargetName);
      if (caController !== void 0) {
        return caController.viewModel;
      }
      const ceController = findElementControllerFor(refHost, { name: refTargetName });
      if (ceController === void 0) {
        throw createMappedError$2(751, refTargetName);
      }
      return ceController.viewModel;
    }
  }
}
const SetPropertyRenderer = /* @__PURE__ */ renderer(class SetPropertyRenderer2 {
  constructor() {
    this.target = InstructionType.setProperty;
  }
  render(renderingCtrl, target, instruction) {
    const obj = getTarget(target);
    if (obj.$observers?.[instruction.to] !== void 0) {
      obj.$observers[instruction.to].setValue(instruction.value);
    } else {
      obj[instruction.to] = instruction.value;
    }
  }
});
const CustomElementRenderer = /* @__PURE__ */ renderer(class CustomElementRenderer2 {
  constructor() {
    this._rendering = resolve(IRendering);
    this.target = InstructionType.hydrateElement;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    let def2;
    let component;
    let childCtrl;
    const res = instruction.res;
    const projections = instruction.projections;
    const ctxContainer = renderingCtrl.container;
    switch (typeof res) {
      case "string":
        def2 = CustomElement.find(ctxContainer, res);
        if (def2 == null) {
          throw createMappedError$2(752, instruction, renderingCtrl);
        }
        break;
      default:
        def2 = res;
    }
    const containerless = instruction.containerless || def2.containerless;
    const location = containerless ? convertToRenderLocation(target) : null;
    const container = createElementContainer(
      /* platform         */
      platform,
      /* parentController */
      renderingCtrl,
      /* host             */
      target,
      /* instruction      */
      instruction,
      /* location         */
      location,
      /* SlotsInfo      */
      projections == null ? void 0 : new AuSlotsInfo(objectKeys(projections))
    );
    component = container.invoke(def2.Type);
    childCtrl = Controller.$el(
      /* own container       */
      container,
      /* viewModel           */
      component,
      /* host                */
      target,
      /* instruction         */
      instruction,
      /* definition          */
      def2,
      /* location            */
      location
    );
    setRef(target, def2.key, childCtrl);
    const renderers = this._rendering.renderers;
    const props2 = instruction.props;
    const ii = props2.length;
    let i3 = 0;
    let propInst;
    while (ii > i3) {
      propInst = props2[i3];
      renderers[propInst.type].render(renderingCtrl, childCtrl, propInst, platform, exprParser, observerLocator);
      ++i3;
    }
    renderingCtrl.addChild(childCtrl);
  }
});
const CustomAttributeRenderer = /* @__PURE__ */ renderer(class CustomAttributeRenderer2 {
  constructor() {
    this._rendering = resolve(IRendering);
    this.target = InstructionType.hydrateAttribute;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    let ctxContainer = renderingCtrl.container;
    let def2;
    switch (typeof instruction.res) {
      case "string":
        def2 = CustomAttribute.find(ctxContainer, instruction.res);
        if (def2 == null) {
          throw createMappedError$2(753, instruction, renderingCtrl);
        }
        break;
      default:
        def2 = instruction.res;
    }
    const results = invokeAttribute(
      /* platform         */
      platform,
      /* attr definition  */
      def2,
      /* parentController */
      renderingCtrl,
      /* host             */
      target,
      /* instruction      */
      instruction,
      /* viewFactory      */
      void 0,
      /* location         */
      void 0
    );
    const childController = Controller.$attr(
      /* context ct */
      results.ctn,
      /* viewModel  */
      results.vm,
      /* host       */
      target,
      /* definition */
      def2
    );
    setRef(target, def2.key, childController);
    const renderers = this._rendering.renderers;
    const props2 = instruction.props;
    const ii = props2.length;
    let i3 = 0;
    let propInst;
    while (ii > i3) {
      propInst = props2[i3];
      renderers[propInst.type].render(renderingCtrl, childController, propInst, platform, exprParser, observerLocator);
      ++i3;
    }
    renderingCtrl.addChild(childController);
  }
});
const TemplateControllerRenderer = /* @__PURE__ */ renderer(class TemplateControllerRenderer2 {
  constructor() {
    this._rendering = resolve(IRendering);
    this.target = InstructionType.hydrateTemplateController;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    let ctxContainer = renderingCtrl.container;
    let def2;
    switch (typeof instruction.res) {
      case "string":
        def2 = CustomAttribute.find(ctxContainer, instruction.res);
        if (def2 == null) {
          throw createMappedError$2(754, instruction, renderingCtrl);
        }
        break;
      default:
        def2 = instruction.res;
    }
    const viewFactory = this._rendering.getViewFactory(instruction.def, def2.containerStrategy === "new" ? ctxContainer.createChild({ inheritParentResources: true }) : ctxContainer);
    const renderLocation = convertToRenderLocation(target);
    const results = invokeAttribute(
      /* platform         */
      platform,
      /* attr definition  */
      def2,
      /* parentController */
      renderingCtrl,
      /* host             */
      target,
      /* instruction      */
      instruction,
      /* viewFactory      */
      viewFactory,
      /* location         */
      renderLocation
    );
    const childController = Controller.$attr(
      /* container ct */
      results.ctn,
      /* viewModel    */
      results.vm,
      /* host         */
      target,
      /* definition   */
      def2
    );
    setRef(renderLocation, def2.key, childController);
    results.vm.link?.(renderingCtrl, childController, target, instruction);
    const renderers = this._rendering.renderers;
    const props2 = instruction.props;
    const ii = props2.length;
    let i3 = 0;
    let propInst;
    while (ii > i3) {
      propInst = props2[i3];
      renderers[propInst.type].render(renderingCtrl, childController, propInst, platform, exprParser, observerLocator);
      ++i3;
    }
    renderingCtrl.addChild(childController);
  }
});
const LetElementRenderer = /* @__PURE__ */ renderer(class LetElementRenderer2 {
  constructor() {
    this.target = InstructionType.hydrateLetElement;
    LetBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    target.remove();
    const childInstructions = instruction.instructions;
    const toBindingContext = instruction.toBindingContext;
    const container = renderingCtrl.container;
    const ii = childInstructions.length;
    let childInstruction;
    let expr;
    let i3 = 0;
    while (ii > i3) {
      childInstruction = childInstructions[i3];
      expr = ensureExpression(exprParser, childInstruction.from, etIsProperty);
      renderingCtrl.addBinding(new LetBinding(container, observerLocator, expr, childInstruction.to, toBindingContext, renderingCtrl.strict ?? false));
      ++i3;
    }
  }
});
const RefBindingRenderer = /* @__PURE__ */ renderer(class RefBindingRenderer2 {
  constructor() {
    this.target = InstructionType.refBinding;
  }
  render(renderingCtrl, target, instruction, platform, exprParser) {
    renderingCtrl.addBinding(new RefBinding(renderingCtrl.container, ensureExpression(exprParser, instruction.from, etIsProperty), getRefTarget(target, instruction.to), renderingCtrl.strict ?? false));
  }
});
const InterpolationBindingRenderer = /* @__PURE__ */ renderer(class InterpolationBindingRenderer2 {
  constructor() {
    this.target = InstructionType.interpolation;
    InterpolationPartBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const container = renderingCtrl.container;
    const binding = new InterpolationBinding(renderingCtrl, container, observerLocator, platform.domQueue, ensureExpression(exprParser, instruction.from, etInterpolation), getTarget(target), instruction.to, toView, renderingCtrl.strict ?? false);
    if (instruction.to === "class" && binding.target.nodeType > 0) {
      const cssMapping = container.get(fromHydrationContext(ICssClassMapping));
      binding.useAccessor(new ClassAttributeAccessor(binding.target, cssMapping));
    }
    renderingCtrl.addBinding(binding);
  }
});
const PropertyBindingRenderer = /* @__PURE__ */ renderer(class PropertyBindingRenderer2 {
  constructor() {
    this.target = InstructionType.propertyBinding;
    PropertyBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const container = renderingCtrl.container;
    const binding = new PropertyBinding(renderingCtrl, container, observerLocator, platform.domQueue, ensureExpression(exprParser, instruction.from, etIsProperty), getTarget(target), instruction.to, instruction.mode, renderingCtrl.strict ?? false);
    if (instruction.to === "class" && binding.target.nodeType > 0) {
      const cssMapping = container.get(fromHydrationContext(ICssClassMapping));
      binding.useTargetObserver(new ClassAttributeAccessor(binding.target, cssMapping));
    }
    renderingCtrl.addBinding(binding);
  }
});
const IteratorBindingRenderer = /* @__PURE__ */ renderer(class IteratorBindingRenderer2 {
  constructor() {
    this.target = InstructionType.iteratorBinding;
    PropertyBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    renderingCtrl.addBinding(new PropertyBinding(renderingCtrl, renderingCtrl.container, observerLocator, platform.domQueue, ensureExpression(exprParser, instruction.forOf, etIsIterator), getTarget(target), instruction.to, toView, renderingCtrl.strict ?? false));
  }
});
const TextBindingRenderer = /* @__PURE__ */ renderer(class TextBindingRenderer2 {
  constructor() {
    this.target = InstructionType.textBinding;
    ContentBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    renderingCtrl.addBinding(new ContentBinding(renderingCtrl, renderingCtrl.container, observerLocator, platform.domQueue, platform, ensureExpression(exprParser, instruction.from, etIsProperty), target, renderingCtrl.strict ?? false));
  }
});
const IListenerBindingOptions = createInterface("IListenerBindingOptions", (x2) => x2.singleton(class {
  constructor() {
    this.p = resolve(IPlatform);
    this.prevent = false;
    this.onError = (event, error2) => {
      const errorEvent = new this.p.CustomEvent("au-event-error", { cancelable: true, detail: { event, error: error2 } });
      this.p.window.dispatchEvent(errorEvent);
      if (errorEvent.defaultPrevented) {
        return;
      }
      throw error2;
    };
  }
}));
const ListenerBindingRenderer = /* @__PURE__ */ renderer(class ListenerBindingRenderer2 {
  constructor() {
    this.target = InstructionType.listenerBinding;
    this._modifierHandler = resolve(IEventModifier);
    this._defaultOptions = resolve(IListenerBindingOptions);
    ListenerBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser) {
    renderingCtrl.addBinding(new ListenerBinding(renderingCtrl.container, ensureExpression(exprParser, instruction.from, etIsFunction), target, instruction.to, new ListenerBindingOptions(this._defaultOptions.prevent, instruction.capture, this._defaultOptions.onError), this._modifierHandler.getHandler(instruction.to, instruction.modifier), renderingCtrl.strict ?? false));
  }
});
const SetAttributeRenderer = /* @__PURE__ */ renderer(class SetAttributeRenderer2 {
  constructor() {
    this.target = InstructionType.setAttribute;
  }
  render(_2, target, instruction) {
    target.setAttribute(instruction.to, instruction.value);
  }
});
const SetClassAttributeRenderer = /* @__PURE__ */ renderer(class SetClassAttributeRenderer2 {
  constructor() {
    this.target = InstructionType.setClassAttribute;
  }
  render(_2, target, instruction) {
    addClasses(target.classList, instruction.value);
  }
});
const SetStyleAttributeRenderer = /* @__PURE__ */ renderer(class SetStyleAttributeRenderer2 {
  constructor() {
    this.target = InstructionType.setStyleAttribute;
  }
  render(_2, target, instruction) {
    target.style.cssText += instruction.value;
  }
});
const ambiguousStyles = [
  "height",
  "width",
  "border-width",
  "padding",
  "padding-left",
  "padding-right",
  "padding-top",
  "padding-right",
  "padding-inline",
  "padding-block",
  "margin",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-bottom",
  "margin-inline",
  "margin-block",
  "top",
  "right",
  "bottom",
  "left"
];
const StylePropertyBindingRenderer = /* @__PURE__ */ renderer(class StylePropertyBindingRenderer2 {
  constructor() {
    this.target = InstructionType.stylePropertyBinding;
    PropertyBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    {
      if (ambiguousStyles.includes(instruction.to)) {
        renderingCtrl.addBinding(new DevStylePropertyBinding(renderingCtrl, renderingCtrl.container, observerLocator, platform.domQueue, ensureExpression(exprParser, instruction.from, etIsProperty), target.style, instruction.to, toView, renderingCtrl.strict ?? false));
        return;
      }
    }
    renderingCtrl.addBinding(new PropertyBinding(renderingCtrl, renderingCtrl.container, observerLocator, platform.domQueue, ensureExpression(exprParser, instruction.from, etIsProperty), target.style, instruction.to, toView, renderingCtrl.strict ?? false));
  }
});
class DevStylePropertyBinding extends PropertyBinding {
  updateTarget(value) {
    if (typeof value === "number" && value > 0) {
      console.warn(`[DEV]: Setting number ${value} as value for style.${this.targetProperty}. Did you meant "${value}px"?`);
    }
    return super.updateTarget(value);
  }
}
const AttributeBindingRenderer = /* @__PURE__ */ renderer(class AttributeBindingRenderer2 {
  constructor() {
    this.target = InstructionType.attributeBinding;
    AttributeBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const container = renderingCtrl.container;
    const classMapping = container.has(ICssClassMapping, false) ? container.get(ICssClassMapping) : null;
    renderingCtrl.addBinding(new AttributeBinding(renderingCtrl, container, observerLocator, platform.domQueue, ensureExpression(exprParser, instruction.from, etIsProperty), target, instruction.attr, classMapping == null ? instruction.to : instruction.to.split(/\s/g).map((c2) => classMapping[c2] ?? c2).join(" "), toView, renderingCtrl.strict ?? false));
  }
});
const SpreadRenderer = /* @__PURE__ */ renderer(class SpreadRenderer2 {
  constructor() {
    this._compiler = resolve(ITemplateCompiler);
    this._rendering = resolve(IRendering);
    this.target = InstructionType.spreadTransferedBinding;
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    SpreadBinding.create(renderingCtrl.container.get(IHydrationContext), target, void 0, this._rendering, this._compiler, platform, exprParser, observerLocator).forEach((b3) => renderingCtrl.addBinding(b3));
  }
});
const SpreadValueRenderer = /* @__PURE__ */ renderer(class SpreadValueRenderer2 {
  constructor() {
    this.target = InstructionType.spreadValueBinding;
    SpreadValueBinding.mix();
  }
  render(renderingCtrl, target, instruction, platform, exprParser, observerLocator) {
    const instructionTarget = instruction.target;
    if (instructionTarget === "$bindables") {
      renderingCtrl.addBinding(new SpreadValueBinding(renderingCtrl, target.viewModel, objectKeys(target.definition.bindables), exprParser.parse(instruction.from, etIsProperty), observerLocator, renderingCtrl.container, platform.domQueue, renderingCtrl.strict ?? false));
    } else {
      throw createMappedError$2(820, instructionTarget);
    }
  }
});
function addClasses(classList, className) {
  const len = className.length;
  let start2 = 0;
  for (let i3 = 0; i3 < len; ++i3) {
    if (className.charCodeAt(i3) === 32) {
      if (i3 !== start2) {
        classList.add(className.slice(start2, i3));
      }
      start2 = i3 + 1;
    } else if (i3 + 1 === len) {
      classList.add(className.slice(start2));
    }
  }
}
const controllerProviderName = "IController";
const instructionProviderName = "IInstruction";
const locationProviderName = "IRenderLocation";
const slotInfoProviderName = "ISlotsInfo";
function createElementContainer(p2, renderingCtrl, host, instruction, location, auSlotsInfo) {
  const ctn = renderingCtrl.container.createChild();
  registerHostNode(ctn, host, p2);
  registerResolver(ctn, IController, new InstanceProvider(controllerProviderName, renderingCtrl));
  registerResolver(ctn, IInstruction, new InstanceProvider(instructionProviderName, instruction));
  registerResolver(ctn, IRenderLocation, location == null ? noLocationProvider : new RenderLocationProvider(location));
  registerResolver(ctn, IViewFactory, noViewFactoryProvider);
  registerResolver(ctn, IAuSlotsInfo, auSlotsInfo == null ? noAuSlotProvider : new InstanceProvider(slotInfoProviderName, auSlotsInfo));
  return ctn;
}
class ViewFactoryProvider {
  get $isResolver() {
    return true;
  }
  constructor(factory) {
    this.f = factory;
  }
  resolve() {
    const f2 = this.f;
    if (f2 === null) {
      throw createMappedError$2(
        755
        /* ErrorNames.view_factory_provider_not_ready */
      );
    }
    if (!isString(f2.name) || f2.name.length === 0) {
      throw createMappedError$2(
        756
        /* ErrorNames.view_factory_invalid_name */
      );
    }
    return f2;
  }
}
function invokeAttribute(p2, definition, $renderingCtrl, host, instruction, viewFactory, location, auSlotsInfo) {
  const renderingCtrl = $renderingCtrl instanceof Controller ? $renderingCtrl : $renderingCtrl.$controller;
  const ctn = renderingCtrl.container.createChild();
  registerHostNode(ctn, host, p2);
  registerResolver(ctn, IController, new InstanceProvider(controllerProviderName, renderingCtrl));
  registerResolver(ctn, IInstruction, new InstanceProvider(instructionProviderName, instruction));
  registerResolver(ctn, IRenderLocation, location == null ? noLocationProvider : new InstanceProvider(locationProviderName, location));
  registerResolver(ctn, IViewFactory, viewFactory == null ? noViewFactoryProvider : new ViewFactoryProvider(viewFactory));
  registerResolver(
    ctn,
    IAuSlotsInfo,
    noAuSlotProvider
  );
  return { vm: ctn.invoke(definition.Type), ctn };
}
class RenderLocationProvider {
  get name() {
    return "IRenderLocation";
  }
  get $isResolver() {
    return true;
  }
  constructor(_location) {
    this._location = _location;
  }
  resolve() {
    return this._location;
  }
}
const noLocationProvider = new RenderLocationProvider(null);
const noViewFactoryProvider = new ViewFactoryProvider(null);
const noAuSlotProvider = new InstanceProvider(slotInfoProviderName, new AuSlotsInfo(emptyArray));
const IRendering = /* @__PURE__ */ createInterface("IRendering", (x2) => x2.singleton(Rendering));
class Rendering {
  get renderers() {
    return this._renderers ??= this._ctn.getAll(IRenderer, false).reduce((all2, r2) => {
      {
        if (all2[r2.target] !== void 0) {
          console.warn(`[DEV:aurelia] Renderer for target ${r2.target} already exists.`);
        }
      }
      all2[r2.target] ??= r2;
      return all2;
    }, createLookup$1());
  }
  constructor() {
    this._compilationCache = /* @__PURE__ */ new WeakMap();
    this._fragmentCache = /* @__PURE__ */ new WeakMap();
    const ctn = this._ctn = resolve(IContainer).root;
    const p2 = this._platform = ctn.get(IPlatform);
    this._exprParser = ctn.get(IExpressionParser);
    this._observerLocator = ctn.get(IObserverLocator);
    this._marker = p2.document.createElement("au-m");
    this._empty = new FragmentNodeSequence(p2, p2.document.createDocumentFragment());
  }
  compile(definition, container) {
    const compiler = container.get(ITemplateCompiler);
    const compiledMap = this._compilationCache;
    let compiled = compiledMap.get(definition);
    if (compiled == null) {
      compiledMap.set(definition, compiled = CustomElementDefinition.create(definition.needsCompile ? compiler.compile(definition, container) : definition));
    }
    return compiled;
  }
  getViewFactory(definition, container) {
    return new ViewFactory(container, CustomElementDefinition.getOrCreate(definition));
  }
  createNodes(definition) {
    if (definition.enhance === true) {
      return new FragmentNodeSequence(this._platform, this._transformMarker(definition.template));
    }
    let fragment;
    let needsImportNode = false;
    const cache2 = this._fragmentCache;
    const p2 = this._platform;
    const doc = p2.document;
    if (cache2.has(definition)) {
      fragment = cache2.get(definition);
    } else {
      const template2 = definition.template;
      let tpl;
      if (template2 == null) {
        fragment = null;
      } else if (template2 instanceof p2.Node) {
        if (template2.nodeName === "TEMPLATE") {
          fragment = template2.content;
          needsImportNode = true;
        } else {
          (fragment = doc.createDocumentFragment()).appendChild(template2.cloneNode(true));
        }
      } else {
        tpl = doc.createElement("template");
        if (isString(template2)) {
          tpl.innerHTML = template2;
        }
        fragment = tpl.content;
        needsImportNode = true;
      }
      this._transformMarker(fragment);
      cache2.set(definition, fragment);
    }
    return fragment == null ? this._empty : new FragmentNodeSequence(this._platform, needsImportNode ? doc.importNode(fragment, true) : doc.adoptNode(fragment.cloneNode(true)));
  }
  render(controller, targets, definition, host) {
    const rows = definition.instructions;
    const renderers = this.renderers;
    const ii = targets.length;
    let i3 = 0;
    let j2 = 0;
    let jj = rows.length;
    let row;
    let instruction;
    let target;
    if (ii !== jj) {
      throw createMappedError$2(757, ii, jj);
    }
    if (ii > 0) {
      while (ii > i3) {
        row = rows[i3];
        target = targets[i3];
        j2 = 0;
        jj = row.length;
        while (jj > j2) {
          instruction = row[j2];
          renderers[instruction.type].render(controller, target, instruction, this._platform, this._exprParser, this._observerLocator);
          ++j2;
        }
        ++i3;
      }
    }
    if (host != null) {
      row = definition.surrogates;
      if ((jj = row.length) > 0) {
        j2 = 0;
        while (jj > j2) {
          instruction = row[j2];
          renderers[instruction.type].render(controller, host, instruction, this._platform, this._exprParser, this._observerLocator);
          ++j2;
        }
      }
    }
  }
  /** @internal */
  _transformMarker(fragment) {
    if (fragment == null) {
      return null;
    }
    const walker = this._platform.document.createTreeWalker(
      fragment,
      /* NodeFilter.SHOW_COMMENT */
      128
    );
    let currentNode;
    while ((currentNode = walker.nextNode()) != null) {
      if (currentNode.nodeValue === "au*") {
        currentNode.parentNode.replaceChild(walker.currentNode = this._marker.cloneNode(), currentNode);
      }
    }
    return fragment;
  }
}
const IShadowDOMStyles = /* @__PURE__ */ createInterface("IShadowDOMStyles");
const IShadowDOMGlobalStyles = /* @__PURE__ */ createInterface("IShadowDOMGlobalStyles", (x2) => x2.instance({ applyTo: noop$1 }));
const { enter, exit } = ConnectableSwitcher;
const { wrap, unwrap } = ProxyObservable;
class ComputedWatcher {
  get value() {
    return this._value;
  }
  constructor(obj, observerLocator, $get, cb, useProxy) {
    this.obj = obj;
    this.$get = $get;
    this.useProxy = useProxy;
    this.isBound = false;
    this.running = false;
    this._value = void 0;
    this._callback = cb;
    this.oL = observerLocator;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  bind() {
    if (this.isBound) {
      return;
    }
    this.compute();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    this.obs.clearAll();
  }
  run() {
    if (!this.isBound || this.running) {
      return;
    }
    const obj = this.obj;
    const oldValue = this._value;
    const newValue = this.compute();
    if (!areEqual(newValue, oldValue)) {
      this._callback.call(obj, newValue, oldValue, obj);
    }
  }
  compute() {
    this.running = true;
    this.obs.version++;
    try {
      enter(this);
      return this._value = unwrap(this.$get.call(void 0, this.useProxy ? wrap(this.obj) : this.obj, this));
    } finally {
      this.obs.clear();
      this.running = false;
      exit(this);
    }
  }
}
(() => {
  connectable(ComputedWatcher, null);
})();
class ExpressionWatcher {
  get value() {
    return this._value;
  }
  constructor(scope, l2, oL, expression, callback) {
    this.scope = scope;
    this.l = l2;
    this.oL = oL;
    this.isBound = false;
    this.boundFn = false;
    this.obj = scope.bindingContext;
    this._expression = expression;
    this._callback = callback;
  }
  handleChange(value) {
    const expr = this._expression;
    const obj = this.obj;
    const oldValue = this._value;
    const canOptimize = expr.$kind === "AccessScope" && this.obs.count === 1;
    if (!canOptimize) {
      this.obs.version++;
      value = astEvaluate(expr, this.scope, this, this);
      this.obs.clear();
    }
    if (!areEqual(value, oldValue)) {
      this._value = value;
      this._callback.call(obj, value, oldValue, obj);
    }
  }
  bind() {
    if (this.isBound) {
      return;
    }
    this.obs.version++;
    this._value = astEvaluate(this._expression, this.scope, this, this);
    this.obs.clear();
    this.isBound = true;
  }
  unbind() {
    if (!this.isBound) {
      return;
    }
    this.isBound = false;
    this.obs.clearAll();
    this._value = void 0;
  }
}
(() => {
  connectable(ExpressionWatcher, null);
  mixinAstEvaluator(ExpressionWatcher);
})();
class Controller {
  get lifecycleHooks() {
    return this._lifecycleHooks;
  }
  get isActive() {
    return (this.state & (activating | activated)) > 0 && (this.state & deactivating) === 0;
  }
  get name() {
    if (this.parent === null) {
      switch (this.vmKind) {
        case vmkCa:
          return `[${this.definition.name}]`;
        case vmkCe:
          return this.definition.name;
        case vmkSynth:
          return this.viewFactory.name;
      }
    }
    switch (this.vmKind) {
      case vmkCa:
        return `${this.parent.name}>[${this.definition.name}]`;
      case vmkCe:
        return `${this.parent.name}>${this.definition.name}`;
      case vmkSynth:
        return this.viewFactory.name === this.parent.definition?.name ? `${this.parent.name}[view]` : `${this.parent.name}[view:${this.viewFactory.name}]`;
    }
  }
  get viewModel() {
    return this._vm;
  }
  set viewModel(v2) {
    this._vm = v2;
    this._vmHooks = v2 == null || this.vmKind === vmkSynth ? HooksDefinition.none : new HooksDefinition(v2);
  }
  get strict() {
    return this.definition?.strict;
  }
  constructor(container, vmKind, definition, viewFactory, viewModel, host, location) {
    this.container = container;
    this.vmKind = vmKind;
    this.definition = definition;
    this.viewFactory = viewFactory;
    this.host = host;
    this.head = null;
    this.tail = null;
    this.next = null;
    this.parent = null;
    this.bindings = null;
    this.children = null;
    this.hasLockedScope = false;
    this.scope = null;
    this.isBound = false;
    this._isBindingDone = false;
    this.hostController = null;
    this.mountTarget = targetNone;
    this.shadowRoot = null;
    this.nodes = null;
    this.location = null;
    this._lifecycleHooks = null;
    this.state = none;
    this._fullyNamed = false;
    this.$initiator = null;
    this.$resolve = void 0;
    this.$reject = void 0;
    this.$promise = void 0;
    this._activatingStack = 0;
    this._detachingStack = 0;
    this._unbindingStack = 0;
    this._vm = viewModel;
    this._vmHooks = vmKind === vmkSynth ? HooksDefinition.none : new HooksDefinition(viewModel);
    {
      this.logger = null;
      this.debug = false;
    }
    this.location = location;
    this._rendering = container.root.get(IRendering);
    this.coercion = vmKind === vmkSynth ? void 0 : container.get(optionalCoercionConfigResolver);
  }
  static getCached(viewModel) {
    return controllerLookup.get(viewModel);
  }
  static getCachedOrThrow(viewModel) {
    const $el = Controller.getCached(viewModel);
    if ($el === void 0) {
      throw createMappedError$2(500, viewModel);
    }
    return $el;
  }
  /**
   * Create a controller for a custom element based on a given set of parameters
   *
   * @param ctn - The own container of the custom element
   * @param viewModel - The view model object (can be any object if a definition is specified)
   *
   * Semi private API
   */
  static $el(ctn, viewModel, host, hydrationInst, definition = void 0, location = null) {
    if (controllerLookup.has(viewModel)) {
      return controllerLookup.get(viewModel);
    }
    {
      if (definition == null) {
        try {
          definition = getElementDefinition(viewModel.constructor);
        } catch (ex) {
          console.error(`[DEV:aurelia] Custom element definition not found for creating a controller with host: <${host.nodeName} /> and component ${viewModel.constructor.name || "(Anonymous) class"}`);
          throw ex;
        }
      }
    }
    registerResolver(ctn, definition.Type, new InstanceProvider(definition.key, viewModel, definition.Type));
    const controller = new Controller(
      /* container      */
      ctn,
      /* vmKind         */
      vmkCe,
      /* definition     */
      definition,
      /* viewFactory    */
      null,
      /* viewModel      */
      viewModel,
      /* host           */
      host,
      /* location       */
      location
    );
    const hydrationContext = ctn.get(optional(IHydrationContext));
    if (definition.dependencies.length > 0) {
      ctn.register(...definition.dependencies);
    }
    registerResolver(ctn, IHydrationContext, new InstanceProvider("IHydrationContext", new HydrationContext(controller, hydrationInst, hydrationContext)));
    controllerLookup.set(viewModel, controller);
    if (hydrationInst == null || hydrationInst.hydrate !== false) {
      controller._hydrateCustomElement(hydrationInst);
    }
    return controller;
  }
  /**
   * Create a controller for a custom attribute based on a given set of parameters
   *
   * @param ctn - own container associated with the custom attribute object
   * @param viewModel - the view model object
   * @param host - host element where this custom attribute is used
   * @param flags - todo(comment)
   * @param definition - the definition of the custom attribute,
   * will be used to override the definition associated with the view model object contructor if given
   */
  static $attr(ctn, viewModel, host, definition) {
    if (controllerLookup.has(viewModel)) {
      return controllerLookup.get(viewModel);
    }
    definition = definition ?? getAttributeDefinition(viewModel.constructor);
    registerResolver(ctn, definition.Type, new InstanceProvider(definition.key, viewModel, definition.Type));
    const controller = new Controller(
      /* own ct         */
      ctn,
      /* vmKind         */
      vmkCa,
      /* definition     */
      definition,
      /* viewFactory    */
      null,
      /* viewModel      */
      viewModel,
      /* host           */
      host,
      /* location       */
      null
    );
    if (definition.dependencies.length > 0) {
      ctn.register(...definition.dependencies);
    }
    controllerLookup.set(viewModel, controller);
    controller._hydrateCustomAttribute();
    return controller;
  }
  /**
   * Create a synthetic view (controller) for a given factory
   *
   * @param viewFactory - todo(comment)
   * @param flags - todo(comment)
   * @param parentController - the parent controller to connect the created view with. Used in activation
   *
   * Semi private API
   */
  static $view(viewFactory, parentController = void 0) {
    const controller = new Controller(
      /* container      */
      viewFactory.container,
      /* vmKind         */
      vmkSynth,
      /* definition     */
      null,
      /* viewFactory    */
      viewFactory,
      /* viewModel      */
      null,
      /* host           */
      null,
      /* location       */
      null
    );
    controller.parent = parentController ?? null;
    controller._hydrateSynthetic();
    return controller;
  }
  /** @internal */
  _hydrateCustomElement(hydrationInst) {
    {
      this.logger = this.container.get(ILogger).root;
      this.debug = this.logger.config.level <= LogLevel.debug;
      if (this.debug) {
        this.logger = this.logger.scopeTo(this.name);
      }
    }
    const container = this.container;
    const instance = this._vm;
    const definition = this.definition;
    this.scope = Scope.create(instance, null, true);
    if (definition.watches.length > 0) {
      createWatchers(this, container, definition, instance);
    }
    createObservers(this, definition, instance);
    this._lifecycleHooks = LifecycleHooks.resolve(container);
    container.register(definition.Type);
    if (definition.injectable !== null) {
      registerResolver(container, definition.injectable, new InstanceProvider("definition.injectable", instance));
    }
    if (hydrationInst == null || hydrationInst.hydrate !== false) {
      this._hydrate(hydrationInst?.hostController);
      this._hydrateChildren();
    }
  }
  /** @internal */
  _hydrate(hostController) {
    if (this._lifecycleHooks.hydrating != null) {
      this._lifecycleHooks.hydrating.forEach(callHydratingHook, this);
    }
    if (this._vmHooks._hydrating) {
      if (this.debug) {
        this.logger.trace(`invoking hydrating() hook`);
      }
      this._vm.hydrating(this);
    }
    const definition = this.definition;
    const compiledDef = this._compiledDef = this._rendering.compile(definition, this.container);
    const shadowOptions = compiledDef.shadowOptions;
    const hasSlots = compiledDef.hasSlots;
    const containerless = compiledDef.containerless;
    let host = this.host;
    let location = this.location;
    let createLocation2 = false;
    if (hostController != null) {
      this.hostController = hostController;
      createLocation2 = true;
    } else if ((this.hostController = findElementControllerFor(host, optionalCeFind)) !== null) {
      host = this.host = this.container.root.get(IPlatform).document.createElement(definition.name);
      createLocation2 = true;
    }
    if (createLocation2 && containerless && location == null) {
      location = this.location = convertToRenderLocation(host);
    }
    setRef(host, elementBaseName, this);
    setRef(host, definition.key, this);
    if (shadowOptions !== null || hasSlots) {
      if (location != null) {
        throw createMappedError$2(
          501
          /* ErrorNames.controller_no_shadow_on_containerless */
        );
      }
      setRef(this.shadowRoot = host.attachShadow(shadowOptions ?? defaultShadowOptions), elementBaseName, this);
      setRef(this.shadowRoot, definition.key, this);
      this.mountTarget = targetShadowRoot;
    } else if (location != null) {
      setRef(location, elementBaseName, this);
      setRef(location, definition.key, this);
      this.mountTarget = targetLocation;
    } else {
      this.mountTarget = targetHost;
    }
    this._vm.$controller = this;
    this.nodes = this._rendering.createNodes(compiledDef);
    if (this._lifecycleHooks.hydrated !== void 0) {
      this._lifecycleHooks.hydrated.forEach(callHydratedHook, this);
    }
    if (this._vmHooks._hydrated) {
      if (this.debug) {
        this.logger.trace(`invoking hydrated() hook`);
      }
      this._vm.hydrated(this);
    }
  }
  /** @internal */
  _hydrateChildren() {
    this._rendering.render(
      /* controller */
      this,
      /* targets    */
      this.nodes.findTargets(),
      /* definition */
      this._compiledDef,
      /* host       */
      this.host
    );
    if (this._lifecycleHooks.created !== void 0) {
      this._lifecycleHooks.created.forEach(callCreatedHook, this);
    }
    if (this._vmHooks._created) {
      if (this.debug) {
        this.logger.trace(`invoking created() hook`);
      }
      this._vm.created(this);
    }
  }
  /** @internal */
  _hydrateCustomAttribute() {
    const definition = this.definition;
    const instance = this._vm;
    if (definition.watches.length > 0) {
      createWatchers(this, this.container, definition, instance);
    }
    createObservers(this, definition, instance);
    instance.$controller = this;
    this._lifecycleHooks = LifecycleHooks.resolve(this.container);
    if (this._lifecycleHooks.created !== void 0) {
      this._lifecycleHooks.created.forEach(callCreatedHook, this);
    }
    if (this._vmHooks._created) {
      if (this.debug) {
        this.logger.trace(`invoking created() hook`);
      }
      this._vm.created(this);
    }
  }
  /** @internal */
  _hydrateSynthetic() {
    this._compiledDef = this._rendering.compile(this.viewFactory.def, this.container);
    this._rendering.render(
      /* controller */
      this,
      /* targets    */
      (this.nodes = this._rendering.createNodes(this._compiledDef)).findTargets(),
      /* definition */
      this._compiledDef,
      /* host       */
      void 0
    );
  }
  activate(initiator, parent, scope) {
    switch (this.state) {
      case none:
      case deactivated:
        if (!(parent === null || parent.isActive)) {
          return;
        }
        this.state = activating;
        break;
      case activated:
        return;
      case disposed:
        throw createMappedError$2(502, this.name);
      default:
        throw createMappedError$2(503, this.name, stringifyState$1(this.state));
    }
    this.parent = parent;
    if (this.debug && !this._fullyNamed) {
      this._fullyNamed = true;
      (this.logger ??= this.container.get(ILogger).root.scopeTo(this.name)).trace(`activate()`);
    }
    switch (this.vmKind) {
      case vmkCe:
        this.scope.parent = scope ?? null;
        break;
      case vmkCa:
        this.scope = scope ?? null;
        break;
      case vmkSynth:
        if (scope === void 0 || scope === null) {
          throw createMappedError$2(504, this.name);
        }
        if (!this.hasLockedScope) {
          this.scope = scope;
        }
        break;
    }
    this.$initiator = initiator;
    this._enterActivating();
    let ret = void 0;
    if (this.vmKind !== vmkSynth && this._lifecycleHooks.binding != null) {
      if (this.debug) {
        this.logger.trace(`lifecycleHooks.binding()`);
      }
      ret = onResolveAll(...this._lifecycleHooks.binding.map(callBindingHook, this));
    }
    if (this._vmHooks._binding) {
      if (this.debug) {
        this.logger.trace(`binding()`);
      }
      ret = onResolveAll(ret, this._vm.binding(this.$initiator, this.parent));
    }
    if (isPromise(ret)) {
      this._ensurePromise();
      ret.then(() => {
        this._isBindingDone = true;
        if (this.state !== activating) {
          this._leaveActivating();
        } else {
          this.bind();
        }
      }).catch((err) => {
        this._reject(err);
      });
      return this.$promise;
    }
    this._isBindingDone = true;
    this.bind();
    return this.$promise;
  }
  bind() {
    if (this.debug) {
      this.logger.trace(`bind()`);
    }
    let i3 = 0;
    let ii = 0;
    let ret = void 0;
    if (this.bindings !== null) {
      i3 = 0;
      ii = this.bindings.length;
      while (ii > i3) {
        this.bindings[i3].bind(this.scope);
        ++i3;
      }
    }
    if (this.vmKind !== vmkSynth && this._lifecycleHooks.bound != null) {
      if (this.debug) {
        this.logger.trace(`lifecycleHooks.bound()`);
      }
      ret = onResolveAll(...this._lifecycleHooks.bound.map(callBoundHook, this));
    }
    if (this._vmHooks._bound) {
      if (this.debug) {
        this.logger.trace(`bound()`);
      }
      ret = onResolveAll(ret, this._vm.bound(this.$initiator, this.parent));
    }
    if (isPromise(ret)) {
      this._ensurePromise();
      ret.then(() => {
        this.isBound = true;
        if (this.state !== activating) {
          this._leaveActivating();
        } else {
          this._attach();
        }
      }).catch((err) => {
        this._reject(err);
      });
      return;
    }
    this.isBound = true;
    this._attach();
  }
  /** @internal */
  _append(...nodes) {
    switch (this.mountTarget) {
      case targetHost:
        this.host.append(...nodes);
        break;
      case targetShadowRoot:
        this.shadowRoot.append(...nodes);
        break;
      case targetLocation: {
        let i3 = 0;
        for (; i3 < nodes.length; ++i3) {
          this.location.parentNode.insertBefore(nodes[i3], this.location);
        }
        break;
      }
    }
  }
  /** @internal */
  _attach() {
    if (this.debug) {
      this.logger.trace(`attach()`);
    }
    if (this.hostController !== null) {
      switch (this.mountTarget) {
        case targetHost:
        case targetShadowRoot:
          this.hostController._append(this.host);
          break;
        case targetLocation:
          this.hostController._append(this.location.$start, this.location);
          break;
      }
    }
    switch (this.mountTarget) {
      case targetHost:
        this.nodes.appendTo(this.host, this.definition != null && this.definition.enhance);
        break;
      case targetShadowRoot: {
        const container = this.container;
        const styles2 = container.has(IShadowDOMStyles, false) ? container.get(IShadowDOMStyles) : container.get(IShadowDOMGlobalStyles);
        styles2.applyTo(this.shadowRoot);
        this.nodes.appendTo(this.shadowRoot);
        break;
      }
      case targetLocation:
        this.nodes.insertBefore(this.location);
        break;
    }
    let i3 = 0;
    let ret = void 0;
    if (this.vmKind !== vmkSynth && this._lifecycleHooks.attaching != null) {
      if (this.debug) {
        this.logger.trace(`lifecycleHooks.attaching()`);
      }
      ret = onResolveAll(...this._lifecycleHooks.attaching.map(callAttachingHook, this));
    }
    if (this._vmHooks._attaching) {
      if (this.debug) {
        this.logger.trace(`attaching()`);
      }
      ret = onResolveAll(ret, this._vm.attaching(this.$initiator, this.parent));
    }
    if (isPromise(ret)) {
      this._ensurePromise();
      this._enterActivating();
      ret.then(() => {
        this._leaveActivating();
      }).catch((err) => {
        this._reject(err);
      });
    }
    if (this.children !== null) {
      for (; i3 < this.children.length; ++i3) {
        void this.children[i3].activate(this.$initiator, this, this.scope);
      }
    }
    this._leaveActivating();
  }
  deactivate(initiator, _parent) {
    let prevActivation = void 0;
    switch (this.state & ~released) {
      case activated:
        this.state = deactivating;
        break;
      case activating:
        this.state = deactivating;
        prevActivation = this.$promise?.catch(
          (err) => {
            this.logger.warn("The activation error will be ignored, as the controller is already scheduled for deactivation. The activation was rejected with: %s", err);
          }
        );
        break;
      case none:
      case deactivated:
      case disposed:
      case deactivated | disposed:
        return;
      default:
        throw createMappedError$2(505, this.name, this.state);
    }
    if (this.debug) {
      this.logger.trace(`deactivate()`);
    }
    this.$initiator = initiator;
    if (initiator === this) {
      this._enterDetaching();
    }
    let i3 = 0;
    let ret;
    if (this.children !== null) {
      for (i3 = 0; i3 < this.children.length; ++i3) {
        void this.children[i3].deactivate(initiator, this);
      }
    }
    return onResolve(prevActivation, () => {
      if (this.isBound) {
        if (this.vmKind !== vmkSynth && this._lifecycleHooks.detaching != null) {
          if (this.debug) {
            this.logger.trace(`lifecycleHooks.detaching()`);
          }
          ret = onResolveAll(...this._lifecycleHooks.detaching.map(callDetachingHook, this));
        }
        if (this._vmHooks._detaching) {
          if (this.debug) {
            this.logger.trace(`detaching()`);
          }
          ret = onResolveAll(ret, this._vm.detaching(this.$initiator, this.parent));
        }
      }
      if (isPromise(ret)) {
        this._ensurePromise();
        initiator._enterDetaching();
        ret.then(() => {
          initiator._leaveDetaching();
        }).catch((err) => {
          initiator._reject(err);
        });
      }
      if (initiator.head === null) {
        initiator.head = this;
      } else {
        initiator.tail.next = this;
      }
      initiator.tail = this;
      if (initiator !== this) {
        return;
      }
      this._leaveDetaching();
      return this.$promise;
    });
  }
  removeNodes() {
    switch (this.vmKind) {
      case vmkCe:
      case vmkSynth:
        this.nodes.remove();
        this.nodes.unlink();
    }
    if (this.hostController !== null) {
      switch (this.mountTarget) {
        case targetHost:
        case targetShadowRoot:
          this.host.remove();
          break;
        case targetLocation:
          this.location.$start.remove();
          this.location.remove();
          break;
      }
    }
  }
  unbind() {
    if (this.debug) {
      this.logger.trace(`unbind()`);
    }
    let i3 = 0;
    if (this.bindings !== null) {
      for (; i3 < this.bindings.length; ++i3) {
        this.bindings[i3].unbind();
      }
    }
    this.parent = null;
    switch (this.vmKind) {
      case vmkCa:
        this.scope = null;
        break;
      case vmkSynth:
        if (!this.hasLockedScope) {
          this.scope = null;
        }
        if ((this.state & released) === released && !this.viewFactory.tryReturnToCache(this) && this.$initiator === this) {
          this.dispose();
        }
        break;
      case vmkCe:
        this.scope.parent = null;
        break;
    }
    this.state = deactivated;
    this.$initiator = null;
    this._resolve();
  }
  /** @internal */
  _ensurePromise() {
    if (this.$promise === void 0) {
      this.$promise = new Promise((resolve2, reject) => {
        this.$resolve = resolve2;
        this.$reject = reject;
      });
      if (this.$initiator !== this) {
        this.parent._ensurePromise();
      }
    }
  }
  /** @internal */
  _resolve() {
    if (this.$promise !== void 0) {
      _resolve = this.$resolve;
      this.$resolve = this.$reject = this.$promise = void 0;
      _resolve();
      _resolve = void 0;
    }
  }
  /** @internal */
  _reject(err) {
    if (this.$promise !== void 0) {
      _reject = this.$reject;
      this.$resolve = this.$reject = this.$promise = void 0;
      _reject(err);
      _reject = void 0;
    }
    if (this.$initiator !== this) {
      this.parent._reject(err);
    }
  }
  /** @internal */
  _enterActivating() {
    ++this._activatingStack;
    if (this.$initiator !== this) {
      this.parent._enterActivating();
    }
  }
  /** @internal */
  _leaveActivating() {
    if (this.state !== activating) {
      --this._activatingStack;
      this._resolve();
      if (this.$initiator !== this) {
        this.parent._leaveActivating();
      }
      return;
    }
    if (--this._activatingStack === 0) {
      if (this.vmKind !== vmkSynth && this._lifecycleHooks.attached != null) {
        _retPromise = onResolveAll(...this._lifecycleHooks.attached.map(callAttachedHook, this));
      }
      if (this._vmHooks._attached) {
        if (this.debug) {
          this.logger.trace(`attached()`);
        }
        _retPromise = onResolveAll(_retPromise, this._vm.attached(this.$initiator));
      }
      if (isPromise(_retPromise)) {
        this._ensurePromise();
        _retPromise.then(() => {
          this.state = activated;
          this._resolve();
          if (this.$initiator !== this) {
            this.parent._leaveActivating();
          }
        }).catch((err) => {
          this._reject(err);
        });
        _retPromise = void 0;
        return;
      }
      _retPromise = void 0;
      this.state = activated;
      this._resolve();
    }
    if (this.$initiator !== this) {
      this.parent._leaveActivating();
    }
  }
  /** @internal */
  _enterDetaching() {
    ++this._detachingStack;
  }
  /** @internal */
  _leaveDetaching() {
    if (--this._detachingStack === 0) {
      if (this.debug) {
        this.logger.trace(`detach()`);
      }
      this._enterUnbinding();
      this.removeNodes();
      let cur = this.$initiator.head;
      let ret = void 0;
      while (cur !== null) {
        if (cur !== this) {
          if (cur.debug) {
            cur.logger.trace(`detach()`);
          }
          cur.removeNodes();
        }
        if (cur._isBindingDone) {
          if (cur.vmKind !== vmkSynth && cur._lifecycleHooks.unbinding != null) {
            ret = onResolveAll(...cur._lifecycleHooks.unbinding.map(callUnbindingHook, cur));
          }
          if (cur._vmHooks._unbinding) {
            if (cur.debug) {
              cur.logger.trace("unbinding()");
            }
            ret = onResolveAll(ret, cur.viewModel.unbinding(cur.$initiator, cur.parent));
          }
        }
        if (isPromise(ret)) {
          this._ensurePromise();
          this._enterUnbinding();
          ret.then(() => {
            this._leaveUnbinding();
          }).catch((err) => {
            this._reject(err);
          });
        }
        ret = void 0;
        cur = cur.next;
      }
      this._leaveUnbinding();
    }
  }
  /** @internal */
  _enterUnbinding() {
    ++this._unbindingStack;
  }
  /** @internal */
  _leaveUnbinding() {
    if (--this._unbindingStack === 0) {
      if (this.debug) {
        this.logger.trace(`unbind()`);
      }
      let cur = this.$initiator.head;
      let next = null;
      while (cur !== null) {
        if (cur !== this) {
          cur._isBindingDone = false;
          cur.isBound = false;
          cur.unbind();
        }
        next = cur.next;
        cur.next = null;
        cur = next;
      }
      this.head = this.tail = null;
      this._isBindingDone = false;
      this.isBound = false;
      this.unbind();
    }
  }
  addBinding(binding) {
    if (this.bindings === null) {
      this.bindings = [binding];
    } else {
      this.bindings[this.bindings.length] = binding;
    }
  }
  addChild(controller) {
    if (this.children === null) {
      this.children = [controller];
    } else {
      this.children[this.children.length] = controller;
    }
  }
  is(name2) {
    switch (this.vmKind) {
      case vmkCa:
      case vmkCe: {
        return this.definition.name === name2;
      }
      case vmkSynth:
        return this.viewFactory.name === name2;
    }
  }
  lockScope(scope) {
    this.scope = scope;
    this.hasLockedScope = true;
  }
  setHost(host) {
    if (this.vmKind === vmkCe) {
      setRef(host, elementBaseName, this);
      setRef(host, this.definition.key, this);
    }
    this.host = host;
    this.mountTarget = targetHost;
    return this;
  }
  setShadowRoot(shadowRoot) {
    if (this.vmKind === vmkCe) {
      setRef(shadowRoot, elementBaseName, this);
      setRef(shadowRoot, this.definition.key, this);
    }
    this.shadowRoot = shadowRoot;
    this.mountTarget = targetShadowRoot;
    return this;
  }
  setLocation(location) {
    if (this.vmKind === vmkCe) {
      setRef(location, elementBaseName, this);
      setRef(location, this.definition.key, this);
    }
    this.location = location;
    this.mountTarget = targetLocation;
    return this;
  }
  release() {
    this.state |= released;
  }
  dispose() {
    if (this.debug) {
      this.logger.trace(`dispose()`);
    }
    if ((this.state & disposed) === disposed) {
      return;
    }
    this.state |= disposed;
    if (this._vmHooks._dispose) {
      this._vm.dispose();
    }
    if (this.children !== null) {
      this.children.forEach(callDispose);
      this.children = null;
    }
    this.hostController = null;
    this.scope = null;
    this.nodes = null;
    this.location = null;
    this.viewFactory = null;
    if (this._vm !== null) {
      controllerLookup.delete(this._vm);
      this._vm = null;
    }
    this._vm = null;
    this.host = null;
    this.shadowRoot = null;
    this.container.disposeResolvers();
  }
  accept(visitor) {
    if (visitor(this) === true) {
      return true;
    }
    if (this._vmHooks._accept && this._vm.accept(visitor) === true) {
      return true;
    }
    if (this.children !== null) {
      const { children } = this;
      for (let i3 = 0, ii = children.length; i3 < ii; ++i3) {
        if (children[i3].accept(visitor) === true) {
          return true;
        }
      }
    }
  }
}
const controllerLookup = /* @__PURE__ */ new WeakMap();
const targetNone = 0;
const targetHost = 1;
const targetShadowRoot = 2;
const targetLocation = 3;
const MountTarget = objectFreeze({
  none: targetNone,
  host: targetHost,
  shadowRoot: targetShadowRoot,
  location: targetLocation
});
const optionalCeFind = { optional: true };
const optionalCoercionConfigResolver = optionalResource(ICoercionConfiguration);
function createObservers(controller, definition, instance) {
  const bindables2 = definition.bindables;
  const observableNames = getOwnPropertyNames(bindables2);
  const length = observableNames.length;
  const locator = controller.container.get(IObserverLocator);
  const hasAggregatedCallbacks = "propertiesChanged" in instance;
  if (length === 0)
    return;
  const queueCallback = hasAggregatedCallbacks ? (() => {
    let changes = {};
    let promise = void 0;
    let changeCount = 0;
    const resolvedPromise = Promise.resolve();
    const callPropertiesChanged = () => {
      if (promise == null) {
        promise = resolvedPromise.then(() => {
          const $changes = changes;
          changes = {};
          changeCount = 0;
          promise = void 0;
          if (controller.isBound) {
            instance.propertiesChanged?.($changes);
            if (changeCount > 0) {
              callPropertiesChanged();
            }
          }
        });
      }
    };
    return (key, newValue, oldValue) => {
      changes[key] = { newValue, oldValue };
      changeCount++;
      callPropertiesChanged();
    };
  })() : noop$1;
  for (let i3 = 0; i3 < length; ++i3) {
    const name2 = observableNames[i3];
    const bindable2 = bindables2[name2];
    const handler = bindable2.callback;
    const obs = locator.getObserver(instance, name2);
    if (bindable2.set !== noop$1) {
      if (obs.useCoercer?.(bindable2.set, controller.coercion) !== true) {
        throw createMappedError$2(507, name2);
      }
    }
    if (instance[handler] != null || instance.propertyChanged != null || hasAggregatedCallbacks) {
      const callback = (newValue, oldValue) => {
        if (controller.isBound) {
          instance[handler]?.(newValue, oldValue);
          instance.propertyChanged?.(name2, newValue, oldValue);
          queueCallback(name2, newValue, oldValue);
        }
      };
      if (obs.useCallback?.(callback) !== true) {
        throw createMappedError$2(508, name2);
      }
    }
  }
}
const AccessScopeAstMap = /* @__PURE__ */ new Map();
const getAccessScopeAst = (key) => {
  let ast = AccessScopeAstMap.get(key);
  if (ast == null) {
    ast = new AccessScopeExpression(key, 0);
    AccessScopeAstMap.set(key, ast);
  }
  return ast;
};
function createWatchers(controller, context, definition, instance) {
  const observerLocator = context.get(IObserverLocator);
  const expressionParser = context.get(IExpressionParser);
  const watches = definition.watches;
  const scope = controller.vmKind === vmkCe ? controller.scope : Scope.create(instance, null, true);
  const ii = watches.length;
  let expression;
  let callback;
  let ast;
  let i3 = 0;
  for (; ii > i3; ++i3) {
    ({ expression, callback } = watches[i3]);
    callback = isFunction(callback) ? callback : Reflect.get(instance, callback);
    if (!isFunction(callback)) {
      throw createMappedError$2(506, callback);
    }
    if (isFunction(expression)) {
      controller.addBinding(new ComputedWatcher(instance, observerLocator, expression, callback, true));
    } else {
      ast = isString(expression) ? expressionParser.parse(expression, etIsProperty) : getAccessScopeAst(expression);
      controller.addBinding(new ExpressionWatcher(scope, context, observerLocator, ast, callback));
    }
  }
}
function isCustomElementController(value) {
  return value instanceof Controller && value.vmKind === vmkCe;
}
function isCustomElementViewModel(value) {
  return isElementType(value?.constructor);
}
class HooksDefinition {
  constructor(target) {
    this._define = "define" in target;
    this._hydrating = "hydrating" in target;
    this._hydrated = "hydrated" in target;
    this._created = "created" in target;
    this._binding = "binding" in target;
    this._bound = "bound" in target;
    this._attaching = "attaching" in target;
    this._attached = "attached" in target;
    this._detaching = "detaching" in target;
    this._unbinding = "unbinding" in target;
    this._dispose = "dispose" in target;
    this._accept = "accept" in target;
  }
}
HooksDefinition.none = new HooksDefinition({});
const defaultShadowOptions = {
  mode: "open"
};
const vmkCe = "customElement";
const vmkCa = "customAttribute";
const vmkSynth = "synthetic";
const none = 0;
const activating = 1;
const activated = 2;
const deactivating = 4;
const deactivated = 8;
const released = 16;
const disposed = 32;
function stringifyState$1(state) {
  const names = [];
  if ((state & activating) === activating) {
    names.push("activating");
  }
  if ((state & activated) === activated) {
    names.push("activated");
  }
  if ((state & deactivating) === deactivating) {
    names.push("deactivating");
  }
  if ((state & deactivated) === deactivated) {
    names.push("deactivated");
  }
  if ((state & released) === released) {
    names.push("released");
  }
  if ((state & disposed) === disposed) {
    names.push("disposed");
  }
  return names.length === 0 ? "none" : names.join("|");
}
const IController = /* @__PURE__ */ createInterface("IController");
const IHydrationContext = /* @__PURE__ */ createInterface("IHydrationContext");
class HydrationContext {
  constructor(controller, instruction, parent) {
    this.instruction = instruction;
    this.parent = parent;
    this.controller = controller;
  }
}
function callDispose(disposable) {
  disposable.dispose();
}
function callCreatedHook(l2) {
  l2.instance.created(this._vm, this);
}
function callHydratingHook(l2) {
  l2.instance.hydrating(this._vm, this);
}
function callHydratedHook(l2) {
  l2.instance.hydrated(this._vm, this);
}
function callBindingHook(l2) {
  return l2.instance.binding(this._vm, this["$initiator"], this.parent);
}
function callBoundHook(l2) {
  return l2.instance.bound(this._vm, this["$initiator"], this.parent);
}
function callAttachingHook(l2) {
  return l2.instance.attaching(this._vm, this["$initiator"], this.parent);
}
function callAttachedHook(l2) {
  return l2.instance.attached(this._vm, this["$initiator"]);
}
function callDetachingHook(l2) {
  return l2.instance.detaching(this._vm, this["$initiator"], this.parent);
}
function callUnbindingHook(l2) {
  return l2.instance.unbinding(this._vm, this["$initiator"], this.parent);
}
let _resolve;
let _reject;
let _retPromise;
class Refs {
}
function getRef(node, name2) {
  return node.$au?.[name2] ?? null;
}
function setRef(node, name2, controller) {
  (node.$au ??= new Refs())[name2] = controller;
}
const INode = /* @__PURE__ */ createInterface("INode");
const IEventTarget = /* @__PURE__ */ createInterface("IEventTarget", (x2) => x2.cachedCallback((handler) => {
  if (handler.has(IAppRoot, true)) {
    return handler.get(IAppRoot).host;
  }
  return handler.get(IPlatform).document;
}));
const IRenderLocation = /* @__PURE__ */ createInterface("IRenderLocation");
const ICssClassMapping = /* @__PURE__ */ createInterface("ICssClassMapping");
const effectiveParentNodeOverrides = /* @__PURE__ */ new WeakMap();
function getEffectiveParentNode(node) {
  if (effectiveParentNodeOverrides.has(node)) {
    return effectiveParentNodeOverrides.get(node);
  }
  let containerlessOffset = 0;
  let next = node.nextSibling;
  while (next !== null) {
    if (next.nodeType === 8) {
      switch (next.textContent) {
        case "au-start":
          ++containerlessOffset;
          break;
        case "au-end":
          if (containerlessOffset-- === 0) {
            return next;
          }
      }
    }
    next = next.nextSibling;
  }
  if (node.parentNode === null && node.nodeType === 11) {
    const controller = findElementControllerFor(node, { optional: true });
    if (controller == null) {
      return null;
    }
    if (controller.mountTarget === MountTarget.shadowRoot) {
      return getEffectiveParentNode(controller.host);
    }
  }
  return node.parentNode;
}
function setEffectiveParentNode(childNodeOrNodeSequence, parentNode) {
  if (childNodeOrNodeSequence.platform !== void 0 && !(childNodeOrNodeSequence instanceof childNodeOrNodeSequence.platform.Node)) {
    const nodes = childNodeOrNodeSequence.childNodes;
    for (let i3 = 0, ii = nodes.length; i3 < ii; ++i3) {
      effectiveParentNodeOverrides.set(nodes[i3], parentNode);
    }
  } else {
    effectiveParentNodeOverrides.set(childNodeOrNodeSequence, parentNode);
  }
}
function convertToRenderLocation(node) {
  if (isRenderLocation(node)) {
    return node;
  }
  const locationEnd = node.ownerDocument.createComment("au-end");
  const locationStart = locationEnd.$start = node.ownerDocument.createComment("au-start");
  const parentNode = node.parentNode;
  if (parentNode !== null) {
    parentNode.replaceChild(locationEnd, node);
    parentNode.insertBefore(locationStart, locationEnd);
  }
  return locationEnd;
}
function isRenderLocation(node) {
  return node.textContent === "au-end";
}
class FragmentNodeSequence {
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  constructor(platform, fragment) {
    this.platform = platform;
    this.next = void 0;
    this._isMounted = false;
    this._isLinked = false;
    this.ref = null;
    const targetNodeList = (this.f = fragment).querySelectorAll("au-m");
    let i3 = 0;
    let ii = targetNodeList.length;
    let targets = this.t = Array(ii);
    let target;
    let marker;
    while (ii > i3) {
      marker = targetNodeList[i3];
      target = marker.nextSibling;
      marker.remove();
      if (target.nodeType === 8) {
        marker = target;
        (target = target.nextSibling).$start = marker;
      }
      targets[i3] = target;
      ++i3;
    }
    const childNodeList = fragment.childNodes;
    const childNodes = this.childNodes = Array(ii = childNodeList.length);
    i3 = 0;
    while (ii > i3) {
      childNodes[i3] = childNodeList[i3];
      ++i3;
    }
    this._firstChild = fragment.firstChild;
    this._lastChild = fragment.lastChild;
  }
  findTargets() {
    return this.t;
  }
  insertBefore(refNode) {
    if (this._isLinked && !!this.ref) {
      this.addToLinked();
    } else {
      const parent = refNode.parentNode;
      if (this._isMounted) {
        let current = this._firstChild;
        let next;
        const end2 = this._lastChild;
        while (current != null) {
          next = current.nextSibling;
          parent.insertBefore(current, refNode);
          if (current === end2) {
            break;
          }
          current = next;
        }
      } else {
        this._isMounted = true;
        refNode.parentNode.insertBefore(this.f, refNode);
      }
    }
  }
  appendTo(parent, enhance = false) {
    if (this._isMounted) {
      let current = this._firstChild;
      let next;
      const end2 = this._lastChild;
      while (current != null) {
        next = current.nextSibling;
        parent.appendChild(current);
        if (current === end2) {
          break;
        }
        current = next;
      }
    } else {
      this._isMounted = true;
      if (!enhance) {
        parent.appendChild(this.f);
      }
    }
  }
  remove() {
    if (this._isMounted) {
      this._isMounted = false;
      const fragment = this.f;
      const end2 = this._lastChild;
      let next;
      let current = this._firstChild;
      while (current !== null) {
        next = current.nextSibling;
        fragment.appendChild(current);
        if (current === end2) {
          break;
        }
        current = next;
      }
    }
  }
  addToLinked() {
    const refNode = this.ref;
    const parent = refNode.parentNode;
    if (this._isMounted) {
      let current = this._firstChild;
      let next;
      const end2 = this._lastChild;
      while (current != null) {
        next = current.nextSibling;
        parent.insertBefore(current, refNode);
        if (current === end2) {
          break;
        }
        current = next;
      }
    } else {
      this._isMounted = true;
      parent.insertBefore(this.f, refNode);
    }
  }
  unlink() {
    this._isLinked = false;
    this.next = void 0;
    this.ref = void 0;
  }
  link(next) {
    this._isLinked = true;
    if (isRenderLocation(next)) {
      this.ref = next;
    } else {
      this.next = next;
      this._obtainRefNode();
    }
  }
  /** @internal */
  _obtainRefNode() {
    if (this.next !== void 0) {
      this.ref = this.next.firstChild;
    } else {
      this.ref = void 0;
    }
  }
}
const IWindow = /* @__PURE__ */ createInterface("IWindow", (x2) => x2.callback((handler) => handler.get(IPlatform).window));
const ILocation = /* @__PURE__ */ createInterface("ILocation", (x2) => x2.callback((handler) => handler.get(IWindow).location));
const IHistory = /* @__PURE__ */ createInterface("IHistory", (x2) => x2.callback((handler) => handler.get(IWindow).history));
const registerHostNode = (container, host, platform = container.get(IPlatform)) => {
  registerResolver(container, platform.HTMLElement, registerResolver(container, platform.Element, registerResolver(container, INode, new InstanceProvider("ElementResolver", host))));
  return container;
};
function customElement(nameOrDef) {
  return function(target, context) {
    context.addInitializer(function() {
      defineElement(nameOrDef, this);
    });
    return target;
  };
}
const definitionLookup = /* @__PURE__ */ new WeakMap();
class CustomElementDefinition {
  get type() {
    return dtElement;
  }
  constructor(Type, name2, aliases, key, capture, template2, instructions, dependencies2, injectable, needsCompile, surrogates, bindables2, containerless, shadowOptions, hasSlots, enhance, watches, strict, processContent) {
    this.Type = Type;
    this.name = name2;
    this.aliases = aliases;
    this.key = key;
    this.capture = capture;
    this.template = template2;
    this.instructions = instructions;
    this.dependencies = dependencies2;
    this.injectable = injectable;
    this.needsCompile = needsCompile;
    this.surrogates = surrogates;
    this.bindables = bindables2;
    this.containerless = containerless;
    this.shadowOptions = shadowOptions;
    this.hasSlots = hasSlots;
    this.enhance = enhance;
    this.watches = watches;
    this.strict = strict;
    this.processContent = processContent;
  }
  static create(nameOrDef, Type = null) {
    if (Type === null) {
      const def2 = nameOrDef;
      if (isString(def2)) {
        throw createMappedError$2(761, nameOrDef);
      }
      const name3 = fromDefinitionOrDefault("name", def2, generateElementName);
      if (isFunction(def2.Type)) {
        Type = def2.Type;
      } else {
        Type = generateElementType(pascalCase(name3));
      }
      for (const bindable2 of Object.values(Bindable.from(def2.bindables))) {
        Bindable._add(bindable2, Type);
      }
      return new CustomElementDefinition(
        Type,
        name3,
        mergeArrays(def2.aliases),
        fromDefinitionOrDefault("key", def2, () => getElementKeyFrom(name3)),
        fromAnnotationOrDefinitionOrTypeOrDefault("capture", def2, Type, returnFalse),
        fromDefinitionOrDefault("template", def2, returnNull),
        mergeArrays(def2.instructions),
        mergeArrays(getElementAnnotation(Type, "dependencies"), def2.dependencies),
        fromDefinitionOrDefault("injectable", def2, returnNull),
        fromDefinitionOrDefault("needsCompile", def2, returnTrue),
        mergeArrays(def2.surrogates),
        Bindable.from(getElementAnnotation(Type, "bindables"), def2.bindables),
        fromAnnotationOrDefinitionOrTypeOrDefault("containerless", def2, Type, returnFalse),
        fromDefinitionOrDefault("shadowOptions", def2, returnNull),
        fromDefinitionOrDefault("hasSlots", def2, returnFalse),
        fromDefinitionOrDefault("enhance", def2, returnFalse),
        fromDefinitionOrDefault("watches", def2, returnEmptyArray),
        // casting is incorrect, but it's good enough
        fromDefinitionOrDefault("strict", def2, returnUndefined),
        fromAnnotationOrTypeOrDefault("processContent", Type, returnNull)
      );
    }
    if (isString(nameOrDef)) {
      return new CustomElementDefinition(Type, nameOrDef, mergeArrays(getElementAnnotation(Type, "aliases"), Type.aliases), getElementKeyFrom(nameOrDef), fromAnnotationOrTypeOrDefault("capture", Type, returnFalse), fromAnnotationOrTypeOrDefault("template", Type, returnNull), mergeArrays(getElementAnnotation(Type, "instructions"), Type.instructions), mergeArrays(getElementAnnotation(Type, "dependencies"), Type.dependencies), fromAnnotationOrTypeOrDefault("injectable", Type, returnNull), fromAnnotationOrTypeOrDefault("needsCompile", Type, returnTrue), mergeArrays(getElementAnnotation(Type, "surrogates"), Type.surrogates), Bindable.from(...Bindable.getAll(Type), getElementAnnotation(Type, "bindables"), Type.bindables), fromAnnotationOrTypeOrDefault("containerless", Type, returnFalse), fromAnnotationOrTypeOrDefault("shadowOptions", Type, returnNull), fromAnnotationOrTypeOrDefault("hasSlots", Type, returnFalse), fromAnnotationOrTypeOrDefault("enhance", Type, returnFalse), mergeArrays(Watch.getDefinitions(Type), Type.watches), fromAnnotationOrTypeOrDefault("strict", Type, returnUndefined), fromAnnotationOrTypeOrDefault("processContent", Type, returnNull));
    }
    const name2 = fromDefinitionOrDefault("name", nameOrDef, generateElementName);
    for (const bindable2 of Object.values(Bindable.from(nameOrDef.bindables))) {
      Bindable._add(bindable2, Type);
    }
    return new CustomElementDefinition(Type, name2, mergeArrays(getElementAnnotation(Type, "aliases"), nameOrDef.aliases, Type.aliases), getElementKeyFrom(name2), fromAnnotationOrDefinitionOrTypeOrDefault("capture", nameOrDef, Type, returnFalse), fromAnnotationOrDefinitionOrTypeOrDefault("template", nameOrDef, Type, returnNull), mergeArrays(getElementAnnotation(Type, "instructions"), nameOrDef.instructions, Type.instructions), mergeArrays(getElementAnnotation(Type, "dependencies"), nameOrDef.dependencies, Type.dependencies), fromAnnotationOrDefinitionOrTypeOrDefault("injectable", nameOrDef, Type, returnNull), fromAnnotationOrDefinitionOrTypeOrDefault("needsCompile", nameOrDef, Type, returnTrue), mergeArrays(getElementAnnotation(Type, "surrogates"), nameOrDef.surrogates, Type.surrogates), Bindable.from(...Bindable.getAll(Type), getElementAnnotation(Type, "bindables"), Type.bindables, nameOrDef.bindables), fromAnnotationOrDefinitionOrTypeOrDefault("containerless", nameOrDef, Type, returnFalse), fromAnnotationOrDefinitionOrTypeOrDefault("shadowOptions", nameOrDef, Type, returnNull), fromAnnotationOrDefinitionOrTypeOrDefault("hasSlots", nameOrDef, Type, returnFalse), fromAnnotationOrDefinitionOrTypeOrDefault("enhance", nameOrDef, Type, returnFalse), mergeArrays(nameOrDef.watches, Watch.getDefinitions(Type), Type.watches), fromAnnotationOrDefinitionOrTypeOrDefault("strict", nameOrDef, Type, returnUndefined), fromAnnotationOrDefinitionOrTypeOrDefault("processContent", nameOrDef, Type, returnNull));
  }
  static getOrCreate(partialDefinition) {
    if (partialDefinition instanceof CustomElementDefinition) {
      return partialDefinition;
    }
    if (definitionLookup.has(partialDefinition)) {
      return definitionLookup.get(partialDefinition);
    }
    const definition = CustomElementDefinition.create(partialDefinition);
    definitionLookup.set(partialDefinition, definition);
    defineMetadata(definition, definition.Type, elementBaseName);
    return definition;
  }
  register(container, aliasName) {
    const $Type = this.Type;
    const key = typeof aliasName === "string" ? getElementKeyFrom(aliasName) : this.key;
    const aliases = this.aliases;
    if (container.has(key, false)) {
      console.warn(createMappedError$2(153, this.name));
      return;
    }
    container.register(container.has($Type, false) ? null : singletonRegistration($Type, $Type), aliasRegistration($Type, key), ...aliases.map((alias) => aliasRegistration($Type, getElementKeyFrom(alias))));
  }
  toString() {
    return `au:ce:${this.name}`;
  }
}
const defaultForOpts = {
  name: void 0,
  searchParents: false,
  optional: false
};
const returnNull = () => null;
const returnUndefined = () => void 0;
const returnFalse = () => false;
const returnTrue = () => true;
const returnEmptyArray = () => emptyArray;
const elementTypeName = "custom-element";
const elementBaseName = /* @__PURE__ */ getResourceKeyFor(elementTypeName);
const getElementKeyFrom = (name2) => `${elementBaseName}:${name2}`;
const generateElementName = /* @__PURE__ */ ((id2) => () => `unnamed-${++id2}`)(0);
const annotateElementMetadata = (Type, prop, value) => {
  defineMetadata(value, Type, getAnnotationKeyFor(prop));
};
const defineElement = (nameOrDef, Type) => {
  const definition = CustomElementDefinition.create(nameOrDef, Type);
  const $Type = definition.Type;
  defineMetadata(definition, $Type, elementBaseName, resourceBaseName);
  return $Type;
};
const isElementType = (value) => {
  return isFunction(value) && (hasMetadata(elementBaseName, value) || value.$au?.type === elementTypeName);
};
const findElementControllerFor = (node, opts = defaultForOpts) => {
  if (opts.name === void 0 && opts.searchParents !== true) {
    const controller = getRef(node, elementBaseName);
    if (controller === null) {
      if (opts.optional === true) {
        return null;
      }
      throw createMappedError$2(762, node);
    }
    return controller;
  }
  if (opts.name !== void 0) {
    if (opts.searchParents !== true) {
      const controller = getRef(node, elementBaseName);
      if (controller === null) {
        throw createMappedError$2(763, node);
      }
      if (controller.is(opts.name)) {
        return controller;
      }
      return void 0;
    }
    let cur2 = node;
    let foundAController = false;
    while (cur2 !== null) {
      const controller = getRef(cur2, elementBaseName);
      if (controller !== null) {
        foundAController = true;
        if (controller.is(opts.name)) {
          return controller;
        }
      }
      cur2 = getEffectiveParentNode(cur2);
    }
    if (foundAController) {
      return void 0;
    }
    throw createMappedError$2(764, node);
  }
  let cur = node;
  while (cur !== null) {
    const controller = getRef(cur, elementBaseName);
    if (controller !== null) {
      return controller;
    }
    cur = getEffectiveParentNode(cur);
  }
  throw createMappedError$2(765, node);
};
const getElementAnnotation = (Type, prop) => getMetadata(getAnnotationKeyFor(prop), Type);
const getElementDefinition = (Type) => {
  const def2 = getMetadata(elementBaseName, Type) ?? getDefinitionFromStaticAu(Type, elementTypeName, CustomElementDefinition.create);
  if (def2 == null) {
    throw createMappedError$2(760, Type);
  }
  return def2;
};
const createElementInjectable = () => {
  const $injectable = {
    // Old code is kept around. Needs to be refactored when TC39 supports argument decorator.
    // function(target: Injectable | AbstractInjectable, property: string | symbol | undefined, index?: number): Injectable | AbstractInjectable {
    //   const annotationParamtypes = DI.getOrCreateAnnotationParamTypes(target as Constructable);
    //   annotationParamtypes[index!] = $injectable;
    //   return target;
    // },
    $isInterface: false,
    register() {
      return {
        $isResolver: true,
        resolve(container, requestor) {
          if (requestor.has($injectable, true)) {
            return requestor.get($injectable);
          } else {
            return null;
          }
        }
      };
    }
  };
  return $injectable;
};
const generateElementType = /* @__PURE__ */ function() {
  const nameDescriptor = {
    value: "",
    writable: false,
    enumerable: false,
    configurable: true
  };
  const defaultProto = {};
  return function(name2, proto = defaultProto) {
    const Type = class Anonymous {
    };
    nameDescriptor.value = name2;
    def(Type, "name", nameDescriptor);
    if (proto !== defaultProto) {
      objectAssign(Type.prototype, proto);
    }
    return Type;
  };
}();
const CustomElement = /* @__PURE__ */ objectFreeze({
  name: elementBaseName,
  keyFrom: getElementKeyFrom,
  isType: isElementType,
  for: findElementControllerFor,
  define: defineElement,
  getDefinition: getElementDefinition,
  annotate: annotateElementMetadata,
  getAnnotation: getElementAnnotation,
  generateName: generateElementName,
  createInjectable: createElementInjectable,
  generateType: generateElementType,
  find(c2, name2) {
    const Type = c2.find(elementTypeName, name2);
    return Type == null ? null : getMetadata(elementBaseName, Type) ?? getDefinitionFromStaticAu(Type, elementTypeName, CustomElementDefinition.create) ?? null;
  }
});
const IAppRoot = /* @__PURE__ */ createInterface("IAppRoot");
class AppRoot {
  get controller() {
    return this._controller;
  }
  constructor(config, container, rootProvider, enhance = false) {
    this.config = config;
    this.container = container;
    this._hydratePromise = void 0;
    this._useOwnAppTasks = enhance;
    const host = this.host = config.host;
    rootProvider.prepare(this);
    registerResolver(container, IEventTarget, new InstanceProvider("IEventTarget", host));
    registerHostNode(container, host, this.platform = this._createPlatform(container, host));
    this._hydratePromise = onResolve(this._runAppTasks("creating"), () => {
      if (!config.allowActionlessForm !== false) {
        host.addEventListener("submit", (e2) => {
          const target = e2.target;
          const noAction = !target.getAttribute("action");
          if (target.tagName === "FORM" && noAction) {
            e2.preventDefault();
          }
        }, false);
      }
      const childCtn = enhance ? container : container.createChild();
      const component = config.component;
      let instance;
      if (isFunction(component)) {
        instance = childCtn.invoke(component);
      } else {
        instance = config.component;
      }
      const hydrationInst = { hydrate: false, projections: null };
      const definition = enhance ? CustomElementDefinition.create({ name: generateElementName(), template: this.host, enhance: true, strict: config.strictBinding }) : void 0;
      const controller = this._controller = Controller.$el(childCtn, instance, host, hydrationInst, definition);
      controller._hydrateCustomElement(hydrationInst);
      return onResolve(this._runAppTasks("hydrating"), () => {
        controller._hydrate();
        return onResolve(this._runAppTasks("hydrated"), () => {
          controller._hydrateChildren();
          this._hydratePromise = void 0;
        });
      });
    });
  }
  activate() {
    return onResolve(this._hydratePromise, () => {
      return onResolve(this._runAppTasks("activating"), () => {
        return onResolve(this._controller.activate(this._controller, null, void 0), () => {
          return this._runAppTasks("activated");
        });
      });
    });
  }
  deactivate() {
    return onResolve(this._runAppTasks("deactivating"), () => {
      return onResolve(this._controller.deactivate(this._controller, null), () => {
        return this._runAppTasks("deactivated");
      });
    });
  }
  /** @internal */
  _runAppTasks(slot) {
    const container = this.container;
    const appTasks = this._useOwnAppTasks && !container.has(IAppTask, false) ? [] : container.getAll(IAppTask);
    return onResolveAll(...appTasks.reduce((results, task2) => {
      if (task2.slot === slot) {
        results.push(task2.run());
      }
      return results;
    }, []));
  }
  /** @internal */
  _createPlatform(container, host) {
    let p2;
    if (!container.has(IPlatform, false)) {
      if (host.ownerDocument.defaultView === null) {
        throw createMappedError$2(
          769
          /* ErrorNames.invalid_platform_impl */
        );
      }
      p2 = new BrowserPlatform(host.ownerDocument.defaultView);
      container.register(instanceRegistration(IPlatform, p2));
    } else {
      p2 = container.get(IPlatform);
    }
    return p2;
  }
  dispose() {
    this._controller?.dispose();
  }
}
const IAurelia = /* @__PURE__ */ createInterface("IAurelia");
let Aurelia$1 = class Aurelia {
  get isRunning() {
    return this._isRunning;
  }
  get isStarting() {
    return this._isStarting;
  }
  get isStopping() {
    return this._isStopping;
  }
  get root() {
    if (this._root == null) {
      if (this.next == null) {
        throw createMappedError$2(
          767
          /* ErrorNames.root_not_found */
        );
      }
      return this.next;
    }
    return this._root;
  }
  constructor(container = DI.createContainer()) {
    this.container = container;
    this._isRunning = false;
    this._isStarting = false;
    this._isStopping = false;
    this._root = void 0;
    this.next = void 0;
    this._startPromise = void 0;
    this._stopPromise = void 0;
    if (container.has(IAurelia, true) || container.has(Aurelia, true)) {
      throw createMappedError$2(
        768
        /* ErrorNames.aurelia_instance_existed_in_container */
      );
    }
    registerResolver(container, IAurelia, new InstanceProvider("IAurelia", this));
    registerResolver(container, Aurelia, new InstanceProvider("Aurelia", this));
    registerResolver(container, IAppRoot, this._rootProvider = new InstanceProvider("IAppRoot"));
  }
  register(...params) {
    this.container.register(...params);
    return this;
  }
  app(config) {
    this.next = new AppRoot(config, this.container, this._rootProvider);
    return this;
  }
  /**
   * @param parentController - The owning controller of the view created by this enhance call
   */
  enhance(config) {
    const container = config.container ?? this.container.createChild();
    const rootProvider = registerResolver(container, IAppRoot, new InstanceProvider("IAppRoot"));
    const appRoot = new AppRoot({ host: config.host, component: config.component }, container, rootProvider, true);
    return onResolve(appRoot.activate(), () => appRoot);
  }
  async waitForIdle() {
    const platform = this.root.platform;
    await platform.domQueue.yield();
    await platform.taskQueue.yield();
  }
  start(root = this.next) {
    if (root == null) {
      throw createMappedError$2(
        770
        /* ErrorNames.no_composition_root */
      );
    }
    if (isPromise(this._startPromise)) {
      return this._startPromise;
    }
    return this._startPromise = onResolve(this.stop(), () => {
      Reflect.set(root.host, "$aurelia", this);
      this._rootProvider.prepare(this._root = root);
      this._isStarting = true;
      return onResolve(root.activate(), () => {
        this._isRunning = true;
        this._isStarting = false;
        this._startPromise = void 0;
        this._dispatchEvent(root, "au-started", root.host);
      });
    });
  }
  stop(dispose2 = false) {
    if (isPromise(this._stopPromise)) {
      return this._stopPromise;
    }
    if (this._isRunning === true) {
      const root = this._root;
      this._isRunning = false;
      this._isStopping = true;
      return this._stopPromise = onResolve(root.deactivate(), () => {
        Reflect.deleteProperty(root.host, "$aurelia");
        if (dispose2) {
          root.dispose();
        }
        this._root = void 0;
        this._rootProvider.dispose();
        this._isStopping = false;
        this._dispatchEvent(root, "au-stopped", root.host);
      });
    }
  }
  dispose() {
    if (this._isRunning || this._isStopping) {
      throw createMappedError$2(
        771
        /* ErrorNames.invalid_dispose_call */
      );
    }
    this.container.dispose();
  }
  /** @internal */
  _dispatchEvent(root, name2, target) {
    const ev = new root.platform.window.CustomEvent(name2, { detail: this, bubbles: true, cancelable: true });
    target.dispatchEvent(ev);
  }
};
const ISVGAnalyzer = /* @__PURE__ */ createInterface("ISVGAnalyzer", (x2) => x2.singleton(NoopSVGAnalyzer));
class NoopSVGAnalyzer {
  isStandardSvgAttribute(_node, _attributeName) {
    return false;
  }
}
class AttrMapper {
  constructor() {
    this.fns = [];
    this._tagAttrMap = createLookup$1();
    this._globalAttrMap = createLookup$1();
    this.svg = resolve(ISVGAnalyzer);
    this.useMapping({
      LABEL: { for: "htmlFor" },
      IMG: { usemap: "useMap" },
      INPUT: {
        maxlength: "maxLength",
        minlength: "minLength",
        formaction: "formAction",
        formenctype: "formEncType",
        formmethod: "formMethod",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        inputmode: "inputMode"
      },
      TEXTAREA: { maxlength: "maxLength" },
      TD: { rowspan: "rowSpan", colspan: "colSpan" },
      TH: { rowspan: "rowSpan", colspan: "colSpan" }
    });
    this.useGlobalMapping({
      accesskey: "accessKey",
      contenteditable: "contentEditable",
      tabindex: "tabIndex",
      textcontent: "textContent",
      innerhtml: "innerHTML",
      scrolltop: "scrollTop",
      scrollleft: "scrollLeft",
      readonly: "readOnly"
    });
  }
  /**
   * Allow application to teach Aurelia how to define how to map attributes to properties
   * based on element tagName
   */
  useMapping(config) {
    let newAttrMapping;
    let targetAttrMapping;
    let tagName;
    let attr;
    for (tagName in config) {
      newAttrMapping = config[tagName];
      targetAttrMapping = this._tagAttrMap[tagName] ??= createLookup$1();
      for (attr in newAttrMapping) {
        if (targetAttrMapping[attr] !== void 0) {
          throw createError$1(attr, tagName);
        }
        targetAttrMapping[attr] = newAttrMapping[attr];
      }
    }
  }
  /**
   * Allow applications to teach Aurelia how to define how to map attributes to properties
   * for all elements
   */
  useGlobalMapping(config) {
    const mapper = this._globalAttrMap;
    for (const attr in config) {
      if (mapper[attr] !== void 0) {
        throw createError$1(attr, "*");
      }
      mapper[attr] = config[attr];
    }
  }
  /**
   * Add a given function to a list of fns that will be used
   * to check if `'bind'` command can be understood as `'two-way'` command.
   */
  useTwoWay(fn2) {
    this.fns.push(fn2);
  }
  /**
   * Returns true if an attribute should be two way bound based on an element
   */
  isTwoWay(node, attrName) {
    return shouldDefaultToTwoWay(node, attrName) || this.fns.length > 0 && this.fns.some((fn2) => fn2(node, attrName));
  }
  /**
   * Retrieves the mapping information this mapper have for an attribute on an element
   */
  map(node, attr) {
    return this._tagAttrMap[node.nodeName]?.[attr] ?? this._globalAttrMap[attr] ?? (isDataAttribute(node, attr, this.svg) ? attr : null);
  }
}
AttrMapper.register = createImplementationRegister(IAttrMapper);
function shouldDefaultToTwoWay(element, attr) {
  switch (element.nodeName) {
    case "INPUT":
      switch (element.type) {
        case "checkbox":
        case "radio":
          return attr === "checked";
        default:
          return attr === "value" || attr === "files" || attr === "value-as-number" || attr === "value-as-date";
      }
    case "TEXTAREA":
    case "SELECT":
      return attr === "value";
    default:
      switch (attr) {
        case "textcontent":
        case "innerhtml":
          return element.hasAttribute("contenteditable");
        case "scrolltop":
        case "scrollleft":
          return true;
        default:
          return false;
      }
  }
}
function createError$1(attr, tagName) {
  return createMappedError$2(719, attr, tagName);
}
const RuntimeTemplateCompilerImplementation = {
  register(container) {
    container.register(TemplateCompiler, AttrMapper, ResourceResolver);
  }
};
class BindablesInfo {
  constructor(attrs, bindables2, primary) {
    this.attrs = attrs;
    this.bindables = bindables2;
    this.primary = primary;
  }
}
class ResourceResolver {
  constructor() {
    this._resourceCache = /* @__PURE__ */ new WeakMap();
    this._bindableCache = /* @__PURE__ */ new WeakMap();
  }
  el(c2, name2) {
    let record = this._resourceCache.get(c2);
    if (record == null) {
      this._resourceCache.set(c2, record = new RecordCache());
    }
    return name2 in record._element ? record._element[name2] : record._element[name2] = CustomElement.find(c2, name2);
  }
  attr(c2, name2) {
    let record = this._resourceCache.get(c2);
    if (record == null) {
      this._resourceCache.set(c2, record = new RecordCache());
    }
    return name2 in record._attr ? record._attr[name2] : record._attr[name2] = CustomAttribute.find(c2, name2);
  }
  bindables(def2) {
    let info2 = this._bindableCache.get(def2);
    if (info2 == null) {
      const bindables2 = def2.bindables;
      const attrs = createLookup$1();
      let bindable2;
      let prop;
      let hasPrimary = false;
      let primary;
      let attr;
      for (prop in bindables2) {
        bindable2 = bindables2[prop];
        attr = bindable2.attribute;
        if (bindable2.primary === true) {
          if (hasPrimary) {
            throw createMappedError$2(714, def2);
          }
          hasPrimary = true;
          primary = bindable2;
        } else if (!hasPrimary && primary == null) {
          primary = bindable2;
        }
        attrs[attr] = BindableDefinition.create(prop, bindable2);
      }
      if (bindable2 == null && def2.type === "custom-attribute") {
        primary = attrs.value = BindableDefinition.create("value", { mode: def2.defaultBindingMode ?? defaultMode });
      }
      this._bindableCache.set(def2, info2 = new BindablesInfo(attrs, bindables2, primary ?? null));
    }
    return info2;
  }
}
ResourceResolver.register = createImplementationRegister(IResourceResolver);
class RecordCache {
  constructor() {
    this._element = createLookup$1();
    this._attr = createLookup$1();
  }
}
const nsMap = createLookup$1();
class AttributeNSAccessor {
  static forNs(ns) {
    return nsMap[ns] ??= new AttributeNSAccessor(ns);
  }
  constructor(ns) {
    this.ns = ns;
    this.type = atNode | atLayout;
  }
  getValue(obj, propertyKey) {
    return obj.getAttributeNS(this.ns, propertyKey);
  }
  setValue(newValue, obj, key) {
    if (newValue == null) {
      obj.removeAttributeNS(this.ns, key);
    } else {
      obj.setAttributeNS(this.ns, key, newValue);
    }
  }
}
(() => {
  mixinNoopSubscribable(AttributeNSAccessor);
})();
class DataAttributeAccessor {
  constructor() {
    this.type = atNode | atLayout;
  }
  getValue(obj, key) {
    return obj.getAttribute(key);
  }
  setValue(newValue, obj, key) {
    if (newValue == null) {
      obj.removeAttribute(key);
    } else {
      obj.setAttribute(key, newValue);
    }
  }
}
(() => {
  mixinNoopSubscribable(DataAttributeAccessor);
})();
const attrAccessor = /* @__PURE__ */ new DataAttributeAccessor();
class SelectValueObserver {
  /** @internal */
  static _getSelectedOptions(options) {
    const selection = [];
    if (options.length === 0) {
      return selection;
    }
    const ii = options.length;
    let i3 = 0;
    let option;
    while (ii > i3) {
      option = options[i3];
      if (option.selected) {
        selection[selection.length] = hasOwnProperty.call(option, "model") ? option.model : option.value;
      }
      ++i3;
    }
    return selection;
  }
  /** @internal */
  static _defaultMatcher(a2, b3) {
    return a2 === b3;
  }
  constructor(obj, _key, config, observerLocator) {
    this.type = atNode | atObserver | atLayout;
    this._value = void 0;
    this._oldValue = void 0;
    this._hasChanges = false;
    this._arrayObserver = void 0;
    this._nodeObserver = void 0;
    this._observing = false;
    this._listened = false;
    this._el = obj;
    this._observerLocator = observerLocator;
    this._config = config;
  }
  getValue() {
    return this._observing ? this._value : this._el.multiple ? SelectValueObserver._getSelectedOptions(this._el.options) : this._el.value;
  }
  setValue(newValue) {
    this._oldValue = this._value;
    this._value = newValue;
    this._hasChanges = newValue !== this._oldValue;
    this._observeArray(newValue instanceof Array ? newValue : null);
    this._flushChanges();
  }
  /** @internal */
  _flushChanges() {
    if (this._hasChanges) {
      this._hasChanges = false;
      this.syncOptions();
    }
  }
  handleCollectionChange() {
    this.syncOptions();
  }
  syncOptions() {
    const value = this._value;
    const obj = this._el;
    const $isArray = isArray(value);
    const matcher = obj.matcher ?? SelectValueObserver._defaultMatcher;
    const options = obj.options;
    let i3 = options.length;
    while (i3-- > 0) {
      const option = options[i3];
      const optionValue = hasOwnProperty.call(option, "model") ? option.model : option.value;
      if ($isArray) {
        option.selected = value.findIndex((item) => !!matcher(optionValue, item)) !== -1;
        continue;
      }
      option.selected = !!matcher(optionValue, value);
    }
  }
  syncValue() {
    const obj = this._el;
    const options = obj.options;
    const len = options.length;
    const currentValue = this._value;
    let i3 = 0;
    if (obj.multiple) {
      if (!(currentValue instanceof Array)) {
        return true;
      }
      let option2;
      const matcher = obj.matcher || SelectValueObserver._defaultMatcher;
      const values = [];
      while (i3 < len) {
        option2 = options[i3];
        if (option2.selected) {
          values.push(hasOwnProperty.call(option2, "model") ? option2.model : option2.value);
        }
        ++i3;
      }
      let a2;
      i3 = 0;
      while (i3 < currentValue.length) {
        a2 = currentValue[i3];
        if (values.findIndex((b3) => !!matcher(a2, b3)) === -1) {
          currentValue.splice(i3, 1);
        } else {
          ++i3;
        }
      }
      i3 = 0;
      while (i3 < values.length) {
        a2 = values[i3];
        if (currentValue.findIndex((b3) => !!matcher(a2, b3)) === -1) {
          currentValue.push(a2);
        }
        ++i3;
      }
      return false;
    }
    let value = null;
    let option;
    while (i3 < len) {
      option = options[i3];
      if (option.selected) {
        value = hasOwnProperty.call(option, "model") ? option.model : option.value;
        break;
      }
      ++i3;
    }
    this._oldValue = this._value;
    this._value = value;
    return true;
  }
  /**
   * Used by mixing defined methods subscribe
   *
   * @internal
   */
  _start() {
    (this._nodeObserver = createMutationObserver(this._el, this._handleNodeChange.bind(this))).observe(this._el, {
      childList: true,
      subtree: true,
      characterData: true
    });
    this._observeArray(this._value instanceof Array ? this._value : null);
    this._observing = true;
  }
  /**
   * Used by mixing defined method unsubscribe
   *
   * @internal
   */
  _stop() {
    this._nodeObserver.disconnect();
    this._arrayObserver?.unsubscribe(this);
    this._nodeObserver = this._arrayObserver = void 0;
    this._observing = false;
  }
  // todo: observe all kind of collection
  /** @internal */
  _observeArray(array) {
    this._arrayObserver?.unsubscribe(this);
    this._arrayObserver = void 0;
    if (array != null) {
      if (!this._el.multiple) {
        throw createMappedError$2(
          654
          /* ErrorNames.select_observer_array_on_non_multi_select */
        );
      }
      (this._arrayObserver = this._observerLocator.getArrayObserver(array)).subscribe(this);
    }
  }
  handleEvent() {
    const shouldNotify = this.syncValue();
    if (shouldNotify) {
      this._flush();
    }
  }
  /** @internal */
  _handleNodeChange(_records) {
    this.syncOptions();
    const shouldNotify = this.syncValue();
    if (shouldNotify) {
      this._flush();
    }
  }
  /** @internal */
  _flush() {
    const oV2 = this._oldValue;
    this._oldValue = this._value;
    this.subs.notify(this._value, oV2);
  }
}
(() => {
  mixinNodeObserverUseConfig(SelectValueObserver);
  subscriberCollection(SelectValueObserver, null);
})();
const customPropertyPrefix = "--";
class StyleAttributeAccessor {
  constructor(obj) {
    this.obj = obj;
    this.type = atNode | atLayout;
    this._value = "";
    this._oldValue = "";
    this.styles = {};
    this.version = 0;
    this._hasChanges = false;
  }
  getValue() {
    return this.obj.style.cssText;
  }
  setValue(newValue) {
    this._value = newValue;
    this._hasChanges = newValue !== this._oldValue;
    this._flushChanges();
  }
  /** @internal */
  _getStyleTuplesFromString(currentValue) {
    const styleTuples = [];
    const urlRegexTester = /url\([^)]+$/;
    let offset2 = 0;
    let currentChunk = "";
    let nextSplit;
    let indexOfColon;
    let attribute;
    let value;
    while (offset2 < currentValue.length) {
      nextSplit = currentValue.indexOf(";", offset2);
      if (nextSplit === -1) {
        nextSplit = currentValue.length;
      }
      currentChunk += currentValue.substring(offset2, nextSplit);
      offset2 = nextSplit + 1;
      if (urlRegexTester.test(currentChunk)) {
        currentChunk += ";";
        continue;
      }
      indexOfColon = currentChunk.indexOf(":");
      attribute = currentChunk.substring(0, indexOfColon).trim();
      value = currentChunk.substring(indexOfColon + 1).trim();
      styleTuples.push([attribute, value]);
      currentChunk = "";
    }
    return styleTuples;
  }
  /** @internal */
  _getStyleTuplesFromObject(currentValue) {
    let value;
    let property;
    const styles2 = [];
    for (property in currentValue) {
      value = currentValue[property];
      if (value == null) {
        continue;
      }
      if (isString(value)) {
        if (property.startsWith(customPropertyPrefix)) {
          styles2.push([property, value]);
          continue;
        }
        styles2.push([kebabCase(property), value]);
        continue;
      }
      styles2.push(...this._getStyleTuples(value));
    }
    return styles2;
  }
  /** @internal */
  _getStyleTuplesFromArray(currentValue) {
    const len = currentValue.length;
    if (len > 0) {
      const styles2 = [];
      let i3 = 0;
      for (; len > i3; ++i3) {
        styles2.push(...this._getStyleTuples(currentValue[i3]));
      }
      return styles2;
    }
    return emptyArray;
  }
  /** @internal */
  _getStyleTuples(currentValue) {
    if (isString(currentValue)) {
      return this._getStyleTuplesFromString(currentValue);
    }
    if (currentValue instanceof Array) {
      return this._getStyleTuplesFromArray(currentValue);
    }
    if (currentValue instanceof Object) {
      return this._getStyleTuplesFromObject(currentValue);
    }
    return emptyArray;
  }
  /** @internal */
  _flushChanges() {
    if (this._hasChanges) {
      this._hasChanges = false;
      const currentValue = this._value;
      const styles2 = this.styles;
      const styleTuples = this._getStyleTuples(currentValue);
      let style;
      let version = this.version;
      this._oldValue = currentValue;
      let tuple;
      let name2;
      let value;
      let i3 = 0;
      const len = styleTuples.length;
      for (; i3 < len; ++i3) {
        tuple = styleTuples[i3];
        name2 = tuple[0];
        value = tuple[1];
        this.setProperty(name2, value);
        styles2[name2] = version;
      }
      this.styles = styles2;
      this.version += 1;
      if (version === 0) {
        return;
      }
      version -= 1;
      for (style in styles2) {
        if (!hasOwnProperty.call(styles2, style) || styles2[style] !== version) {
          continue;
        }
        this.obj.style.removeProperty(style);
      }
    }
  }
  setProperty(style, value) {
    let priority = "";
    if (value != null && isFunction(value.indexOf) && value.includes("!important")) {
      priority = "important";
      value = value.replace("!important", "");
    }
    this.obj.style.setProperty(style, value, priority);
  }
  bind() {
    this._value = this._oldValue = this.obj.style.cssText;
  }
}
(() => {
  mixinNoopSubscribable(StyleAttributeAccessor);
})();
class ValueAttributeObserver {
  constructor(obj, key, config) {
    this.type = atNode | atObserver | atLayout;
    this._value = "";
    this._oldValue = "";
    this._hasChanges = false;
    this._listened = false;
    this._el = obj;
    this._key = key;
    this._config = config;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    if (areEqual(newValue, this._value)) {
      return;
    }
    this._oldValue = this._value;
    this._value = newValue;
    this._hasChanges = true;
    if (!this._config.readonly) {
      this._flushChanges();
    }
  }
  /** @internal */
  _flushChanges() {
    if (this._hasChanges) {
      this._hasChanges = false;
      this._el[this._key] = this._value ?? this._config.default;
      this._flush();
    }
  }
  handleEvent() {
    this._oldValue = this._value;
    this._value = this._el[this._key];
    if (this._oldValue !== this._value) {
      this._hasChanges = false;
      this._flush();
    }
  }
  /**
   * Used by mixing defined methods subscribe
   *
   * @internal
   */
  _start() {
    this._value = this._oldValue = this._el[this._key];
  }
  /** @internal */
  _flush() {
    const oV2 = this._oldValue;
    this._oldValue = this._value;
    this.subs.notify(this._value, oV2);
  }
}
(() => {
  mixinNodeObserverUseConfig(ValueAttributeObserver);
  subscriberCollection(ValueAttributeObserver, null);
})();
const nsAttributes = (() => {
  const xlinkNS = "http://www.w3.org/1999/xlink";
  const xmlNS = "http://www.w3.org/XML/1998/namespace";
  const xmlnsNS = "http://www.w3.org/2000/xmlns/";
  return objectAssign(createLookup$1(), {
    "xlink:actuate": ["actuate", xlinkNS],
    "xlink:arcrole": ["arcrole", xlinkNS],
    "xlink:href": ["href", xlinkNS],
    "xlink:role": ["role", xlinkNS],
    "xlink:show": ["show", xlinkNS],
    "xlink:title": ["title", xlinkNS],
    "xlink:type": ["type", xlinkNS],
    "xml:lang": ["lang", xmlNS],
    "xml:space": ["space", xmlNS],
    "xmlns": ["xmlns", xmlnsNS],
    "xmlns:xlink": ["xlink", xmlnsNS]
  });
})();
const elementPropertyAccessor = new PropertyAccessor();
elementPropertyAccessor.type = atNode | atLayout;
class NodeObserverLocator {
  constructor() {
    this.allowDirtyCheck = true;
    this._events = createLookup$1();
    this._globalEvents = createLookup$1();
    this._overrides = createLookup$1();
    this._globalOverrides = createLookup$1();
    this._locator = resolve(IServiceLocator);
    this._platform = resolve(IPlatform);
    this._dirtyChecker = resolve(IDirtyChecker);
    this.svg = resolve(ISVGAnalyzer);
    const inputEvents = ["change", "input"];
    const inputEventsConfig = { events: inputEvents, default: "" };
    this.useConfig({
      INPUT: {
        value: inputEventsConfig,
        valueAsNumber: { events: inputEvents, default: 0 },
        checked: { type: CheckedObserver, events: inputEvents },
        files: { events: inputEvents, readonly: true }
      },
      SELECT: {
        value: { type: SelectValueObserver, events: ["change"], default: "" }
      },
      TEXTAREA: {
        value: inputEventsConfig
      }
    });
    const contentEventsConfig = { events: ["change", "input", "blur", "keyup", "paste"], default: "" };
    const scrollEventsConfig = { events: ["scroll"], default: 0 };
    this.useConfigGlobal({
      scrollTop: scrollEventsConfig,
      scrollLeft: scrollEventsConfig,
      textContent: contentEventsConfig,
      innerHTML: contentEventsConfig
    });
    this.overrideAccessorGlobal("css", "style", "class");
    this.overrideAccessor({
      INPUT: ["value", "checked", "model"],
      SELECT: ["value"],
      TEXTAREA: ["value"]
    });
  }
  // deepscan-disable-next-line
  handles(obj, _key) {
    return obj instanceof this._platform.Node;
  }
  useConfig(nodeNameOrConfig, key, eventsConfig) {
    const lookup2 = this._events;
    let existingMapping;
    if (isString(nodeNameOrConfig)) {
      existingMapping = lookup2[nodeNameOrConfig] ??= createLookup$1();
      if (existingMapping[key] == null) {
        existingMapping[key] = eventsConfig;
      } else {
        throwMappingExisted(nodeNameOrConfig, key);
      }
    } else {
      for (const nodeName in nodeNameOrConfig) {
        existingMapping = lookup2[nodeName] ??= createLookup$1();
        const newMapping = nodeNameOrConfig[nodeName];
        for (key in newMapping) {
          if (existingMapping[key] == null) {
            existingMapping[key] = newMapping[key];
          } else {
            throwMappingExisted(nodeName, key);
          }
        }
      }
    }
  }
  useConfigGlobal(configOrKey, eventsConfig) {
    const lookup2 = this._globalEvents;
    if (typeof configOrKey === "object") {
      for (const key in configOrKey) {
        if (lookup2[key] == null) {
          lookup2[key] = configOrKey[key];
        } else {
          throwMappingExisted("*", key);
        }
      }
    } else {
      if (lookup2[configOrKey] == null) {
        lookup2[configOrKey] = eventsConfig;
      } else {
        throwMappingExisted("*", configOrKey);
      }
    }
  }
  // deepscan-disable-nextline
  getAccessor(obj, key, requestor) {
    if (key in this._globalOverrides || key in (this._overrides[obj.tagName] ?? emptyObject)) {
      return this.getObserver(obj, key, requestor);
    }
    switch (key) {
      case "src":
      case "href":
      case "role":
      case "minLength":
      case "maxLength":
      case "placeholder":
      case "size":
      case "pattern":
      case "title":
      case "popovertarget":
      case "popovertargetaction":
        {
          if ((key === "popovertarget" || key === "popovertargetaction") && obj.nodeName !== "INPUT" && obj.nodeName !== "BUTTON") {
            console.warn(`[aurelia] Popover API are only valid on <input> or <button>. Detected ${key} on <${obj.nodeName.toLowerCase()}>`);
          }
        }
        return attrAccessor;
      default: {
        const nsProps = nsAttributes[key];
        if (nsProps !== void 0) {
          return AttributeNSAccessor.forNs(nsProps[1]);
        }
        if (isDataAttribute(obj, key, this.svg)) {
          return attrAccessor;
        }
        return elementPropertyAccessor;
      }
    }
  }
  overrideAccessor(tagNameOrOverrides, key) {
    let existingTagOverride;
    if (isString(tagNameOrOverrides)) {
      existingTagOverride = this._overrides[tagNameOrOverrides] ??= createLookup$1();
      existingTagOverride[key] = true;
    } else {
      for (const tagName in tagNameOrOverrides) {
        for (const key2 of tagNameOrOverrides[tagName]) {
          existingTagOverride = this._overrides[tagName] ??= createLookup$1();
          existingTagOverride[key2] = true;
        }
      }
    }
  }
  /**
   * For all elements:
   * compose a list of properties,
   * to indicate that an overser should be returned instead of an accessor in `.getAccessor()`
   */
  overrideAccessorGlobal(...keys) {
    for (const key of keys) {
      this._globalOverrides[key] = true;
    }
  }
  getNodeObserverConfig(el, key) {
    return this._events[el.tagName]?.[key] ?? this._globalEvents[key];
  }
  getNodeObserver(el, key, requestor) {
    const eventsConfig = this._events[el.tagName]?.[key] ?? this._globalEvents[key];
    let observer;
    if (eventsConfig != null) {
      observer = new (eventsConfig.type ?? ValueAttributeObserver)(el, key, eventsConfig, requestor, this._locator);
      if (!observer.doNotCache) {
        getObserverLookup(el)[key] = observer;
      }
      return observer;
    }
    return null;
  }
  getObserver(el, key, requestor) {
    switch (key) {
      case "class":
        return new ClassAttributeAccessor(el);
      case "css":
      case "style":
        return new StyleAttributeAccessor(el);
    }
    const nodeObserver = this.getNodeObserver(el, key, requestor);
    if (nodeObserver != null) {
      return nodeObserver;
    }
    const nsProps = nsAttributes[key];
    if (nsProps !== void 0) {
      return AttributeNSAccessor.forNs(nsProps[1]);
    }
    if (isDataAttribute(el, key, this.svg)) {
      return attrAccessor;
    }
    if (key in el.constructor.prototype) {
      if (this.allowDirtyCheck) {
        return this._dirtyChecker.createProperty(el, key);
      }
      throw createMappedError$2(652, key);
    } else {
      return new SetterObserver(el, key);
    }
  }
}
NodeObserverLocator.register = createImplementationRegister(INodeObserverLocator);
function getCollectionObserver(collection, observerLocator) {
  if (collection instanceof Array) {
    return observerLocator.getArrayObserver(collection);
  }
  if (collection instanceof Map) {
    return observerLocator.getMapObserver(collection);
  }
  if (collection instanceof Set) {
    return observerLocator.getSetObserver(collection);
  }
}
function throwMappingExisted(nodeName, key) {
  throw createMappedError$2(653, nodeName, key);
}
function defaultMatcher(a2, b3) {
  return a2 === b3;
}
class CheckedObserver {
  constructor(obj, _key, config, observerLocator) {
    this.type = atNode | atObserver | atLayout;
    this._value = void 0;
    this._oldValue = void 0;
    this._collectionObserver = void 0;
    this._valueObserver = void 0;
    this._listened = false;
    this._el = obj;
    this.oL = observerLocator;
    this._config = config;
  }
  getValue() {
    return this._value;
  }
  setValue(newValue) {
    const currentValue = this._value;
    if (newValue === currentValue) {
      return;
    }
    this._value = newValue;
    this._oldValue = currentValue;
    this._observe();
    this._synchronizeElement();
    this._flush();
  }
  handleCollectionChange() {
    this._synchronizeElement();
  }
  handleChange(_newValue, _previousValue) {
    this._synchronizeElement();
  }
  /** @internal */
  _synchronizeElement() {
    const currentValue = this._value;
    const obj = this._el;
    const elementValue = hasOwnProperty.call(obj, "model") ? obj.model : obj.value;
    const isRadio = obj.type === "radio";
    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
    if (isRadio) {
      obj.checked = !!matcher(currentValue, elementValue);
    } else if (currentValue === true) {
      obj.checked = true;
    } else {
      let hasMatch = false;
      if (isArray(currentValue)) {
        hasMatch = currentValue.findIndex((item) => !!matcher(item, elementValue)) !== -1;
      } else if (currentValue instanceof Set) {
        for (const v2 of currentValue) {
          if (matcher(v2, elementValue)) {
            hasMatch = true;
            break;
          }
        }
      } else if (currentValue instanceof Map) {
        for (const pair of currentValue) {
          const existingItem = pair[0];
          const $isChecked = pair[1];
          if (matcher(existingItem, elementValue) && $isChecked === true) {
            hasMatch = true;
            break;
          }
        }
      }
      obj.checked = hasMatch;
    }
  }
  handleEvent() {
    let currentValue = this._oldValue = this._value;
    const obj = this._el;
    const elementValue = hasOwnProperty.call(obj, "model") ? obj.model : obj.value;
    const isChecked = obj.checked;
    const matcher = obj.matcher !== void 0 ? obj.matcher : defaultMatcher;
    if (obj.type === "checkbox") {
      if (isArray(currentValue)) {
        const index = currentValue.findIndex((item) => !!matcher(item, elementValue));
        if (isChecked && index === -1) {
          currentValue.push(elementValue);
        } else if (!isChecked && index !== -1) {
          currentValue.splice(index, 1);
        }
        return;
      } else if (currentValue instanceof Set) {
        const unset = {};
        let existingItem = unset;
        for (const value of currentValue) {
          if (matcher(value, elementValue) === true) {
            existingItem = value;
            break;
          }
        }
        if (isChecked && existingItem === unset) {
          currentValue.add(elementValue);
        } else if (!isChecked && existingItem !== unset) {
          currentValue.delete(existingItem);
        }
        return;
      } else if (currentValue instanceof Map) {
        let existingItem;
        for (const pair of currentValue) {
          const currItem = pair[0];
          if (matcher(currItem, elementValue) === true) {
            existingItem = currItem;
            break;
          }
        }
        currentValue.set(existingItem, isChecked);
        return;
      }
      currentValue = isChecked;
    } else if (isChecked) {
      currentValue = elementValue;
    } else {
      return;
    }
    this._value = currentValue;
    this._flush();
  }
  /**
   * Used by mixing defined methods subscribe
   *
   * @internal
   */
  _start() {
    this._observe();
  }
  /**
   * Used by mixing defined methods unsubscribe
   *
   * @internal
   */
  _stop() {
    this._value = this._oldValue = void 0;
    this._collectionObserver?.unsubscribe(this);
    this._valueObserver?.unsubscribe(this);
    this._collectionObserver = this._valueObserver = void 0;
  }
  /** @internal */
  _flush() {
    oV = this._oldValue;
    this._oldValue = this._value;
    this.subs.notify(this._value, oV);
    oV = void 0;
  }
  /** @internal */
  _observe() {
    const obj = this._el;
    (this._valueObserver ??= obj.$observers?.model ?? obj.$observers?.value)?.subscribe(this);
    this._collectionObserver?.unsubscribe(this);
    this._collectionObserver = void 0;
    if (obj.type === "checkbox") {
      (this._collectionObserver = getCollectionObserver(this._value, this.oL))?.subscribe(this);
    }
  }
}
(() => {
  mixinNodeObserverUseConfig(CheckedObserver);
  subscriberCollection(CheckedObserver, null);
})();
let oV = void 0;
class AttrBindingBehavior {
  bind(_scope, binding) {
    if (!(binding instanceof PropertyBinding)) {
      throw createMappedError$2(9994, binding);
    }
    binding.useTargetObserver(attrAccessor);
  }
}
AttrBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "attr"
};
class SelfBindingBehavior {
  bind(_scope, binding) {
    if (!("handleEvent" in binding)) {
      throw createMappedError$2(
        801
        /* ErrorNames.self_behavior_invalid_usage */
      );
    }
    binding.self = true;
  }
  unbind(_scope, binding) {
    binding.self = false;
  }
}
SelfBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "self"
};
class UpdateTriggerBindingBehavior {
  constructor() {
    this._observerLocator = resolve(IObserverLocator);
    this._nodeObserverLocator = resolve(INodeObserverLocator);
  }
  bind(_scope, binding, ...events2) {
    if (!(this._nodeObserverLocator instanceof NodeObserverLocator)) {
      throw createMappedError$2(
        9993
        /* ErrorNames.update_trigger_behavior_not_supported */
      );
    }
    if (events2.length === 0) {
      throw createMappedError$2(
        802
        /* ErrorNames.update_trigger_behavior_no_triggers */
      );
    }
    if (!(binding instanceof PropertyBinding) || !(binding.mode & fromView)) {
      throw createMappedError$2(
        803
        /* ErrorNames.update_trigger_invalid_usage */
      );
    }
    const targetConfig = this._nodeObserverLocator.getNodeObserverConfig(binding.target, binding.targetProperty);
    if (targetConfig == null) {
      throw createMappedError$2(9992, binding);
    }
    const targetObserver = this._nodeObserverLocator.getNodeObserver(binding.target, binding.targetProperty, this._observerLocator);
    targetObserver.useConfig({ readonly: targetConfig.readonly, default: targetConfig.default, events: events2 });
    binding.useTargetObserver(targetObserver);
  }
}
UpdateTriggerBindingBehavior.$au = {
  type: behaviorTypeName,
  name: "updateTrigger"
};
class If {
  constructor() {
    this.elseFactory = void 0;
    this.elseView = void 0;
    this.ifView = void 0;
    this.view = void 0;
    this.value = false;
    this.cache = true;
    this.pending = void 0;
    this._wantsDeactivate = false;
    this._swapId = 0;
    this._ifFactory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  attaching(_initiator, _parent) {
    return this._swap(this.value);
  }
  detaching(initiator, _parent) {
    this._wantsDeactivate = true;
    return onResolve(this.pending, () => {
      this._wantsDeactivate = false;
      this.pending = void 0;
      void this.view?.deactivate(initiator, this.$controller);
    });
  }
  valueChanged(newValue, oldValue) {
    if (!this.$controller.isActive)
      return;
    newValue = !!newValue;
    oldValue = !!oldValue;
    if (newValue !== oldValue)
      return this._swap(newValue);
  }
  /** @internal */
  _swap(value) {
    const currView = this.view;
    const ctrl = this.$controller;
    const swapId = this._swapId++;
    const isCurrent = () => !this._wantsDeactivate && this._swapId === swapId + 1;
    let view;
    return onResolve(this.pending, () => this.pending = onResolve(currView?.deactivate(currView, ctrl), () => {
      if (!isCurrent()) {
        return;
      }
      if (value) {
        view = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this._ifFactory.create();
      } else {
        view = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create();
      }
      if (view == null) {
        return;
      }
      view.setLocation(this._location);
      return onResolve(view.activate(view, ctrl, ctrl.scope), () => {
        if (isCurrent()) {
          this.pending = void 0;
        }
      });
    }));
  }
  dispose() {
    this.ifView?.dispose();
    this.elseView?.dispose();
    this.ifView = this.elseView = this.view = void 0;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
}
If.$au = {
  type: attrTypeName,
  name: "if",
  isTemplateController: true,
  bindables: {
    value: true,
    cache: {
      set: (v2) => v2 === "" || !!v2 && v2 !== "false"
    }
  }
};
class Else {
  constructor() {
    this._factory = resolve(IViewFactory);
  }
  link(controller, _childController, _target, _instruction) {
    const children = controller.children;
    const ifBehavior = children[children.length - 1];
    if (ifBehavior instanceof If) {
      ifBehavior.elseFactory = this._factory;
    } else if (ifBehavior.viewModel instanceof If) {
      ifBehavior.viewModel.elseFactory = this._factory;
    } else {
      throw createMappedError$2(
        810
        /* ErrorNames.else_without_if */
      );
    }
  }
}
Else.$au = {
  type: "custom-attribute",
  name: "else",
  isTemplateController: true
};
function dispose(disposable) {
  disposable.dispose();
}
const wrappedExprs = [
  "BindingBehavior",
  "ValueConverter"
];
class Repeat {
  constructor() {
    this.views = [];
    this.key = null;
    this._oldViews = [];
    this._scopes = [];
    this._oldScopes = [];
    this._scopeMap = /* @__PURE__ */ new Map();
    this._observer = void 0;
    this._observingInnerItems = false;
    this._reevaluating = false;
    this._innerItemsExpression = null;
    this._normalizedItems = void 0;
    this._hasDestructuredLocal = false;
    this._location = resolve(IRenderLocation);
    this._parent = resolve(IController);
    this._factory = resolve(IViewFactory);
    this._resolver = resolve(IRepeatableHandlerResolver);
    const instruction = resolve(IInstruction);
    const keyProp = instruction.props[0].props[0];
    if (keyProp !== void 0) {
      const { to, value, command } = keyProp;
      if (to === "key") {
        if (command === null) {
          this.key = value;
        } else if (command === "bind") {
          this.key = resolve(IExpressionParser).parse(value, etIsProperty);
        } else {
          throw createMappedError$2(775, command);
        }
      } else {
        throw createMappedError$2(776, to);
      }
    }
  }
  binding(_initiator, _parent) {
    const bindings = this._parent.bindings;
    const ii = bindings.length;
    let binding = void 0;
    let forOf;
    let i3 = 0;
    for (; ii > i3; ++i3) {
      binding = bindings[i3];
      if (binding.target === this && binding.targetProperty === "items") {
        forOf = this.forOf = binding.ast;
        this._forOfBinding = binding;
        let expression = forOf.iterable;
        while (expression != null && wrappedExprs.includes(expression.$kind)) {
          expression = expression.expression;
          this._observingInnerItems = true;
        }
        this._innerItemsExpression = expression;
        break;
      }
    }
    this._refreshCollectionObserver();
    const dec = forOf.declaration;
    if (!(this._hasDestructuredLocal = dec.$kind === "ArrayDestructuring" || dec.$kind === "ObjectDestructuring")) {
      this.local = astEvaluate(dec, this.$controller.scope, binding, null);
    }
  }
  attaching(initiator, _parent) {
    this._normalizeToArray();
    this._createScopes();
    return this._activateAllViews(initiator, this._normalizedItems ?? emptyArray);
  }
  detaching(initiator, _parent) {
    this._refreshCollectionObserver();
    return this._deactivateAllViews(initiator);
  }
  unbinding(_initiator, _parent) {
    this._scopeMap.clear();
  }
  // called by SetterObserver
  itemsChanged() {
    if (!this.$controller.isActive) {
      return;
    }
    this._refreshCollectionObserver();
    this._normalizeToArray();
    this._createScopes();
    this._applyIndexMap(void 0);
  }
  handleCollectionChange(collection, indexMap) {
    const $controller = this.$controller;
    if (!$controller.isActive) {
      return;
    }
    if (this._observingInnerItems) {
      if (this._reevaluating) {
        return;
      }
      this._reevaluating = true;
      this.items = astEvaluate(this.forOf.iterable, $controller.scope, this._forOfBinding, null);
      this._reevaluating = false;
      return;
    }
    this._normalizeToArray();
    this._createScopes();
    this._applyIndexMap(indexMap);
  }
  /** @internal */
  _applyIndexMap(indexMap) {
    const oldViews = this.views;
    this._oldViews = oldViews.slice();
    const oldLen = oldViews.length;
    const key = this.key;
    const hasKey = key !== null;
    const oldScopes = this._oldScopes;
    const newScopes = this._scopes;
    if (hasKey || indexMap === void 0) {
      const local = this.local;
      const newItems = this._normalizedItems;
      const newLen = newItems.length;
      const forOf = this.forOf;
      const dec = forOf.declaration;
      const binding = this._forOfBinding;
      const hasDestructuredLocal = this._hasDestructuredLocal;
      indexMap = createIndexMap(newLen);
      let i3 = 0;
      if (oldLen === 0) {
        for (; i3 < newLen; ++i3) {
          indexMap[i3] = -2;
        }
      } else if (newLen === 0) {
        for (i3 = 0; i3 < oldLen; ++i3) {
          indexMap.deletedIndices.push(i3);
          indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i3], binding, local));
        }
      } else if (hasKey) {
        const oldKeys = Array(oldLen);
        for (i3 = 0; i3 < oldLen; ++i3) {
          oldKeys[i3] = getKeyValue(hasDestructuredLocal, key, dec, oldScopes[i3], binding, local);
        }
        const newKeys = Array(oldLen);
        for (i3 = 0; i3 < newLen; ++i3) {
          newKeys[i3] = getKeyValue(hasDestructuredLocal, key, dec, newScopes[i3], binding, local);
        }
        for (i3 = 0; i3 < newLen; ++i3) {
          if (oldKeys.includes(newKeys[i3])) {
            indexMap[i3] = oldKeys.indexOf(newKeys[i3]);
          } else {
            indexMap[i3] = -2;
          }
        }
        for (i3 = 0; i3 < oldLen; ++i3) {
          if (!newKeys.includes(oldKeys[i3])) {
            indexMap.deletedIndices.push(i3);
            indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i3], binding, local));
          }
        }
      } else {
        for (i3 = 0; i3 < newLen; ++i3) {
          if (oldScopes.includes(newScopes[i3])) {
            indexMap[i3] = oldScopes.indexOf(newScopes[i3]);
          } else {
            indexMap[i3] = -2;
          }
        }
        for (i3 = 0; i3 < oldLen; ++i3) {
          if (!newScopes.includes(oldScopes[i3])) {
            indexMap.deletedIndices.push(i3);
            indexMap.deletedItems.push(getItem(hasDestructuredLocal, dec, oldScopes[i3], binding, local));
          }
        }
      }
    }
    if (indexMap.deletedIndices.length > 0) {
      const ret = onResolve(this._deactivateAndRemoveViewsByKey(indexMap), () => {
        return this._createAndActivateAndSortViewsByKey(indexMap);
      });
      if (isPromise(ret)) {
        ret.catch(rethrow);
      }
    } else {
      this._createAndActivateAndSortViewsByKey(indexMap);
    }
  }
  // todo: subscribe to collection from inner expression
  /** @internal */
  _refreshCollectionObserver() {
    const scope = this.$controller.scope;
    let innerItems = this._innerItems;
    let observingInnerItems = this._observingInnerItems;
    let newObserver;
    if (observingInnerItems) {
      innerItems = this._innerItems = astEvaluate(this._innerItemsExpression, scope, this._forOfBinding, null) ?? null;
      observingInnerItems = this._observingInnerItems = !areEqual(this.items, innerItems);
    }
    const oldObserver = this._observer;
    if (this.$controller.isActive) {
      const items = observingInnerItems ? innerItems : this.items;
      newObserver = this._observer = this._resolver.resolve(items).getObserver?.(items);
      if (oldObserver !== newObserver) {
        oldObserver?.unsubscribe(this);
        newObserver?.subscribe(this);
      }
    } else {
      oldObserver?.unsubscribe(this);
      this._observer = void 0;
    }
  }
  /** @internal */
  _createScopes() {
    const oldScopes = this._scopes;
    this._oldScopes = oldScopes.slice();
    const items = this._normalizedItems;
    const len = items.length;
    const scopes = this._scopes = Array(items.length);
    const oldScopeMap = this._scopeMap;
    const newScopeMap = /* @__PURE__ */ new Map();
    const parentScope = this.$controller.scope;
    const binding = this._forOfBinding;
    const forOf = this.forOf;
    const local = this.local;
    const hasDestructuredLocal = this._hasDestructuredLocal;
    for (let i3 = 0; i3 < len; ++i3) {
      scopes[i3] = getScope(oldScopeMap, newScopeMap, items[i3], forOf, parentScope, binding, local, hasDestructuredLocal);
    }
    oldScopeMap.clear();
    this._scopeMap = newScopeMap;
  }
  /** @internal */
  _normalizeToArray() {
    const items = this.items;
    if (isArray(items)) {
      this._normalizedItems = items.slice(0);
      return;
    }
    const normalizedItems = [];
    this._resolver.resolve(items).iterate(items, (item, index) => {
      normalizedItems[index] = item;
    });
    this._normalizedItems = normalizedItems;
  }
  /** @internal */
  _activateAllViews(initiator, $items) {
    let promises = void 0;
    let ret;
    let view;
    let scope;
    const { $controller, _factory, _location, _scopes } = this;
    const newLen = $items.length;
    const views = this.views = Array(newLen);
    for (let i3 = 0; i3 < newLen; ++i3) {
      view = views[i3] = _factory.create().setLocation(_location);
      view.nodes.unlink();
      scope = _scopes[i3];
      setContextualProperties(scope.overrideContext, i3, newLen);
      ret = view.activate(initiator ?? view, $controller, scope);
      if (isPromise(ret)) {
        (promises ??= []).push(ret);
      }
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  /** @internal */
  _deactivateAllViews(initiator) {
    let promises = void 0;
    let ret;
    let view;
    let i3 = 0;
    const { views, $controller } = this;
    const ii = views.length;
    for (; ii > i3; ++i3) {
      view = views[i3];
      view.release();
      ret = view.deactivate(initiator ?? view, $controller);
      if (isPromise(ret)) {
        (promises ?? (promises = [])).push(ret);
      }
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  /** @internal */
  _deactivateAndRemoveViewsByKey(indexMap) {
    let promises = void 0;
    let ret;
    let view;
    const { $controller, views } = this;
    const deleted = indexMap.deletedIndices.slice().sort(compareNumber);
    const deletedLen = deleted.length;
    let i3 = 0;
    for (; deletedLen > i3; ++i3) {
      view = views[deleted[i3]];
      view.release();
      ret = view.deactivate(view, $controller);
      if (isPromise(ret)) {
        (promises ?? (promises = [])).push(ret);
      }
    }
    i3 = 0;
    for (; deletedLen > i3; ++i3) {
      views.splice(deleted[i3] - i3, 1);
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  /** @internal */
  _createAndActivateAndSortViewsByKey(indexMap) {
    let promises = void 0;
    let ret;
    let view;
    let i3 = 0;
    const { $controller, _factory, _location, views, _scopes, _oldViews } = this;
    const newLen = indexMap.length;
    for (; newLen > i3; ++i3) {
      if (indexMap[i3] === -2) {
        view = _factory.create();
        views.splice(i3, 0, view);
      }
    }
    if (views.length !== newLen) {
      throw createMappedError$2(814, [views.length, newLen]);
    }
    let source = 0;
    i3 = 0;
    for (; i3 < indexMap.length; ++i3) {
      if ((source = indexMap[i3]) !== -2) {
        views[i3] = _oldViews[source];
      }
    }
    const seq = longestIncreasingSubsequence(indexMap);
    const seqLen = seq.length;
    let next;
    let j2 = seqLen - 1;
    i3 = newLen - 1;
    for (; i3 >= 0; --i3) {
      view = views[i3];
      next = views[i3 + 1];
      view.nodes.link(next?.nodes ?? _location);
      if (indexMap[i3] === -2) {
        view.setLocation(_location);
        setContextualProperties(_scopes[i3].overrideContext, i3, newLen);
        ret = view.activate(view, $controller, _scopes[i3]);
        if (isPromise(ret)) {
          (promises ?? (promises = [])).push(ret);
        }
      } else if (j2 < 0 || seqLen === 1 || i3 !== seq[j2]) {
        setContextualProperties(view.scope.overrideContext, i3, newLen);
        view.nodes.insertBefore(view.location);
      } else {
        setContextualProperties(view.scope.overrideContext, i3, newLen);
        --j2;
      }
    }
    if (promises !== void 0) {
      return promises.length === 1 ? promises[0] : Promise.all(promises);
    }
  }
  dispose() {
    this.views.forEach(dispose);
    this.views = void 0;
  }
  accept(visitor) {
    const { views } = this;
    if (views !== void 0) {
      for (let i3 = 0, ii = views.length; i3 < ii; ++i3) {
        if (views[i3].accept(visitor) === true) {
          return true;
        }
      }
    }
  }
}
Repeat.$au = {
  type: attrTypeName,
  name: "repeat",
  isTemplateController: true,
  bindables: ["items"]
};
let maxLen = 16;
let prevIndices = new Int32Array(maxLen);
let tailIndices = new Int32Array(maxLen);
function longestIncreasingSubsequence(indexMap) {
  const len = indexMap.length;
  if (len > maxLen) {
    maxLen = len;
    prevIndices = new Int32Array(len);
    tailIndices = new Int32Array(len);
  }
  let cursor = 0;
  let cur = 0;
  let prev = 0;
  let i3 = 0;
  let j2 = 0;
  let low = 0;
  let high = 0;
  let mid = 0;
  for (; i3 < len; i3++) {
    cur = indexMap[i3];
    if (cur !== -2) {
      j2 = prevIndices[cursor];
      prev = indexMap[j2];
      if (prev !== -2 && prev < cur) {
        tailIndices[i3] = j2;
        prevIndices[++cursor] = i3;
        continue;
      }
      low = 0;
      high = cursor;
      while (low < high) {
        mid = low + high >> 1;
        prev = indexMap[prevIndices[mid]];
        if (prev !== -2 && prev < cur) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      prev = indexMap[prevIndices[low]];
      if (cur < prev || prev === -2) {
        if (low > 0) {
          tailIndices[i3] = prevIndices[low - 1];
        }
        prevIndices[low] = i3;
      }
    }
  }
  i3 = ++cursor;
  const result = new Int32Array(i3);
  cur = prevIndices[cursor - 1];
  while (cursor-- > 0) {
    result[cursor] = cur;
    cur = tailIndices[cur];
  }
  while (i3-- > 0)
    prevIndices[i3] = 0;
  return result;
}
class RepeatOverrideContext {
  get $odd() {
    return !this.$even;
  }
  get $even() {
    return this.$index % 2 === 0;
  }
  get $first() {
    return this.$index === 0;
  }
  get $middle() {
    return !this.$first && !this.$last;
  }
  get $last() {
    return this.$index === this.$length - 1;
  }
  constructor($index2 = 0, $length2 = 1) {
    this.$index = $index2;
    this.$length = $length2;
  }
}
const setContextualProperties = (oc, index, length) => {
  oc.$index = index;
  oc.$length = length;
};
const IRepeatableHandlerResolver = /* @__PURE__ */ createInterface("IRepeatableHandlerResolver", (x2) => x2.singleton(RepeatableHandlerResolver));
class RepeatableHandlerResolver {
  constructor() {
    this._handlers = resolve(all(IRepeatableHandler));
  }
  resolve(value) {
    if (_arrayHandler.handles(value)) {
      return _arrayHandler;
    }
    if (_setHandler.handles(value)) {
      return _setHandler;
    }
    if (_mapHandler.handles(value)) {
      return _mapHandler;
    }
    if (_numberHandler.handles(value)) {
      return _numberHandler;
    }
    if (_nullishHandler.handles(value)) {
      return _nullishHandler;
    }
    const handler = this._handlers.find((x2) => x2.handles(value));
    if (handler !== void 0) {
      return handler;
    }
    return _unknownHandler;
  }
}
const IRepeatableHandler = /* @__PURE__ */ createInterface("IRepeatableHandler");
const _arrayHandler = {
  handles: isArray,
  getObserver: getCollectionObserver$1,
  /* istanbul ignore next */
  iterate(value, func) {
    const ii = value.length;
    let i3 = 0;
    for (; i3 < ii; ++i3) {
      func(value[i3], i3, value);
    }
  }
  // getCount: items => items.length,
};
const _setHandler = {
  handles: isSet,
  getObserver: getCollectionObserver$1,
  iterate(value, func) {
    let i3 = 0;
    let key;
    for (key of value.keys()) {
      func(key, i3++, value);
    }
  }
  // getCount: s => s.size,
};
const _mapHandler = {
  handles: isMap,
  getObserver: getCollectionObserver$1,
  iterate(value, func) {
    let i3 = 0;
    let entry;
    for (entry of value.entries()) {
      func(entry, i3++, value);
    }
  }
  // getCount: s => s.size,
};
const _numberHandler = {
  handles: isNumber,
  iterate(value, func) {
    let i3 = 0;
    for (; i3 < value; ++i3) {
      func(i3, i3, value);
    }
  }
  // getCount: v => v,
};
const _nullishHandler = {
  handles: (v2) => v2 == null,
  iterate() {
  }
  // getCount: () => 0,
};
const _unknownHandler = {
  handles(_value) {
    return false;
  },
  iterate(value, _func) {
    throw createMappedError$2(777, value);
  }
  // getCount: () => 0,
};
const setItem = (hasDestructuredLocal, dec, scope, binding, local, item) => {
  if (hasDestructuredLocal) {
    astAssign(dec, scope, binding, item);
  } else {
    scope.bindingContext[local] = item;
  }
};
const getItem = (hasDestructuredLocal, dec, scope, binding, local) => {
  return hasDestructuredLocal ? astEvaluate(dec, scope, binding, null) : scope.bindingContext[local];
};
const getKeyValue = (hasDestructuredLocal, key, dec, scope, binding, local) => {
  if (typeof key === "string") {
    const item = getItem(hasDestructuredLocal, dec, scope, binding, local);
    return item[key];
  }
  return astEvaluate(key, scope, binding, null);
};
const getScope = (oldScopeMap, newScopeMap, item, forOf, parentScope, binding, local, hasDestructuredLocal) => {
  let scope = oldScopeMap.get(item);
  if (scope === void 0) {
    scope = createScope(item, forOf, parentScope, binding, local, hasDestructuredLocal);
  } else if (scope instanceof Scope) {
    oldScopeMap.delete(item);
  } else if (scope.length === 1) {
    scope = scope[0];
    oldScopeMap.delete(item);
  } else {
    scope = scope.shift();
  }
  if (newScopeMap.has(item)) {
    const entry = newScopeMap.get(item);
    if (entry instanceof Scope) {
      newScopeMap.set(item, [entry, scope]);
    } else {
      entry.push(scope);
    }
  } else {
    newScopeMap.set(item, scope);
  }
  setItem(hasDestructuredLocal, forOf.declaration, scope, binding, local, item);
  return scope;
};
const createScope = (item, forOf, parentScope, binding, local, hasDestructuredLocal) => {
  if (hasDestructuredLocal) {
    const scope = Scope.fromParent(parentScope, new BindingContext(), new RepeatOverrideContext());
    astAssign(forOf.declaration, scope, binding, item);
  }
  return Scope.fromParent(parentScope, new BindingContext(local, item), new RepeatOverrideContext());
};
const compareNumber = (a2, b3) => a2 - b3;
class With {
  constructor() {
    this.view = resolve(IViewFactory).create().setLocation(resolve(IRenderLocation));
  }
  valueChanged(newValue, _oldValue) {
    const $controller = this.$controller;
    const bindings = this.view.bindings;
    let scope;
    let i3 = 0, ii = 0;
    if ($controller.isActive && bindings != null) {
      scope = Scope.fromParent($controller.scope, newValue === void 0 ? {} : newValue);
      for (ii = bindings.length; ii > i3; ++i3) {
        bindings[i3].bind(scope);
      }
    }
  }
  attaching(initiator, _parent) {
    const { $controller, value } = this;
    const scope = Scope.fromParent($controller.scope, value === void 0 ? {} : value);
    return this.view.activate(initiator, $controller, scope);
  }
  detaching(initiator, _parent) {
    return this.view.deactivate(initiator, this.$controller);
  }
  dispose() {
    this.view.dispose();
    this.view = void 0;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
}
With.$au = {
  type: attrTypeName,
  name: "with",
  isTemplateController: true,
  bindables: ["value"]
};
let Switch$1 = class Switch {
  constructor() {
    this.cases = [];
    this.activeCases = [];
    this.promise = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(_controller, _childController, _target, _instruction) {
    this.view = this._factory.create(this.$controller).setLocation(this._location);
  }
  attaching(initiator, _parent) {
    const view = this.view;
    const $controller = this.$controller;
    this.queue(() => view.activate(initiator, $controller, $controller.scope));
    this.queue(() => this.swap(initiator, this.value));
    return this.promise;
  }
  detaching(initiator, _parent) {
    this.queue(() => {
      const view = this.view;
      return view.deactivate(initiator, this.$controller);
    });
    return this.promise;
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
  valueChanged(_newValue, _oldValue) {
    if (!this.$controller.isActive) {
      return;
    }
    this.queue(() => this.swap(null, this.value));
  }
  caseChanged($case) {
    this.queue(() => this._handleCaseChange($case));
  }
  /** @internal */
  _handleCaseChange($case) {
    const isMatch = $case.isMatch(this.value);
    const activeCases = this.activeCases;
    const numActiveCases = activeCases.length;
    if (!isMatch) {
      if (numActiveCases > 0 && activeCases[0].id === $case.id) {
        return this._clearActiveCases(null);
      }
      return;
    }
    if (numActiveCases > 0 && activeCases[0].id < $case.id) {
      return;
    }
    const newActiveCases = [];
    let fallThrough = $case.fallThrough;
    if (!fallThrough) {
      newActiveCases.push($case);
    } else {
      const cases = this.cases;
      const idx = cases.indexOf($case);
      for (let i3 = idx, ii = cases.length; i3 < ii && fallThrough; i3++) {
        const c2 = cases[i3];
        newActiveCases.push(c2);
        fallThrough = c2.fallThrough;
      }
    }
    return onResolve(this._clearActiveCases(null, newActiveCases), () => {
      this.activeCases = newActiveCases;
      return this._activateCases(null);
    });
  }
  swap(initiator, value) {
    const newActiveCases = [];
    let fallThrough = false;
    for (const $case of this.cases) {
      if (fallThrough || $case.isMatch(value)) {
        newActiveCases.push($case);
        fallThrough = $case.fallThrough;
      }
      if (newActiveCases.length > 0 && !fallThrough) {
        break;
      }
    }
    const defaultCase = this.defaultCase;
    if (newActiveCases.length === 0 && defaultCase !== void 0) {
      newActiveCases.push(defaultCase);
    }
    return onResolve(this.activeCases.length > 0 ? this._clearActiveCases(initiator, newActiveCases) : void 0, () => {
      this.activeCases = newActiveCases;
      if (newActiveCases.length === 0) {
        return;
      }
      return this._activateCases(initiator);
    });
  }
  /** @internal */
  _activateCases(initiator) {
    const controller = this.$controller;
    if (!controller.isActive) {
      return;
    }
    const cases = this.activeCases;
    const length = cases.length;
    if (length === 0) {
      return;
    }
    const scope = controller.scope;
    if (length === 1) {
      return cases[0].activate(initiator, scope);
    }
    return onResolveAll(...cases.map(($case) => $case.activate(initiator, scope)));
  }
  /** @internal */
  _clearActiveCases(initiator, newActiveCases = []) {
    const cases = this.activeCases;
    const numCases = cases.length;
    if (numCases === 0) {
      return;
    }
    if (numCases === 1) {
      const firstCase = cases[0];
      if (!newActiveCases.includes(firstCase)) {
        cases.length = 0;
        return firstCase.deactivate(initiator);
      }
      return;
    }
    return onResolve(onResolveAll(...cases.reduce((acc, $case) => {
      if (!newActiveCases.includes($case)) {
        acc.push($case.deactivate(initiator));
      }
      return acc;
    }, [])), () => {
      cases.length = 0;
    });
  }
  queue(action) {
    const previousPromise = this.promise;
    let promise = void 0;
    promise = this.promise = onResolve(onResolve(previousPromise, action), () => {
      if (this.promise === promise) {
        this.promise = void 0;
      }
    });
  }
  accept(visitor) {
    if (this.$controller.accept(visitor) === true) {
      return true;
    }
    if (this.activeCases.some((x2) => x2.accept(visitor))) {
      return true;
    }
  }
};
Switch$1.$au = {
  type: attrTypeName,
  name: "switch",
  isTemplateController: true,
  bindables: ["value"]
};
let caseId = 0;
const bindables$1 = [
  "value",
  {
    name: "fallThrough",
    mode: oneTime,
    set(v2) {
      switch (v2) {
        case "true":
          return true;
        case "false":
          return false;
        default:
          return !!v2;
      }
    }
  }
];
class Case {
  constructor() {
    this.id = ++caseId;
    this.fallThrough = false;
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._locator = resolve(IObserverLocator);
    this._location = resolve(IRenderLocation);
    this._logger = resolve(ILogger).scopeTo(`${this.constructor.name}-#${this.id}`);
  }
  link(controller, _childController, _target, _instruction) {
    const switchController = controller.parent;
    const $switch = switchController?.viewModel;
    if ($switch instanceof Switch$1) {
      this.$switch = $switch;
      this.linkToSwitch($switch);
    } else {
      throw createMappedError$2(
        815
        /* ErrorNames.switch_invalid_usage */
      );
    }
  }
  detaching(initiator, _parent) {
    return this.deactivate(initiator);
  }
  isMatch(value) {
    this._logger.debug("isMatch()");
    const $value = this.value;
    if (isArray($value)) {
      if (this._observer === void 0) {
        this._observer = this._observeCollection($value);
      }
      return $value.includes(value);
    }
    return $value === value;
  }
  valueChanged(newValue, _oldValue) {
    if (isArray(newValue)) {
      this._observer?.unsubscribe(this);
      this._observer = this._observeCollection(newValue);
    } else if (this._observer !== void 0) {
      this._observer.unsubscribe(this);
    }
    this.$switch.caseChanged(this);
  }
  handleCollectionChange() {
    this.$switch.caseChanged(this);
  }
  activate(initiator, scope) {
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(initiator ?? view, this.$controller, scope);
  }
  deactivate(initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(initiator ?? view, this.$controller);
  }
  dispose() {
    this._observer?.unsubscribe(this);
    this.view?.dispose();
    this.view = void 0;
  }
  linkToSwitch(auSwitch) {
    auSwitch.cases.push(this);
  }
  /** @internal */
  _observeCollection($value) {
    const observer = this._locator.getArrayObserver($value);
    observer.subscribe(this);
    return observer;
  }
  accept(visitor) {
    if (this.$controller.accept(visitor) === true) {
      return true;
    }
    return this.view?.accept(visitor);
  }
}
(() => {
  defineAttribute({ name: "case", bindables: bindables$1, isTemplateController: true }, Case);
})();
class DefaultCase extends Case {
  linkToSwitch($switch) {
    if ($switch.defaultCase !== void 0) {
      throw createMappedError$2(
        816
        /* ErrorNames.switch_no_multiple_default */
      );
    }
    $switch.defaultCase = this;
  }
}
(() => {
  defineAttribute({ name: "default-case", bindables: bindables$1, isTemplateController: true }, DefaultCase);
})();
var _a$4, _b$1, _c;
class PromiseTemplateController {
  constructor() {
    this.preSettledTask = null;
    this.postSettledTask = null;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
    this._platform = resolve(IPlatform);
    this.logger = resolve(ILogger).scopeTo("promise.resolve");
  }
  link(_controller, _childController, _target, _instruction) {
    this.view = this._factory.create(this.$controller).setLocation(this._location);
  }
  attaching(initiator, _parent) {
    const view = this.view;
    const $controller = this.$controller;
    return onResolve(view.activate(initiator, $controller, this.viewScope = Scope.fromParent($controller.scope, {})), () => this.swap(initiator));
  }
  valueChanged(_newValue, _oldValue) {
    if (!this.$controller.isActive) {
      return;
    }
    this.swap(null);
  }
  swap(initiator) {
    const value = this.value;
    if (!isPromise(value)) {
      {
        this.logger.warn(`The value '${safeString(value)}' is not a promise. No change will be done.`);
      }
      return;
    }
    const q2 = this._platform.domQueue;
    const fulfilled = this.fulfilled;
    const rejected = this.rejected;
    const pending = this.pending;
    const s3 = this.viewScope;
    let preSettlePromise;
    const $swap = () => {
      void onResolveAll(
        // At first deactivate the fulfilled and rejected views, as well as activate the pending view.
        // The order of these 3 should not necessarily be sequential (i.e. order-irrelevant).
        preSettlePromise = (this.preSettledTask = q2.queueTask(() => {
          return onResolveAll(fulfilled?.deactivate(initiator), rejected?.deactivate(initiator), pending?.activate(initiator, s3));
        })).result.catch((err) => {
          if (!(err instanceof TaskAbortError))
            throw err;
        }),
        value.then((data) => {
          if (this.value !== value) {
            return;
          }
          const fulfill = () => {
            this.postSettlePromise = (this.postSettledTask = q2.queueTask(() => onResolveAll(pending?.deactivate(initiator), rejected?.deactivate(initiator), fulfilled?.activate(initiator, s3, data)))).result;
          };
          if (this.preSettledTask.status === tsRunning) {
            void preSettlePromise.then(fulfill);
          } else {
            this.preSettledTask.cancel();
            fulfill();
          }
        }, (err) => {
          if (this.value !== value) {
            return;
          }
          const reject = () => {
            this.postSettlePromise = (this.postSettledTask = q2.queueTask(() => onResolveAll(pending?.deactivate(initiator), fulfilled?.deactivate(initiator), rejected?.activate(initiator, s3, err)))).result;
          };
          if (this.preSettledTask.status === tsRunning) {
            void preSettlePromise.then(reject);
          } else {
            this.preSettledTask.cancel();
            reject();
          }
        })
      );
    };
    if (this.postSettledTask?.status === tsRunning) {
      void this.postSettlePromise.then($swap);
    } else {
      this.postSettledTask?.cancel();
      $swap();
    }
  }
  detaching(initiator, _parent) {
    this.preSettledTask?.cancel();
    this.postSettledTask?.cancel();
    this.preSettledTask = this.postSettledTask = null;
    return this.view.deactivate(initiator, this.$controller);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
PromiseTemplateController.$au = {
  type: attrTypeName,
  name: "promise",
  isTemplateController: true,
  bindables: ["value"]
};
class PendingTemplateController {
  constructor() {
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(controller, _childController, _target, _instruction) {
    getPromiseController(controller).pending = this;
  }
  activate(initiator, scope) {
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(view, this.$controller, scope);
  }
  deactivate(_initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(view, this.$controller);
  }
  detaching(initiator) {
    return this.deactivate(initiator);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
PendingTemplateController.$au = {
  type: attrTypeName,
  name: "pending",
  isTemplateController: true,
  bindables: {
    value: { mode: toView }
  }
};
class FulfilledTemplateController {
  constructor() {
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(controller, _childController, _target, _instruction) {
    getPromiseController(controller).fulfilled = this;
  }
  activate(initiator, scope, resolvedValue) {
    this.value = resolvedValue;
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(view, this.$controller, scope);
  }
  deactivate(_initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(view, this.$controller);
  }
  detaching(initiator, _parent) {
    return this.deactivate(initiator);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
FulfilledTemplateController.$au = {
  type: attrTypeName,
  name: "then",
  isTemplateController: true,
  bindables: {
    value: { mode: fromView }
  }
};
class RejectedTemplateController {
  constructor() {
    this.view = void 0;
    this._factory = resolve(IViewFactory);
    this._location = resolve(IRenderLocation);
  }
  link(controller, _childController, _target, _instruction) {
    getPromiseController(controller).rejected = this;
  }
  activate(initiator, scope, error2) {
    this.value = error2;
    let view = this.view;
    if (view === void 0) {
      view = this.view = this._factory.create().setLocation(this._location);
    }
    if (view.isActive) {
      return;
    }
    return view.activate(view, this.$controller, scope);
  }
  deactivate(_initiator) {
    const view = this.view;
    if (view === void 0 || !view.isActive) {
      return;
    }
    return view.deactivate(view, this.$controller);
  }
  detaching(initiator, _parent) {
    return this.deactivate(initiator);
  }
  dispose() {
    this.view?.dispose();
    this.view = void 0;
  }
}
RejectedTemplateController.$au = {
  type: attrTypeName,
  name: "catch",
  isTemplateController: true,
  bindables: {
    value: { mode: fromView }
  }
};
function getPromiseController(controller) {
  const promiseController = controller.parent;
  const $promise = promiseController?.viewModel;
  if ($promise instanceof PromiseTemplateController) {
    return $promise;
  }
  throw createMappedError$2(
    813
    /* ErrorNames.promise_invalid_usage */
  );
}
class PromiseAttributePattern {
  "promise.resolve"(name2, value) {
    return new AttrSyntax(name2, value, "promise", "bind");
  }
}
_a$4 = Symbol.metadata;
PromiseAttributePattern[_a$4] = {
  [registrableMetadataKey]: AttributePattern.create([{ pattern: "promise.resolve", symbols: "" }], PromiseAttributePattern)
};
class FulfilledAttributePattern {
  "then"(name2, value) {
    return new AttrSyntax(name2, value, "then", "from-view");
  }
}
_b$1 = Symbol.metadata;
FulfilledAttributePattern[_b$1] = {
  [registrableMetadataKey]: AttributePattern.create([{ pattern: "then", symbols: "" }], FulfilledAttributePattern)
};
class RejectedAttributePattern {
  "catch"(name2, value) {
    return new AttrSyntax(name2, value, "catch", "from-view");
  }
}
_c = Symbol.metadata;
RejectedAttributePattern[_c] = {
  [registrableMetadataKey]: AttributePattern.create([{ pattern: "catch", symbols: "" }], RejectedAttributePattern)
};
class Focus {
  constructor() {
    this._needsApply = false;
    this._element = resolve(INode);
    this._platform = resolve(IPlatform);
  }
  binding() {
    this.valueChanged();
  }
  /**
   * Invoked everytime the bound value changes.
   *
   * @param newValue - The new value.
   */
  valueChanged() {
    if (this.$controller.isActive) {
      this._apply();
    } else {
      this._needsApply = true;
    }
  }
  /**
   * Invoked when the attribute is attached to the DOM.
   */
  attached() {
    if (this._needsApply) {
      this._needsApply = false;
      this._apply();
    }
    this._element.addEventListener("focus", this);
    this._element.addEventListener("blur", this);
  }
  /**
   * Invoked when the attribute is afterDetachChildren from the DOM.
   */
  detaching() {
    const el = this._element;
    el.removeEventListener("focus", this);
    el.removeEventListener("blur", this);
  }
  /**
   * EventTarget interface handler for better memory usage
   */
  handleEvent(e2) {
    if (e2.type === "focus") {
      this.value = true;
    } else if (!this._isElFocused) {
      this.value = false;
    }
  }
  /**
   * Focus/blur based on current value
   *
   * @internal
   */
  _apply() {
    const el = this._element;
    const isFocused = this._isElFocused;
    const shouldFocus = this.value;
    if (shouldFocus && !isFocused) {
      el.focus();
    } else if (!shouldFocus && isFocused) {
      el.blur();
    }
  }
  /** @internal */
  get _isElFocused() {
    return this._element === this._platform.document.activeElement;
  }
}
Focus.$au = {
  type: attrTypeName,
  name: "focus",
  bindables: {
    value: { mode: twoWay }
  }
};
class Portal {
  constructor() {
    this.position = "beforeend";
    this.strict = false;
    const factory = resolve(IViewFactory);
    const originalLoc = resolve(IRenderLocation);
    const p2 = resolve(IPlatform);
    this._platform = p2;
    this._resolvedTarget = p2.document.createElement("div");
    (this.view = factory.create()).setLocation(this._targetLocation = createLocation(p2));
    setEffectiveParentNode(this.view.nodes, originalLoc);
  }
  attaching(initiator) {
    if (this.callbackContext == null) {
      this.callbackContext = this.$controller.scope.bindingContext;
    }
    const newTarget = this._resolvedTarget = this._getTarget();
    this._moveLocation(newTarget, this.position);
    return this._activating(initiator, newTarget);
  }
  detaching(initiator) {
    return this._deactivating(initiator, this._resolvedTarget);
  }
  targetChanged() {
    const { $controller } = this;
    if (!$controller.isActive) {
      return;
    }
    const newTarget = this._getTarget();
    if (this._resolvedTarget === newTarget) {
      return;
    }
    this._resolvedTarget = newTarget;
    const ret = onResolve(this._deactivating(null, newTarget), () => {
      this._moveLocation(newTarget, this.position);
      return this._activating(null, newTarget);
    });
    if (isPromise(ret)) {
      ret.catch(rethrow);
    }
  }
  positionChanged() {
    const { $controller, _resolvedTarget } = this;
    if (!$controller.isActive) {
      return;
    }
    const ret = onResolve(this._deactivating(null, _resolvedTarget), () => {
      this._moveLocation(_resolvedTarget, this.position);
      return this._activating(null, _resolvedTarget);
    });
    if (isPromise(ret)) {
      ret.catch(rethrow);
    }
  }
  /** @internal */
  _activating(initiator, target) {
    const { activating: activating2, callbackContext, view } = this;
    return onResolve(activating2?.call(callbackContext, target, view), () => {
      return this._activate(initiator, target);
    });
  }
  /** @internal */
  _activate(initiator, target) {
    const { $controller, view } = this;
    if (initiator === null) {
      view.nodes.insertBefore(this._targetLocation);
    } else {
      return onResolve(view.activate(initiator ?? view, $controller, $controller.scope), () => {
        return this._activated(target);
      });
    }
    return this._activated(target);
  }
  /** @internal */
  _activated(target) {
    const { activated: activated2, callbackContext, view } = this;
    return activated2?.call(callbackContext, target, view);
  }
  /** @internal */
  _deactivating(initiator, target) {
    const { deactivating: deactivating2, callbackContext, view } = this;
    return onResolve(deactivating2?.call(callbackContext, target, view), () => {
      return this._deactivate(initiator, target);
    });
  }
  /** @internal */
  _deactivate(initiator, target) {
    const { $controller, view } = this;
    if (initiator === null) {
      view.nodes.remove();
    } else {
      return onResolve(view.deactivate(initiator, $controller), () => {
        return this._deactivated(target);
      });
    }
    return this._deactivated(target);
  }
  /** @internal */
  _deactivated(target) {
    const { deactivated: deactivated2, callbackContext, view } = this;
    return onResolve(deactivated2?.call(callbackContext, target, view), () => this._removeLocation());
  }
  /** @internal */
  _getTarget() {
    const p2 = this._platform;
    const $document = p2.document;
    let target = this.target;
    let context = this.renderContext;
    if (target === "") {
      if (this.strict) {
        throw createMappedError$2(
          811
          /* ErrorNames.portal_query_empty */
        );
      }
      return $document.body;
    }
    if (isString(target)) {
      let queryContext = $document;
      if (isString(context)) {
        context = $document.querySelector(context);
      }
      if (context instanceof p2.Node) {
        queryContext = context;
      }
      target = queryContext.querySelector(target);
    }
    if (target instanceof p2.Node) {
      return target;
    }
    if (target == null) {
      if (this.strict) {
        throw createMappedError$2(
          812
          /* ErrorNames.portal_no_target */
        );
      }
      return $document.body;
    }
    return target;
  }
  /** @internal */
  _removeLocation() {
    this._targetLocation.remove();
    this._targetLocation.$start.remove();
  }
  /** @internal */
  _moveLocation(target, position) {
    const end2 = this._targetLocation;
    const start2 = end2.$start;
    const parent = target.parentNode;
    const nodes = [start2, end2];
    switch (position) {
      case "beforeend":
        insertManyBefore(target, null, nodes);
        break;
      case "afterbegin":
        insertManyBefore(target, target.firstChild, nodes);
        break;
      case "beforebegin":
        insertManyBefore(parent, target, nodes);
        break;
      case "afterend":
        insertManyBefore(parent, target.nextSibling, nodes);
        break;
      default:
        throw createMappedError$2(779, position);
    }
  }
  dispose() {
    this.view.dispose();
    this.view = void 0;
    this.callbackContext = null;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
}
Portal.$au = {
  type: attrTypeName,
  name: "portal",
  isTemplateController: true,
  bindables: [
    { name: "target", primary: true },
    "position",
    "activated",
    "activating",
    "callbackContext",
    { name: "renderContext", callback: "targetChanged" },
    "strict",
    "deactivated",
    "deactivating"
  ]
  // bindables: {
  //   target: { primary: true },
  //   position: true,
  //   renderContext: { callback: 'targetChanged' },
  //   activated: true,
  //   activating: true,
  //   callbackContext: true,
  //   deactivated: true,
  //   deactivating: true,
  //   strict: true
  // }
};
let emptyTemplate;
class AuSlot {
  constructor() {
    this._parentScope = null;
    this._outerScope = null;
    this._attached = false;
    this.expose = null;
    this.slotchange = null;
    this._subs = /* @__PURE__ */ new Set();
    this._observer = null;
    const hdrContext = resolve(IHydrationContext);
    const location = resolve(IRenderLocation);
    const instruction = resolve(IInstruction);
    const rendering = resolve(IRendering);
    const slotName = this.name = instruction.data.name;
    const fallback = instruction.projections?.[defaultSlotName];
    const projection = hdrContext.instruction?.projections?.[slotName];
    const contextContainer = hdrContext.controller.container;
    let factory;
    let container;
    if (projection == null) {
      container = contextContainer.createChild({ inheritParentResources: true });
      factory = rendering.getViewFactory(fallback ?? (emptyTemplate ??= CustomElementDefinition.create({
        name: "au-slot-empty-template",
        template: "",
        needsCompile: false
      })), container);
      this._hasProjection = false;
    } else {
      container = contextContainer.createChild();
      container.useResources(hdrContext.parent.controller.container);
      registerResolver(container, IHydrationContext, new InstanceProvider(void 0, hdrContext.parent));
      factory = rendering.getViewFactory(projection, container);
      this._hasProjection = true;
      this._slotwatchers = contextContainer.getAll(IAuSlotWatcher, false)?.filter((w2) => w2.slotName === "*" || w2.slotName === slotName) ?? emptyArray;
    }
    this._hasSlotWatcher = (this._slotwatchers ??= emptyArray).length > 0;
    this._hdrContext = hdrContext;
    this.view = factory.create().setLocation(this._location = location);
  }
  get nodes() {
    const nodes = [];
    const location = this._location;
    let curr = location.$start.nextSibling;
    while (curr != null && curr !== location) {
      if (curr.nodeType !== /* comment */
      8) {
        nodes.push(curr);
      }
      curr = curr.nextSibling;
    }
    return nodes;
  }
  subscribe(subscriber) {
    this._subs.add(subscriber);
  }
  unsubscribe(subscriber) {
    this._subs.delete(subscriber);
  }
  binding(_initiator, parent) {
    this._parentScope = parent.scope;
    while (parent.vmKind === "synthetic" && parent.parent?.viewModel instanceof AuSlot) {
      parent = parent.parent.parent;
    }
    const host = parent.scope.bindingContext;
    let outerScope;
    if (this._hasProjection) {
      outerScope = this._hdrContext.controller.scope.parent;
      (this._outerScope = Scope.fromParent(outerScope, outerScope.bindingContext)).overrideContext.$host = this.expose ?? host;
    }
  }
  attaching(initiator, _parent) {
    return onResolve(this.view.activate(initiator, this.$controller, this._hasProjection ? this._outerScope : this._parentScope), () => {
      if (this._hasSlotWatcher) {
        this._slotwatchers.forEach((w2) => w2.watch(this));
        this._observe();
        this._notifySlotChange();
        this._attached = true;
      }
    });
  }
  detaching(initiator, _parent) {
    this._attached = false;
    this._unobserve();
    this._slotwatchers.forEach((w2) => w2.unwatch(this));
    return this.view.deactivate(initiator, this.$controller);
  }
  exposeChanged(v2) {
    if (this._hasProjection && this._outerScope != null) {
      this._outerScope.overrideContext.$host = v2;
    }
  }
  dispose() {
    this.view.dispose();
    this.view = void 0;
  }
  accept(visitor) {
    if (this.view?.accept(visitor) === true) {
      return true;
    }
  }
  /** @internal */
  _observe() {
    if (this._observer != null) {
      return;
    }
    const location = this._location;
    const parent = location.parentElement;
    if (parent == null) {
      return;
    }
    (this._observer = createMutationObserver(parent, (records) => {
      if (isMutationWithinLocation(location, records)) {
        this._notifySlotChange();
      }
    })).observe(parent, { childList: true });
  }
  /** @internal */
  _unobserve() {
    this._observer?.disconnect();
    this._observer = null;
  }
  /** @internal */
  _notifySlotChange() {
    const nodes = this.nodes;
    const subs = new Set(this._subs);
    let sub;
    if (this._attached) {
      this.slotchange?.call(void 0, this.name, nodes);
    }
    for (sub of subs) {
      sub.handleSlotChange(this, nodes);
    }
  }
}
AuSlot.$au = {
  type: elementTypeName,
  name: "au-slot",
  template: null,
  containerless: true,
  processContent(el, p2, data) {
    data.name = el.getAttribute("name") ?? defaultSlotName;
    let node = el.firstChild;
    let next = null;
    while (node !== null) {
      next = node.nextSibling;
      if (isElement$2(node) && node.hasAttribute(auslotAttr)) {
        {
          console.warn(`[DEV:aurelia] detected [au-slot] attribute on a child node`, `of an <au-slot> element: "<${node.nodeName} au-slot>".`, `This element will be ignored and removed`);
        }
        el.removeChild(node);
      }
      node = next;
    }
  },
  bindables: ["expose", "slotchange"]
};
const comparePosition = (a2, b3) => a2.compareDocumentPosition(b3);
const isMutationWithinLocation = (location, records) => {
  for (const { addedNodes, removedNodes, nextSibling } of records) {
    let i3 = 0;
    let ii = addedNodes.length;
    let node;
    for (; i3 < ii; ++i3) {
      node = addedNodes[i3];
      if (comparePosition(location.$start, node) === /* DOCUMENT_POSITION_FOLLOWING */
      4 && comparePosition(location, node) === /* DOCUMENT_POSITION_PRECEDING */
      2) {
        return true;
      }
    }
    if (removedNodes.length > 0) {
      if (nextSibling != null && comparePosition(location.$start, nextSibling) === /* DOCUMENT_POSITION_FOLLOWING */
      4 && comparePosition(location, nextSibling) === /* DOCUMENT_POSITION_PRECEDING */
      2) {
        return true;
      }
    }
  }
};
class AuCompose {
  constructor() {
    this.scopeBehavior = "auto";
    this._composition = void 0;
    this.tag = null;
    this._container = resolve(IContainer);
    this.parent = resolve(IController);
    this._host = resolve(INode);
    this._location = resolve(IRenderLocation);
    this._platform = resolve(IPlatform);
    this._rendering = resolve(IRendering);
    this._instruction = resolve(IInstruction);
    this._contextFactory = resolve(transient(CompositionContextFactory));
    this._compiler = resolve(ITemplateCompiler);
    this._hydrationContext = resolve(IHydrationContext);
    this._exprParser = resolve(IExpressionParser);
    this._observerLocator = resolve(IObserverLocator);
  }
  get composing() {
    return this._composing;
  }
  get composition() {
    return this._composition;
  }
  attaching(initiator, _parent) {
    return this._composing = onResolve(this.queue(new ChangeInfo(this.template, this.component, this.model, void 0), initiator), (context) => {
      if (this._contextFactory._isCurrent(context)) {
        this._composing = void 0;
      }
    });
  }
  detaching(initiator) {
    const cmpstn = this._composition;
    const pending = this._composing;
    this._contextFactory.invalidate();
    this._composition = this._composing = void 0;
    return onResolve(pending, () => cmpstn?.deactivate(initiator));
  }
  /** @internal */
  propertyChanged(name2) {
    if (name2 === "composing" || name2 === "composition")
      return;
    if (name2 === "model" && this._composition != null) {
      this._composition.update(this.model);
      return;
    }
    if (name2 === "tag" && this._composition?.controller.vmKind === vmkCe) {
      {
        console.warn("[DEV:aurelia] Changing tag name of a custom element composition is ignored.");
      }
      return;
    }
    this._composing = onResolve(this._composing, () => onResolve(this.queue(new ChangeInfo(this.template, this.component, this.model, name2), void 0), (context) => {
      if (this._contextFactory._isCurrent(context)) {
        this._composing = void 0;
      }
    }));
  }
  /** @internal */
  queue(change, initiator) {
    const factory = this._contextFactory;
    const prevCompositionCtrl = this._composition;
    return onResolve(factory.create(change), (context) => {
      if (factory._isCurrent(context)) {
        return onResolve(this.compose(context), (result) => {
          if (factory._isCurrent(context)) {
            return onResolve(result.activate(initiator), () => {
              if (factory._isCurrent(context)) {
                this._composition = result;
                return onResolve(prevCompositionCtrl?.deactivate(initiator), () => context);
              } else {
                return onResolve(
                  result.controller.deactivate(result.controller, this.$controller),
                  // todo: do we need to deactivate?
                  () => {
                    result.controller.dispose();
                    return context;
                  }
                );
              }
            });
          }
          result.controller.dispose();
          return context;
        });
      }
      return context;
    });
  }
  /** @internal */
  compose(context) {
    const { _template: template2, _component: component, _model: model } = context.change;
    const { _container: container, $controller, _location: loc, _instruction } = this;
    const vmDef = this._getDefinition(this._hydrationContext.controller.container, component);
    const childCtn = container.createChild();
    const compositionHost = this._platform.document.createElement(vmDef == null ? this.tag ?? "div" : vmDef.name);
    loc.parentNode.insertBefore(compositionHost, loc);
    let compositionLocation;
    if (vmDef == null) {
      compositionLocation = this.tag == null ? convertToRenderLocation(compositionHost) : null;
    } else {
      compositionLocation = vmDef.containerless ? convertToRenderLocation(compositionHost) : null;
    }
    const removeCompositionHost = () => {
      compositionHost.remove();
      if (compositionLocation != null) {
        let curr = compositionLocation.$start.nextSibling;
        let next = null;
        while (curr !== null && curr !== compositionLocation) {
          next = curr.nextSibling;
          curr.remove();
          curr = next;
        }
        compositionLocation.$start?.remove();
        compositionLocation.remove();
      }
    };
    const comp = this._createComponentInstance(childCtn, typeof component === "string" ? vmDef.Type : component, compositionHost, compositionLocation);
    const compose = () => {
      const aucomposeCapturedAttrs = _instruction.captures ?? emptyArray;
      if (vmDef !== null) {
        const capture = vmDef.capture;
        const [capturedBindingAttrs, transferedToHostBindingAttrs] = aucomposeCapturedAttrs.reduce((attrGroups, attr) => {
          const shouldCapture = !(attr.target in vmDef.bindables) && (capture === true || isFunction(capture) && !!capture(attr.target));
          attrGroups[shouldCapture ? 0 : 1].push(attr);
          return attrGroups;
        }, [[], []]);
        const controller = Controller.$el(childCtn, comp, compositionHost, {
          projections: _instruction.projections,
          captures: capturedBindingAttrs
        }, vmDef, compositionLocation);
        this._createSpreadBindings(compositionHost, vmDef, transferedToHostBindingAttrs).forEach((b3) => controller.addBinding(b3));
        return new CompositionController(
          controller,
          (attachInitiator) => controller.activate(attachInitiator ?? controller, $controller, $controller.scope.parent),
          // todo: call deactivate on the component component
          (deactachInitiator) => onResolve(controller.deactivate(deactachInitiator ?? controller, $controller), removeCompositionHost),
          // casting is technically incorrect
          // but it's ignored in the caller anyway
          (model2) => comp.activate?.(model2),
          context
        );
      } else {
        const targetDef = CustomElementDefinition.create({
          name: CustomElement.generateName(),
          template: template2
        });
        const viewFactory = this._rendering.getViewFactory(targetDef, childCtn);
        const controller = Controller.$view(viewFactory, $controller);
        const scope = this.scopeBehavior === "auto" ? Scope.fromParent(this.parent.scope, comp) : Scope.create(comp);
        controller.setHost(compositionHost);
        if (compositionLocation == null) {
          this._createSpreadBindings(compositionHost, targetDef, aucomposeCapturedAttrs).forEach((b3) => controller.addBinding(b3));
        } else {
          controller.setLocation(compositionLocation);
        }
        return new CompositionController(
          controller,
          (attachInitiator) => controller.activate(attachInitiator ?? controller, $controller, scope),
          // todo: call deactivate on the component
          // a difference with composing custom element is that we leave render location/host alone
          // as they all share the same host/render location
          (detachInitiator) => onResolve(controller.deactivate(detachInitiator ?? controller, $controller), removeCompositionHost),
          // casting is technically incorrect
          // but it's ignored in the caller anyway
          (model2) => comp.activate?.(model2),
          context
        );
      }
    };
    if ("activate" in comp) {
      return onResolve(comp.activate(model), () => compose());
    } else {
      return compose();
    }
  }
  /** @internal */
  _createComponentInstance(container, comp, host, location) {
    if (comp == null) {
      return new EmptyComponent();
    }
    if (typeof comp === "object") {
      return comp;
    }
    const p2 = this._platform;
    registerHostNode(container, host, p2);
    registerResolver(container, IRenderLocation, new InstanceProvider("IRenderLocation", location));
    const instance = container.invoke(comp);
    registerResolver(container, comp, new InstanceProvider("au-compose.component", instance));
    return instance;
  }
  /** @internal */
  _getDefinition(container, component) {
    if (typeof component === "string") {
      const def2 = CustomElement.find(container, component);
      if (def2 == null) {
        throw createMappedError$2(806, component);
      }
      return def2;
    }
    const Ctor = isFunction(component) ? component : component?.constructor;
    return CustomElement.isType(Ctor, void 0) ? CustomElement.getDefinition(Ctor, null) : null;
  }
  /** @internal */
  _createSpreadBindings(host, def2, capturedAttrs) {
    const transferHydrationContext = new HydrationContext(this.$controller, { projections: null, captures: capturedAttrs }, this._hydrationContext.parent);
    return SpreadBinding.create(transferHydrationContext, host, def2, this._rendering, this._compiler, this._platform, this._exprParser, this._observerLocator);
  }
}
AuCompose.$au = {
  type: elementTypeName,
  name: "au-compose",
  capture: true,
  containerless: true,
  bindables: [
    "template",
    "component",
    "model",
    { name: "scopeBehavior", set: (v2) => {
      if (v2 === "scoped" || v2 === "auto") {
        return v2;
      }
      throw createMappedError$2(805, v2);
    } },
    { name: "composing", mode: fromView },
    { name: "composition", mode: fromView },
    "tag"
  ]
};
class EmptyComponent {
}
class CompositionContextFactory {
  constructor() {
    this.id = 0;
  }
  _isCurrent(context) {
    return context.id === this.id;
  }
  create(changes) {
    return onResolve(changes.load(), (loaded) => new CompositionContext(++this.id, loaded));
  }
  // simplify increasing the id will invalidate all previously created context
  invalidate() {
    this.id++;
  }
}
class ChangeInfo {
  constructor(_template, _component, _model, _src) {
    this._template = _template;
    this._component = _component;
    this._model = _model;
    this._src = _src;
  }
  load() {
    if (isPromise(this._template) || isPromise(this._component)) {
      return Promise.all([this._template, this._component]).then(([template2, component]) => {
        return new LoadedChangeInfo(template2, component, this._model, this._src);
      });
    } else {
      return new LoadedChangeInfo(this._template, this._component, this._model, this._src);
    }
  }
}
class LoadedChangeInfo {
  constructor(_template, _component, _model, _src) {
    this._template = _template;
    this._component = _component;
    this._model = _model;
    this._src = _src;
  }
}
class CompositionContext {
  constructor(id2, change) {
    this.id = id2;
    this.change = change;
  }
}
class CompositionController {
  constructor(controller, start2, stop, update, context) {
    this.controller = controller;
    this.start = start2;
    this.stop = stop;
    this.update = update;
    this.context = context;
    this.state = 0;
  }
  activate(initiator) {
    if (this.state !== 0) {
      throw createMappedError$2(807, this);
    }
    this.state = 1;
    return this.start(initiator);
  }
  deactivate(detachInitator) {
    switch (this.state) {
      case 1:
        this.state = -1;
        return this.stop(detachInitator);
      case -1:
        throw createMappedError$2(
          808
          /* ErrorNames.au_compose_duplicate_deactivate */
        );
      default:
        this.state = -1;
    }
  }
}
const ISanitizer = /* @__PURE__ */ createInterface("ISanitizer", (x2) => x2.singleton(class {
  sanitize() {
    throw createMappedError$2(99, "sanitize");
  }
}));
class SanitizeValueConverter {
  constructor() {
    this._sanitizer = resolve(ISanitizer);
  }
  /**
   * Process the provided markup that flows to the view.
   *
   * @param untrustedMarkup - The untrusted markup to be sanitized.
   */
  toView(untrustedMarkup) {
    if (untrustedMarkup == null) {
      return null;
    }
    return this._sanitizer.sanitize(untrustedMarkup);
  }
}
SanitizeValueConverter.$au = {
  type: converterTypeName,
  name: "sanitize"
};
class Show {
  constructor() {
    this.el = resolve(INode);
    this.p = resolve(IPlatform);
    this._isActive = false;
    this._task = null;
    this.$val = "";
    this.$prio = "";
    this.update = () => {
      this._task = null;
      if (Boolean(this.value) !== this._isToggled) {
        if (this._isToggled === this._base) {
          this._isToggled = !this._base;
          this.$val = this.el.style.getPropertyValue("display");
          this.$prio = this.el.style.getPropertyPriority("display");
          this.el.style.setProperty("display", "none", "important");
        } else {
          this._isToggled = this._base;
          this.el.style.setProperty("display", this.$val, this.$prio);
          if (this.el.getAttribute("style") === "") {
            this.el.removeAttribute("style");
          }
        }
      }
    };
    const instr = resolve(IInstruction);
    this._isToggled = this._base = instr.alias !== "hide";
  }
  binding() {
    this._isActive = true;
    this.update();
  }
  detaching() {
    this._isActive = false;
    this._task?.cancel();
    this._task = null;
  }
  valueChanged() {
    if (this._isActive && this._task === null) {
      this._task = this.p.domQueue.queueTask(this.update);
    }
  }
}
Show.$au = {
  type: attrTypeName,
  name: "show",
  bindables: ["value"],
  aliases: ["hide"]
};
const DefaultComponents$1 = [
  RuntimeTemplateCompilerImplementation,
  DirtyChecker,
  NodeObserverLocator
];
const DefaultBindingSyntax = [
  RefAttributePattern,
  DotSeparatedAttributePattern,
  EventAttributePattern,
  EventModifierRegistration
];
const DefaultBindingLanguage = [
  DefaultBindingCommand,
  OneTimeBindingCommand,
  FromViewBindingCommand,
  ToViewBindingCommand,
  TwoWayBindingCommand,
  ForBindingCommand,
  RefBindingCommand,
  TriggerBindingCommand,
  CaptureBindingCommand,
  ClassBindingCommand,
  StyleBindingCommand,
  AttrBindingCommand,
  SpreadValueBindingCommand
];
const DefaultResources$1 = [
  DebounceBindingBehavior,
  OneTimeBindingBehavior,
  ToViewBindingBehavior,
  FromViewBindingBehavior,
  SignalBindingBehavior,
  ThrottleBindingBehavior,
  TwoWayBindingBehavior,
  SanitizeValueConverter,
  If,
  Else,
  Repeat,
  With,
  Switch$1,
  Case,
  DefaultCase,
  PromiseTemplateController,
  PendingTemplateController,
  FulfilledTemplateController,
  RejectedTemplateController,
  PromiseAttributePattern,
  FulfilledAttributePattern,
  RejectedAttributePattern,
  AttrBindingBehavior,
  SelfBindingBehavior,
  UpdateTriggerBindingBehavior,
  AuCompose,
  Portal,
  Focus,
  Show,
  AuSlot
];
const DefaultRenderers = [
  PropertyBindingRenderer,
  IteratorBindingRenderer,
  RefBindingRenderer,
  InterpolationBindingRenderer,
  SetPropertyRenderer,
  CustomElementRenderer,
  CustomAttributeRenderer,
  TemplateControllerRenderer,
  LetElementRenderer,
  ListenerBindingRenderer,
  AttributeBindingRenderer,
  SetAttributeRenderer,
  SetClassAttributeRenderer,
  SetStyleAttributeRenderer,
  StylePropertyBindingRenderer,
  TextBindingRenderer,
  SpreadRenderer,
  SpreadValueRenderer
];
const StandardConfiguration = /* @__PURE__ */ createConfiguration$2(noop$1);
function createConfiguration$2(optionsProvider) {
  return {
    optionsProvider,
    /**
     * Apply this configuration to the provided container.
     */
    register(container) {
      const runtimeConfigurationOptions = {
        coercingOptions: {
          enableCoercion: false,
          coerceNullish: false
        }
      };
      optionsProvider(runtimeConfigurationOptions);
      return container.register(instanceRegistration(ICoercionConfiguration, runtimeConfigurationOptions.coercingOptions), ExpressionParser, ...DefaultComponents$1, ...DefaultResources$1, ...DefaultBindingSyntax, ...DefaultBindingLanguage, ...DefaultRenderers);
    },
    customize(cb) {
      return createConfiguration$2(cb ?? optionsProvider);
    }
  };
}
const PLATFORM = BrowserPlatform.getOrCreate(globalThis);
function createContainer() {
  return DI.createContainer().register(Registration.instance(IPlatform, PLATFORM), StandardConfiguration);
}
class Aurelia2 extends Aurelia$1 {
  constructor(container = createContainer()) {
    super(container);
  }
  static app(config) {
    return new Aurelia2().app(config);
  }
  static enhance(config) {
    return new Aurelia2().enhance(config);
  }
  static register(...params) {
    return new Aurelia2().register(...params);
  }
  app(config) {
    if (CustomElement.isType(config)) {
      const definition = CustomElement.getDefinition(config);
      let host = document.querySelector(definition.name);
      if (host === null) {
        host = document.body;
      }
      return super.app({
        host,
        component: config
      });
    }
    return super.app(config);
  }
}
class Parameter {
  constructor(name2, isOptional, isStar, pattern) {
    this.name = name2;
    this.isOptional = isOptional;
    this.isStar = isStar;
    this.pattern = pattern;
  }
  satisfiesPattern(value) {
    if (this.pattern === null)
      return true;
    this.pattern.lastIndex = 0;
    return this.pattern.test(value);
  }
}
class ConfigurableRoute {
  constructor(path, caseSensitive, handler) {
    this.path = path;
    this.caseSensitive = caseSensitive;
    this.handler = handler;
  }
}
class Endpoint {
  get residualEndpoint() {
    return this._residualEndpoint;
  }
  /** @internal */
  set residualEndpoint(endpoint) {
    if (this._residualEndpoint !== null)
      throw new Error("Residual endpoint is already set");
    this._residualEndpoint = endpoint;
  }
  constructor(route2, params) {
    this.route = route2;
    this.params = params;
    this._residualEndpoint = null;
  }
  equalsOrResidual(other) {
    return other != null && this === other || this._residualEndpoint === other;
  }
}
class RecognizedRoute {
  constructor(endpoint, params) {
    this.endpoint = endpoint;
    const $params = /* @__PURE__ */ Object.create(null);
    for (const key in params) {
      const value = params[key];
      $params[key] = value != null ? decodeURIComponent(value) : value;
    }
    this.params = Object.freeze($params);
  }
}
class Candidate {
  constructor(chars, states, skippedStates, result) {
    this.chars = chars;
    this.states = states;
    this.skippedStates = skippedStates;
    this.result = result;
    this.params = null;
    this.isConstrained = false;
    this.satisfiesConstraints = null;
    this.head = states[states.length - 1];
    this.endpoint = this.head?.endpoint;
  }
  advance(ch) {
    const { chars, states, skippedStates, result } = this;
    let stateToAdd = null;
    let matchCount = 0;
    const state = states[states.length - 1];
    function $process(nextState, skippedState) {
      if (nextState.isMatch(ch)) {
        if (++matchCount === 1) {
          stateToAdd = nextState;
        } else {
          result.add(new Candidate(chars.concat(ch), states.concat(nextState), skippedState === null ? skippedStates : skippedStates.concat(skippedState), result));
        }
      }
      if (state.segment === null && nextState.isOptional && nextState.nextStates !== null) {
        if (nextState.nextStates.length > 1) {
          throw createError(`${nextState.nextStates.length} nextStates`);
        }
        const separator = nextState.nextStates[0];
        if (!separator.isSeparator) {
          throw createError(`Not a separator`);
        }
        if (separator.nextStates !== null) {
          for (const $nextState of separator.nextStates) {
            $process($nextState, nextState);
          }
        }
      }
    }
    if (state.isDynamic) {
      $process(state, null);
    }
    if (state.nextStates !== null) {
      for (const nextState of state.nextStates) {
        $process(nextState, null);
      }
    }
    if (stateToAdd !== null) {
      states.push(this.head = stateToAdd);
      chars.push(ch);
      this.isConstrained = this.isConstrained || stateToAdd.isDynamic && stateToAdd.segment.isConstrained;
      if (stateToAdd.endpoint !== null) {
        this.endpoint = stateToAdd.endpoint;
      }
    }
    if (matchCount === 0) {
      result.remove(this);
    }
  }
  /** @internal */
  _finalize() {
    function collectSkippedStates(skippedStates, state) {
      const nextStates = state.nextStates;
      if (nextStates !== null) {
        if (nextStates.length === 1 && nextStates[0].segment === null) {
          collectSkippedStates(skippedStates, nextStates[0]);
        } else {
          for (const nextState of nextStates) {
            if (nextState.isOptional && nextState.endpoint !== null) {
              skippedStates.push(nextState);
              if (nextState.nextStates !== null) {
                for (const $nextState of nextState.nextStates) {
                  collectSkippedStates(skippedStates, $nextState);
                }
              }
              break;
            }
          }
        }
      }
    }
    collectSkippedStates(this.skippedStates, this.head);
    if (!this.isConstrained)
      return true;
    this._getParams();
    return this.satisfiesConstraints;
  }
  /** @internal */
  _getParams() {
    let params = this.params;
    if (params != null)
      return params;
    const { states, chars, endpoint } = this;
    params = {};
    this.satisfiesConstraints = true;
    for (const param of endpoint.params) {
      params[param.name] = void 0;
    }
    for (let i3 = 0, ii = states.length; i3 < ii; ++i3) {
      const state = states[i3];
      if (state.isDynamic) {
        const segment = state.segment;
        const name2 = segment.name;
        if (params[name2] === void 0) {
          params[name2] = chars[i3];
        } else {
          params[name2] += chars[i3];
        }
        const checkConstraint = state.isConstrained && !Object.is(states[i3 + 1]?.segment, segment);
        if (!checkConstraint)
          continue;
        this.satisfiesConstraints = this.satisfiesConstraints && state.satisfiesConstraint(params[name2]);
      }
    }
    if (this.satisfiesConstraints) {
      this.params = params;
    }
    return params;
  }
  /**
   * Compares this candidate to another candidate to determine the correct sorting order.
   *
   * This algorithm is different from `sortSolutions` in v1's route-recognizer in that it compares
   * the candidates segment-by-segment, rather than merely comparing the cumulative of segment types
   *
   * This resolves v1's ambiguity in situations like `/foo/:id/bar` vs. `/foo/bar/:id`, which had the
   * same sorting value because they both consist of two static segments and one dynamic segment.
   *
   * With this algorithm, `/foo/bar/:id` would always be sorted first because the second segment is different,
   * and static wins over dynamic.
   *
   * ### NOTE
   * This algorithm violates some of the invariants of v1's algorithm,
   * but those invariants were arguably not very sound to begin with. Example:
   *
   * `/foo/*path/bar/baz` vs. `/foo/bar/*path1/*path2`
   * - in v1, the first would win because that match has fewer stars
   * - in v2, the second will win because there is a bigger static match at the start of the pattern
   *
   * The algorithm should be more logical and easier to reason about in v2, but it's important to be aware of
   * subtle difference like this which might surprise some users who happened to rely on this behavior from v1,
   * intentionally or unintentionally.
   *
   * @param b - The candidate to compare this to.
   * Parameter name is `b` because the method should be used like so: `states.sort((a, b) => a.compareTo(b))`.
   * This will bring the candidate with the highest score to the first position of the array.
   */
  compareTo(b3) {
    const statesA = this.states;
    const statesB = b3.states;
    for (let iA = 0, iB = 0, ii = Math.max(statesA.length, statesB.length); iA < ii; ++iA) {
      let stateA = statesA[iA];
      if (stateA === void 0) {
        return 1;
      }
      let stateB = statesB[iB];
      if (stateB === void 0) {
        return -1;
      }
      let segmentA = stateA.segment;
      let segmentB = stateB.segment;
      if (segmentA === null) {
        if (segmentB === null) {
          ++iB;
          continue;
        }
        if ((stateA = statesA[++iA]) === void 0) {
          return 1;
        }
        segmentA = stateA.segment;
      } else if (segmentB === null) {
        if ((stateB = statesB[++iB]) === void 0) {
          return -1;
        }
        segmentB = stateB.segment;
      }
      if (segmentA.kind < segmentB.kind) {
        return 1;
      }
      if (segmentA.kind > segmentB.kind) {
        return -1;
      }
      ++iB;
    }
    const skippedStatesA = this.skippedStates;
    const skippedStatesB = b3.skippedStates;
    const skippedStatesALen = skippedStatesA.length;
    const skippedStatesBLen = skippedStatesB.length;
    if (skippedStatesALen < skippedStatesBLen) {
      return 1;
    }
    if (skippedStatesALen > skippedStatesBLen) {
      return -1;
    }
    for (let i3 = 0; i3 < skippedStatesALen; ++i3) {
      const skippedStateA = skippedStatesA[i3];
      const skippedStateB = skippedStatesB[i3];
      if (skippedStateA.length < skippedStateB.length) {
        return 1;
      }
      if (skippedStateA.length > skippedStateB.length) {
        return -1;
      }
    }
    return 0;
  }
}
function hasEndpoint(candidate) {
  return candidate.head.endpoint !== null;
}
function compareChains(a2, b3) {
  return a2.compareTo(b3);
}
class RecognizeResult {
  get isEmpty() {
    return this.candidates.length === 0;
  }
  constructor(rootState) {
    this.candidates = [];
    this.candidates = [new Candidate([""], [rootState], [], this)];
  }
  getSolution() {
    const candidates = this.candidates.filter((x2) => hasEndpoint(x2) && x2._finalize());
    if (candidates.length === 0) {
      return null;
    }
    candidates.sort(compareChains);
    return candidates[0];
  }
  add(candidate) {
    this.candidates.push(candidate);
  }
  remove(candidate) {
    this.candidates.splice(this.candidates.indexOf(candidate), 1);
  }
  advance(ch) {
    const candidates = this.candidates.slice();
    for (const candidate of candidates) {
      candidate.advance(ch);
    }
  }
}
const RESIDUE = "$$residue";
const routeParameterPattern = /^:(?<name>[^?\s{}]+)(?:\{\{(?<constraint>.+)\}\})?(?<optional>\?)?$/g;
class RouteRecognizer {
  constructor() {
    this.rootState = new State$1(null, null, "");
    this.cache = /* @__PURE__ */ new Map();
    this.endpointLookup = /* @__PURE__ */ new Map();
  }
  add(routeOrRoutes, addResidue = false) {
    let params;
    let endpoint;
    if (routeOrRoutes instanceof Array) {
      for (const route2 of routeOrRoutes) {
        endpoint = this.$add(route2, false);
        params = endpoint.params;
        if (!addResidue || (params[params.length - 1]?.isStar ?? false))
          continue;
        endpoint.residualEndpoint = this.$add({ ...route2, path: `${route2.path}/*${RESIDUE}` }, true);
      }
    } else {
      endpoint = this.$add(routeOrRoutes, false);
      params = endpoint.params;
      if (addResidue && !(params[params.length - 1]?.isStar ?? false)) {
        endpoint.residualEndpoint = this.$add({ ...routeOrRoutes, path: `${routeOrRoutes.path}/*${RESIDUE}` }, true);
      }
    }
    this.cache.clear();
  }
  $add(route2, addResidue) {
    const path = route2.path;
    const lookup2 = this.endpointLookup;
    if (lookup2.has(path))
      throw createError(`Cannot add duplicate path '${path}'.`);
    const $route = new ConfigurableRoute(path, route2.caseSensitive === true, route2.handler);
    const parts = path === "" ? [""] : path.split("/").filter(isNotEmpty);
    const params = [];
    let state = this.rootState;
    for (const part of parts) {
      state = state.append(null, "/");
      switch (part.charAt(0)) {
        case ":": {
          routeParameterPattern.lastIndex = 0;
          const match = routeParameterPattern.exec(part);
          const { name: name2, optional: optional2 } = match?.groups ?? {};
          const isOptional = optional2 === "?";
          if (name2 === RESIDUE)
            throw new Error(`Invalid parameter name; usage of the reserved parameter name '${RESIDUE}' is used.`);
          const constraint = match?.groups?.constraint;
          const pattern = constraint != null ? new RegExp(constraint) : null;
          params.push(new Parameter(name2, isOptional, false, pattern));
          state = new DynamicSegment2(name2, isOptional, pattern).appendTo(state);
          break;
        }
        case "*": {
          const name2 = part.slice(1);
          let kind;
          if (name2 === RESIDUE) {
            if (!addResidue)
              throw new Error(`Invalid parameter name; usage of the reserved parameter name '${RESIDUE}' is used.`);
            kind = 1;
          } else {
            kind = 2;
          }
          params.push(new Parameter(name2, true, true, null));
          state = new StarSegment(name2, kind).appendTo(state);
          break;
        }
        default: {
          state = new StaticSegment2(part, $route.caseSensitive).appendTo(state);
          break;
        }
      }
    }
    const endpoint = new Endpoint($route, params);
    state.setEndpoint(endpoint);
    lookup2.set(path, endpoint);
    return endpoint;
  }
  recognize(path) {
    let result = this.cache.get(path);
    if (result === void 0) {
      this.cache.set(path, result = this.$recognize(path));
    }
    return result;
  }
  $recognize(path) {
    path = decodeURI(path);
    if (!path.startsWith("/")) {
      path = `/${path}`;
    }
    if (path.length > 1 && path.endsWith("/")) {
      path = path.slice(0, -1);
    }
    const result = new RecognizeResult(this.rootState);
    for (let i3 = 0, ii = path.length; i3 < ii; ++i3) {
      const ch = path.charAt(i3);
      result.advance(ch);
      if (result.isEmpty) {
        return null;
      }
    }
    const candidate = result.getSolution();
    if (candidate === null) {
      return null;
    }
    const { endpoint } = candidate;
    const params = candidate._getParams();
    return new RecognizedRoute(endpoint, params);
  }
  getEndpoint(path) {
    return this.endpointLookup.get(path) ?? null;
  }
}
let State$1 = class State {
  constructor(prevState, segment, value) {
    this.prevState = prevState;
    this.segment = segment;
    this.value = value;
    this.nextStates = null;
    this.endpoint = null;
    this.isConstrained = false;
    switch (segment?.kind) {
      case 3:
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = true;
        this.isOptional = segment.optional;
        this.isConstrained = segment.isConstrained;
        break;
      case 2:
      case 1:
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = true;
        this.isOptional = false;
        break;
      case 4:
        this.length = prevState.length + 1;
        this.isSeparator = false;
        this.isDynamic = false;
        this.isOptional = false;
        break;
      case void 0:
        this.length = prevState === null ? 0 : prevState.length;
        this.isSeparator = true;
        this.isDynamic = false;
        this.isOptional = false;
        break;
    }
  }
  append(segment, value) {
    let state;
    let nextStates = this.nextStates;
    if (nextStates === null) {
      state = void 0;
      nextStates = this.nextStates = [];
    } else if (segment === null) {
      state = nextStates.find((s3) => s3.value === value);
    } else {
      state = nextStates.find((s3) => s3.segment?.equals(segment));
    }
    if (state === void 0) {
      nextStates.push(state = new State(this, segment, value));
    }
    return state;
  }
  setEndpoint(endpoint) {
    if (this.endpoint !== null) {
      throw createError(`Cannot add ambiguous route. The pattern '${endpoint.route.path}' clashes with '${this.endpoint.route.path}'`);
    }
    this.endpoint = endpoint;
    if (this.isOptional) {
      this.prevState.setEndpoint(endpoint);
      if (this.prevState.isSeparator && this.prevState.prevState !== null) {
        this.prevState.prevState.setEndpoint(endpoint);
      }
    }
  }
  isMatch(ch) {
    const segment = this.segment;
    switch (segment?.kind) {
      case 3:
        return !this.value.includes(ch);
      case 2:
      case 1:
        return true;
      case 4:
      case void 0:
        return this.value.includes(ch);
    }
  }
  satisfiesConstraint(value) {
    return this.isConstrained ? this.segment.satisfiesPattern(value) : true;
  }
};
function isNotEmpty(segment) {
  return segment.length > 0;
}
class StaticSegment2 {
  get kind() {
    return 4;
  }
  constructor(value, caseSensitive) {
    this.value = value;
    this.caseSensitive = caseSensitive;
  }
  appendTo(state) {
    const { value, value: { length } } = this;
    if (this.caseSensitive) {
      for (let i3 = 0; i3 < length; ++i3) {
        state = state.append(
          /* segment */
          this,
          /* value   */
          value.charAt(i3)
        );
      }
    } else {
      for (let i3 = 0; i3 < length; ++i3) {
        const ch = value.charAt(i3);
        state = state.append(
          /* segment */
          this,
          /* value   */
          ch.toUpperCase() + ch.toLowerCase()
        );
      }
    }
    return state;
  }
  equals(b3) {
    return b3.kind === 4 && b3.caseSensitive === this.caseSensitive && b3.value === this.value;
  }
}
class DynamicSegment2 {
  get kind() {
    return 3;
  }
  constructor(name2, optional2, pattern) {
    this.name = name2;
    this.optional = optional2;
    this.pattern = pattern;
    if (pattern === void 0)
      throw new Error(`Pattern is undefined`);
    this.isConstrained = pattern !== null;
  }
  appendTo(state) {
    state = state.append(
      /* segment */
      this,
      /* value   */
      "/"
    );
    return state;
  }
  equals(b3) {
    return b3.kind === 3 && b3.optional === this.optional && b3.name === this.name;
  }
  satisfiesPattern(value) {
    if (this.pattern === null)
      return true;
    this.pattern.lastIndex = 0;
    return this.pattern.test(value);
  }
}
class StarSegment {
  constructor(name2, kind) {
    this.name = name2;
    this.kind = kind;
  }
  appendTo(state) {
    state = state.append(
      /* segment */
      this,
      /* value   */
      ""
    );
    return state;
  }
  equals(b3) {
    return (b3.kind === 2 || b3.kind === 1) && b3.name === this.name;
  }
}
const createError = (msg) => new Error(msg);
const eventMessageMap = {
  // #region viewport
  [
    3e3
    /* Events.vpHydrated */
  ]: "hydrated",
  [
    3001
    /* Events.vpAttaching */
  ]: "attaching",
  [
    3002
    /* Events.vpDetaching */
  ]: "detaching",
  [
    3003
    /* Events.vpDispose */
  ]: "dispose",
  // #endregion
  // #region component agent
  [
    3050
    /* Events.caCreated */
  ]: "created",
  [
    3051
    /* Events.caActivateSelf */
  ]: "activating - self",
  [
    3052
    /* Events.caActivateInitiator */
  ]: "activating - via initiator",
  [
    3053
    /* Events.caDeactivateSelf */
  ]: "deactivating - self",
  [
    3054
    /* Events.caDeactivateInitiator */
  ]: "deactivating - via initiator",
  [
    3055
    /* Events.caDispose */
  ]: "disposing",
  [
    3056
    /* Events.caCanUnload */
  ]: "canUnload(next:%s) - invoking %s hooks",
  [
    3057
    /* Events.caCanLoad */
  ]: "canLoad(next:%s) - invoking %s hooks",
  [
    3058
    /* Events.caUnloading */
  ]: "unloading(next:%s) - invoking %s hooks",
  [
    3059
    /* Events.caLoading */
  ]: "loading(next:%s) - invoking %s hooks",
  // #endregion
  // #region location manager
  [
    3100
    /* Events.lmBaseHref */
  ]: "baseHref set to path: %s",
  [
    3101
    /* Events.lmStartListening */
  ]: "starting listening to %s",
  [
    3102
    /* Events.lmStopListening */
  ]: "stopping listening to %s",
  [
    3103
    /* Events.lmPushState */
  ]: "pushing to history state: %s (title: '%s', url: '%s')",
  [
    3104
    /* Events.lmReplaceState */
  ]: "replacing history state: %s (title: '%s', url: '%s')",
  [
    3105
    /* Events.lmPushStateNonSerializable */
  ]: "pushing to history state: NOT_SERIALIZABLE (title: '%s', url: '%s')",
  [
    3106
    /* Events.lmReplaceStateNonSerializable */
  ]: "replacing history state: NOT_SERIALIZABLE (title: '%s', url: '%s')",
  // #endregion
  // #region route context
  [
    3150
    /* Events.rcCreated */
  ]: "created",
  [
    3151
    /* Events.rcNodeChanged */
  ]: "Node changed from %s to %s",
  [
    3152
    /* Events.rcResolveNullishContext */
  ]: "The given context is nullish (%s); resolving to root RouteContext",
  [
    3153
    /* Events.rcResolveInstance */
  ]: "The given context (%s) is an instance of RouteContext; resolving to it",
  [
    3154
    /* Events.rcResolveNode */
  ]: "The given context is a node (nodeName:%s); resolving RouteContext from controller's RenderContext",
  [
    3155
    /* Events.rcResolveNodeFailed */
  ]: "Failed to resolve RouteContext from node %s; error: %s",
  [
    3156
    /* Events.rcResolveCe */
  ]: "The given context is a custom element viewmodel (name:%s); resolving RouteContext from controller's RenderContext",
  [
    3157
    /* Events.rcResolveCtrl */
  ]: "The given context is a custom element controller (name:%s); resolving RouteContext from controller's RenderContext",
  [
    3158
    /* Events.rcResolveVpa */
  ]: "Resolving viewport agent for the request: %s",
  [
    3159
    /* Events.rcCreateCa */
  ]: "Creating component agent for the node: %s",
  [
    3160
    /* Events.rcRegisterVp */
  ]: "Registering viewport: %s",
  [
    3161
    /* Events.rcRegisterVpSkip */
  ]: "Skipping registering viewport: %s; it is already registered",
  [
    3162
    /* Events.rcUnregisterVp */
  ]: "Unregistering viewport: %s",
  [
    3163
    /* Events.rcUnregisterVpSkip */
  ]: "Skipping unregistering viewport: %s; it is not registered",
  [
    3164
    /* Events.rcRecognizePath */
  ]: "Recognizing path: %s",
  [
    3165
    /* Events.rcAddRoute */
  ]: "Adding route: %s",
  [
    3166
    /* Events.rcEagerPathGenerationFailed */
  ]: "Unable to eagerly generate path for %s; reasons: %s",
  [
    3167
    /* Events.rcNoAppRoot */
  ]: "The provided container has no registered IAppRoot. RouteContext.setRoot can only be used after Aurelia.app was called, on a container that is within that app's component tree.",
  [
    3168
    /* Events.rcHasRootContext */
  ]: 'A root RouteContext is already registered. A possible cause is the RouterConfiguration being registered more than once in the same container tree. If you have a multi-rooted app, make sure you register RouterConfiguration only in the "forked" containers and not in the common root.',
  [
    3169
    /* Events.rcNoRootCtrl */
  ]: "The provided IAppRoot does not (yet) have a controller. A possible cause is calling this API manually before Aurelia.start() is called",
  [
    3170
    /* Events.rcResolveInvalidCtxType */
  ]: "Invalid context type: %s",
  [
    3171
    /* Events.rcNoNode */
  ]: "Invariant violation: RouteNode should be set immediately after the RouteContext is created. Context: %s",
  [
    3172
    /* Events.rcNoVpa */
  ]: "RouteContext has no ViewportAgent: %s",
  [
    3173
    /* Events.rcNoPathLazyImport */
  ]: "Invalid route config. When the component property is a lazy import, the path must be specified.",
  [
    3174
    /* Events.rcNoAvailableVpa */
  ]: "Failed to resolve %s at:\n%s",
  [
    3175
    /* Events.rcInvalidLazyImport */
  ]: "%s does not appear to be a component or CustomElement recognizable by Aurelia; make sure to use the @customElement decorator for your class if not using conventions.",
  // #endregion
  // #region router events
  [
    3200
    /* Events.rePublishingEvent */
  ]: "Publishing event: %s",
  [
    3201
    /* Events.reInvokingSubscriber */
  ]: "Invoking subscriber #%s (event: %s)",
  // #endregion
  // #region router
  [
    3250
    /* Events.rtrLoading */
  ]: "Loading instruction: %s",
  [
    3251
    /* Events.rtrIsActive */
  ]: "Checking if the route %s is active in context %s",
  [
    3252
    /* Events.rtrResolvingRcExisting */
  ]: "Resolving existing RouteContext for %s",
  [
    3253
    /* Events.rtrResolvingRcNew */
  ]: "Creating new RouteContext for %s",
  [
    3254
    /* Events.rtrIgnoringIdenticalNav */
  ]: "Ignoring navigation triggered by '%s' because it is the same URL as the previous navigation which was triggered by 'api'.",
  [
    3255
    /* Events.rtrReusingPromise */
  ]: "Reusing promise/resolve/reject from the previously failed transition %s",
  [
    3256
    /* Events.rtrSchedulingTr */
  ]: "Scheduling transition: %s",
  [
    3257
    /* Events.rtrTrSucceeded */
  ]: "Transition succeeded: %s",
  [
    3258
    /* Events.rtrRunBegin */
  ]: "Running transition: %s",
  [
    3259
    /* Events.rtrRunCancelled */
  ]: "Aborting transition %s because a new transition was queued in response to the NavigationStartEvent",
  [
    3260
    /* Events.rtrRunVitCompile */
  ]: "Compiling viewport instructions tree %s",
  [
    3261
    /* Events.rtrRunCanUnload */
  ]: "invoking canUnload on %s nodes",
  [
    3262
    /* Events.rtrRunCanLoad */
  ]: "invoking canLoad on %s nodes",
  [
    3263
    /* Events.rtrRunUnloading */
  ]: "invoking unloading on %s nodes",
  [
    3264
    /* Events.rtrRunLoading */
  ]: "invoking loading on %s nodes",
  [
    3265
    /* Events.rtrRunSwapping */
  ]: "invoking swapping on %s nodes",
  [
    3266
    /* Events.rtrRunFinalizing */
  ]: "finalizing transition",
  [
    3267
    /* Events.rtrCancelNavigationStart */
  ]: "navigation %s",
  [
    3268
    /* Events.rtrCancelNavigationCompleted */
  ]: "navigation %s; finished.",
  [
    3269
    /* Events.rtrNextTr */
  ]: "scheduling next transition: %s",
  [
    3270
    /* Events.rtrTrFailed */
  ]: "Transition %s failed with error: %s",
  [
    3271
    /* Events.rtrNoCtx */
  ]: "Root RouteContext is not set. Did you forget to register RouteConfiguration, or try to navigate before calling Aurelia.start()?",
  // #endregion
  // #region viewport agent
  [
    3300
    /* Events.vpaCreated */
  ]: "created",
  [
    3301
    /* Events.vpaActivateFromVpNone */
  ]: "Nothing to activate at %s",
  [
    3302
    /* Events.vpaActivateFromVpExisting */
  ]: "Activating existing component agent at %s",
  [
    3303
    /* Events.vpaActivateFromVpNext */
  ]: "Activating next component agent at %s",
  [
    3304
    /* Events.vpaDeactivateFromVpNone */
  ]: "Nothing to deactivate at %s",
  [
    3305
    /* Events.vpaDeactivateFromVpExisting */
  ]: "Deactivating existing component agent at %s",
  [
    3306
    /* Events.vpaDeactivationFromVpRunning */
  ]: "Already deactivating at %s",
  [
    3307
    /* Events.vpaDeactivateFromVpCurrent */
  ]: "Deactivating current component agent at %s",
  [
    3308
    /* Events.vpaHandlesVpMismatch */
  ]: "Cannot handle the request %s due to viewport name mismatch %s",
  [
    3309
    /* Events.vpaHandlesUsedByMismatch */
  ]: "Cannot handle the request %s as componentName not included in usedBy %s",
  [
    3310
    /* Events.vpaHandles */
  ]: "Viewport %s can handle the request %s",
  [
    3311
    /* Events.vpaIsAvailableInactive */
  ]: "Viewport is not available as it is inactive",
  [
    3312
    /* Events.vpaIsAvailableScheduled */
  ]: "Viewport is not available as an update is scheduled for %s",
  [
    3313
    /* Events.vpaCanUnloadChildren */
  ]: "Invoking on children at %s",
  [
    3314
    /* Events.vpaCanUnloadExisting */
  ]: "Invoking on existing component at %s",
  [
    3315
    /* Events.vpaCanUnloadSelf */
  ]: "Finished invoking on children, now invoking on own component at %s",
  [
    3316
    /* Events.vpaCanUnloadFinished */
  ]: "Finished at %s",
  [
    3317
    /* Events.vpaCanUnloadNone */
  ]: "Nothing to unload at %s",
  [
    3318
    /* Events.vpaCanLoadNext */
  ]: "Invoking on next component at %s",
  [
    3319
    /* Events.vpaCanLoadNone */
  ]: "Nothing to load at %s",
  [
    3320
    /* Events.vpaCanLoadResidue */
  ]: "Compiling residue for %s; plan is set to %s",
  [
    3321
    /* Events.vpaCanLoadResidueDelay */
  ]: "Delaying residue compilation for %s until activate",
  [
    3322
    /* Events.vpaCanLoadChildren */
  ]: "Finished own component; invoking on children at %s",
  [
    3323
    /* Events.vpaCanLoadFinished */
  ]: "Finished at %s",
  [
    3324
    /* Events.vpaUnloadingChildren */
  ]: "Invoking on children at %s",
  [
    3325
    /* Events.vpaUnloadingExisting */
  ]: "Invoking on existing component at %s",
  [
    3326
    /* Events.vpaUnloadingSelf */
  ]: "Finished invoking on children, now invoking on own component at %s",
  [
    3327
    /* Events.vpaUnloadingFinished */
  ]: "Finished at %s",
  [
    3328
    /* Events.vpaUnloadingNone */
  ]: "Nothing to unload at %s",
  [
    3329
    /* Events.vpaLoadingNext */
  ]: "Invoking on next component at %s",
  [
    3330
    /* Events.vpaLoadingNone */
  ]: "Nothing to load at %s",
  [
    3331
    /* Events.vpaLoadingChildren */
  ]: "Finished own component; invoking on children at %s",
  [
    3332
    /* Events.vpaLoadingFinished */
  ]: "Finished at %s",
  [
    3333
    /* Events.vpaDeactivateCurrent */
  ]: "Invoking on the current component at %s",
  [
    3334
    /* Events.vpaDeactivateNone */
  ]: "Nothing to deactivate at %s",
  [
    3335
    /* Events.vpaDeactivationRunning */
  ]: "Already deactivating at %s",
  [
    3336
    /* Events.vpaActivateNextScheduled */
  ]: "Invoking canLoad(), loading() and activate() on the next component at %s",
  [
    3337
    /* Events.vpaActivateNext */
  ]: "Invoking on the next component at %s",
  [
    3338
    /* Events.vpaActivateNone */
  ]: "Nothing to activate at %s",
  [
    3339
    /* Events.vpaSwapEmptyCurr */
  ]: "Running activate on next instead, because there is nothing to deactivate at %s",
  [
    3340
    /* Events.vpaSwapEmptyNext */
  ]: "Running deactivate on current instead, because there is nothing to activate at %s",
  [
    3341
    /* Events.vpaSwapSkipToChildren */
  ]: "Skipping this level and swapping children instead at %s",
  [
    3342
    /* Events.vpaSwap */
  ]: "Swapping current and next at %s",
  [
    3343
    /* Events.vpaProcessDynamicChildren */
  ]: "Processing dynamic children at %s",
  [
    3344
    /* Events.vpaScheduleUpdate */
  ]: "Scheduling update for %s; plan is set to %s",
  [
    3345
    /* Events.vpaCancelUpdate */
  ]: "Cancelling update for %s",
  [
    3346
    /* Events.vpaEndTransitionEmptyCurr */
  ]: "setting currState to State.currIsEmpty at %s",
  [
    3347
    /* Events.vpaEndTransitionActiveCurrLifecycle */
  ]: "setting currState to State.currIsActive at %s",
  [
    3348
    /* Events.vpaEndTransitionActiveCurrReplace */
  ]: "setting currState to State.currIsActive and reassigning curCA at %s",
  [
    3349
    /* Events.vpaDispose */
  ]: "disposing at %s",
  [
    3350
    /* Events.vpaUnexpectedActivation */
  ]: "Unexpected viewport activation outside of a transition context at %s",
  [
    3351
    /* Events.vpaUnexpectedDeactivation */
  ]: "Unexpected viewport deactivation outside of a transition context at %s",
  [
    3352
    /* Events.vpaUnexpectedState */
  ]: "Unexpected state at %s of %s",
  [
    3353
    /* Events.vpaUnexpectedGuardsResult */
  ]: "Unexpected guardsResult %s at %s",
  // #endregion
  // #region instruction
  [
    3400
    /* Events.instrInvalid */
  ]: "Invalid component %s: must be either a class, a custom element ViewModel, or a (partial) custom element definition",
  [
    3401
    /* Events.instrNoFallback */
  ]: "Neither the route '%s' matched any configured route at '%s' nor a fallback is configured for the viewport '%s' - did you forget to add '%s' to the routes list of the route decorator of '%s'?",
  [
    3402
    /* Events.instrUnknownRedirect */
  ]: "'%s' did not match any configured route or registered component name at '%s' - did you forget to add '%s' to the routes list of the route decorator of '%s'?",
  [
    3403
    /* Events.instrInvalidUrlComponentOperation */
  ]: 'Invalid instruction type %s for "toUrlComponent" operation. If you are seeing this error, then it is probably because of an internal bug. Please report it.',
  // #endregion
  // #region navigation model
  [
    3450
    /* Events.nmNoEndpoint */
  ]: "No endpoint found for path '%s'",
  // #endregion
  // #region expression
  [
    3500
    /* Events.exprUnexpectedSegment */
  ]: "Expected %s at index %s of '%s', but got: '%s' (rest='%s')",
  [
    3501
    /* Events.exprNotDone */
  ]: "Unexpected '%s' at index %s of '%s'",
  [
    3502
    /* Events.exprUnexpectedKind */
  ]: "Unexpected expression kind %s",
  // #endregion
  // #region route
  [
    3550
    /* Events.rtConfigFromHookApplied */
  ]: "Invalid operation, the configuration from the get hook is already applied.",
  [
    3551
    /* Events.rtNoCtxStrComponent */
  ]: "When retrieving the RouteConfig for a component name, a RouteContext (that can resolve it) must be provided",
  [
    3552
    /* Events.rtNoComponent */
  ]: "Could not find a CustomElement named '%s' in the current container scope of %s. This means the component is neither registered at Aurelia startup nor via the 'dependencies' decorator or static property.",
  [
    3553
    /* Events.rtNoCtxLazyImport */
  ]: "RouteContext must be provided when resolving an imported module",
  [
    3554
    /* Events.rtInvalidConfigProperty */
  ]: 'Invalid route config property: "%s". Expected %s, but got %s.',
  [
    3555
    /* Events.rtInvalidConfig */
  ]: "Invalid route config: expected an object or string, but got: %s",
  [
    3556
    /* Events.rtUnknownConfigProperty */
  ]: 'Unknown route config property: "%s.%s". Please specify known properties only.',
  [
    3557
    /* Events.rtUnknownRedirectConfigProperty */
  ]: `Unknown redirect route config property: "%s.%s". Only 'path' and 'redirectTo' should be specified for redirects.`
  // #endregion
};
function trace(logger, event, ...optionalParameters) {
  const message = eventMessageMap[event] ?? "Unknown event";
  logger.trace(`AUR${event}: ${message}`, ...optionalParameters);
}
function debug(logger, event, ...optionalParameters) {
  const message = eventMessageMap[event] ?? "Unknown event";
  logger.debug(`AUR${event}: ${message}`, ...optionalParameters);
}
function warn(logger, event, ...optionalParameters) {
  {
    const message = eventMessageMap[event];
    logger.warn(`AUR${event}: ${message}`, ...optionalParameters);
  }
}
function error(logger, event, ...optionalParameters) {
  {
    const message = eventMessageMap[event];
    logger.error(`AUR${event}: ${message}`, ...optionalParameters);
  }
}
function getMessage(event, ...optionalParameters) {
  {
    let message = eventMessageMap[event];
    let offset2 = 0;
    while (message.includes("%s") || offset2 < optionalParameters.length) {
      message = message.replace("%s", String(optionalParameters[offset2++]));
    }
    return `AUR${event}: ${message}`;
  }
}
function logAndThrow(err, logger) {
  logger.error(err);
  throw err;
}
class Batch {
  constructor(_stack, _cb, head) {
    this._stack = _stack;
    this._cb = _cb;
    this._done = false;
    this._next = null;
    this._head = head ?? this;
  }
  static _start(cb) {
    return new Batch(0, cb, null);
  }
  _push() {
    let cur = this;
    do {
      ++cur._stack;
      cur = cur._next;
    } while (cur !== null);
  }
  _pop() {
    let cur = this;
    do {
      if (--cur._stack === 0) {
        cur._invoke();
      }
      cur = cur._next;
    } while (cur !== null);
  }
  _invoke() {
    const cb = this._cb;
    if (cb !== null) {
      this._cb = null;
      cb(this);
      this._done = true;
    }
  }
  _continueWith(cb) {
    if (this._next === null) {
      return this._next = new Batch(this._stack, cb, this._head);
    } else {
      return this._next._continueWith(cb);
    }
  }
  _start() {
    this._head._push();
    this._head._pop();
    return this;
  }
}
function mergeDistinct(prev, next) {
  prev = prev.slice();
  next = next.slice();
  const merged = [];
  while (prev.length > 0) {
    const p2 = prev.shift();
    const prevVpa = p2.context.vpa;
    if (merged.every((m2) => m2.context.vpa !== prevVpa)) {
      const i3 = next.findIndex((n3) => n3.context.vpa === prevVpa);
      if (i3 >= 0) {
        merged.push(...next.splice(0, i3 + 1));
      } else {
        merged.push(p2);
      }
    }
  }
  merged.push(...next);
  return merged;
}
function tryStringify(value) {
  try {
    return JSON.stringify(value);
  } catch {
    return Object.prototype.toString.call(value);
  }
}
function ensureArrayOfStrings(value) {
  return typeof value === "string" ? [value] : value;
}
function ensureString(value) {
  return typeof value === "string" ? value : value[0];
}
function mergeURLSearchParams(source, other, clone) {
  const query = clone ? new URLSearchParams(source) : source;
  if (other == null)
    return query;
  for (const [key, value] of Object.entries(other)) {
    if (value == null)
      continue;
    query.append(key, value);
  }
  return query;
}
const bmToView = BindingMode.toView;
const bmFromView = BindingMode.fromView;
function isNotNullishOrTypeOrViewModel(value) {
  return typeof value === "object" && value !== null && !isCustomElementViewModel(value);
}
function isPartialCustomElementDefinition(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "name") === true;
}
function isPartialChildRouteConfig(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "component") === true;
}
function isPartialRedirectRouteConfig(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "redirectTo") === true;
}
function isPartialViewportInstruction(value) {
  return isNotNullishOrTypeOrViewModel(value) && Object.prototype.hasOwnProperty.call(value, "component") === true;
}
function expectType(expected, prop, value) {
  throw new Error(getMessage(3554, prop, expected, tryStringify(value)));
}
function validateRouteConfig(config, parentPath) {
  if (config == null)
    throw new Error(getMessage(3555, config));
  const keys = Object.keys(config);
  for (const key of keys) {
    const value = config[key];
    const path = [parentPath, key].join(".");
    switch (key) {
      case "id":
      case "viewport":
      case "redirectTo":
        if (typeof value !== "string") {
          expectType("string", path, value);
        }
        break;
      case "caseSensitive":
      case "nav":
        if (typeof value !== "boolean") {
          expectType("boolean", path, value);
        }
        break;
      case "data":
        if (typeof value !== "object" || value === null) {
          expectType("object", path, value);
        }
        break;
      case "title":
        switch (typeof value) {
          case "string":
          case "function":
            break;
          default:
            expectType("string or function", path, value);
        }
        break;
      case "path":
        if (value instanceof Array) {
          for (let i3 = 0; i3 < value.length; ++i3) {
            if (typeof value[i3] !== "string") {
              expectType("string", `${path}[${i3}]`, value[i3]);
            }
          }
        } else if (typeof value !== "string") {
          expectType("string or Array of strings", path, value);
        }
        break;
      case "component":
        validateComponent(value, path, "component");
        break;
      case "routes": {
        if (!(value instanceof Array)) {
          expectType("Array", path, value);
        }
        for (const route2 of value) {
          const childPath = `${path}[${value.indexOf(route2)}]`;
          validateComponent(route2, childPath, "component");
        }
        break;
      }
      case "transitionPlan":
        switch (typeof value) {
          case "string":
            switch (value) {
              case "none":
              case "replace":
              case "invoke-lifecycles":
                break;
              default:
                expectType("string('none'|'replace'|'invoke-lifecycles') or function", path, value);
            }
            break;
          case "function":
            break;
          default:
            expectType("string('none'|'replace'|'invoke-lifecycles') or function", path, value);
        }
        break;
      case "fallback":
        validateComponent(value, path, "fallback");
        break;
      default:
        throw new Error(getMessage(3556, parentPath, key));
    }
  }
}
function validateRedirectRouteConfig(config, parentPath) {
  if (config == null)
    throw new Error(getMessage(3555, config));
  const keys = Object.keys(config);
  for (const key of keys) {
    const value = config[key];
    const path = [parentPath, key].join(".");
    switch (key) {
      case "path":
        if (value instanceof Array) {
          for (let i3 = 0; i3 < value.length; ++i3) {
            if (typeof value[i3] !== "string") {
              expectType("string", `${path}[${i3}]`, value[i3]);
            }
          }
        } else if (typeof value !== "string") {
          expectType("string or Array of strings", path, value);
        }
        break;
      case "redirectTo":
        if (typeof value !== "string") {
          expectType("string", path, value);
        }
        break;
      default:
        throw new Error(getMessage(3557, parentPath, key));
    }
  }
}
function validateComponent(component, parentPath, property) {
  switch (typeof component) {
    case "function":
      break;
    case "object":
      if (component instanceof Promise) {
        break;
      }
      if (isPartialRedirectRouteConfig(component)) {
        validateRedirectRouteConfig(component, parentPath);
        break;
      }
      if (isPartialChildRouteConfig(component)) {
        validateRouteConfig(component, parentPath);
        break;
      }
      if (!isCustomElementViewModel(component) && !isPartialCustomElementDefinition(component)) {
        expectType(`an object with at least a '${property}' property (see Routeable)`, parentPath, component);
      }
      break;
    case "string":
      break;
    default:
      expectType("function, object or string (see Routeable)", parentPath, component);
  }
}
function shallowEquals(a2, b3) {
  if (a2 === b3) {
    return true;
  }
  if (typeof a2 !== typeof b3) {
    return false;
  }
  if (a2 === null || b3 === null) {
    return false;
  }
  if (Object.getPrototypeOf(a2) !== Object.getPrototypeOf(b3)) {
    return false;
  }
  const aKeys = Object.keys(a2);
  const bKeys = Object.keys(b3);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  for (let i3 = 0, ii = aKeys.length; i3 < ii; ++i3) {
    const key = aKeys[i3];
    if (key !== bKeys[i3]) {
      return false;
    }
    if (a2[key] !== b3[key]) {
      return false;
    }
  }
  return true;
}
const AuNavId = "au-nav-id";
class Subscription {
  constructor(_events, _serial, _inner) {
    this._events = _events;
    this._serial = _serial;
    this._inner = _inner;
    this._disposed = false;
  }
  dispose() {
    if (!this._disposed) {
      this._disposed = true;
      this._inner.dispose();
      const subscriptions = this._events["_subscriptions"];
      subscriptions.splice(subscriptions.indexOf(this), 1);
    }
  }
}
const IRouterEvents = /* @__PURE__ */ DI.createInterface("IRouterEvents", (x2) => x2.singleton(RouterEvents));
class RouterEvents {
  constructor() {
    this._subscriptionSerial = 0;
    this._subscriptions = [];
    this._ea = resolve(IEventAggregator);
    this._logger = resolve(ILogger).scopeTo("RouterEvents");
  }
  publish(event) {
    trace(this._logger, 3200, event);
    this._ea.publish(event.name, event);
  }
  subscribe(event, callback) {
    const subscription = new Subscription(this, ++this._subscriptionSerial, this._ea.subscribe(event, (message) => {
      trace(this._logger, 3201, subscription._serial, event);
      callback(message);
    }));
    this._subscriptions.push(subscription);
    return subscription;
  }
}
class LocationChangeEvent {
  get name() {
    return "au:router:location-change";
  }
  constructor(id2, url, trigger, state) {
    this.id = id2;
    this.url = url;
    this.trigger = trigger;
    this.state = state;
  }
  toString() {
    return `LocationChangeEvent(id:${this.id},url:'${this.url}',trigger:'${this.trigger}')`;
  }
}
class NavigationStartEvent {
  get name() {
    return "au:router:navigation-start";
  }
  constructor(id2, instructions, trigger, managedState) {
    this.id = id2;
    this.instructions = instructions;
    this.trigger = trigger;
    this.managedState = managedState;
  }
  toString() {
    return `NavigationStartEvent(id:${this.id},instructions:'${this.instructions}',trigger:'${this.trigger}')`;
  }
}
class NavigationEndEvent {
  get name() {
    return "au:router:navigation-end";
  }
  constructor(id2, instructions, finalInstructions) {
    this.id = id2;
    this.instructions = instructions;
    this.finalInstructions = finalInstructions;
  }
  toString() {
    return `NavigationEndEvent(id:${this.id},instructions:'${this.instructions}',finalInstructions:'${this.finalInstructions}')`;
  }
}
class NavigationCancelEvent {
  get name() {
    return "au:router:navigation-cancel";
  }
  constructor(id2, instructions, reason) {
    this.id = id2;
    this.instructions = instructions;
    this.reason = reason;
  }
  toString() {
    return `NavigationCancelEvent(id:${this.id},instructions:'${this.instructions}',reason:${String(this.reason)})`;
  }
}
class NavigationErrorEvent {
  get name() {
    return "au:router:navigation-error";
  }
  constructor(id2, instructions, error2) {
    this.id = id2;
    this.instructions = instructions;
    this.error = error2;
  }
  toString() {
    return `NavigationErrorEvent(id:${this.id},instructions:'${this.instructions}',error:${String(this.error)})`;
  }
}
const IBaseHref = /* @__PURE__ */ DI.createInterface("IBaseHref");
const ILocationManager = /* @__PURE__ */ DI.createInterface("ILocationManager", (x2) => x2.singleton(BrowserLocationManager));
class BrowserLocationManager {
  constructor() {
    this._eventId = 0;
    this._logger = resolve(ILogger).root.scopeTo("LocationManager");
    this._events = resolve(IRouterEvents);
    this._history = resolve(IHistory);
    this._location = resolve(ILocation);
    this._window = resolve(IWindow);
    this._baseHref = resolve(IBaseHref);
    this._event = resolve(IRouterOptions).useUrlFragmentHash ? "hashchange" : "popstate";
    debug(this._logger, 3100, this._baseHref.href);
  }
  startListening() {
    trace(this._logger, 3101, this._event);
    this._window.addEventListener(this._event, this, false);
  }
  stopListening() {
    trace(this._logger, 3102, this._event);
    this._window.removeEventListener(this._event, this, false);
  }
  handleEvent(event) {
    this._events.publish(new LocationChangeEvent(++this._eventId, this.getPath(), this._event, "state" in event ? event.state : null));
  }
  pushState(state, title, url) {
    url = this.addBaseHref(url);
    {
      try {
        const stateString = JSON.stringify(state);
        trace(this._logger, 3103, stateString, title, url);
      } catch (_err) {
        warn(this._logger, 3105, title, url);
      }
    }
    this._history.pushState(state, title, url);
  }
  replaceState(state, title, url) {
    url = this.addBaseHref(url);
    {
      try {
        const stateString = JSON.stringify(state);
        trace(this._logger, 3104, stateString, title, url);
      } catch (err) {
        warn(this._logger, 3106, title, url);
      }
    }
    this._history.replaceState(state, title, url);
  }
  getPath() {
    const { pathname, search, hash: hash2 } = this._location;
    return this.removeBaseHref(`${pathname}${normalizeQuery(search)}${hash2}`);
  }
  addBaseHref(path) {
    let fullPath;
    let base = this._baseHref.href;
    if (base.endsWith("/")) {
      base = base.slice(0, -1);
    }
    if (base.length === 0) {
      fullPath = path;
    } else {
      if (path.startsWith("/")) {
        path = path.slice(1);
      }
      fullPath = `${base}/${path}`;
    }
    return fullPath;
  }
  removeBaseHref(path) {
    const basePath = this._baseHref.pathname;
    if (path.startsWith(basePath)) {
      path = path.slice(basePath.length);
    }
    return normalizePath(path);
  }
}
function normalizePath(path) {
  let start2;
  let end2;
  let index;
  if ((index = path.indexOf("?")) >= 0 || (index = path.indexOf("#")) >= 0) {
    start2 = path.slice(0, index);
    end2 = path.slice(index);
  } else {
    start2 = path;
    end2 = "";
  }
  if (start2.endsWith("/")) {
    start2 = start2.slice(0, -1);
  } else if (start2.endsWith("/index.html")) {
    start2 = start2.slice(
      0,
      -11
      /* '/index.html'.length */
    );
  }
  return `${start2}${end2}`;
}
function normalizeQuery(query) {
  return query.length > 0 && !query.startsWith("?") ? `?${query}` : query;
}
const noRoutes = emptyArray;
class RouteConfig {
  get path() {
    const path = this._path;
    if (path.length > 0)
      return path;
    const ceDfn = CustomElement.getDefinition(this.component);
    return this._path = [ceDfn.name, ...ceDfn.aliases];
  }
  constructor(id2, _path, title, redirectTo, caseSensitive, transitionPlan, viewport2, data, routes, fallback, component, nav) {
    this.id = id2;
    this._path = _path;
    this.title = title;
    this.redirectTo = redirectTo;
    this.caseSensitive = caseSensitive;
    this.transitionPlan = transitionPlan;
    this.viewport = viewport2;
    this.data = data;
    this.routes = routes;
    this.fallback = fallback;
    this.component = component;
    this.nav = nav;
    this._configurationFromHookApplied = false;
  }
  /** @internal */
  static _create(configOrPath, Type) {
    if (typeof configOrPath === "string" || configOrPath instanceof Array) {
      const path = ensureArrayOfStrings(configOrPath);
      const redirectTo = Type?.redirectTo ?? null;
      const caseSensitive = Type?.caseSensitive ?? false;
      const id2 = ensureString(Type?.id ?? (path instanceof Array ? path[0] : path));
      const title = Type?.title ?? null;
      const reentryBehavior = Type?.transitionPlan ?? null;
      const viewport2 = Type?.viewport ?? defaultViewportName;
      const data = Type?.data ?? {};
      const children = Type?.routes ?? noRoutes;
      return new RouteConfig(id2, path, title, redirectTo, caseSensitive, reentryBehavior, viewport2, data, children, Type?.fallback ?? null, Type, Type?.nav ?? true);
    } else if (typeof configOrPath === "object") {
      const config = configOrPath;
      validateRouteConfig(config, "");
      const path = ensureArrayOfStrings(config.path ?? Type?.path ?? emptyArray);
      const title = config.title ?? Type?.title ?? null;
      const redirectTo = config.redirectTo ?? Type?.redirectTo ?? null;
      const caseSensitive = config.caseSensitive ?? Type?.caseSensitive ?? false;
      const id2 = config.id ?? Type?.id ?? (path instanceof Array ? path[0] : path);
      const reentryBehavior = config.transitionPlan ?? Type?.transitionPlan ?? null;
      const viewport2 = config.viewport ?? Type?.viewport ?? defaultViewportName;
      const data = {
        ...Type?.data,
        ...config.data
      };
      const children = [
        ...config.routes ?? noRoutes,
        ...Type?.routes ?? noRoutes
      ];
      return new RouteConfig(id2, path, title, redirectTo, caseSensitive, reentryBehavior, viewport2, data, children, config.fallback ?? Type?.fallback ?? null, config.component ?? Type ?? null, config.nav ?? true);
    } else {
      expectType("string, function/class or object", "", configOrPath);
    }
  }
  /**
   * Invoked when this component is used as a child under another parent.
   * Creates a new route config applying the child route config.
   * Note that the current rote config is not mutated.
   *
   * @internal
   */
  _applyChildRouteConfig(config, parentConfig) {
    validateRouteConfig(config, this.path[0] ?? "");
    const path = ensureArrayOfStrings(config.path ?? this.path);
    return new RouteConfig(
      ensureString(config.id ?? this.id ?? path),
      path,
      config.title ?? this.title,
      config.redirectTo ?? this.redirectTo,
      config.caseSensitive ?? this.caseSensitive,
      config.transitionPlan ?? this.transitionPlan ?? parentConfig?.transitionPlan ?? null,
      config.viewport ?? this.viewport,
      config.data ?? this.data,
      config.routes ?? this.routes,
      config.fallback ?? this.fallback ?? parentConfig?.fallback ?? null,
      this.component,
      // The RouteConfig is created using a definitive Type as component; do not overwrite it.
      config.nav ?? this.nav
    );
  }
  /** @internal */
  _getTransitionPlan(cur, next, overridingTransitionPlan) {
    if (hasSamePath(cur, next) && shallowEquals(cur.params, next.params))
      return "none";
    if (overridingTransitionPlan != null)
      return overridingTransitionPlan;
    const plan = this.transitionPlan ?? "replace";
    return typeof plan === "function" ? plan(cur, next) : plan;
    function cleanPath(path) {
      return path.replace(`/*${RESIDUE}`, "");
    }
    function hasSamePath(nodeA, nodeB) {
      const pathA = nodeA.finalPath;
      const pathB = nodeB.finalPath;
      return pathA.length === 0 || pathB.length === 0 || cleanPath(pathA) === cleanPath(pathB);
    }
  }
  /** @internal */
  _applyFromConfigurationHook(instance, parent, routeNode) {
    if (this._configurationFromHookApplied)
      throw new Error(getMessage(
        3550
        /* Events.rtConfigFromHookApplied */
      ));
    if (typeof instance.getRouteConfig !== "function")
      return;
    return onResolve(instance.getRouteConfig(parent, routeNode), (value) => {
      this._configurationFromHookApplied = true;
      if (value == null)
        return;
      let parentPath = parent?.path ?? "";
      if (typeof parentPath !== "string") {
        parentPath = parentPath[0];
      }
      validateRouteConfig(value, parentPath);
      this.id = value.id ?? this.id;
      this._path = ensureArrayOfStrings(value.path ?? this.path);
      this.title = value.title ?? this.title;
      this.redirectTo = value.redirectTo ?? this.redirectTo;
      this.caseSensitive = value.caseSensitive ?? this.caseSensitive;
      this.transitionPlan = value.transitionPlan ?? this.transitionPlan;
      this.viewport = value.viewport ?? this.viewport;
      this.data = value.data ?? this.data;
      this.routes = value.routes ?? this.routes;
      this.fallback = value.fallback ?? this.fallback;
      this.nav = value.nav ?? this.nav;
    });
  }
  /** @internal */
  _clone() {
    return new RouteConfig(this.id, this.path, this.title, this.redirectTo, this.caseSensitive, this.transitionPlan, this.viewport, this.data, this.routes, this.fallback, this.component, this.nav);
  }
  /** @internal */
  _getFallback(viewportInstruction, routeNode, context) {
    const fallback = this.fallback;
    return typeof fallback === "function" && !CustomElement.isType(fallback) ? fallback(viewportInstruction, routeNode, context) : fallback;
  }
}
const Route = {
  name: /* @__PURE__ */ getResourceKeyFor("route-configuration"),
  /**
   * Returns `true` if the specified type has any static route configuration (either via static properties or a &#64;route decorator)
   */
  isConfigured(Type) {
    return Metadata.has(Route.name, Type);
  },
  /**
   * Apply the specified configuration to the specified type, overwriting any existing configuration.
   */
  configure(configOrPath, Type) {
    const config = RouteConfig._create(configOrPath, Type);
    Metadata.define(config, Type, Route.name);
    return Type;
  },
  /**
   * Get the `RouteConfig` associated with the specified type, creating a new one if it does not yet exist.
   */
  getConfig(Type) {
    if (!Route.isConfigured(Type)) {
      Route.configure({}, Type);
    }
    return Metadata.get(Route.name, Type);
  }
};
function route(configOrPath) {
  return function(target, context) {
    context.addInitializer(function() {
      Route.configure(configOrPath, this);
    });
    return target;
  };
}
function resolveRouteConfiguration(routeable, isChild, parent, routeNode, context) {
  if (isPartialRedirectRouteConfig(routeable))
    return RouteConfig._create(routeable, null);
  const [instruction, ceDef] = resolveCustomElementDefinition(routeable, context);
  return onResolve(ceDef, ($ceDef) => {
    const type = $ceDef.Type;
    const routeConfig = Route.getConfig(type);
    if (isPartialChildRouteConfig(routeable))
      return routeConfig._applyChildRouteConfig(routeable, parent);
    if (isChild)
      return routeConfig._clone();
    if (!routeConfig._configurationFromHookApplied && instruction.type === 4 && typeof routeable.getRouteConfig === "function") {
      return onResolve(routeConfig._applyFromConfigurationHook(routeable, parent, routeNode), () => routeConfig);
    }
    return routeConfig;
  });
}
function resolveCustomElementDefinition(routeable, context) {
  const instruction = createNavigationInstruction(routeable);
  let ceDef;
  switch (instruction.type) {
    case 0: {
      if (context == null)
        throw new Error(getMessage(
          3551
          /* Events.rtNoCtxStrComponent */
        ));
      const component = CustomElement.find(context.container, instruction.value);
      if (component === null)
        throw new Error(getMessage(3552, instruction.value, context));
      ceDef = component;
      break;
    }
    case 2:
      ceDef = instruction.value;
      break;
    case 4:
      ceDef = CustomElement.getDefinition(instruction.value.constructor);
      break;
    case 3:
      if (context == null)
        throw new Error(getMessage(
          3553
          /* Events.rtNoCtxLazyImport */
        ));
      ceDef = context._resolveLazy(instruction.value);
      break;
  }
  return [instruction, ceDef];
}
function createNavigationInstruction(routeable) {
  return isPartialChildRouteConfig(routeable) ? createNavigationInstruction(routeable.component) : TypedNavigationInstruction.create(routeable);
}
const terminal = ["?", "#", "/", "+", "(", ")", "@", "!", "=", ",", "&", "'", "~", ";"];
class ParserState {
  get _done() {
    return this._rest.length === 0;
  }
  constructor(_input) {
    this._input = _input;
    this._buffers = [];
    this._bufferIndex = 0;
    this._index = 0;
    this._rest = _input;
  }
  _startsWith(...values) {
    const rest = this._rest;
    return values.some(function(value) {
      return rest.startsWith(value);
    });
  }
  _consumeOptional(str) {
    if (this._startsWith(str)) {
      this._rest = this._rest.slice(str.length);
      this._index += str.length;
      this._append(str);
      return true;
    }
    return false;
  }
  _consume(str) {
    if (!this._consumeOptional(str)) {
      this._expect(`'${str}'`);
    }
  }
  _expect(msg) {
    throw new Error(getMessage(3500, msg, this._index, this._input, this._rest, this._rest));
  }
  _ensureDone() {
    if (!this._done) {
      throw new Error(getMessage(3501, this._rest, this._index, this._input));
    }
  }
  _advance() {
    const char = this._rest[0];
    this._rest = this._rest.slice(1);
    ++this._index;
    this._append(char);
  }
  _record() {
    this._buffers[this._bufferIndex++] = "";
  }
  _playback() {
    const bufferIndex = --this._bufferIndex;
    const buffers = this._buffers;
    const buffer = buffers[bufferIndex];
    buffers[bufferIndex] = "";
    return buffer;
  }
  _discard() {
    this._buffers[--this._bufferIndex] = "";
  }
  _append(str) {
    const bufferIndex = this._bufferIndex;
    const buffers = this._buffers;
    for (let i3 = 0; i3 < bufferIndex; ++i3) {
      buffers[i3] += str;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
class RouteExpression {
  get kind() {
    return "Route";
  }
  constructor(isAbsolute, root, queryParams, fragment) {
    this.isAbsolute = isAbsolute;
    this.root = root;
    this.queryParams = queryParams;
    this.fragment = fragment;
  }
  static parse(value) {
    const key = value.toString();
    let result = cache.get(key);
    if (result === void 0) {
      cache.set(key, result = RouteExpression._$parse(value));
    }
    return result;
  }
  /** @internal */
  static _$parse(value) {
    const path = value.path;
    if (path === "") {
      return new RouteExpression(false, SegmentExpression.Empty, value.query, value.fragment);
    }
    const state = new ParserState(path);
    state._record();
    const isAbsolute = state._consumeOptional("/");
    const root = CompositeSegmentExpression._parse(state);
    state._ensureDone();
    state._discard();
    return new RouteExpression(isAbsolute, root, value.query, value.fragment);
  }
  toInstructionTree(options) {
    return new ViewportInstructionTree(options, this.isAbsolute, this.root._toInstructions(0, 0), mergeURLSearchParams(this.queryParams, options.queryParams, true), this.fragment ?? options.fragment);
  }
}
class CompositeSegmentExpression {
  get kind() {
    return "CompositeSegment";
  }
  constructor(siblings) {
    this.siblings = siblings;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const append = state._consumeOptional("+");
    const siblings = [];
    do {
      siblings.push(ScopedSegmentExpression._parse(state));
    } while (state._consumeOptional("+"));
    if (!append && siblings.length === 1) {
      state._discard();
      return siblings[0];
    }
    state._discard();
    return new CompositeSegmentExpression(siblings);
  }
  /** @internal */
  _toInstructions(open, close) {
    switch (this.siblings.length) {
      case 0:
        return [];
      case 1:
        return this.siblings[0]._toInstructions(open, close);
      case 2:
        return [
          ...this.siblings[0]._toInstructions(open, 0),
          ...this.siblings[1]._toInstructions(0, close)
        ];
      default:
        return [
          ...this.siblings[0]._toInstructions(open, 0),
          ...this.siblings.slice(1, -1).flatMap(function(x2) {
            return x2._toInstructions(0, 0);
          }),
          ...this.siblings[this.siblings.length - 1]._toInstructions(0, close)
        ];
    }
  }
}
class ScopedSegmentExpression {
  get kind() {
    return "ScopedSegment";
  }
  constructor(left2, right2) {
    this.left = left2;
    this.right = right2;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const left2 = SegmentGroupExpression._parse(state);
    if (state._consumeOptional("/")) {
      const right2 = ScopedSegmentExpression._parse(state);
      state._discard();
      return new ScopedSegmentExpression(left2, right2);
    }
    state._discard();
    return left2;
  }
  /** @internal */
  _toInstructions(open, close) {
    const leftInstructions = this.left._toInstructions(open, 0);
    const rightInstructions = this.right._toInstructions(0, close);
    let cur = leftInstructions[leftInstructions.length - 1];
    while (cur.children.length > 0) {
      cur = cur.children[cur.children.length - 1];
    }
    cur.children.push(...rightInstructions);
    return leftInstructions;
  }
}
class SegmentGroupExpression {
  get kind() {
    return "SegmentGroup";
  }
  constructor(expression) {
    this.expression = expression;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    if (state._consumeOptional("(")) {
      const expression = CompositeSegmentExpression._parse(state);
      state._consume(")");
      state._discard();
      return new SegmentGroupExpression(expression);
    }
    state._discard();
    return SegmentExpression._parse(state);
  }
  /** @internal */
  _toInstructions(open, close) {
    return this.expression._toInstructions(open + 1, close + 1);
  }
}
class SegmentExpression {
  get kind() {
    return "Segment";
  }
  static get Empty() {
    return new SegmentExpression(ComponentExpression.Empty, ViewportExpression.Empty, true);
  }
  constructor(component, viewport2, scoped) {
    this.component = component;
    this.viewport = viewport2;
    this.scoped = scoped;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const component = ComponentExpression._parse(state);
    const viewport2 = ViewportExpression._parse(state);
    const scoped = !state._consumeOptional("!");
    state._discard();
    return new SegmentExpression(component, viewport2, scoped);
  }
  /** @internal */
  _toInstructions(open, close) {
    return [
      ViewportInstruction.create({
        component: this.component.name,
        params: this.component.parameterList._toObject(),
        viewport: this.viewport.name,
        open,
        close
      })
    ];
  }
}
class ComponentExpression {
  get kind() {
    return "Component";
  }
  static get Empty() {
    return new ComponentExpression("", ParameterListExpression.Empty);
  }
  constructor(name2, parameterList) {
    this.name = name2;
    this.parameterList = parameterList;
    switch (name2.charAt(0)) {
      case ":":
        this.isParameter = true;
        this.isStar = false;
        this.isDynamic = true;
        this.parameterName = name2.slice(1);
        break;
      case "*":
        this.isParameter = false;
        this.isStar = true;
        this.isDynamic = true;
        this.parameterName = name2.slice(1);
        break;
      default:
        this.isParameter = false;
        this.isStar = false;
        this.isDynamic = false;
        this.parameterName = name2;
        break;
    }
  }
  /** @internal */
  static _parse(state) {
    state._record();
    state._record();
    if (!state._done) {
      if (state._startsWith("./")) {
        state._advance();
      } else if (state._startsWith("../")) {
        state._advance();
        state._advance();
      } else {
        while (!state._done && !state._startsWith(...terminal)) {
          state._advance();
        }
      }
    }
    const name2 = state._playback();
    if (name2.length === 0) {
      state._expect("component name");
    }
    const parameterList = ParameterListExpression._parse(state);
    state._discard();
    return new ComponentExpression(name2, parameterList);
  }
}
class ViewportExpression {
  get kind() {
    return "Viewport";
  }
  static get Empty() {
    return new ViewportExpression("");
  }
  constructor(name2) {
    this.name = name2;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    let name2 = null;
    if (state._consumeOptional("@")) {
      state._record();
      while (!state._done && !state._startsWith(...terminal)) {
        state._advance();
      }
      name2 = decodeURIComponent(state._playback());
      if (name2.length === 0) {
        state._expect("viewport name");
      }
    }
    state._discard();
    return new ViewportExpression(name2);
  }
}
class ParameterListExpression {
  get kind() {
    return "ParameterList";
  }
  static get Empty() {
    return new ParameterListExpression([]);
  }
  constructor(expressions) {
    this.expressions = expressions;
  }
  /** @internal */
  static _parse(state) {
    state._record();
    const expressions = [];
    if (state._consumeOptional("(")) {
      do {
        expressions.push(ParameterExpression._parse(state, expressions.length));
        if (!state._consumeOptional(",")) {
          break;
        }
      } while (!state._done && !state._startsWith(")"));
      state._consume(")");
    }
    state._discard();
    return new ParameterListExpression(expressions);
  }
  /** @internal */
  _toObject() {
    const params = {};
    for (const expr of this.expressions) {
      params[expr.key] = expr.value;
    }
    return params;
  }
}
class ParameterExpression {
  get kind() {
    return "Parameter";
  }
  static get Empty() {
    return new ParameterExpression("", "");
  }
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /** @internal */
  static _parse(state, index) {
    state._record();
    state._record();
    while (!state._done && !state._startsWith(...terminal)) {
      state._advance();
    }
    let key = state._playback();
    if (key.length === 0) {
      state._expect("parameter key");
    }
    let value;
    if (state._consumeOptional("=")) {
      state._record();
      while (!state._done && !state._startsWith(...terminal)) {
        state._advance();
      }
      value = decodeURIComponent(state._playback());
      if (value.length === 0) {
        state._expect("parameter value");
      }
    } else {
      value = key;
      key = index.toString();
    }
    state._discard();
    return new ParameterExpression(key, value);
  }
}
class ViewportRequest {
  constructor(viewportName, componentName) {
    this.viewportName = viewportName;
    this.componentName = componentName;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `VR(viewport:'${this.viewportName}',component:'${this.componentName}')`;
  }
}
const viewportAgentLookup = /* @__PURE__ */ new WeakMap();
class ViewportAgent {
  /** @internal */
  get _currState() {
    return this._state & 16256;
  }
  /** @internal */
  set _currState(state) {
    this._state = this._state & 127 | state;
  }
  /** @internal */
  get _nextState() {
    return this._state & 127;
  }
  /** @internal */
  set _nextState(state) {
    this._state = this._state & 16256 | state;
  }
  constructor(viewport2, hostController, ctx) {
    this.viewport = viewport2;
    this.hostController = hostController;
    this._isActive = false;
    this._curCA = null;
    this._nextCA = null;
    this._state = 8256;
    this._$plan = "replace";
    this._currNode = null;
    this._nextNode = null;
    this._currTransition = null;
    this._cancellationPromise = null;
    this._logger = ctx.container.get(ILogger).scopeTo(`ViewportAgent<${ctx._friendlyPath}>`);
    trace(
      this._logger,
      3300
      /* Events.vpaCreated */
    );
  }
  static for(viewport2, ctx) {
    let viewportAgent = viewportAgentLookup.get(viewport2);
    if (viewportAgent === void 0) {
      const controller = Controller.getCachedOrThrow(viewport2);
      viewportAgentLookup.set(viewport2, viewportAgent = new ViewportAgent(viewport2, controller, ctx));
    }
    return viewportAgent;
  }
  /** @internal */
  _activateFromViewport(initiator, parent) {
    const tr = this._currTransition;
    if (tr !== null) {
      ensureTransitionHasNotErrored(tr);
    }
    this._isActive = true;
    const logger = /* @__PURE__ */ this._logger.scopeTo("activateFromViewport()");
    switch (this._nextState) {
      case 64:
        switch (this._currState) {
          case 8192:
            trace(logger, 3301, this);
            return;
          case 4096:
            trace(logger, 3302, this);
            return this._curCA._activate(initiator, parent);
          default:
            this._unexpectedState("activateFromViewport 1");
        }
      case 2: {
        if (this._currTransition === null)
          throw new Error(getMessage(3350, this));
        trace(logger, 3303, this);
        const b3 = Batch._start((b1) => {
          this._activate(initiator, this._currTransition, b1);
        });
        const p2 = new Promise((resolve2) => {
          b3._continueWith(() => {
            resolve2();
          });
        });
        return b3._start()._done ? void 0 : p2;
      }
      default:
        this._unexpectedState("activateFromViewport 2");
    }
  }
  /** @internal */
  _deactivateFromViewport(initiator, parent) {
    const tr = this._currTransition;
    if (tr !== null) {
      ensureTransitionHasNotErrored(tr);
    }
    this._isActive = false;
    const logger = /* @__PURE__ */ this._logger.scopeTo("deactivateFromViewport()");
    switch (this._currState) {
      case 8192:
        trace(logger, 3304, this);
        return;
      case 4096:
        trace(logger, 3305, this);
        return this._curCA._deactivate(initiator, parent);
      case 128:
        trace(logger, 3306, this);
        return;
      default: {
        if (this._currTransition === null)
          throw new Error(getMessage(3351, this));
        trace(logger, 3307, this);
        const b3 = Batch._start((b1) => {
          this._deactivate(initiator, this._currTransition, b1);
        });
        const p2 = new Promise((resolve2) => {
          b3._continueWith(() => {
            resolve2();
          });
        });
        return b3._start()._done ? void 0 : p2;
      }
    }
  }
  /** @internal */
  _handles(req) {
    if (!this._isAvailable()) {
      return false;
    }
    const $vp = this.viewport;
    const reqVp = req.viewportName;
    const vp = $vp.name;
    const logger = /* @__PURE__ */ this._logger.scopeTo("handles()");
    if (reqVp !== defaultViewportName && vp !== reqVp) {
      trace(logger, 3308, req, vp);
      return false;
    }
    const usedBy = $vp.usedBy;
    if (usedBy.length > 0 && !usedBy.split(",").includes(req.componentName)) {
      trace(logger, 3309, req, usedBy);
      return false;
    }
    trace(logger, 3310, vp, req);
    return true;
  }
  /** @internal */
  _isAvailable() {
    const logger = /* @__PURE__ */ this._logger.scopeTo("isAvailable()");
    if (!this._isActive) {
      trace(
        logger,
        3311
        /* Events.vpaIsAvailableInactive */
      );
      return false;
    }
    if (this._nextState !== 64) {
      trace(logger, 3312, this._nextNode);
      return false;
    }
    return true;
  }
  /** @internal */
  _canUnload(tr, b3) {
    if (this._currTransition === null) {
      this._currTransition = tr;
    }
    ensureTransitionHasNotErrored(tr);
    if (tr.guardsResult !== true) {
      return;
    }
    b3._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("canUnload()");
    void onResolve(this._cancellationPromise, () => {
      Batch._start((b1) => {
        trace(logger, 3313, this);
        for (const node of this._currNode.children) {
          node.context.vpa._canUnload(tr, b1);
        }
      })._continueWith((b1) => {
        switch (this._currState) {
          case 4096:
            trace(logger, 3314, this);
            switch (this._$plan) {
              case "none":
                this._currState = 1024;
                return;
              case "invoke-lifecycles":
              case "replace":
                this._currState = 2048;
                b1._push();
                Batch._start((b22) => {
                  trace(logger, 3315, this);
                  this._curCA._canUnload(tr, this._nextNode, b22);
                })._continueWith(() => {
                  trace(logger, 3316, this);
                  this._currState = 1024;
                  b1._pop();
                })._start();
                return;
            }
          case 8192:
            trace(logger, 3317, this);
            return;
          default:
            tr._handleError(new Error(`Unexpected state at canUnload of ${this}`));
        }
      })._continueWith(() => {
        b3._pop();
      })._start();
    });
  }
  /** @internal */
  _canLoad(tr, b3) {
    if (this._currTransition === null) {
      this._currTransition = tr;
    }
    ensureTransitionHasNotErrored(tr);
    if (tr.guardsResult !== true) {
      return;
    }
    b3._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("canLoad()");
    Batch._start((b1) => {
      switch (this._nextState) {
        case 32:
          trace(logger, 3318, this);
          this._nextState = 16;
          switch (this._$plan) {
            case "none":
              return;
            case "invoke-lifecycles":
              return this._curCA._canLoad(tr, this._nextNode, b1);
            case "replace":
              b1._push();
              void onResolve(this._nextNode.context._createComponentAgent(this.hostController, this._nextNode), (ca) => {
                (this._nextCA = ca)._canLoad(tr, this._nextNode, b1);
                b1._pop();
              });
          }
        case 64:
          trace(logger, 3319, this);
          return;
        default:
          this._unexpectedState("canLoad");
      }
    })._continueWith((b1) => {
      const next = this._nextNode;
      switch (this._$plan) {
        case "none":
        case "invoke-lifecycles": {
          trace(logger, 3320, next, this._$plan);
          b1._push();
          const ctx = next.context;
          void onResolve(ctx.allResolved, () => onResolve(onResolve(onResolveAll(...next.residue.splice(0).map((vi) => createAndAppendNodes(this._logger, next, vi))), () => onResolveAll(...ctx.getAvailableViewportAgents().reduce((acc, vpa) => {
            const vp = vpa.viewport;
            const component = vp.default;
            if (component === null)
              return acc;
            acc.push(createAndAppendNodes(this._logger, next, ViewportInstruction.create({ component, viewport: vp.name })));
            return acc;
          }, []))), () => {
            b1._pop();
          }));
          return;
        }
        case "replace":
          trace(logger, 3321, next);
          return;
      }
    })._continueWith((b1) => {
      switch (this._nextState) {
        case 16:
          trace(logger, 3322, this);
          this._nextState = 8;
          for (const node of this._nextNode.children) {
            node.context.vpa._canLoad(tr, b1);
          }
          return;
        case 64:
          return;
        default:
          this._unexpectedState("canLoad");
      }
    })._continueWith(() => {
      trace(logger, 3323, this);
      b3._pop();
    })._start();
  }
  /** @internal */
  _unloading(tr, b3) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b3._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("unloading()");
    Batch._start((b1) => {
      trace(logger, 3324, this);
      for (const node of this._currNode.children) {
        node.context.vpa._unloading(tr, b1);
      }
    })._continueWith((b1) => {
      switch (this._currState) {
        case 1024:
          trace(logger, 3325, this);
          switch (this._$plan) {
            case "none":
              this._currState = 256;
              return;
            case "invoke-lifecycles":
            case "replace":
              this._currState = 512;
              b1._push();
              Batch._start((b22) => {
                trace(logger, 3326, this);
                this._curCA._unloading(tr, this._nextNode, b22);
              })._continueWith(() => {
                trace(logger, 3327, this);
                this._currState = 256;
                b1._pop();
              })._start();
              return;
          }
        case 8192:
          trace(logger, 3328, this);
          for (const node of this._currNode.children) {
            node.context.vpa._unloading(tr, b3);
          }
          return;
        default:
          this._unexpectedState("unloading");
      }
    })._continueWith(() => {
      b3._pop();
    })._start();
  }
  /** @internal */
  _loading(tr, b3) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b3._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("loading()");
    Batch._start((b1) => {
      switch (this._nextState) {
        case 8: {
          trace(logger, 3329, this);
          this._nextState = 4;
          switch (this._$plan) {
            case "none":
              return;
            case "invoke-lifecycles":
              return this._curCA._loading(tr, this._nextNode, b1);
            case "replace":
              return this._nextCA._loading(tr, this._nextNode, b1);
          }
        }
        case 64:
          trace(logger, 3330, this);
          return;
        default:
          this._unexpectedState("loading");
      }
    })._continueWith((b1) => {
      switch (this._nextState) {
        case 4:
          trace(logger, 3331, this);
          this._nextState = 2;
          for (const node of this._nextNode.children) {
            node.context.vpa._loading(tr, b1);
          }
          return;
        case 64:
          return;
        default:
          this._unexpectedState("loading");
      }
    })._continueWith(() => {
      trace(logger, 3332, this);
      b3._pop();
    })._start();
  }
  /** @internal */
  _deactivate(initiator, tr, b3) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b3._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("deactivate()");
    switch (this._currState) {
      case 256:
        trace(logger, 3333, this);
        this._currState = 128;
        switch (this._$plan) {
          case "none":
          case "invoke-lifecycles":
            b3._pop();
            return;
          case "replace": {
            const controller = this.hostController;
            const curCa = this._curCA;
            tr._run(() => {
              return onResolve(curCa._deactivate(initiator, controller), () => {
                if (initiator === null) {
                  curCa._dispose();
                }
              });
            }, () => {
              b3._pop();
            });
          }
        }
        return;
      case 8192:
        trace(logger, 3334, this);
        b3._pop();
        return;
      case 128:
        trace(logger, 3335, this);
        b3._pop();
        return;
      default:
        this._unexpectedState("deactivate");
    }
  }
  /** @internal */
  _activate(initiator, tr, b3) {
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    b3._push();
    const logger = /* @__PURE__ */ this._logger.scopeTo("activate()");
    if (this._nextState === 32) {
      trace(logger, 3336, this);
      Batch._start((b1) => {
        this._canLoad(tr, b1);
      })._continueWith((b1) => {
        this._loading(tr, b1);
      })._continueWith((b1) => {
        this._activate(initiator, tr, b1);
      })._continueWith(() => {
        b3._pop();
      })._start();
      return;
    }
    switch (this._nextState) {
      case 2:
        trace(logger, 3337, this);
        this._nextState = 1;
        Batch._start((b1) => {
          switch (this._$plan) {
            case "none":
            case "invoke-lifecycles":
              return;
            case "replace": {
              const controller = this.hostController;
              tr._run(() => {
                b1._push();
                return this._nextCA._activate(initiator, controller);
              }, () => {
                b1._pop();
              });
            }
          }
        })._continueWith((b1) => {
          this._processDynamicChildren(tr, b1);
        })._continueWith(() => {
          b3._pop();
        })._start();
        return;
      case 64:
        trace(logger, 3338, this);
        b3._pop();
        return;
      default:
        this._unexpectedState("activate");
    }
  }
  /** @internal */
  _swap(tr, b3) {
    const logger = /* @__PURE__ */ this._logger.scopeTo("swap()");
    if (this._currState === 8192) {
      trace(logger, 3339, this);
      this._activate(null, tr, b3);
      return;
    }
    if (this._nextState === 64) {
      trace(logger, 3340, this);
      this._deactivate(null, tr, b3);
      return;
    }
    ensureTransitionHasNotErrored(tr);
    ensureGuardsResultIsTrue(this, tr);
    if (!(this._currState === 256 && this._nextState === 2)) {
      this._unexpectedState("swap");
    }
    this._currState = 128;
    this._nextState = 1;
    switch (this._$plan) {
      case "none":
      case "invoke-lifecycles": {
        trace(logger, 3341, this);
        const nodes = mergeDistinct(this._nextNode.children, this._currNode.children);
        for (const node of nodes) {
          node.context.vpa._swap(tr, b3);
        }
        return;
      }
      case "replace": {
        trace(logger, 3342, this);
        const controller = this.hostController;
        const curCA = this._curCA;
        const nextCA = this._nextCA;
        b3._push();
        Batch._start((b1) => {
          tr._run(() => {
            b1._push();
            return onResolve(curCA._deactivate(null, controller), () => curCA._dispose());
          }, () => {
            b1._pop();
          });
        })._continueWith((b1) => {
          tr._run(() => {
            b1._push();
            return nextCA._activate(null, controller);
          }, () => {
            b1._pop();
          });
        })._continueWith((b1) => {
          this._processDynamicChildren(tr, b1);
        })._continueWith(() => {
          b3._pop();
        })._start();
        return;
      }
    }
  }
  /** @internal */
  _processDynamicChildren(tr, b3) {
    trace(this._logger, 3343, this);
    const next = this._nextNode;
    tr._run(() => {
      b3._push();
      const ctx = next.context;
      return onResolve(ctx.allResolved, () => {
        const existingChildren = next.children.slice();
        return onResolve(onResolveAll(...next.residue.splice(0).map((vi) => createAndAppendNodes(this._logger, next, vi))), () => onResolve(onResolveAll(...ctx.getAvailableViewportAgents().reduce((acc, vpa) => {
          const vp = vpa.viewport;
          const component = vp.default;
          if (component === null)
            return acc;
          acc.push(createAndAppendNodes(this._logger, next, ViewportInstruction.create({ component, viewport: vp.name })));
          return acc;
        }, [])), () => next.children.filter((x2) => !existingChildren.includes(x2))));
      });
    }, (newChildren) => {
      Batch._start((b1) => {
        for (const node of newChildren) {
          tr._run(() => {
            b1._push();
            return node.context.vpa._canLoad(tr, b1);
          }, () => {
            b1._pop();
          });
        }
      })._continueWith((b1) => {
        for (const node of newChildren) {
          tr._run(() => {
            b1._push();
            return node.context.vpa._loading(tr, b1);
          }, () => {
            b1._pop();
          });
        }
      })._continueWith((b1) => {
        for (const node of newChildren) {
          tr._run(() => {
            b1._push();
            return node.context.vpa._activate(null, tr, b1);
          }, () => {
            b1._pop();
          });
        }
      })._continueWith(() => {
        b3._pop();
      })._start();
    });
  }
  /** @internal */
  _scheduleUpdate(options, next) {
    switch (this._nextState) {
      case 64:
        this._nextNode = next;
        this._nextState = 32;
        break;
      default:
        this._unexpectedState("scheduleUpdate 1");
    }
    switch (this._currState) {
      case 8192:
      case 4096:
      case 1024:
        break;
      default:
        this._unexpectedState("scheduleUpdate 2");
    }
    const cur = this._curCA?._routeNode ?? null;
    if (cur === null || cur.component !== next.component) {
      this._$plan = "replace";
    } else {
      this._$plan = next.context.config._getTransitionPlan(cur, next, options.transitionPlan);
    }
    trace(this._logger, 3344, this);
  }
  /** @internal */
  _cancelUpdate() {
    if (this._currNode !== null) {
      this._currNode.children.forEach(function(node) {
        node.context.vpa._cancelUpdate();
      });
    }
    if (this._nextNode !== null) {
      this._nextNode.children.forEach(function(node) {
        node.context.vpa._cancelUpdate();
      });
    }
    trace(this._logger, 3345, this._nextNode);
    let currentDeactivationPromise = null;
    let nextDeactivationPromise = null;
    switch (this._currState) {
      case 8192:
      case 4096:
        this._currTransition = null;
        break;
      case 2048:
      case 1024:
        this._currState = 4096;
        this._currTransition = null;
        break;
      case 512:
      case 256:
      case 128:
        currentDeactivationPromise = onResolve(this._curCA?._deactivate(null, this.hostController), () => {
          this._curCA?._dispose();
          this._currState = 8192;
          this._curCA = null;
        });
        break;
    }
    switch (this._nextState) {
      case 64:
      case 32:
      case 16:
      case 8:
        this._nextNode = null;
        this._nextState = 64;
        break;
      case 4:
      case 2:
      case 1: {
        nextDeactivationPromise = onResolve(this._nextCA?._deactivate(null, this.hostController), () => {
          this._nextCA?._dispose();
          this._$plan = "replace";
          this._nextState = 64;
          this._nextCA = null;
          this._nextNode = null;
        });
        break;
      }
    }
    if (currentDeactivationPromise !== null && nextDeactivationPromise !== null) {
      this._cancellationPromise = onResolve(onResolveAll(currentDeactivationPromise, nextDeactivationPromise), () => {
        this._currTransition = null;
        this._cancellationPromise = null;
      });
    }
  }
  /** @internal */
  _endTransition() {
    if (this._currNode !== null) {
      this._currNode.children.forEach(function(node) {
        node.context.vpa._endTransition();
      });
    }
    if (this._nextNode !== null) {
      this._nextNode.children.forEach(function(node) {
        node.context.vpa._endTransition();
      });
    }
    if (this._currTransition !== null) {
      const logger = /* @__PURE__ */ this._logger.scopeTo("endTransition()");
      ensureTransitionHasNotErrored(this._currTransition);
      switch (this._nextState) {
        case 64:
          switch (this._currState) {
            case 8192:
            case 128:
              trace(logger, 3346, this);
              this._currState = 8192;
              this._curCA = null;
              break;
            default:
              this._unexpectedState("endTransition 1");
          }
          break;
        case 1:
          switch (this._currState) {
            case 8192:
            case 128:
              switch (this._$plan) {
                case "none":
                  trace(logger, 3347, this);
                  this._currState = 4096;
                  break;
                case "invoke-lifecycles":
                  trace(logger, 3347, this);
                  this._currState = 4096;
                  this._curCA._routeNode = this._nextNode;
                  break;
                case "replace":
                  trace(logger, 3348, this);
                  this._currState = 4096;
                  this._curCA = this._nextCA;
                  break;
              }
              this._currNode = this._nextNode;
              break;
            default:
              this._unexpectedState("endTransition 2");
          }
          break;
        default:
          this._unexpectedState("endTransition 3");
      }
      this._$plan = "replace";
      this._nextState = 64;
      this._nextNode = null;
      this._nextCA = null;
      this._currTransition = null;
    }
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `VPA(state:${$state(this._state)},plan:'${this._$plan}',n:${this._nextNode},c:${this._currNode},viewport:${this.viewport})`;
  }
  /** @internal */
  _dispose() {
    trace(this._logger, 3349, this);
    this._curCA?._dispose();
  }
  /** @internal */
  _unexpectedState(label) {
    throw new Error(getMessage(3352, label, this));
  }
}
function ensureGuardsResultIsTrue(vpa, tr) {
  if (tr.guardsResult !== true)
    throw new Error(getMessage(3353, tr.guardsResult, vpa));
}
function ensureTransitionHasNotErrored(tr) {
  if (tr.error !== void 0 && !tr.erredWithUnknownRoute)
    throw tr.error;
}
const $stateCache = /* @__PURE__ */ new Map();
function $state(state) {
  let str = $stateCache.get(state);
  if (str === void 0) {
    $stateCache.set(state, str = stringifyState(state));
  }
  return str;
}
function stringifyState(state) {
  const flags = [];
  if ((state & 8192) === 8192) {
    flags.push("currIsEmpty");
  }
  if ((state & 4096) === 4096) {
    flags.push("currIsActive");
  }
  if ((state & 2048) === 2048) {
    flags.push("currCanUnload");
  }
  if ((state & 1024) === 1024) {
    flags.push("currCanUnloadDone");
  }
  if ((state & 512) === 512) {
    flags.push("currUnload");
  }
  if ((state & 256) === 256) {
    flags.push("currUnloadDone");
  }
  if ((state & 128) === 128) {
    flags.push("currDeactivate");
  }
  if ((state & 64) === 64) {
    flags.push("nextIsEmpty");
  }
  if ((state & 32) === 32) {
    flags.push("nextIsScheduled");
  }
  if ((state & 16) === 16) {
    flags.push("nextCanLoad");
  }
  if ((state & 8) === 8) {
    flags.push("nextCanLoadDone");
  }
  if ((state & 4) === 4) {
    flags.push("nextLoad");
  }
  if ((state & 2) === 2) {
    flags.push("nextLoadDone");
  }
  if ((state & 1) === 1) {
    flags.push("nextActivate");
  }
  return flags.join("|");
}
class RouteNode {
  get root() {
    return this._tree.root;
  }
  get isInstructionsFinalized() {
    return this._isInstructionsFinalized;
  }
  constructor(path, finalPath, context, _originalInstruction, instruction, params, queryParams, fragment, data, _viewport, title, component, residue) {
    this.path = path;
    this.finalPath = finalPath;
    this.context = context;
    this._originalInstruction = _originalInstruction;
    this.instruction = instruction;
    this.params = params;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.data = data;
    this._viewport = _viewport;
    this.title = title;
    this.component = component;
    this.residue = residue;
    this._version = 1;
    this._isInstructionsFinalized = false;
    this.children = [];
    this._originalInstruction ??= instruction;
  }
  static create(input) {
    const { [RESIDUE]: _2, ...params } = input.params ?? {};
    return new RouteNode(
      /*        path */
      input.path,
      /*   finalPath */
      input.finalPath,
      /*     context */
      input.context,
      /* originalIns */
      input.originalInstruction ?? input.instruction,
      /* instruction */
      input.instruction,
      /*      params */
      Object.freeze(params),
      /* queryParams */
      input.queryParams ?? emptyQuery,
      /*    fragment */
      input.fragment ?? null,
      /*        data */
      Object.freeze(input.data ?? emptyObject),
      /*    viewport */
      input._viewport ?? null,
      /*       title */
      input.title ?? null,
      /*   component */
      input.component,
      /*     residue */
      input.residue ?? []
    );
  }
  contains(instructions, matchEndpoint = false) {
    if (this.context === instructions.options.context) {
      const nodeChildren = this.children;
      const instructionChildren = instructions.children;
      for (let i3 = 0, ii = nodeChildren.length; i3 < ii; ++i3) {
        for (let j2 = 0, jj = instructionChildren.length; j2 < jj; ++j2) {
          const instructionChild = instructionChildren[j2];
          const instructionEndpoint = matchEndpoint ? instructionChild.recognizedRoute?.route.endpoint : null;
          const nodeChild = nodeChildren[i3 + j2] ?? null;
          const instruction = nodeChild !== null ? nodeChild.isInstructionsFinalized ? nodeChild.instruction : nodeChild._originalInstruction : null;
          const childEndpoint = instruction?.recognizedRoute?.route.endpoint;
          if (i3 + j2 < ii && ((instructionEndpoint?.equalsOrResidual(childEndpoint) ?? false) || (instruction?.contains(instructionChild) ?? false))) {
            if (j2 + 1 === jj) {
              return true;
            }
          } else {
            break;
          }
        }
      }
    }
    return this.children.some(function(x2) {
      return x2.contains(instructions, matchEndpoint);
    });
  }
  /** @internal */
  _appendChild(child) {
    this.children.push(child);
    child._setTree(this._tree);
  }
  /** @internal */
  _clearChildren() {
    for (const c2 of this.children) {
      c2._clearChildren();
      c2.context.vpa._cancelUpdate();
    }
    this.children.length = 0;
  }
  getTitle(separator) {
    const titleParts = [
      ...this.children.map((x2) => x2.getTitle(separator)),
      typeof this.title === "function" ? this.title.call(void 0, this) : this.title
    ].filter((x2) => x2 !== null);
    return titleParts.length === 0 ? null : titleParts.join(separator);
  }
  computeAbsolutePath() {
    if (this.context.isRoot) {
      return "";
    }
    const parentPath = this.context.parent.node.computeAbsolutePath();
    const thisPath = this.instruction.toUrlComponent(false);
    return parentPath.length > 0 ? thisPath.length > 0 ? `${parentPath}/${thisPath}` : parentPath : thisPath;
  }
  /** @internal */
  _setTree(tree) {
    this._tree = tree;
    for (const child of this.children) {
      child._setTree(tree);
    }
  }
  /** @internal */
  _finalizeInstruction() {
    this._isInstructionsFinalized = true;
    const children = this.children.map((x2) => x2._finalizeInstruction());
    const instruction = this.instruction._clone();
    instruction.children.splice(0, instruction.children.length, ...children);
    return this.instruction = instruction;
  }
  /** @internal */
  _clone() {
    const clone = new RouteNode(
      this.path,
      this.finalPath,
      this.context,
      this._originalInstruction,
      this.instruction,
      this.params,
      // as this is frozen, it's safe to share
      this.queryParams,
      // as this is frozen, it's safe to share
      this.fragment,
      this.data,
      // as this is frozen, it's safe to share
      this._viewport,
      this.title,
      this.component,
      [...this.residue]
    );
    const children = this.children;
    const len = children.length;
    for (let i3 = 0; i3 < len; ++i3) {
      clone.children.push(children[i3]._clone());
    }
    clone._version = this._version + 1;
    if (clone.context.node === this) {
      clone.context.node = clone;
    }
    return clone;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const props2 = [];
    const component = this.context?.config.component?.name ?? "";
    if (component.length > 0) {
      props2.push(`c:'${component}'`);
    }
    const path = this.context?.config.path ?? "";
    if (path.length > 0) {
      props2.push(`path:'${path}'`);
    }
    if (this.children.length > 0) {
      props2.push(`children:[${this.children.map(String).join(",")}]`);
    }
    if (this.residue.length > 0) {
      props2.push(`residue:${this.residue.map(function(r2) {
        if (typeof r2 === "string") {
          return `'${r2}'`;
        }
        return String(r2);
      }).join(",")}`);
    }
    return `RN(ctx:'${this.context?._friendlyPath}',${props2.join(",")})`;
  }
}
class RouteTree {
  constructor(options, queryParams, fragment, root) {
    this.options = options;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.root = root;
  }
  contains(instructions, matchEndpoint = false) {
    return this.root.contains(instructions, matchEndpoint);
  }
  /** @internal */
  _clone() {
    const clone = new RouteTree(
      this.options._clone(),
      this.queryParams,
      // as this is frozen, it's safe to share
      this.fragment,
      this.root._clone()
    );
    clone.root._setTree(this);
    return clone;
  }
  /** @internal */
  _finalizeInstructions() {
    return new ViewportInstructionTree(this.options, true, this.root.children.map((x2) => x2._finalizeInstruction()), this.queryParams, this.fragment);
  }
  /** @internal */
  _mergeQuery(other) {
    this.queryParams = Object.freeze(mergeURLSearchParams(this.queryParams, other, true));
  }
  toString() {
    return this.root.toString();
  }
}
function createAndAppendNodes(log, node, vi) {
  log.trace(`createAndAppendNodes(node:%s,vi:%s`, node, vi);
  switch (vi.component.type) {
    case 0:
      switch (vi.component.value) {
        case "..":
          node = node.context.parent?.node ?? node;
          node._clearChildren();
        case ".":
          return onResolveAll(...vi.children.map((childVI) => {
            return createAndAppendNodes(log, node, childVI);
          }));
        default: {
          log.trace(`createAndAppendNodes invoking createNode`);
          const ctx = node.context;
          const originalInstruction = vi._clone();
          let rr = vi.recognizedRoute;
          if (rr !== null)
            return appendNode(log, node, createConfiguredNode(log, node, vi, rr, originalInstruction));
          if (vi.children.length === 0) {
            const result = ctx._generateViewportInstruction(vi);
            if (result !== null) {
              node._tree._mergeQuery(result.query);
              const newVi = result.vi;
              newVi.children.push(...vi.children);
              return appendNode(log, node, createConfiguredNode(log, node, newVi, newVi.recognizedRoute, vi));
            }
          }
          let collapse = 0;
          let path = vi.component.value;
          let cur = vi;
          while (cur.children.length === 1) {
            cur = cur.children[0];
            if (cur.component.type === 0) {
              ++collapse;
              path = `${path}/${cur.component.value}`;
            } else {
              break;
            }
          }
          rr = ctx.recognize(path);
          log.trace("createNode recognized route: %s", rr);
          const residue = rr?.residue ?? null;
          log.trace("createNode residue:", residue);
          const noResidue = residue === null;
          if (rr === null || residue === path) {
            const eagerResult = ctx._generateViewportInstruction({
              component: vi.component.value,
              params: vi.params ?? emptyObject,
              open: vi.open,
              close: vi.close,
              viewport: vi.viewport,
              children: vi.children
            });
            if (eagerResult !== null) {
              node._tree._mergeQuery(eagerResult.query);
              return appendNode(log, node, createConfiguredNode(log, node, eagerResult.vi, eagerResult.vi.recognizedRoute, vi));
            }
            const name2 = vi.component.value;
            if (name2 === "")
              return;
            let vp = vi.viewport;
            if (vp === null || vp.length === 0)
              vp = defaultViewportName;
            const vpa = ctx.getFallbackViewportAgent(vp);
            const fallback = vpa !== null ? vpa.viewport._getFallback(vi, node, ctx) : ctx.config._getFallback(vi, node, ctx);
            if (fallback === null)
              throw new UnknownRouteError(getMessage(3401, name2, ctx._friendlyPath, vp, name2, ctx.component.name));
            if (typeof fallback === "string") {
              log.trace(`Fallback is set to '${fallback}'. Looking for a recognized route.`);
              const rd = ctx.childRoutes.find((x2) => x2.id === fallback);
              if (rd !== void 0)
                return appendNode(log, node, createFallbackNode(log, rd, node, vi));
              log.trace(`No route configuration for the fallback '${fallback}' is found; trying to recognize the route.`);
              const rr2 = ctx.recognize(fallback, true);
              if (rr2 !== null && rr2.residue !== fallback)
                return appendNode(log, node, createConfiguredNode(log, node, vi, rr2, null));
            }
            log.trace(`The fallback '${fallback}' is not recognized as a route; treating as custom element name.`);
            return onResolve(resolveRouteConfiguration(fallback, false, ctx.config, null, ctx), (rc) => appendNode(log, node, createFallbackNode(log, rc, node, vi)));
          }
          rr.residue = null;
          vi.component.value = noResidue ? path : path.slice(0, -(residue.length + 1));
          let addResidue = !noResidue;
          for (let i3 = 0; i3 < collapse; ++i3) {
            const child = vi.children[0];
            if (residue?.startsWith(child.component.value) ?? false) {
              addResidue = false;
              break;
            }
            vi.viewport = child.viewport;
            vi.children = child.children;
          }
          if (addResidue) {
            vi.children.unshift(ViewportInstruction.create(residue));
          }
          vi.recognizedRoute = rr;
          log.trace("createNode after adjustment vi:%s", vi);
          return appendNode(log, node, createConfiguredNode(log, node, vi, rr, originalInstruction));
        }
      }
    case 3:
    case 4:
    case 2: {
      const rc = node.context;
      return onResolve(resolveCustomElementDefinition(vi.component.value, rc)[1], (ced) => {
        const { vi: newVi, query } = rc._generateViewportInstruction({
          component: ced,
          params: vi.params ?? emptyObject,
          open: vi.open,
          close: vi.close,
          viewport: vi.viewport,
          children: vi.children
        });
        node._tree._mergeQuery(query);
        return appendNode(log, node, createConfiguredNode(log, node, newVi, newVi.recognizedRoute, vi));
      });
    }
  }
}
function createConfiguredNode(log, node, vi, rr, originalVi, route2 = rr.route.endpoint.route) {
  const ctx = node.context;
  const rt = node._tree;
  return onResolve(route2.handler, ($handler) => {
    route2.handler = $handler;
    log.trace(`creatingConfiguredNode(rdc:%s, vi:%s)`, $handler, vi);
    if ($handler.redirectTo === null) {
      const viWithVp = (vi.viewport?.length ?? 0) > 0;
      const vpName = viWithVp ? vi.viewport : $handler.viewport;
      return onResolve(resolveCustomElementDefinition($handler.component, ctx)[1], (ced) => {
        const vpa = ctx._resolveViewportAgent(new ViewportRequest(vpName, ced.name));
        if (!viWithVp) {
          vi.viewport = vpa.viewport.name;
        }
        const router = ctx.container.get(IRouter);
        return onResolve(router.getRouteContext(vpa, ced, null, vpa.hostController.container, ctx.config, ctx, $handler), (childCtx) => {
          log.trace("createConfiguredNode setting the context node");
          const $node = childCtx.node = RouteNode.create({
            path: rr.route.endpoint.route.path,
            finalPath: route2.path,
            context: childCtx,
            instruction: vi,
            originalInstruction: originalVi,
            params: rr.route.params,
            queryParams: rt.queryParams,
            fragment: rt.fragment,
            data: $handler.data,
            _viewport: vpName,
            component: ced,
            title: $handler.title,
            // Note: at this point, the residue from the recognized route should be converted to VI children. Hence the residues are not added back to the RouteNode.
            residue: vi.children.slice()
          });
          $node._setTree(node._tree);
          log.trace(`createConfiguredNode(vi:%s) -> %s`, vi, $node);
          return $node;
        });
      });
    }
    const origPath = RouteExpression.parse(pathUrlParser.parse(route2.path));
    const redirPath = RouteExpression.parse(pathUrlParser.parse($handler.redirectTo));
    let origCur;
    let redirCur;
    const newSegs = [];
    switch (origPath.root.kind) {
      case "ScopedSegment":
      case "Segment":
        origCur = origPath.root;
        break;
      default:
        throw new Error(getMessage(3502, origPath.root.kind));
    }
    switch (redirPath.root.kind) {
      case "ScopedSegment":
      case "Segment":
        redirCur = redirPath.root;
        break;
      default:
        throw new Error(getMessage(3502, redirPath.root.kind));
    }
    let origSeg;
    let redirSeg;
    let origDone = false;
    let redirDone = false;
    while (!(origDone && redirDone)) {
      if (origDone) {
        origSeg = null;
      } else if (origCur.kind === "Segment") {
        origSeg = origCur;
        origDone = true;
      } else if (origCur.left.kind === "Segment") {
        origSeg = origCur.left;
        switch (origCur.right.kind) {
          case "ScopedSegment":
          case "Segment":
            origCur = origCur.right;
            break;
          default:
            throw new Error(getMessage(3502, origCur.right.kind));
        }
      } else {
        throw new Error(getMessage(3502, origCur.left.kind));
      }
      if (redirDone) {
        redirSeg = null;
      } else if (redirCur.kind === "Segment") {
        redirSeg = redirCur;
        redirDone = true;
      } else if (redirCur.left.kind === "Segment") {
        redirSeg = redirCur.left;
        switch (redirCur.right.kind) {
          case "ScopedSegment":
          case "Segment":
            redirCur = redirCur.right;
            break;
          default:
            throw new Error(getMessage(3502, redirCur.right.kind));
        }
      } else {
        throw new Error(getMessage(3502, redirCur.left.kind));
      }
      if (redirSeg !== null) {
        if (redirSeg.component.isDynamic && (origSeg?.component.isDynamic ?? false)) {
          newSegs.push(rr.route.params[redirSeg.component.parameterName]);
        } else {
          newSegs.push(redirSeg.component.name);
        }
      }
    }
    const newPath = newSegs.filter(Boolean).join("/");
    const redirRR = ctx.recognize(newPath);
    if (redirRR === null)
      throw new UnknownRouteError(getMessage(3402, newPath, ctx._friendlyPath, newPath, ctx.component.name));
    return createConfiguredNode(log, node, ViewportInstruction.create({
      recognizedRoute: redirRR,
      component: newPath,
      children: vi.children,
      viewport: vi.viewport,
      open: vi.open,
      close: vi.close
    }), redirRR, originalVi);
  });
}
function appendNode(log, node, childNode) {
  return onResolve(childNode, ($childNode) => {
    log.trace(`appendNode($childNode:%s)`, $childNode);
    node._appendChild($childNode);
    return $childNode.context.vpa._scheduleUpdate(node._tree.options, $childNode);
  });
}
function createFallbackNode(log, rc, node, vi) {
  const rr = new $RecognizedRoute(new RecognizedRoute(new Endpoint(new ConfigurableRoute(rc.path[0], rc.caseSensitive, rc), []), emptyObject), null);
  vi.children.length = 0;
  return createConfiguredNode(log, node, vi, rr, null);
}
const emptyQuery = Object.freeze(new URLSearchParams());
function isManagedState(state) {
  return isObjectOrFunction(state) && Object.prototype.hasOwnProperty.call(state, AuNavId) === true;
}
function toManagedState(state, navId) {
  return { ...state, [AuNavId]: navId };
}
class UnknownRouteError extends Error {
}
class Transition {
  get erredWithUnknownRoute() {
    return this._erredWithUnknownRoute;
  }
  constructor(id2, prevInstructions, instructions, finalInstructions, instructionsChanged, trigger, options, managedState, previousRouteTree, routeTree, promise, resolve2, reject, guardsResult, error2) {
    this.id = id2;
    this.prevInstructions = prevInstructions;
    this.instructions = instructions;
    this.finalInstructions = finalInstructions;
    this.instructionsChanged = instructionsChanged;
    this.trigger = trigger;
    this.options = options;
    this.managedState = managedState;
    this.previousRouteTree = previousRouteTree;
    this.routeTree = routeTree;
    this.promise = promise;
    this.resolve = resolve2;
    this.reject = reject;
    this.guardsResult = guardsResult;
    this.error = error2;
    this._erredWithUnknownRoute = false;
  }
  /** @internal */
  static _create(input) {
    return new Transition(input.id, input.prevInstructions, input.instructions, input.finalInstructions, input.instructionsChanged, input.trigger, input.options, input.managedState, input.previousRouteTree, input.routeTree, input.promise, input.resolve, input.reject, input.guardsResult, void 0);
  }
  /** @internal */
  _run(cb, next) {
    if (this.guardsResult !== true) {
      return;
    }
    try {
      const ret = cb();
      if (ret instanceof Promise) {
        ret.then(next).catch((err) => {
          this._handleError(err);
        });
      } else {
        next(ret);
      }
    } catch (err) {
      this._handleError(err);
    }
  }
  /** @internal */
  _handleError(err) {
    this._erredWithUnknownRoute = err instanceof UnknownRouteError;
    this.reject(this.error = err);
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `T(id:${this.id},trigger:'${this.trigger}',instructions:${this.instructions})`;
  }
}
const IRouter = /* @__PURE__ */ DI.createInterface("IRouter", (x2) => x2.singleton(Router));
class Router {
  /** @internal */
  get _ctx() {
    const ctx = this._$ctx;
    if (ctx !== null)
      return ctx;
    if (!this._container.has(IRouteContext, true))
      throw new Error(getMessage(
        3271
        /* Events.rtrNoCtx */
      ));
    return this._$ctx = this._container.get(IRouteContext);
  }
  get routeTree() {
    let routeTree = this._routeTree;
    if (routeTree === null) {
      const ctx = this._ctx;
      routeTree = this._routeTree = new RouteTree(NavigationOptions.create(this.options, {}), emptyQuery, null, RouteNode.create({
        path: "",
        finalPath: "",
        context: ctx,
        instruction: null,
        component: CustomElement.getDefinition(ctx.config.component),
        title: ctx.config.title
      }));
    }
    return routeTree;
  }
  get currentTr() {
    return this._currentTr ??= Transition._create({
      id: 0,
      prevInstructions: this._instructions,
      instructions: this._instructions,
      finalInstructions: this._instructions,
      instructionsChanged: true,
      trigger: "api",
      options: NavigationOptions.create(this.options, {}),
      managedState: null,
      previousRouteTree: this.routeTree._clone(),
      routeTree: this.routeTree,
      resolve: null,
      reject: null,
      promise: null,
      guardsResult: true,
      error: void 0
    });
  }
  /** @internal */
  set currentTr(value) {
    this._currentTr = value;
  }
  get isNavigating() {
    return this._isNavigating;
  }
  constructor() {
    this._$ctx = null;
    this._routeTree = null;
    this._currentTr = null;
    this._navigated = false;
    this._navigationId = 0;
    this._nextTr = null;
    this._locationChangeSubscription = null;
    this._hasTitleBuilder = false;
    this._isNavigating = false;
    this._container = resolve(IContainer);
    this._p = resolve(IPlatform);
    this._logger = resolve(ILogger).root.scopeTo("Router");
    this._events = resolve(IRouterEvents);
    this._locationMgr = resolve(ILocationManager);
    this.options = resolve(IRouterOptions);
    this._vpaLookup = /* @__PURE__ */ new Map();
    this._instructions = ViewportInstructionTree.create("", this.options);
    this._container.registerResolver(Router, Registration.instance(Router, this));
  }
  /**
   * Get the closest RouteContext relative to the provided component, controller or node.
   *
   * @param context - The object from which to resolve the closest RouteContext.
   *
   * @returns when the value is:
   * - `null`: the root
   * - `IRouteContext`: the provided value (no-op)
   * - `HTMLElement`: the context of the routeable component (page) that directly or indirectly contains this element.
   * - `ICustomElementViewModel` (the `this` object when working from inside a view model): the context of this component (if it was loaded as a route), or the routeable component (page) directly or indirectly containing it.
   * - `ICustomElementController`: same as `ICustomElementViewModel`, but using the controller object instead of the view model object (advanced users).
   *
   * @internal
   */
  _resolveContext(context) {
    return RouteContext.resolve(this._ctx, context);
  }
  start(performInitialNavigation) {
    this._hasTitleBuilder = typeof this.options.buildTitle === "function";
    this._locationMgr.startListening();
    this._locationChangeSubscription = this._events.subscribe("au:router:location-change", (e2) => {
      this._p.taskQueue.queueTask(() => {
        const state = isManagedState(e2.state) ? e2.state : null;
        const routerOptions = this.options;
        const options = NavigationOptions.create(routerOptions, { historyStrategy: "replace" });
        const instructions = ViewportInstructionTree.create(e2.url, routerOptions, options, this._ctx);
        this._enqueue(instructions, e2.trigger, state, null);
      });
    });
    if (!this._navigated && performInitialNavigation) {
      return this.load(this._locationMgr.getPath(), { historyStrategy: this.options.historyStrategy !== "none" ? "replace" : "none" });
    }
  }
  stop() {
    this._locationMgr.stopListening();
    this._locationChangeSubscription?.dispose();
  }
  load(instructionOrInstructions, options) {
    const instructions = this.createViewportInstructions(instructionOrInstructions, options);
    trace(this._logger, 3250, instructions);
    return this._enqueue(instructions, "api", null, null);
  }
  isActive(instructionOrInstructions, context) {
    const ctx = this._resolveContext(context);
    const instructions = instructionOrInstructions instanceof ViewportInstructionTree ? instructionOrInstructions : this.createViewportInstructions(instructionOrInstructions, { context: ctx, historyStrategy: this.options.historyStrategy });
    trace(this._logger, 3251, instructions, ctx);
    return this.routeTree.contains(instructions, false);
  }
  /**
   * Retrieve the RouteContext, which contains statically configured routes combined with the customElement metadata associated with a type.
   *
   * The customElement metadata is lazily associated with a type via the RouteContext the first time `getOrCreate` is called.
   *
   * @param viewportAgent - The ViewportAgent hosting the component associated with this RouteContext. If the RouteContext for the component+viewport combination already exists, the ViewportAgent will be updated in case it changed.
   * @param componentDefinition - The custom element definition.
   * @param container - The `controller.container` of the component hosting the viewport that the route will be loaded into.
   *
   */
  getRouteContext(viewportAgent, componentDefinition, componentInstance, container, parentRouteConfig, parentContext, $rdConfig) {
    const logger = /* @__PURE__ */ container.get(ILogger).scopeTo("RouteContext");
    return onResolve($rdConfig instanceof RouteConfig ? $rdConfig : resolveRouteConfiguration(typeof componentInstance?.getRouteConfig === "function" ? componentInstance : componentDefinition.Type, false, parentRouteConfig, null, parentContext), (rdConfig) => {
      let routeConfigLookup = this._vpaLookup.get(viewportAgent);
      if (routeConfigLookup === void 0) {
        this._vpaLookup.set(viewportAgent, routeConfigLookup = /* @__PURE__ */ new WeakMap());
      }
      let routeContext = routeConfigLookup.get(rdConfig);
      if (routeContext !== void 0) {
        trace(logger, 3252, rdConfig);
        return routeContext;
      }
      trace(logger, 3253, rdConfig);
      const parent = container.has(IRouteContext, true) ? container.get(IRouteContext) : null;
      routeConfigLookup.set(rdConfig, routeContext = new RouteContext(viewportAgent, parent, componentDefinition, rdConfig, container, this));
      return routeContext;
    });
  }
  createViewportInstructions(instructionOrInstructions, options) {
    if (instructionOrInstructions instanceof ViewportInstructionTree)
      return instructionOrInstructions;
    let context = options?.context ?? null;
    if (typeof instructionOrInstructions === "string") {
      instructionOrInstructions = this._locationMgr.removeBaseHref(instructionOrInstructions);
    }
    const isVpInstr = isPartialViewportInstruction(instructionOrInstructions);
    let $instruction = isVpInstr ? instructionOrInstructions.component : instructionOrInstructions;
    if (typeof $instruction === "string" && $instruction.startsWith("../") && context !== null) {
      context = this._resolveContext(context);
      while ($instruction.startsWith("../") && (context?.parent ?? null) !== null) {
        $instruction = $instruction.slice(3);
        context = context.parent;
      }
    }
    if (isVpInstr) {
      instructionOrInstructions.component = $instruction;
    } else {
      instructionOrInstructions = $instruction;
    }
    const routerOptions = this.options;
    return ViewportInstructionTree.create(instructionOrInstructions, routerOptions, NavigationOptions.create(routerOptions, { ...options, context }), this._ctx);
  }
  /**
   * Enqueue an instruction tree to be processed as soon as possible.
   *
   * Will wait for any existing in-flight transition to finish, otherwise starts immediately.
   *
   * @param instructions - The instruction tree that determines the transition
   * @param trigger - `'popstate'` or `'hashchange'` if initiated by a browser event, or `'api'` for manually initiated transitions via the `load` api.
   * @param state - The state to restore, if any.
   * @param failedTr - If this is a redirect / fallback from a failed transition, the previous transition is passed forward to ensure the original promise resolves with the latest result.
   *
   * @internal
   */
  _enqueue(instructions, trigger, state, failedTr) {
    const lastTr = this.currentTr;
    const logger = this._logger;
    if (trigger !== "api" && lastTr.trigger === "api" && lastTr.instructions.equals(instructions)) {
      debug(logger, 3254, trigger);
      return true;
    }
    let resolve2 = void 0;
    let reject = void 0;
    let promise;
    const restorePrevRT = this.options.restorePreviousRouteTreeOnError;
    if (failedTr === null || failedTr.erredWithUnknownRoute || failedTr.error != null && restorePrevRT) {
      promise = new Promise(function($resolve2, $reject2) {
        resolve2 = $resolve2;
        reject = $reject2;
      });
    } else {
      debug(logger, 3255, failedTr);
      promise = failedTr.promise;
      resolve2 = failedTr.resolve;
      reject = failedTr.reject;
    }
    const nextTr = this._nextTr = Transition._create({
      id: ++this._navigationId,
      trigger,
      managedState: state,
      prevInstructions: lastTr.finalInstructions,
      finalInstructions: instructions,
      instructionsChanged: !lastTr.finalInstructions.equals(instructions),
      instructions,
      options: instructions.options,
      promise,
      resolve: resolve2,
      reject,
      previousRouteTree: this.routeTree,
      routeTree: this._routeTree = this.routeTree._clone(),
      guardsResult: true,
      error: void 0
    });
    debug(logger, 3256, nextTr);
    if (!this._isNavigating) {
      try {
        this._run(nextTr);
      } catch (err) {
        nextTr._handleError(err);
      }
    }
    return nextTr.promise.then((ret) => {
      debug(logger, 3257, nextTr);
      return ret;
    }).catch((err) => {
      error(logger, 3270, nextTr, err);
      if (nextTr.erredWithUnknownRoute) {
        this._cancelNavigation(nextTr);
      } else {
        this._isNavigating = false;
        this._events.publish(new NavigationErrorEvent(nextTr.id, nextTr.instructions, err));
        if (restorePrevRT) {
          this._cancelNavigation(nextTr);
        } else {
          const $nextTr = this._nextTr;
          if ($nextTr !== null) {
            $nextTr.previousRouteTree = nextTr.previousRouteTree;
          } else {
            this._routeTree = nextTr.previousRouteTree;
          }
        }
      }
      throw err;
    });
  }
  /** @internal */
  _run(tr) {
    this.currentTr = tr;
    this._nextTr = null;
    this._isNavigating = true;
    let navigationContext = this._resolveContext(tr.options.context);
    const logger = /* @__PURE__ */ this._logger.scopeTo("run()");
    trace(logger, 3258, tr);
    this._events.publish(new NavigationStartEvent(tr.id, tr.instructions, tr.trigger, tr.managedState));
    if (this._nextTr !== null) {
      debug(logger, 3259, tr);
      return this._run(this._nextTr);
    }
    tr._run(() => {
      const vit = tr.finalInstructions;
      trace(logger, 3260, vit);
      const rootCtx = this._ctx;
      const rt = tr.routeTree;
      rt.options = vit.options;
      rt.queryParams = rootCtx.node._tree.queryParams = vit.queryParams;
      rt.fragment = rootCtx.node._tree.fragment = vit.fragment;
      const log = /* @__PURE__ */ navigationContext.container.get(ILogger).scopeTo("RouteTree");
      if (vit.isAbsolute) {
        navigationContext = rootCtx;
      }
      if (navigationContext === rootCtx) {
        rt.root._setTree(rt);
        rootCtx.node = rt.root;
      }
      const suffix = navigationContext.allResolved instanceof Promise ? " - awaiting promise" : "";
      log.trace(`updateRouteTree(rootCtx:%s,rt:%s,vit:%s)${suffix}`, rootCtx, rt, vit);
      return onResolve(navigationContext.allResolved, () => updateNode(log, vit, navigationContext, rootCtx.node));
    }, () => {
      const prev = tr.previousRouteTree.root.children;
      const next = tr.routeTree.root.children;
      const all2 = mergeDistinct(prev, next);
      Batch._start((b3) => {
        trace(logger, 3261, prev.length);
        for (const node of prev) {
          node.context.vpa._canUnload(tr, b3);
        }
      })._continueWith((b3) => {
        if (tr.guardsResult !== true) {
          b3._push();
          this._cancelNavigation(tr);
        }
      })._continueWith((b3) => {
        trace(logger, 3262, next.length);
        for (const node of next) {
          node.context.vpa._canLoad(tr, b3);
        }
      })._continueWith((b3) => {
        if (tr.guardsResult !== true) {
          b3._push();
          this._cancelNavigation(tr);
        }
      })._continueWith((b3) => {
        trace(logger, 3263, prev.length);
        for (const node of prev) {
          node.context.vpa._unloading(tr, b3);
        }
      })._continueWith((b3) => {
        trace(logger, 3264, next.length);
        for (const node of next) {
          node.context.vpa._loading(tr, b3);
        }
      })._continueWith((b3) => {
        trace(logger, 3265, all2.length);
        for (const node of all2) {
          node.context.vpa._swap(tr, b3);
        }
      })._continueWith(() => {
        trace(
          logger,
          3266
          /* Events.rtrRunFinalizing */
        );
        all2.forEach(function(node) {
          node.context.vpa._endTransition();
        });
        this._navigated = true;
        this._instructions = tr.finalInstructions = tr.routeTree._finalizeInstructions();
        this._isNavigating = false;
        const newUrl = tr.finalInstructions.toUrl(true, this.options._urlParser);
        switch (tr.options._getHistoryStrategy(this._instructions)) {
          case "none":
            break;
          case "push":
            this._locationMgr.pushState(toManagedState(tr.options.state, tr.id), this.updateTitle(tr), newUrl);
            break;
          case "replace":
            this._locationMgr.replaceState(toManagedState(tr.options.state, tr.id), this.updateTitle(tr), newUrl);
            break;
        }
        this._events.publish(new NavigationEndEvent(tr.id, tr.instructions, this._instructions));
        tr.resolve(true);
        this._runNextTransition();
      })._start();
    });
  }
  updateTitle(tr = this.currentTr) {
    const title = this._getTitle(tr);
    if (title.length > 0) {
      this._p.document.title = title;
    }
    return this._p.document.title;
  }
  /** @internal */
  _getTitle(tr = this.currentTr) {
    let title;
    if (this._hasTitleBuilder) {
      title = this.options.buildTitle(tr) ?? "";
    } else {
      switch (typeof tr.options.title) {
        case "function":
          title = tr.options.title.call(void 0, tr.routeTree.root) ?? "";
          break;
        case "string":
          title = tr.options.title;
          break;
        default:
          title = tr.routeTree.root.getTitle(tr.options.titleSeparator) ?? "";
          break;
      }
    }
    return title;
  }
  /** @internal */
  _cancelNavigation(tr) {
    const logger = /* @__PURE__ */ this._logger.scopeTo("cancelNavigation()");
    trace(logger, 3267, tr);
    const prev = tr.previousRouteTree.root.children;
    const next = tr.routeTree.root.children;
    const all2 = mergeDistinct(prev, next);
    all2.forEach(function(node) {
      node.context.vpa._cancelUpdate();
    });
    this._instructions = tr.prevInstructions;
    this._routeTree = tr.previousRouteTree;
    this._isNavigating = false;
    const guardsResult = tr.guardsResult;
    this._events.publish(new NavigationCancelEvent(tr.id, tr.instructions, `guardsResult is ${guardsResult}`));
    if (guardsResult === false) {
      tr.resolve(false);
      this._runNextTransition();
    } else {
      let instructions;
      if (this._navigated && (tr.erredWithUnknownRoute || tr.error != null && this.options.restorePreviousRouteTreeOnError))
        instructions = tr.prevInstructions;
      else if (guardsResult === true)
        return;
      else
        instructions = guardsResult;
      void onResolve(this._enqueue(instructions, "api", tr.managedState, tr), () => {
        trace(this._logger, 3268, tr);
      });
    }
  }
  /** @internal */
  _runNextTransition() {
    if (this._nextTr === null)
      return;
    trace(this._logger, 3269, this._nextTr);
    this._p.taskQueue.queueTask(() => {
      const nextTr = this._nextTr;
      if (nextTr === null)
        return;
      try {
        this._run(nextTr);
      } catch (err) {
        nextTr._handleError(err);
      }
    });
  }
}
function updateNode(log, vit, ctx, node) {
  log.trace(`updateNode(ctx:%s,node:%s)`, ctx, node);
  node.queryParams = vit.queryParams;
  node.fragment = vit.fragment;
  if (!node.context.isRoot) {
    node.context.vpa._scheduleUpdate(node._tree.options, node);
  }
  if (node.context === ctx) {
    node._clearChildren();
    return onResolve(onResolveAll(...vit.children.map((vi) => createAndAppendNodes(log, node, vi))), () => onResolveAll(...ctx.getAvailableViewportAgents().reduce((acc, vpa) => {
      const vp = vpa.viewport;
      const component = vp.default;
      if (component === null)
        return acc;
      acc.push(createAndAppendNodes(log, node, ViewportInstruction.create({ component, viewport: vp.name })));
      return acc;
    }, [])));
  }
  return onResolveAll(...node.children.map((child) => {
    return updateNode(log, vit, ctx, child);
  }));
}
class ParsedUrl {
  constructor(path, query, fragment) {
    this.path = path;
    this.query = query;
    this.fragment = fragment;
    this.id = `${path}?${query?.toString() ?? ""}#${fragment ?? ""}`;
  }
  toString() {
    return this.id;
  }
  /** @internal */
  static _create(value) {
    let fragment = null;
    const fragmentStart = value.indexOf("#");
    if (fragmentStart >= 0) {
      const rawFragment = value.slice(fragmentStart + 1);
      fragment = decodeURIComponent(rawFragment);
      value = value.slice(0, fragmentStart);
    }
    let queryParams = null;
    const queryStart = value.indexOf("?");
    if (queryStart >= 0) {
      const queryString = value.slice(queryStart + 1);
      value = value.slice(0, queryStart);
      queryParams = Object.freeze(new URLSearchParams(queryString));
    }
    return new ParsedUrl(value, queryParams ?? emptyQuery, fragment);
  }
}
function stringify(pathOrParsedUrl, query, fragment) {
  let path;
  if (typeof pathOrParsedUrl === "string") {
    path = pathOrParsedUrl;
  } else {
    path = pathOrParsedUrl.path;
    query = pathOrParsedUrl.query;
    fragment = pathOrParsedUrl.fragment;
  }
  query ??= emptyQuery;
  let queryString = query.toString();
  queryString = queryString === "" ? "" : `?${queryString}`;
  const hash2 = fragment != null && fragment.length > 0 ? `#${encodeURIComponent(fragment)}` : "";
  return `${path}${queryString}${hash2}`;
}
const pathUrlParser = Object.freeze({
  parse(value) {
    return ParsedUrl._create(value);
  },
  stringify(pathOrParsedUrl, query, fragment) {
    return stringify(pathOrParsedUrl, query, fragment);
  }
});
const fragmentUrlParser = Object.freeze({
  parse(value) {
    const start2 = value.indexOf("#");
    if (start2 >= 0) {
      const rawFragment = value.slice(start2 + 1);
      value = decodeURIComponent(rawFragment);
    }
    return ParsedUrl._create(value);
  },
  stringify(pathOrParsedUrl, query, fragment) {
    return `/#/${stringify(pathOrParsedUrl, query, fragment)}`;
  }
});
function valueOrFuncToValue(instructions, valueOrFunc) {
  if (typeof valueOrFunc === "function") {
    return valueOrFunc(instructions);
  }
  return valueOrFunc;
}
const IRouterOptions = /* @__PURE__ */ DI.createInterface("RouterOptions");
class RouterOptions {
  constructor(useUrlFragmentHash, useHref, historyStrategy, buildTitle, useNavigationModel, activeClass, restorePreviousRouteTreeOnError) {
    this.useUrlFragmentHash = useUrlFragmentHash;
    this.useHref = useHref;
    this.historyStrategy = historyStrategy;
    this.buildTitle = buildTitle;
    this.useNavigationModel = useNavigationModel;
    this.activeClass = activeClass;
    this.restorePreviousRouteTreeOnError = restorePreviousRouteTreeOnError;
    this._urlParser = useUrlFragmentHash ? fragmentUrlParser : pathUrlParser;
  }
  static create(input) {
    return new RouterOptions(input.useUrlFragmentHash ?? false, input.useHref ?? true, input.historyStrategy ?? "push", input.buildTitle ?? null, input.useNavigationModel ?? true, input.activeClass ?? null, input.restorePreviousRouteTreeOnError ?? true);
  }
  toString() {
    return `RO(${[
      ["historyStrategy", "history"]
    ].map(([key, name2]) => {
      const value = this[key];
      return `${name2}:${typeof value === "function" ? value : `'${value}'`}`;
    }).join(",")})`;
  }
}
class NavigationOptions {
  constructor(historyStrategy, title, titleSeparator, context, queryParams, fragment, state, transitionPlan) {
    this.historyStrategy = historyStrategy;
    this.title = title;
    this.titleSeparator = titleSeparator;
    this.context = context;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.state = state;
    this.transitionPlan = transitionPlan;
  }
  static create(routerOptions, input) {
    return new NavigationOptions(input.historyStrategy ?? routerOptions.historyStrategy, input.title ?? null, input.titleSeparator ?? " | ", input.context ?? null, input.queryParams ?? null, input.fragment ?? "", input.state ?? null, input.transitionPlan ?? null);
  }
  /** @internal */
  _clone() {
    return new NavigationOptions(this.historyStrategy, this.title, this.titleSeparator, this.context, { ...this.queryParams }, this.fragment, this.state === null ? null : { ...this.state }, this.transitionPlan);
  }
  /** @internal */
  _getHistoryStrategy(instructions) {
    return valueOrFuncToValue(instructions, this.historyStrategy);
  }
}
const defaultViewportName = "default";
class ViewportInstruction {
  constructor(open, close, recognizedRoute, component, viewport2, params, children) {
    this.open = open;
    this.close = close;
    this.recognizedRoute = recognizedRoute;
    this.component = component;
    this.viewport = viewport2;
    this.params = params;
    this.children = children;
  }
  static create(instruction) {
    if (instruction instanceof ViewportInstruction)
      return instruction;
    if (isPartialViewportInstruction(instruction)) {
      const component = TypedNavigationInstruction.create(instruction.component);
      const children = instruction.children?.map(ViewportInstruction.create) ?? [];
      return new ViewportInstruction(instruction.open ?? 0, instruction.close ?? 0, instruction.recognizedRoute ?? null, component, instruction.viewport ?? null, Object.freeze(instruction.params ?? null), children);
    }
    const typedInstruction = TypedNavigationInstruction.create(instruction);
    return new ViewportInstruction(0, 0, null, typedInstruction, null, null, []);
  }
  contains(other) {
    const thisChildren = this.children;
    const otherChildren = other.children;
    if (thisChildren.length < otherChildren.length) {
      return false;
    }
    if (!this.component.equals(other.component))
      return false;
    const vp = this.viewport ?? null;
    const otherVp = other.viewport ?? null;
    if (vp !== null && otherVp !== null && vp !== otherVp)
      return false;
    for (let i3 = 0, ii = otherChildren.length; i3 < ii; ++i3) {
      if (!thisChildren[i3].contains(otherChildren[i3])) {
        return false;
      }
    }
    return true;
  }
  equals(other) {
    const thisChildren = this.children;
    const otherChildren = other.children;
    if (thisChildren.length !== otherChildren.length) {
      return false;
    }
    if (!this.component.equals(other.component) || this.viewport !== other.viewport || !shallowEquals(this.params, other.params)) {
      return false;
    }
    for (let i3 = 0, ii = thisChildren.length; i3 < ii; ++i3) {
      if (!thisChildren[i3].equals(otherChildren[i3])) {
        return false;
      }
    }
    return true;
  }
  /** @internal */
  _clone() {
    return new ViewportInstruction(this.open, this.close, this.recognizedRoute, this.component._clone(), this.viewport, this.params, [...this.children]);
  }
  toUrlComponent(recursive = true) {
    const component = this.component.toUrlComponent();
    const vp = this.viewport;
    const viewport2 = component.length === 0 || vp === null || vp.length === 0 || vp === defaultViewportName ? "" : `@${vp}`;
    const thisPart = `${"(".repeat(this.open)}${component}${stringifyParams(this.params)}${viewport2}${")".repeat(this.close)}`;
    const childPart = recursive ? this.children.map((x2) => x2.toUrlComponent()).join("+") : "";
    return thisPart.length > 0 ? childPart.length > 0 ? `${thisPart}/${childPart}` : thisPart : childPart;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const component = `c:${this.component}`;
    const viewport2 = this.viewport === null || this.viewport.length === 0 ? "" : `viewport:${this.viewport}`;
    const children = this.children.length === 0 ? "" : `children:[${this.children.map(String).join(",")}]`;
    const props2 = [component, viewport2, children].filter(Boolean).join(",");
    return `VPI(${props2})`;
  }
}
function stringifyParams(params) {
  if (params === null)
    return "";
  const keys = Object.keys(params);
  const numKeys = keys.length;
  if (numKeys === 0)
    return "";
  const values = Array(numKeys);
  const indexKeys = [];
  const namedKeys = [];
  for (const key of keys) {
    if (isArrayIndex(key)) {
      indexKeys.push(Number(key));
    } else {
      namedKeys.push(key);
    }
  }
  for (let i3 = 0; i3 < numKeys; ++i3) {
    const indexKeyIdx = indexKeys.indexOf(i3);
    if (indexKeyIdx > -1) {
      values[i3] = params[i3];
      indexKeys.splice(indexKeyIdx, 1);
    } else {
      const namedKey = namedKeys.shift();
      values[i3] = `${namedKey}=${params[namedKey]}`;
    }
  }
  return `(${values.join(",")})`;
}
class ViewportInstructionTree {
  constructor(options, isAbsolute, children, queryParams, fragment) {
    this.options = options;
    this.isAbsolute = isAbsolute;
    this.children = children;
    this.queryParams = queryParams;
    this.fragment = fragment;
    Object.freeze(queryParams);
  }
  static create(instructionOrInstructions, routerOptions, options, rootCtx) {
    options = options instanceof NavigationOptions ? options : NavigationOptions.create(routerOptions, options ?? emptyObject);
    let context = options.context;
    if (!(context instanceof RouteContext) && rootCtx != null) {
      context = options.context = RouteContext.resolve(rootCtx, context);
    }
    const hasContext = context != null;
    if (instructionOrInstructions instanceof Array) {
      const len = instructionOrInstructions.length;
      const children = new Array(len);
      const query2 = new URLSearchParams(options.queryParams ?? emptyObject);
      for (let i3 = 0; i3 < len; i3++) {
        const instruction = instructionOrInstructions[i3];
        const eagerVi2 = hasContext ? context._generateViewportInstruction(instruction) : null;
        if (eagerVi2 !== null) {
          children[i3] = eagerVi2.vi;
          mergeURLSearchParams(query2, eagerVi2.query, false);
        } else {
          children[i3] = ViewportInstruction.create(instruction);
        }
      }
      return new ViewportInstructionTree(options, false, children, query2, options.fragment);
    }
    if (typeof instructionOrInstructions === "string") {
      const expr = RouteExpression.parse(routerOptions._urlParser.parse(instructionOrInstructions));
      return expr.toInstructionTree(options);
    }
    const eagerVi = hasContext ? context._generateViewportInstruction(isPartialViewportInstruction(instructionOrInstructions) ? { ...instructionOrInstructions, params: instructionOrInstructions.params ?? emptyObject } : { component: instructionOrInstructions, params: emptyObject }) : null;
    const query = new URLSearchParams(options.queryParams ?? emptyObject);
    return eagerVi !== null ? new ViewportInstructionTree(options, false, [eagerVi.vi], mergeURLSearchParams(query, eagerVi.query, false), options.fragment) : new ViewportInstructionTree(options, false, [ViewportInstruction.create(instructionOrInstructions)], query, options.fragment);
  }
  equals(other) {
    const thisChildren = this.children;
    const otherChildren = other.children;
    if (thisChildren.length !== otherChildren.length) {
      return false;
    }
    for (let i3 = 0, ii = thisChildren.length; i3 < ii; ++i3) {
      if (!thisChildren[i3].equals(otherChildren[i3])) {
        return false;
      }
    }
    return true;
  }
  toUrl(isFinalInstruction, parser) {
    let parentPath = "";
    if (!isFinalInstruction) {
      const parentPaths = [];
      let ctx = this.options.context;
      if (ctx != null && !(ctx instanceof RouteContext))
        throw new Error("Invalid operation; incompatible navigation context.");
      while (ctx != null && !ctx.isRoot) {
        const vpa = ctx.vpa;
        const node = vpa._currState === 4096 ? vpa._currNode : vpa._nextNode;
        if (node == null)
          throw new Error("Invalid operation; nodes of the viewport agent are not set.");
        parentPaths.splice(0, 0, node.instruction.toUrlComponent());
        ctx = ctx.parent;
      }
      if (parentPaths[0] === "") {
        parentPaths.splice(0, 1);
      }
      parentPath = parentPaths.join("/");
    }
    const currentPath = this.toPath();
    return parser.stringify(parentPath.length > 0 ? `${parentPath}/${currentPath}` : currentPath, this.queryParams, this.fragment);
  }
  toPath() {
    return this.children.map((x2) => x2.toUrlComponent()).join("+");
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    return `[${this.children.map(String).join(",")}]`;
  }
}
class TypedNavigationInstruction {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
  static create(instruction) {
    if (instruction instanceof TypedNavigationInstruction) {
      return instruction;
    }
    if (typeof instruction === "string")
      return new TypedNavigationInstruction(0, instruction);
    if (!isObjectOrFunction(instruction))
      expectType("function/class or object", "", instruction);
    if (typeof instruction === "function") {
      if (CustomElement.isType(instruction)) {
        const definition = CustomElement.getDefinition(instruction);
        return new TypedNavigationInstruction(2, definition);
      } else {
        return TypedNavigationInstruction.create(instruction());
      }
    }
    if (instruction instanceof Promise)
      return new TypedNavigationInstruction(3, instruction);
    if (isPartialViewportInstruction(instruction)) {
      const viewportInstruction = ViewportInstruction.create(instruction);
      return new TypedNavigationInstruction(1, viewportInstruction);
    }
    if (isCustomElementViewModel(instruction))
      return new TypedNavigationInstruction(4, instruction);
    if (instruction instanceof CustomElementDefinition)
      return new TypedNavigationInstruction(2, instruction);
    throw new Error(getMessage(3400, tryStringify(instruction)));
  }
  equals(other) {
    switch (this.type) {
      case 2:
      case 4:
      case 3:
      case 0:
        return this.type === other.type && this.value === other.value;
      case 1:
        return this.type === other.type && this.value.equals(other.value);
    }
  }
  /** @internal */
  _clone() {
    return new TypedNavigationInstruction(this.type, this.value);
  }
  toUrlComponent() {
    switch (this.type) {
      case 2:
        return this.value.name;
      case 4:
      case 3:
        throw new Error(getMessage(3403, this.type));
      case 1:
        return this.value.toUrlComponent();
      case 0:
        return this.value;
    }
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    switch (this.type) {
      case 2:
        return `CEDef(name:'${this.value.name}')`;
      case 3:
        return `Promise`;
      case 4:
        return `VM(name:'${CustomElement.getDefinition(this.value.constructor).name}')`;
      case 1:
        return this.value.toString();
      case 0:
        return `'${this.value}'`;
    }
  }
}
class ComponentAgent {
  constructor(_instance, _controller, _routeNode, _ctx, _routerOptions) {
    this._instance = _instance;
    this._controller = _controller;
    this._routeNode = _routeNode;
    this._ctx = _ctx;
    this._routerOptions = _routerOptions;
    this._logger = _controller.container.get(ILogger).scopeTo(`ComponentAgent<${_ctx._friendlyPath}>`);
    trace(
      this._logger,
      3050
      /* Events.caCreated */
    );
    const lifecycleHooks = _controller.lifecycleHooks;
    this._canLoadHooks = (lifecycleHooks.canLoad ?? []).map((x2) => x2.instance);
    this._loadHooks = (lifecycleHooks.loading ?? []).map((x2) => x2.instance);
    this._canUnloadHooks = (lifecycleHooks.canUnload ?? []).map((x2) => x2.instance);
    this._unloadHooks = (lifecycleHooks.unloading ?? []).map((x2) => x2.instance);
    this._hasCanLoad = "canLoad" in _instance;
    this._hasLoad = "loading" in _instance;
    this._hasCanUnload = "canUnload" in _instance;
    this._hasUnload = "unloading" in _instance;
  }
  /** @internal */
  _activate(initiator, parent) {
    if (initiator === null) {
      trace(
        this._logger,
        3051
        /* Events.caActivateSelf */
      );
      return this._controller.activate(this._controller, parent);
    }
    trace(
      this._logger,
      3052
      /* Events.caActivateInitiator */
    );
    void this._controller.activate(initiator, parent);
  }
  /** @internal */
  _deactivate(initiator, parent) {
    if (initiator === null) {
      trace(
        this._logger,
        3053
        /* Events.caDeactivateSelf */
      );
      return this._controller.deactivate(this._controller, parent);
    }
    trace(
      this._logger,
      3054
      /* Events.caDeactivateInitiator */
    );
    void this._controller.deactivate(initiator, parent);
  }
  /** @internal */
  _dispose() {
    trace(
      this._logger,
      3055
      /* Events.caDispose */
    );
    this._controller.dispose();
  }
  /** @internal */
  _canUnload(tr, next, b3) {
    trace(this._logger, 3056, next, this._canUnloadHooks.length);
    b3._push();
    let promise = Promise.resolve();
    for (const hook of this._canUnloadHooks) {
      b3._push();
      promise = promise.then(() => new Promise((res) => {
        if (tr.guardsResult !== true) {
          b3._pop();
          res();
          return;
        }
        tr._run(() => {
          return hook.canUnload(this._instance, next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret === false) {
            tr.guardsResult = false;
          }
          b3._pop();
          res();
        });
      }));
    }
    if (this._hasCanUnload) {
      b3._push();
      promise = promise.then(() => {
        if (tr.guardsResult !== true) {
          b3._pop();
          return;
        }
        tr._run(() => {
          return this._instance.canUnload(next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret === false) {
            tr.guardsResult = false;
          }
          b3._pop();
        });
      });
    }
    b3._pop();
  }
  /** @internal */
  _canLoad(tr, next, b3) {
    trace(this._logger, 3057, next, this._canLoadHooks.length);
    const rootCtx = this._ctx.root;
    b3._push();
    let promise = Promise.resolve();
    for (const hook of this._canLoadHooks) {
      b3._push();
      promise = promise.then(() => new Promise((res) => {
        if (tr.guardsResult !== true) {
          b3._pop();
          res();
          return;
        }
        tr._run(() => {
          return hook.canLoad(this._instance, next.params, next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret != null && ret !== true) {
            tr.guardsResult = ret === false ? false : ViewportInstructionTree.create(ret, this._routerOptions, void 0, rootCtx);
          }
          b3._pop();
          res();
        });
      }));
    }
    if (this._hasCanLoad) {
      b3._push();
      promise = promise.then(() => {
        if (tr.guardsResult !== true) {
          b3._pop();
          return;
        }
        tr._run(() => {
          return this._instance.canLoad(next.params, next, this._routeNode);
        }, (ret) => {
          if (tr.guardsResult === true && ret != null && ret !== true) {
            tr.guardsResult = ret === false ? false : ViewportInstructionTree.create(ret, this._routerOptions, void 0, rootCtx);
          }
          b3._pop();
        });
      });
    }
    b3._pop();
  }
  /** @internal */
  _unloading(tr, next, b3) {
    trace(this._logger, 3058, next, this._unloadHooks.length);
    b3._push();
    for (const hook of this._unloadHooks) {
      tr._run(() => {
        b3._push();
        return hook.unloading(this._instance, next, this._routeNode);
      }, () => {
        b3._pop();
      });
    }
    if (this._hasUnload) {
      tr._run(() => {
        b3._push();
        return this._instance.unloading(next, this._routeNode);
      }, () => {
        b3._pop();
      });
    }
    b3._pop();
  }
  /** @internal */
  _loading(tr, next, b3) {
    trace(this._logger, 3059, next, this._loadHooks.length);
    b3._push();
    for (const hook of this._loadHooks) {
      tr._run(() => {
        b3._push();
        return hook.loading(this._instance, next.params, next, this._routeNode);
      }, () => {
        b3._pop();
      });
    }
    if (this._hasLoad) {
      tr._run(() => {
        b3._push();
        return this._instance.loading(next.params, next, this._routeNode);
      }, () => {
        b3._pop();
      });
    }
    b3._pop();
  }
}
const IRouteContext = /* @__PURE__ */ DI.createInterface("IRouteContext");
const allowedEagerComponentTypes = Object.freeze(["string", "object", "function"]);
function isEagerInstruction(val) {
  if (val == null)
    return false;
  const params = val.params;
  const component = val.component;
  return typeof params === "object" && params !== null && component != null && allowedEagerComponentTypes.includes(typeof component) && !(component instanceof Promise);
}
class RouteContext {
  get isRoot() {
    return this.parent === null;
  }
  get depth() {
    return this.path.length - 1;
  }
  get allResolved() {
    return this._allResolved;
  }
  get node() {
    const node = this._node;
    if (node === null)
      throw new Error(getMessage(3171, this));
    return node;
  }
  /** @internal */
  set node(value) {
    const prev = this._prevNode = this._node;
    if (prev !== value) {
      this._node = value;
      trace(this._logger, 3151, this._prevNode, value);
    }
  }
  /**
   * The viewport hosting the component associated with this RouteContext.
   * The root RouteContext has no ViewportAgent and will throw when attempting to access this property.
   */
  get vpa() {
    const vpa = this._vpa;
    if (vpa === null)
      throw new Error(getMessage(3172, this));
    return vpa;
  }
  get navigationModel() {
    return this._navigationModel;
  }
  constructor(viewportAgent, parent, component, config, parentContainer, _router) {
    this.parent = parent;
    this.component = component;
    this.config = config;
    this._router = _router;
    this._childViewportAgents = [];
    this.childRoutes = [];
    this._allResolved = null;
    this._prevNode = null;
    this._node = null;
    this._childRoutesConfigured = false;
    this._vpa = viewportAgent;
    if (parent === null) {
      this.root = this;
      this.path = [this];
      this._friendlyPath = component.name;
    } else {
      this.root = parent.root;
      this.path = [...parent.path, this];
      this._friendlyPath = `${parent._friendlyPath}/${component.name}`;
    }
    this._logger = parentContainer.get(ILogger).scopeTo(`RouteContext<${this._friendlyPath}>`);
    trace(
      this._logger,
      3150
      /* Events.rcCreated */
    );
    this._moduleLoader = parentContainer.get(IModuleLoader);
    const container = this.container = parentContainer.createChild();
    this._platform = container.get(IPlatform);
    container.registerResolver(IController, this._hostControllerProvider = new InstanceProvider(), true);
    const ctxProvider = new InstanceProvider("IRouteContext", this);
    container.registerResolver(IRouteContext, ctxProvider);
    container.registerResolver(RouteContext, ctxProvider);
    this._recognizer = new RouteRecognizer();
    if (_router.options.useNavigationModel) {
      const navModel = this._navigationModel = new NavigationModel([]);
      container.get(IRouterEvents).subscribe("au:router:navigation-end", () => navModel._setIsActive(_router, this));
    } else {
      this._navigationModel = null;
    }
    this._processConfig(config);
  }
  /** @internal */
  _processConfig(config) {
    const allPromises = [];
    const childrenRoutes = config.routes ?? noRoutes;
    const len = childrenRoutes.length;
    if (len === 0) {
      const getRouteConfig = config.component.prototype?.getRouteConfig;
      this._childRoutesConfigured = getRouteConfig == null ? true : typeof getRouteConfig !== "function";
      return;
    }
    const navModel = this._navigationModel;
    const hasNavModel = navModel !== null;
    let i3 = 0;
    for (; i3 < len; i3++) {
      const childRoute = childrenRoutes[i3];
      if (childRoute instanceof Promise) {
        allPromises.push(this._addRoute(childRoute));
        continue;
      }
      const rdResolution = resolveRouteConfiguration(childRoute, true, config, null, this);
      if (rdResolution instanceof Promise) {
        if (!isPartialChildRouteConfig(childRoute) || childRoute.path == null)
          throw new Error(getMessage(
            3173
            /* Events.rcNoPathLazyImport */
          ));
        for (const path of ensureArrayOfStrings(childRoute.path)) {
          this._$addRoute(path, childRoute.caseSensitive ?? false, rdResolution);
        }
        const idx = this.childRoutes.length;
        const p2 = rdResolution.then((rdConfig) => {
          return this.childRoutes[idx] = rdConfig;
        });
        this.childRoutes.push(p2);
        if (hasNavModel) {
          navModel._addRoute(p2);
        }
        allPromises.push(p2.then(noop$1));
        continue;
      }
      for (const path of rdResolution.path ?? emptyArray) {
        this._$addRoute(path, rdResolution.caseSensitive, rdResolution);
      }
      this.childRoutes.push(rdResolution);
      if (hasNavModel) {
        navModel._addRoute(rdResolution);
      }
    }
    this._childRoutesConfigured = true;
    if (allPromises.length > 0) {
      this._allResolved = Promise.all(allPromises).then(() => {
        this._allResolved = null;
      });
    }
  }
  /**
   * Create a new `RouteContext` and register it in the provided container.
   *
   * Uses the `RenderContext` of the registered `IAppRoot` as the root context.
   *
   * @param container - The container from which to resolve the `IAppRoot` and in which to register the `RouteContext`
   */
  static setRoot(container) {
    const logger = container.get(ILogger).scopeTo("RouteContext");
    if (!container.has(IAppRoot, true)) {
      logAndThrow(new Error(getMessage(
        3167
        /* Events.rcNoAppRoot */
      )), logger);
    }
    if (container.has(IRouteContext, true)) {
      logAndThrow(new Error(getMessage(
        3168
        /* Events.rcHasRootContext */
      )), logger);
    }
    const { controller } = container.get(IAppRoot);
    if (controller === void 0) {
      logAndThrow(new Error(getMessage(
        3169
        /* Events.rcNoRootCtrl */
      )), logger);
    }
    const router = container.get(IRouter);
    return onResolve(router.getRouteContext(null, controller.definition, controller.viewModel, controller.container, null, null, null), (routeContext) => {
      container.register(Registration.instance(IRouteContext, routeContext));
      routeContext.node = router.routeTree.root;
    });
  }
  static resolve(root, context) {
    const rootContainer = root.container;
    const logger = rootContainer.get(ILogger).scopeTo("RouteContext");
    if (context == null) {
      trace(logger, 3152, context);
      return root;
    }
    if (context instanceof RouteContext) {
      trace(logger, 3153, context);
      return context;
    }
    if (context instanceof rootContainer.get(IPlatform).Node) {
      trace(logger, 3154, context.nodeName);
      try {
        const controller = CustomElement.for(context, { searchParents: true });
        return controller.container.get(IRouteContext);
      } catch (err) {
        error(logger, 3155, context.nodeName, err);
        throw err;
      }
    }
    if (isCustomElementViewModel(context)) {
      const controller = context.$controller;
      trace(logger, 3156, controller.definition.name);
      return controller.container.get(IRouteContext);
    }
    if (isCustomElementController(context)) {
      const controller = context;
      trace(logger, 3157, controller.definition.name);
      return controller.container.get(IRouteContext);
    }
    logAndThrow(new Error(getMessage(3170, Object.prototype.toString.call(context))), logger);
  }
  dispose() {
    this.container.dispose();
  }
  /** @internal */
  _resolveViewportAgent(req) {
    trace(this._logger, 3158, req);
    const agent = this._childViewportAgents.find((x2) => {
      return x2._handles(req);
    });
    if (agent === void 0)
      throw new Error(getMessage(3174, req, this._printTree()));
    return agent;
  }
  getAvailableViewportAgents() {
    return this._childViewportAgents.filter((x2) => x2._isAvailable());
  }
  getFallbackViewportAgent(name2) {
    return this._childViewportAgents.find((x2) => x2._isAvailable() && x2.viewport.name === name2 && x2.viewport.fallback !== "") ?? null;
  }
  /**
   * Create a component based on the provided viewportInstruction.
   *
   * @param hostController - The `ICustomElementController` whose component (typically `au-viewport`) will host this component.
   * @param routeNode - The routeNode that describes the component + state.
   *
   * @internal
   */
  _createComponentAgent(hostController, routeNode) {
    trace(this._logger, 3159, routeNode);
    this._hostControllerProvider.prepare(hostController);
    const container = this.container.createChild({ inheritParentResources: true });
    const platform = this._platform;
    const elDefn = routeNode.component;
    const host = platform.document.createElement(elDefn.name);
    registerHostNode(container, host, platform);
    const componentInstance = container.invoke(elDefn.Type);
    const task2 = this._childRoutesConfigured ? void 0 : onResolve(resolveRouteConfiguration(componentInstance, false, this.config, routeNode, null), (config) => this._processConfig(config));
    return onResolve(task2, () => {
      const controller = Controller.$el(container, componentInstance, host, { hostController, projections: null }, elDefn);
      const componentAgent = new ComponentAgent(componentInstance, controller, routeNode, this, this._router.options);
      this._hostControllerProvider.dispose();
      return componentAgent;
    });
  }
  /** @internal */
  _registerViewport(viewport2) {
    const agent = ViewportAgent.for(viewport2, this);
    if (this._childViewportAgents.includes(agent)) {
      trace(this._logger, 3161, agent);
      return agent;
    }
    trace(this._logger, 3160, agent);
    this._childViewportAgents.push(agent);
    return agent;
  }
  /** @internal */
  _unregisterViewport(viewport2) {
    const agent = ViewportAgent.for(viewport2, this);
    if (!this._childViewportAgents.includes(agent)) {
      trace(this._logger, 3163, agent);
      return;
    }
    trace(this._logger, 3162, agent);
    this._childViewportAgents.splice(this._childViewportAgents.indexOf(agent), 1);
  }
  recognize(path, searchAncestor = false) {
    trace(this._logger, 3164, path);
    let _current = this;
    let _continue = true;
    let result = null;
    while (_continue) {
      result = _current._recognizer.recognize(path);
      if (result === null) {
        if (!searchAncestor || _current.isRoot)
          return null;
        _current = _current.parent;
      } else {
        _continue = false;
      }
    }
    return new $RecognizedRoute(result, Reflect.has(result.params, RESIDUE) ? result.params[RESIDUE] ?? null : null);
  }
  _addRoute(routeable) {
    trace(this._logger, 3165, routeable);
    return onResolve(resolveRouteConfiguration(routeable, true, this.config, null, this), (rdConfig) => {
      for (const path of rdConfig.path ?? emptyArray) {
        this._$addRoute(path, rdConfig.caseSensitive, rdConfig);
      }
      this._navigationModel?._addRoute(rdConfig);
      this.childRoutes.push(rdConfig);
    });
  }
  /** @internal */
  _$addRoute(path, caseSensitive, handler) {
    this._recognizer.add({
      path,
      caseSensitive,
      handler
    }, true);
  }
  /** @internal */
  _resolveLazy(promise) {
    return this._moduleLoader.load(promise, (m2) => {
      const raw = m2.raw;
      if (typeof raw === "function") {
        const def2 = CustomElement.isType(raw) ? CustomElement.getDefinition(raw) : null;
        if (def2 != null)
          return def2;
      }
      let defaultExport = void 0;
      let firstNonDefaultExport = void 0;
      for (const item of m2.items) {
        const def2 = CustomElement.isType(item.value) ? item.definition : null;
        if (def2 != null) {
          if (item.key === "default") {
            defaultExport = def2;
          } else if (firstNonDefaultExport === void 0) {
            firstNonDefaultExport = def2;
          }
        }
      }
      if (defaultExport === void 0 && firstNonDefaultExport === void 0)
        throw new Error(getMessage(3175, promise));
      return firstNonDefaultExport ?? defaultExport;
    });
  }
  _generateViewportInstruction(instruction) {
    if (!isEagerInstruction(instruction))
      return null;
    const component = instruction.component;
    let paths;
    let throwError = false;
    if (component instanceof RouteConfig) {
      paths = component.path;
      throwError = true;
    } else if (typeof component === "string") {
      const $rdConfig = this.childRoutes.find((x2) => x2.id === component);
      if ($rdConfig === void 0)
        return null;
      paths = $rdConfig.path;
    } else if (component.type === 0) {
      const $rdConfig = this.childRoutes.find((x2) => x2.id === component.value);
      if ($rdConfig === void 0)
        return null;
      paths = $rdConfig.path;
    } else {
      const ced = resolveCustomElementDefinition(component, this)[1];
      paths = this.childRoutes.reduce((acc, x2) => {
        if (x2.component === ced.Type) {
          acc.push(...x2.path);
        }
        return acc;
      }, []);
      throwError = true;
    }
    if (paths === void 0)
      return null;
    const params = instruction.params;
    const recognizer = this._recognizer;
    const numPaths = paths.length;
    const errors = [];
    let result = null;
    if (numPaths === 1) {
      const result2 = core(paths[0]);
      if (result2 === null) {
        if (throwError)
          throw new Error(getMessage(3166, instruction, errors));
        debug(this._logger, 3166, instruction, errors);
        return null;
      }
      return {
        vi: ViewportInstruction.create({
          recognizedRoute: new $RecognizedRoute(new RecognizedRoute(result2.endpoint, result2.consumed), null),
          component: result2.path,
          children: instruction.children,
          viewport: instruction.viewport,
          open: instruction.open,
          close: instruction.close
        }),
        query: result2.query
      };
    }
    let maxScore = 0;
    for (let i3 = 0; i3 < numPaths; i3++) {
      const res = core(paths[i3]);
      if (res === null)
        continue;
      if (result === null) {
        result = res;
        maxScore = Object.keys(res.consumed).length;
      } else if (Object.keys(res.consumed).length > maxScore) {
        result = res;
      }
    }
    if (result === null) {
      if (throwError)
        throw new Error(getMessage(3166, instruction, errors));
      debug(this._logger, 3166, instruction, errors);
      return null;
    }
    return {
      vi: ViewportInstruction.create({
        recognizedRoute: new $RecognizedRoute(new RecognizedRoute(result.endpoint, result.consumed), null),
        component: result.path,
        children: instruction.children,
        viewport: instruction.viewport,
        open: instruction.open,
        close: instruction.close
      }),
      query: result.query
    };
    function core(path) {
      const endpoint = recognizer.getEndpoint(path);
      if (endpoint === null) {
        errors.push(`No endpoint found for the path: '${path}'.`);
        return null;
      }
      const consumed = /* @__PURE__ */ Object.create(null);
      for (const param of endpoint.params) {
        const key = param.name;
        let value = params[key];
        if (value == null || String(value).length === 0) {
          if (!param.isOptional) {
            errors.push(`No value for the required parameter '${key}' is provided for the path: '${path}'.`);
            return null;
          }
          value = "";
        } else {
          if (!param.satisfiesPattern(value)) {
            errors.push(`The value '${value}' for the parameter '${key}' does not satisfy the pattern '${param.pattern}'.`);
            return null;
          }
          consumed[key] = value;
        }
        const pattern = param.isStar ? `*${key}` : param.isOptional ? `:${key}?` : `:${key}`;
        path = path.replace(pattern, encodeURIComponent(value));
      }
      const consumedKeys = Object.keys(consumed);
      const query = Object.fromEntries(Object.entries(params).filter(([key]) => !consumedKeys.includes(key)));
      return { path: path.replace(/\/\//g, "/"), endpoint, consumed, query };
    }
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const vpAgents = this._childViewportAgents;
    const viewports = vpAgents.map(String).join(",");
    return `RC(path:'${this._friendlyPath}',viewports:[${viewports}])`;
  }
  /** @internal */
  _printTree() {
    const tree = [];
    for (let i3 = 0; i3 < this.path.length; ++i3) {
      tree.push(`${" ".repeat(i3)}${this.path[i3]}`);
    }
    return tree.join("\n");
  }
}
class $RecognizedRoute {
  constructor(route2, residue) {
    this.route = route2;
    this.residue = residue;
  }
  toString() {
    const route2 = this.route;
    const cr = route2.endpoint.route;
    return `RR(route:(endpoint:(route:(path:${cr.path},handler:${cr.handler})),params:${JSON.stringify(route2.params)}),residue:${this.residue})`;
  }
}
class NavigationModel {
  constructor(routes) {
    this.routes = routes;
    this._promise = void 0;
  }
  resolve() {
    return onResolve(this._promise, noop$1);
  }
  /** @internal */
  _setIsActive(router, context) {
    void onResolve(this._promise, () => {
      for (const route2 of this.routes) {
        route2._setIsActive(router, context);
      }
    });
  }
  /** @internal */
  _addRoute(route2) {
    const routes = this.routes;
    if (!(route2 instanceof Promise)) {
      if ((route2.nav ?? false) && route2.redirectTo === null) {
        routes.push(NavigationRoute._create(route2));
      }
      return;
    }
    const index = routes.length;
    routes.push(void 0);
    let promise = void 0;
    promise = this._promise = onResolve(this._promise, () => onResolve(route2, (rdConfig) => {
      if (rdConfig.nav && rdConfig.redirectTo === null) {
        routes[index] = NavigationRoute._create(rdConfig);
      } else {
        routes.splice(index, 1);
      }
      if (this._promise === promise) {
        this._promise = void 0;
      }
    }));
  }
}
class NavigationRoute {
  constructor(id2, path, title, data) {
    this.id = id2;
    this.path = path;
    this.title = title;
    this.data = data;
    this._trees = null;
  }
  /** @internal */
  static _create(rdConfig) {
    return new NavigationRoute(rdConfig.id, ensureArrayOfStrings(rdConfig.path ?? emptyArray), rdConfig.title, rdConfig.data);
  }
  get isActive() {
    return this._isActive;
  }
  /** @internal */
  _setIsActive(router, context) {
    let trees = this._trees;
    if (trees === null) {
      const routerOptions = router.options;
      trees = this._trees = this.path.map((p2) => {
        const ep = context._recognizer.getEndpoint(p2);
        if (ep === null)
          throw new Error(getMessage(3450, p2));
        return new ViewportInstructionTree(NavigationOptions.create(routerOptions, { context }), false, [
          ViewportInstruction.create({
            recognizedRoute: new $RecognizedRoute(new RecognizedRoute(ep, emptyObject), null),
            component: p2
          })
        ], emptyQuery, null);
      });
    }
    this._isActive = trees.some((vit) => router.routeTree.contains(vit, true));
  }
}
class ViewportCustomElement {
  constructor() {
    this.name = defaultViewportName;
    this.usedBy = "";
    this.default = "";
    this.fallback = "";
    this._agent = void 0;
    this._controller = void 0;
    this._ctx = resolve(IRouteContext);
    this._logger = resolve(ILogger).scopeTo(`au-viewport<${this._ctx._friendlyPath}>`);
  }
  /** @internal */
  _getFallback(viewportInstruction, routeNode, context) {
    const fallback = this.fallback;
    return typeof fallback === "function" && !CustomElement.isType(fallback) ? fallback(viewportInstruction, routeNode, context) : fallback;
  }
  hydrated(controller) {
    trace(
      this._logger,
      3e3
      /* Events.vpHydrated */
    );
    this._controller = controller;
    this._agent = this._ctx._registerViewport(this);
  }
  attaching(initiator, _parent) {
    trace(
      this._logger,
      3001
      /* Events.vpAttaching */
    );
    return this._agent._activateFromViewport(initiator, this._controller);
  }
  detaching(initiator, _parent) {
    trace(
      this._logger,
      3002
      /* Events.vpDetaching */
    );
    return this._agent._deactivateFromViewport(initiator, this._controller);
  }
  dispose() {
    trace(
      this._logger,
      3003
      /* Events.vpDispose */
    );
    this._ctx._unregisterViewport(this);
    this._agent._dispose();
    this._agent = void 0;
  }
  // Should not be adjust for DEV as it is also used of logging in production build.
  toString() {
    const propStrings = [];
    for (const prop of props) {
      const value = this[prop];
      switch (typeof value) {
        case "string":
          if (value !== "") {
            propStrings.push(`${prop}:'${value}'`);
          }
          break;
        default: {
          propStrings.push(`${prop}:${String(value)}`);
        }
      }
    }
    return `VP(ctx:'${this._ctx._friendlyPath}',${propStrings.join(",")})`;
  }
}
CustomElement.define({
  name: "au-viewport",
  bindables: ["name", "usedBy", "default", "fallback"]
}, ViewportCustomElement);
const props = [
  "name",
  "usedBy",
  "default",
  "fallback"
];
class LoadCustomAttribute {
  constructor() {
    this._el = resolve(INode);
    this._router = resolve(IRouter);
    this._ctx = resolve(IRouteContext);
    this._events = resolve(IRouterEvents);
    this._locationMgr = resolve(ILocationManager);
    this.attribute = "href";
    this.active = false;
    this._href = null;
    this._instructions = null;
    this._navigationEndListener = null;
    this.onClick = (e2) => {
      if (this._instructions === null) {
        return;
      }
      if (e2.altKey || e2.ctrlKey || e2.shiftKey || e2.metaKey || e2.button !== 0) {
        return;
      }
      e2.preventDefault();
      void this._router.load(this._instructions, { context: this.context });
    };
    const el = this._el;
    this._isEnabled = !el.hasAttribute("external") && !el.hasAttribute("data-external");
    this._activeClass = this._router.options.activeClass;
  }
  binding() {
    if (this._isEnabled) {
      this._el.addEventListener("click", this.onClick);
    }
    this.valueChanged();
    this._navigationEndListener = this._events.subscribe("au:router:navigation-end", (_e2) => {
      const active = this.active = this._instructions !== null && this._router.isActive(this._instructions, this.context);
      const activeClass = this._activeClass;
      if (activeClass === null)
        return;
      this._el.classList.toggle(activeClass, active);
    });
  }
  attaching() {
    const ctx = this.context;
    const promise = ctx.allResolved;
    if (promise !== null) {
      return promise.then(() => {
        this.valueChanged();
      });
    }
  }
  unbinding() {
    if (this._isEnabled) {
      this._el.removeEventListener("click", this.onClick);
    }
    this._navigationEndListener.dispose();
  }
  valueChanged() {
    const router = this._router;
    const options = router.options;
    const component = this.route;
    let ctx = this.context;
    if (ctx === void 0) {
      ctx = this.context = this._ctx;
    } else if (ctx === null) {
      ctx = this.context = this._ctx.root;
    }
    if (component != null && ctx.allResolved === null) {
      const params = this.params;
      const instructions = this._instructions = router.createViewportInstructions(typeof params === "object" && params !== null ? { component, params } : component, { context: ctx });
      this._href = instructions.toUrl(false, options._urlParser);
    } else {
      this._instructions = null;
      this._href = null;
    }
    const controller = CustomElement.for(this._el, { optional: true });
    if (controller !== null) {
      controller.viewModel[this.attribute] = this._instructions;
    } else {
      if (this._href === null) {
        this._el.removeAttribute(this.attribute);
      } else {
        const value = options.useUrlFragmentHash ? this._href : this._locationMgr.addBaseHref(this._href);
        this._el.setAttribute(this.attribute, value);
      }
    }
  }
}
CustomAttribute.define({
  name: "load",
  bindables: {
    route: { mode: bmToView, primary: true, callback: "valueChanged" },
    params: { mode: bmToView, callback: "valueChanged" },
    attribute: { mode: bmToView },
    active: { mode: bmFromView },
    context: { mode: bmToView, callback: "valueChanged" }
  }
}, LoadCustomAttribute);
class HrefCustomAttribute {
  /** @internal */
  get _isExternal() {
    return this._el.hasAttribute("external") || this._el.hasAttribute("data-external");
  }
  constructor() {
    this._el = resolve(INode);
    this._router = resolve(IRouter);
    this._ctx = resolve(IRouteContext);
    this._isInitialized = false;
    if (this._router.options.useHref && // Ensure the element is an anchor
    this._el.nodeName === "A") {
      const windowName = resolve(IWindow).name;
      switch (this._el.getAttribute("target")) {
        case null:
        case windowName:
        case "_self":
          this._isEnabled = true;
          break;
        default:
          this._isEnabled = false;
          break;
      }
    } else {
      this._isEnabled = false;
    }
  }
  binding() {
    if (!this._isInitialized) {
      this._isInitialized = true;
      this._isEnabled = this._isEnabled && getRef(this._el, CustomAttribute.getDefinition(LoadCustomAttribute).key) === null;
    }
    this.valueChanged(this.value);
    this._el.addEventListener("click", this);
  }
  unbinding() {
    this._el.removeEventListener("click", this);
  }
  valueChanged(newValue) {
    if (newValue == null) {
      this._el.removeAttribute("href");
    } else {
      if (this._router.options.useUrlFragmentHash && this._ctx.isRoot && !/^[.#]/.test(newValue) && !this._isExternal) {
        newValue = `#${newValue}`;
      }
      this._el.setAttribute("href", newValue);
    }
  }
  handleEvent(e2) {
    this._onClick(e2);
  }
  /** @internal */
  _onClick(e2) {
    if (e2.altKey || e2.ctrlKey || e2.shiftKey || e2.metaKey || e2.button !== 0 || this._isExternal || !this._isEnabled) {
      return;
    }
    const href = this._el.getAttribute("href");
    if (href !== null) {
      e2.preventDefault();
      void this._router.load(href, { context: this._ctx });
    }
  }
}
HrefCustomAttribute.$au = {
  type: "custom-attribute",
  name: "href",
  noMultiBindings: true,
  bindables: {
    value: { mode: bmToView }
  }
};
const RouterRegistration = IRouter;
const DefaultComponents = [
  RouterRegistration
];
const DefaultResources = [
  ViewportCustomElement,
  LoadCustomAttribute,
  HrefCustomAttribute
];
function configure(container, options) {
  let basePath = null;
  if (isObjectOrFunction(options)) {
    basePath = options.basePath ?? null;
  } else {
    options = {};
  }
  const routerOptions = RouterOptions.create(options);
  return container.register(Registration.cachedCallback(IBaseHref, (handler, _2, __) => {
    const window2 = handler.get(IWindow);
    const url = new URL(window2.document.baseURI);
    url.pathname = normalizePath(basePath ?? url.pathname);
    return url;
  }), Registration.instance(IRouterOptions, routerOptions), Registration.instance(RouterOptions, routerOptions), AppTask.creating(IRouter, (_2) => {
  }), AppTask.hydrated(IContainer, RouteContext.setRoot), AppTask.activated(IRouter, (router) => router.start(true)), AppTask.deactivated(IRouter, (router) => router.stop()), ...DefaultComponents, ...DefaultResources);
}
const RouterConfiguration = {
  register(container) {
    return configure(container);
  },
  /**
   * Make it possible to specify options to Router activation.
   * Parameter is either a config object that's passed to Router's activate
   * or a config function that's called instead of Router's activate.
   */
  customize(options) {
    return {
      register(container) {
        return configure(container, options);
      }
    };
  }
};
var extendStatics = function(d2, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
    d3.__proto__ = b4;
  } || function(d3, b4) {
    for (var p2 in b4) if (Object.prototype.hasOwnProperty.call(b4, p2)) d3[p2] = b4[p2];
  };
  return extendStatics(d2, b3);
};
function __extends(d2, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics(d2, b3);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s3 = arguments[i3];
      for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2)) t2[p2] = s3[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i3 = decorators.length - 1; i3 >= 0; i3--) if (d2 = decorators[i3]) r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __values(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m2 = s3 && o2[s3], i3 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i3 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i3++], done: !o2 };
    }
  };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n3) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i3 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n3 === void 0 || n3-- > 0) && !(r2 = i3.next()).done) ar.push(r2.value);
  } catch (error2) {
    e2 = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i3["return"])) m2.call(i3);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l2 = from.length, ar; i3 < l2; i3++) {
    if (ar || !(i3 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
      ar[i3] = from[i3];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$3 = (t2) => (e2, o2) => {
  void 0 !== o2 ? o2.addInitializer(() => {
    customElements.define(t2, e2);
  }) : customElements.define(t2, e2);
};
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$2 = globalThis, e$8 = t$2.ShadowRoot && (void 0 === t$2.ShadyCSS || t$2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype, s$3 = Symbol(), o$7 = /* @__PURE__ */ new WeakMap();
let n$7 = class n {
  constructor(t2, e2, o2) {
    if (this._$cssResult$ = true, o2 !== s$3) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t2, this.t = e2;
  }
  get styleSheet() {
    let t2 = this.o;
    const s3 = this.t;
    if (e$8 && void 0 === t2) {
      const e2 = void 0 !== s3 && 1 === s3.length;
      e2 && (t2 = o$7.get(s3)), void 0 === t2 && ((this.o = t2 = new CSSStyleSheet()).replaceSync(this.cssText), e2 && o$7.set(s3, t2));
    }
    return t2;
  }
  toString() {
    return this.cssText;
  }
};
const r$7 = (t2) => new n$7("string" == typeof t2 ? t2 : t2 + "", void 0, s$3), i$4 = (t2, ...e2) => {
  const o2 = 1 === t2.length ? t2[0] : e2.reduce((e3, s3, o3) => e3 + ((t3) => {
    if (true === t3._$cssResult$) return t3.cssText;
    if ("number" == typeof t3) return t3;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + t3 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(s3) + t2[o3 + 1], t2[0]);
  return new n$7(o2, t2, s$3);
}, S$2 = (s3, o2) => {
  if (e$8) s3.adoptedStyleSheets = o2.map((t2) => t2 instanceof CSSStyleSheet ? t2 : t2.styleSheet);
  else for (const e2 of o2) {
    const o3 = document.createElement("style"), n3 = t$2.litNonce;
    void 0 !== n3 && o3.setAttribute("nonce", n3), o3.textContent = e2.cssText, s3.appendChild(o3);
  }
}, c$2 = e$8 ? (t2) => t2 : (t2) => t2 instanceof CSSStyleSheet ? ((t3) => {
  let e2 = "";
  for (const s3 of t3.cssRules) e2 += s3.cssText;
  return r$7(e2);
})(t2) : t2;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const { is: i$3, defineProperty: e$7, getOwnPropertyDescriptor: r$6, getOwnPropertyNames: h$1, getOwnPropertySymbols: o$6, getPrototypeOf: n$6 } = Object, a$2 = globalThis, c$1 = a$2.trustedTypes, l$3 = c$1 ? c$1.emptyScript : "", p$2 = a$2.reactiveElementPolyfillSupport, d$1 = (t2, s3) => t2, u$2 = { toAttribute(t2, s3) {
  switch (s3) {
    case Boolean:
      t2 = t2 ? l$3 : null;
      break;
    case Object:
    case Array:
      t2 = null == t2 ? t2 : JSON.stringify(t2);
  }
  return t2;
}, fromAttribute(t2, s3) {
  let i3 = t2;
  switch (s3) {
    case Boolean:
      i3 = null !== t2;
      break;
    case Number:
      i3 = null === t2 ? null : Number(t2);
      break;
    case Object:
    case Array:
      try {
        i3 = JSON.parse(t2);
      } catch (t3) {
        i3 = null;
      }
  }
  return i3;
} }, f$2 = (t2, s3) => !i$3(t2, s3), y$2 = { attribute: true, type: String, converter: u$2, reflect: false, hasChanged: f$2 };
Symbol.metadata ??= Symbol("metadata"), a$2.litPropertyMetadata ??= /* @__PURE__ */ new WeakMap();
let b$1 = class b extends HTMLElement {
  static addInitializer(t2) {
    this._$Ei(), (this.l ??= []).push(t2);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t2, s3 = y$2) {
    if (s3.state && (s3.attribute = false), this._$Ei(), this.elementProperties.set(t2, s3), !s3.noAccessor) {
      const i3 = Symbol(), r2 = this.getPropertyDescriptor(t2, i3, s3);
      void 0 !== r2 && e$7(this.prototype, t2, r2);
    }
  }
  static getPropertyDescriptor(t2, s3, i3) {
    const { get: e2, set: h2 } = r$6(this.prototype, t2) ?? { get() {
      return this[s3];
    }, set(t3) {
      this[s3] = t3;
    } };
    return { get() {
      return e2?.call(this);
    }, set(s4) {
      const r2 = e2?.call(this);
      h2.call(this, s4), this.requestUpdate(t2, r2, i3);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t2) {
    return this.elementProperties.get(t2) ?? y$2;
  }
  static _$Ei() {
    if (this.hasOwnProperty(d$1("elementProperties"))) return;
    const t2 = n$6(this);
    t2.finalize(), void 0 !== t2.l && (this.l = [...t2.l]), this.elementProperties = new Map(t2.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(d$1("finalized"))) return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(d$1("properties"))) {
      const t3 = this.properties, s3 = [...h$1(t3), ...o$6(t3)];
      for (const i3 of s3) this.createProperty(i3, t3[i3]);
    }
    const t2 = this[Symbol.metadata];
    if (null !== t2) {
      const s3 = litPropertyMetadata.get(t2);
      if (void 0 !== s3) for (const [t3, i3] of s3) this.elementProperties.set(t3, i3);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [t3, s3] of this.elementProperties) {
      const i3 = this._$Eu(t3, s3);
      void 0 !== i3 && this._$Eh.set(i3, t3);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(s3) {
    const i3 = [];
    if (Array.isArray(s3)) {
      const e2 = new Set(s3.flat(1 / 0).reverse());
      for (const s4 of e2) i3.unshift(c$2(s4));
    } else void 0 !== s3 && i3.push(c$2(s3));
    return i3;
  }
  static _$Eu(t2, s3) {
    const i3 = s3.attribute;
    return false === i3 ? void 0 : "string" == typeof i3 ? i3 : "string" == typeof t2 ? t2.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    this._$ES = new Promise((t2) => this.enableUpdating = t2), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), this.constructor.l?.forEach((t2) => t2(this));
  }
  addController(t2) {
    (this._$EO ??= /* @__PURE__ */ new Set()).add(t2), void 0 !== this.renderRoot && this.isConnected && t2.hostConnected?.();
  }
  removeController(t2) {
    this._$EO?.delete(t2);
  }
  _$E_() {
    const t2 = /* @__PURE__ */ new Map(), s3 = this.constructor.elementProperties;
    for (const i3 of s3.keys()) this.hasOwnProperty(i3) && (t2.set(i3, this[i3]), delete this[i3]);
    t2.size > 0 && (this._$Ep = t2);
  }
  createRenderRoot() {
    const t2 = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return S$2(t2, this.constructor.elementStyles), t2;
  }
  connectedCallback() {
    this.renderRoot ??= this.createRenderRoot(), this.enableUpdating(true), this._$EO?.forEach((t2) => t2.hostConnected?.());
  }
  enableUpdating(t2) {
  }
  disconnectedCallback() {
    this._$EO?.forEach((t2) => t2.hostDisconnected?.());
  }
  attributeChangedCallback(t2, s3, i3) {
    this._$AK(t2, i3);
  }
  _$EC(t2, s3) {
    const i3 = this.constructor.elementProperties.get(t2), e2 = this.constructor._$Eu(t2, i3);
    if (void 0 !== e2 && true === i3.reflect) {
      const r2 = (void 0 !== i3.converter?.toAttribute ? i3.converter : u$2).toAttribute(s3, i3.type);
      this._$Em = t2, null == r2 ? this.removeAttribute(e2) : this.setAttribute(e2, r2), this._$Em = null;
    }
  }
  _$AK(t2, s3) {
    const i3 = this.constructor, e2 = i3._$Eh.get(t2);
    if (void 0 !== e2 && this._$Em !== e2) {
      const t3 = i3.getPropertyOptions(e2), r2 = "function" == typeof t3.converter ? { fromAttribute: t3.converter } : void 0 !== t3.converter?.fromAttribute ? t3.converter : u$2;
      this._$Em = e2, this[e2] = r2.fromAttribute(s3, t3.type), this._$Em = null;
    }
  }
  requestUpdate(t2, s3, i3) {
    if (void 0 !== t2) {
      if (i3 ??= this.constructor.getPropertyOptions(t2), !(i3.hasChanged ?? f$2)(this[t2], s3)) return;
      this.P(t2, s3, i3);
    }
    false === this.isUpdatePending && (this._$ES = this._$ET());
  }
  P(t2, s3, i3) {
    this._$AL.has(t2) || this._$AL.set(t2, s3), true === i3.reflect && this._$Em !== t2 && (this._$Ej ??= /* @__PURE__ */ new Set()).add(t2);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (t3) {
      Promise.reject(t3);
    }
    const t2 = this.scheduleUpdate();
    return null != t2 && await t2, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    if (!this.isUpdatePending) return;
    if (!this.hasUpdated) {
      if (this.renderRoot ??= this.createRenderRoot(), this._$Ep) {
        for (const [t4, s4] of this._$Ep) this[t4] = s4;
        this._$Ep = void 0;
      }
      const t3 = this.constructor.elementProperties;
      if (t3.size > 0) for (const [s4, i3] of t3) true !== i3.wrapped || this._$AL.has(s4) || void 0 === this[s4] || this.P(s4, this[s4], i3);
    }
    let t2 = false;
    const s3 = this._$AL;
    try {
      t2 = this.shouldUpdate(s3), t2 ? (this.willUpdate(s3), this._$EO?.forEach((t3) => t3.hostUpdate?.()), this.update(s3)) : this._$EU();
    } catch (s4) {
      throw t2 = false, this._$EU(), s4;
    }
    t2 && this._$AE(s3);
  }
  willUpdate(t2) {
  }
  _$AE(t2) {
    this._$EO?.forEach((t3) => t3.hostUpdated?.()), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t2)), this.updated(t2);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t2) {
    return true;
  }
  update(t2) {
    this._$Ej &&= this._$Ej.forEach((t3) => this._$EC(t3, this[t3])), this._$EU();
  }
  updated(t2) {
  }
  firstUpdated(t2) {
  }
};
b$1.elementStyles = [], b$1.shadowRootOptions = { mode: "open" }, b$1[d$1("elementProperties")] = /* @__PURE__ */ new Map(), b$1[d$1("finalized")] = /* @__PURE__ */ new Map(), p$2?.({ ReactiveElement: b$1 }), (a$2.reactiveElementVersions ??= []).push("2.0.4");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$5 = { attribute: true, type: String, converter: u$2, reflect: false, hasChanged: f$2 }, r$5 = (t2 = o$5, e2, r2) => {
  const { kind: n3, metadata: i3 } = r2;
  let s3 = globalThis.litPropertyMetadata.get(i3);
  if (void 0 === s3 && globalThis.litPropertyMetadata.set(i3, s3 = /* @__PURE__ */ new Map()), s3.set(r2.name, t2), "accessor" === n3) {
    const { name: o2 } = r2;
    return { set(r3) {
      const n4 = e2.get.call(this);
      e2.set.call(this, r3), this.requestUpdate(o2, n4, t2);
    }, init(e3) {
      return void 0 !== e3 && this.P(o2, void 0, t2), e3;
    } };
  }
  if ("setter" === n3) {
    const { name: o2 } = r2;
    return function(r3) {
      const n4 = this[o2];
      e2.call(this, r3), this.requestUpdate(o2, n4, t2);
    };
  }
  throw Error("Unsupported decorator location: " + n3);
};
function n$5(t2) {
  return (e2, o2) => "object" == typeof o2 ? r$5(t2, e2, o2) : ((t3, e3, o3) => {
    const r2 = e3.hasOwnProperty(o3);
    return e3.constructor.createProperty(o3, r2 ? { ...t3, wrapped: true } : t3), r2 ? Object.getOwnPropertyDescriptor(e3, o3) : void 0;
  })(t2, e2, o2);
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$4(r2) {
  return n$5({ ...r2, state: true, attribute: false });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$6 = (e2, t2, c2) => (c2.configurable = true, c2.enumerable = true, Reflect.decorate && "object" != typeof t2 && Object.defineProperty(e2, t2, c2), c2);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function e$5(e2, r2) {
  return (n3, s3, i3) => {
    const o2 = (t2) => t2.renderRoot?.querySelector(e2) ?? null;
    return e$6(n3, s3, { get() {
      return o2(this);
    } });
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let e$4;
function r$3(r2) {
  return (n3, o2) => e$6(n3, o2, { get() {
    return (this.renderRoot ?? (e$4 ??= document.createDocumentFragment())).querySelectorAll(r2);
  } });
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function r$2(r2) {
  return (n3, e2) => e$6(n3, e2, { async get() {
    return await this.updateComplete, this.renderRoot?.querySelector(r2) ?? null;
  } });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function o$4(o2) {
  return (e2, n3) => {
    const { slot: r2, selector: s3 } = o2 ?? {}, c2 = "slot" + (r2 ? `[name=${r2}]` : ":not([name])");
    return e$6(e2, n3, { get() {
      const t2 = this.renderRoot?.querySelector(c2), e3 = t2?.assignedElements(o2) ?? [];
      return void 0 === s3 ? e3 : e3.filter((t3) => t3.matches(s3));
    } });
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function n$4(n3) {
  return (o2, r2) => {
    const { slot: e2 } = n3 ?? {}, s3 = "slot" + (e2 ? `[name=${e2}]` : ":not([name])");
    return e$6(o2, r2, { get() {
      const t2 = this.renderRoot?.querySelector(s3);
      return t2?.assignedNodes(n3) ?? [];
    } });
  };
}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t$1 = globalThis, i$2 = t$1.trustedTypes, s$2 = i$2 ? i$2.createPolicy("lit-html", { createHTML: (t2) => t2 }) : void 0, e$3 = "$lit$", h = `lit$${Math.random().toFixed(9).slice(2)}$`, o$3 = "?" + h, n$3 = `<${o$3}>`, r$1 = document, l$2 = () => r$1.createComment(""), c = (t2) => null === t2 || "object" != typeof t2 && "function" != typeof t2, a$1 = Array.isArray, u$1 = (t2) => a$1(t2) || "function" == typeof t2?.[Symbol.iterator], d = "[ 	\n\f\r]", f$1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g, v$1 = /-->/g, _ = />/g, m$1 = RegExp(`>|${d}(?:([^\\s"'>=/]+)(${d}*=${d}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g"), p$1 = /'/g, g$1 = /"/g, $$1 = /^(?:script|style|textarea|title)$/i, y$1 = (t2) => (i3, ...s3) => ({ _$litType$: t2, strings: i3, values: s3 }), x$1 = y$1(1), w$1 = Symbol.for("lit-noChange"), T$1 = Symbol.for("lit-nothing"), A$2 = /* @__PURE__ */ new WeakMap(), E$1 = r$1.createTreeWalker(r$1, 129);
function C(t2, i3) {
  if (!Array.isArray(t2) || !t2.hasOwnProperty("raw")) throw Error("invalid template strings array");
  return void 0 !== s$2 ? s$2.createHTML(i3) : i3;
}
const P$2 = (t2, i3) => {
  const s3 = t2.length - 1, o2 = [];
  let r2, l2 = 2 === i3 ? "<svg>" : "", c2 = f$1;
  for (let i4 = 0; i4 < s3; i4++) {
    const s4 = t2[i4];
    let a2, u2, d2 = -1, y2 = 0;
    for (; y2 < s4.length && (c2.lastIndex = y2, u2 = c2.exec(s4), null !== u2); ) y2 = c2.lastIndex, c2 === f$1 ? "!--" === u2[1] ? c2 = v$1 : void 0 !== u2[1] ? c2 = _ : void 0 !== u2[2] ? ($$1.test(u2[2]) && (r2 = RegExp("</" + u2[2], "g")), c2 = m$1) : void 0 !== u2[3] && (c2 = m$1) : c2 === m$1 ? ">" === u2[0] ? (c2 = r2 ?? f$1, d2 = -1) : void 0 === u2[1] ? d2 = -2 : (d2 = c2.lastIndex - u2[2].length, a2 = u2[1], c2 = void 0 === u2[3] ? m$1 : '"' === u2[3] ? g$1 : p$1) : c2 === g$1 || c2 === p$1 ? c2 = m$1 : c2 === v$1 || c2 === _ ? c2 = f$1 : (c2 = m$1, r2 = void 0);
    const x2 = c2 === m$1 && t2[i4 + 1].startsWith("/>") ? " " : "";
    l2 += c2 === f$1 ? s4 + n$3 : d2 >= 0 ? (o2.push(a2), s4.slice(0, d2) + e$3 + s4.slice(d2) + h + x2) : s4 + h + (-2 === d2 ? i4 : x2);
  }
  return [C(t2, l2 + (t2[s3] || "<?>") + (2 === i3 ? "</svg>" : "")), o2];
};
let V$1 = class V {
  constructor({ strings: t2, _$litType$: s3 }, n3) {
    let r2;
    this.parts = [];
    let c2 = 0, a2 = 0;
    const u2 = t2.length - 1, d2 = this.parts, [f2, v2] = P$2(t2, s3);
    if (this.el = V.createElement(f2, n3), E$1.currentNode = this.el.content, 2 === s3) {
      const t3 = this.el.content.firstChild;
      t3.replaceWith(...t3.childNodes);
    }
    for (; null !== (r2 = E$1.nextNode()) && d2.length < u2; ) {
      if (1 === r2.nodeType) {
        if (r2.hasAttributes()) for (const t3 of r2.getAttributeNames()) if (t3.endsWith(e$3)) {
          const i3 = v2[a2++], s4 = r2.getAttribute(t3).split(h), e2 = /([.?@])?(.*)/.exec(i3);
          d2.push({ type: 1, index: c2, name: e2[2], strings: s4, ctor: "." === e2[1] ? k$1 : "?" === e2[1] ? H : "@" === e2[1] ? I$1 : R }), r2.removeAttribute(t3);
        } else t3.startsWith(h) && (d2.push({ type: 6, index: c2 }), r2.removeAttribute(t3));
        if ($$1.test(r2.tagName)) {
          const t3 = r2.textContent.split(h), s4 = t3.length - 1;
          if (s4 > 0) {
            r2.textContent = i$2 ? i$2.emptyScript : "";
            for (let i3 = 0; i3 < s4; i3++) r2.append(t3[i3], l$2()), E$1.nextNode(), d2.push({ type: 2, index: ++c2 });
            r2.append(t3[s4], l$2());
          }
        }
      } else if (8 === r2.nodeType) if (r2.data === o$3) d2.push({ type: 2, index: c2 });
      else {
        let t3 = -1;
        for (; -1 !== (t3 = r2.data.indexOf(h, t3 + 1)); ) d2.push({ type: 7, index: c2 }), t3 += h.length - 1;
      }
      c2++;
    }
  }
  static createElement(t2, i3) {
    const s3 = r$1.createElement("template");
    return s3.innerHTML = t2, s3;
  }
};
function N$1(t2, i3, s3 = t2, e2) {
  if (i3 === w$1) return i3;
  let h2 = void 0 !== e2 ? s3._$Co?.[e2] : s3._$Cl;
  const o2 = c(i3) ? void 0 : i3._$litDirective$;
  return h2?.constructor !== o2 && (h2?._$AO?.(false), void 0 === o2 ? h2 = void 0 : (h2 = new o2(t2), h2._$AT(t2, s3, e2)), void 0 !== e2 ? (s3._$Co ??= [])[e2] = h2 : s3._$Cl = h2), void 0 !== h2 && (i3 = N$1(t2, h2._$AS(t2, i3.values), h2, e2)), i3;
}
let S$1 = class S {
  constructor(t2, i3) {
    this._$AV = [], this._$AN = void 0, this._$AD = t2, this._$AM = i3;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t2) {
    const { el: { content: i3 }, parts: s3 } = this._$AD, e2 = (t2?.creationScope ?? r$1).importNode(i3, true);
    E$1.currentNode = e2;
    let h2 = E$1.nextNode(), o2 = 0, n3 = 0, l2 = s3[0];
    for (; void 0 !== l2; ) {
      if (o2 === l2.index) {
        let i4;
        2 === l2.type ? i4 = new M$2(h2, h2.nextSibling, this, t2) : 1 === l2.type ? i4 = new l2.ctor(h2, l2.name, l2.strings, this, t2) : 6 === l2.type && (i4 = new L$1(h2, this, t2)), this._$AV.push(i4), l2 = s3[++n3];
      }
      o2 !== l2?.index && (h2 = E$1.nextNode(), o2++);
    }
    return E$1.currentNode = r$1, e2;
  }
  p(t2) {
    let i3 = 0;
    for (const s3 of this._$AV) void 0 !== s3 && (void 0 !== s3.strings ? (s3._$AI(t2, s3, i3), i3 += s3.strings.length - 2) : s3._$AI(t2[i3])), i3++;
  }
};
let M$2 = class M {
  get _$AU() {
    return this._$AM?._$AU ?? this._$Cv;
  }
  constructor(t2, i3, s3, e2) {
    this.type = 2, this._$AH = T$1, this._$AN = void 0, this._$AA = t2, this._$AB = i3, this._$AM = s3, this.options = e2, this._$Cv = e2?.isConnected ?? true;
  }
  get parentNode() {
    let t2 = this._$AA.parentNode;
    const i3 = this._$AM;
    return void 0 !== i3 && 11 === t2?.nodeType && (t2 = i3.parentNode), t2;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t2, i3 = this) {
    t2 = N$1(this, t2, i3), c(t2) ? t2 === T$1 || null == t2 || "" === t2 ? (this._$AH !== T$1 && this._$AR(), this._$AH = T$1) : t2 !== this._$AH && t2 !== w$1 && this._(t2) : void 0 !== t2._$litType$ ? this.$(t2) : void 0 !== t2.nodeType ? this.T(t2) : u$1(t2) ? this.k(t2) : this._(t2);
  }
  S(t2) {
    return this._$AA.parentNode.insertBefore(t2, this._$AB);
  }
  T(t2) {
    this._$AH !== t2 && (this._$AR(), this._$AH = this.S(t2));
  }
  _(t2) {
    this._$AH !== T$1 && c(this._$AH) ? this._$AA.nextSibling.data = t2 : this.T(r$1.createTextNode(t2)), this._$AH = t2;
  }
  $(t2) {
    const { values: i3, _$litType$: s3 } = t2, e2 = "number" == typeof s3 ? this._$AC(t2) : (void 0 === s3.el && (s3.el = V$1.createElement(C(s3.h, s3.h[0]), this.options)), s3);
    if (this._$AH?._$AD === e2) this._$AH.p(i3);
    else {
      const t3 = new S$1(e2, this), s4 = t3.u(this.options);
      t3.p(i3), this.T(s4), this._$AH = t3;
    }
  }
  _$AC(t2) {
    let i3 = A$2.get(t2.strings);
    return void 0 === i3 && A$2.set(t2.strings, i3 = new V$1(t2)), i3;
  }
  k(t2) {
    a$1(this._$AH) || (this._$AH = [], this._$AR());
    const i3 = this._$AH;
    let s3, e2 = 0;
    for (const h2 of t2) e2 === i3.length ? i3.push(s3 = new M(this.S(l$2()), this.S(l$2()), this, this.options)) : s3 = i3[e2], s3._$AI(h2), e2++;
    e2 < i3.length && (this._$AR(s3 && s3._$AB.nextSibling, e2), i3.length = e2);
  }
  _$AR(t2 = this._$AA.nextSibling, i3) {
    for (this._$AP?.(false, true, i3); t2 && t2 !== this._$AB; ) {
      const i4 = t2.nextSibling;
      t2.remove(), t2 = i4;
    }
  }
  setConnected(t2) {
    void 0 === this._$AM && (this._$Cv = t2, this._$AP?.(t2));
  }
};
class R {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t2, i3, s3, e2, h2) {
    this.type = 1, this._$AH = T$1, this._$AN = void 0, this.element = t2, this.name = i3, this._$AM = e2, this.options = h2, s3.length > 2 || "" !== s3[0] || "" !== s3[1] ? (this._$AH = Array(s3.length - 1).fill(new String()), this.strings = s3) : this._$AH = T$1;
  }
  _$AI(t2, i3 = this, s3, e2) {
    const h2 = this.strings;
    let o2 = false;
    if (void 0 === h2) t2 = N$1(this, t2, i3, 0), o2 = !c(t2) || t2 !== this._$AH && t2 !== w$1, o2 && (this._$AH = t2);
    else {
      const e3 = t2;
      let n3, r2;
      for (t2 = h2[0], n3 = 0; n3 < h2.length - 1; n3++) r2 = N$1(this, e3[s3 + n3], i3, n3), r2 === w$1 && (r2 = this._$AH[n3]), o2 ||= !c(r2) || r2 !== this._$AH[n3], r2 === T$1 ? t2 = T$1 : t2 !== T$1 && (t2 += (r2 ?? "") + h2[n3 + 1]), this._$AH[n3] = r2;
    }
    o2 && !e2 && this.j(t2);
  }
  j(t2) {
    t2 === T$1 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t2 ?? "");
  }
}
let k$1 = class k extends R {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t2) {
    this.element[this.name] = t2 === T$1 ? void 0 : t2;
  }
};
class H extends R {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t2) {
    this.element.toggleAttribute(this.name, !!t2 && t2 !== T$1);
  }
}
let I$1 = class I extends R {
  constructor(t2, i3, s3, e2, h2) {
    super(t2, i3, s3, e2, h2), this.type = 5;
  }
  _$AI(t2, i3 = this) {
    if ((t2 = N$1(this, t2, i3, 0) ?? T$1) === w$1) return;
    const s3 = this._$AH, e2 = t2 === T$1 && s3 !== T$1 || t2.capture !== s3.capture || t2.once !== s3.once || t2.passive !== s3.passive, h2 = t2 !== T$1 && (s3 === T$1 || e2);
    e2 && this.element.removeEventListener(this.name, this, s3), h2 && this.element.addEventListener(this.name, this, t2), this._$AH = t2;
  }
  handleEvent(t2) {
    "function" == typeof this._$AH ? this._$AH.call(this.options?.host ?? this.element, t2) : this._$AH.handleEvent(t2);
  }
};
let L$1 = class L {
  constructor(t2, i3, s3) {
    this.element = t2, this.type = 6, this._$AN = void 0, this._$AM = i3, this.options = s3;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t2) {
    N$1(this, t2);
  }
};
const Z = t$1.litHtmlPolyfillSupport;
Z?.(V$1, M$2), (t$1.litHtmlVersions ??= []).push("3.1.3");
const j$1 = (t2, i3, s3) => {
  const e2 = s3?.renderBefore ?? i3;
  let h2 = e2._$litPart$;
  if (void 0 === h2) {
    const t3 = s3?.renderBefore ?? null;
    e2._$litPart$ = h2 = new M$2(i3.insertBefore(l$2(), t3), t3, void 0, s3 ?? {});
  }
  return h2._$AI(t2), h2;
};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
let s$1 = class s extends b$1 {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
  }
  createRenderRoot() {
    const t2 = super.createRenderRoot();
    return this.renderOptions.renderBefore ??= t2.firstChild, t2;
  }
  update(t2) {
    const i3 = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t2), this._$Do = j$1(i3, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    super.connectedCallback(), this._$Do?.setConnected(true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._$Do?.setConnected(false);
  }
  render() {
    return w$1;
  }
};
s$1._$litElement$ = true, s$1["finalized"] = true, globalThis.litElementHydrateSupport?.({ LitElement: s$1 });
const r = globalThis.litElementPolyfillSupport;
r?.({ LitElement: s$1 });
(globalThis.litElementVersions ??= []).push("4.0.5");
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const o$2 = false;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let Elevation$1 = class Elevation extends s$1 {
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("aria-hidden", "true");
  }
  render() {
    return x$1`<span class="shadow"></span>`;
  }
};
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$U = i$4`:host,.shadow,.shadow::before,.shadow::after{border-radius:inherit;inset:0;position:absolute;transition-duration:inherit;transition-property:inherit;transition-timing-function:inherit}:host{display:flex;pointer-events:none;transition-property:box-shadow,opacity}.shadow::before,.shadow::after{content:"";transition-property:box-shadow,opacity;--_level: var(--md-elevation-level, 0);--_shadow-color: var(--md-elevation-shadow-color, var(--md-sys-color-shadow, #000))}.shadow::before{box-shadow:0px calc(1px*(clamp(0,var(--_level),1) + clamp(0,var(--_level) - 3,1) + 2*clamp(0,var(--_level) - 4,1))) calc(1px*(2*clamp(0,var(--_level),1) + clamp(0,var(--_level) - 2,1) + clamp(0,var(--_level) - 4,1))) 0px var(--_shadow-color);opacity:.3}.shadow::after{box-shadow:0px calc(1px*(clamp(0,var(--_level),1) + clamp(0,var(--_level) - 1,1) + 2*clamp(0,var(--_level) - 2,3))) calc(1px*(3*clamp(0,var(--_level),2) + 2*clamp(0,var(--_level) - 2,3))) calc(1px*(clamp(0,var(--_level),4) + 2*clamp(0,var(--_level) - 4,1))) var(--_shadow-color);opacity:.15}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdElevation = class MdElevation2 extends Elevation$1 {
};
MdElevation.styles = [styles$U];
MdElevation = __decorate([
  t$3("md-elevation")
], MdElevation);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ATTACHABLE_CONTROLLER = Symbol("attachableController");
let FOR_ATTRIBUTE_OBSERVER;
{
  FOR_ATTRIBUTE_OBSERVER = new MutationObserver((records) => {
    for (const record of records) {
      record.target[ATTACHABLE_CONTROLLER]?.hostConnected();
    }
  });
}
class AttachableController {
  get htmlFor() {
    return this.host.getAttribute("for");
  }
  set htmlFor(htmlFor) {
    if (htmlFor === null) {
      this.host.removeAttribute("for");
    } else {
      this.host.setAttribute("for", htmlFor);
    }
  }
  get control() {
    if (this.host.hasAttribute("for")) {
      if (!this.htmlFor || !this.host.isConnected) {
        return null;
      }
      return this.host.getRootNode().querySelector(`#${this.htmlFor}`);
    }
    return this.currentControl || this.host.parentElement;
  }
  set control(control) {
    if (control) {
      this.attach(control);
    } else {
      this.detach();
    }
  }
  /**
   * Creates a new controller for an `Attachable` element.
   *
   * @param host The `Attachable` element.
   * @param onControlChange A callback with two parameters for the previous and
   *     next control. An `Attachable` element may perform setup or teardown
   *     logic whenever the control changes.
   */
  constructor(host, onControlChange) {
    this.host = host;
    this.onControlChange = onControlChange;
    this.currentControl = null;
    host.addController(this);
    host[ATTACHABLE_CONTROLLER] = this;
    FOR_ATTRIBUTE_OBSERVER?.observe(host, { attributeFilter: ["for"] });
  }
  attach(control) {
    if (control === this.currentControl) {
      return;
    }
    this.setCurrentControl(control);
    this.host.removeAttribute("for");
  }
  detach() {
    this.setCurrentControl(null);
    this.host.setAttribute("for", "");
  }
  /** @private */
  hostConnected() {
    this.setCurrentControl(this.control);
  }
  /** @private */
  hostDisconnected() {
    this.setCurrentControl(null);
  }
  setCurrentControl(control) {
    this.onControlChange(this.currentControl, control);
    this.currentControl = control;
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const EVENTS$1 = ["focusin", "focusout", "pointerdown"];
class FocusRing extends s$1 {
  constructor() {
    super(...arguments);
    this.visible = false;
    this.inward = false;
    this.attachableController = new AttachableController(this, this.onControlChange.bind(this));
  }
  get htmlFor() {
    return this.attachableController.htmlFor;
  }
  set htmlFor(htmlFor) {
    this.attachableController.htmlFor = htmlFor;
  }
  get control() {
    return this.attachableController.control;
  }
  set control(control) {
    this.attachableController.control = control;
  }
  attach(control) {
    this.attachableController.attach(control);
  }
  detach() {
    this.attachableController.detach();
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("aria-hidden", "true");
  }
  /** @private */
  handleEvent(event) {
    if (event[HANDLED_BY_FOCUS_RING]) {
      return;
    }
    switch (event.type) {
      default:
        return;
      case "focusin":
        this.visible = this.control?.matches(":focus-visible") ?? false;
        break;
      case "focusout":
      case "pointerdown":
        this.visible = false;
        break;
    }
    event[HANDLED_BY_FOCUS_RING] = true;
  }
  onControlChange(prev, next) {
    for (const event of EVENTS$1) {
      prev?.removeEventListener(event, this);
      next?.addEventListener(event, this);
    }
  }
  update(changed) {
    if (changed.has("visible")) {
      this.dispatchEvent(new Event("visibility-changed"));
    }
    super.update(changed);
  }
}
__decorate([
  n$5({ type: Boolean, reflect: true })
], FocusRing.prototype, "visible", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], FocusRing.prototype, "inward", void 0);
const HANDLED_BY_FOCUS_RING = Symbol("handledByFocusRing");
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$T = i$4`:host{animation-delay:0s,calc(var(--md-focus-ring-duration, 600ms)*.25);animation-duration:calc(var(--md-focus-ring-duration, 600ms)*.25),calc(var(--md-focus-ring-duration, 600ms)*.75);animation-timing-function:cubic-bezier(0.2, 0, 0, 1);box-sizing:border-box;color:var(--md-focus-ring-color, var(--md-sys-color-secondary, #625b71));display:none;pointer-events:none;position:absolute}:host([visible]){display:flex}:host(:not([inward])){animation-name:outward-grow,outward-shrink;border-end-end-radius:calc(var(--md-focus-ring-shape-end-end, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) + var(--md-focus-ring-outward-offset, 2px));border-end-start-radius:calc(var(--md-focus-ring-shape-end-start, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) + var(--md-focus-ring-outward-offset, 2px));border-start-end-radius:calc(var(--md-focus-ring-shape-start-end, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) + var(--md-focus-ring-outward-offset, 2px));border-start-start-radius:calc(var(--md-focus-ring-shape-start-start, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) + var(--md-focus-ring-outward-offset, 2px));inset:calc(-1*var(--md-focus-ring-outward-offset, 2px));outline:var(--md-focus-ring-width, 3px) solid currentColor}:host([inward]){animation-name:inward-grow,inward-shrink;border-end-end-radius:calc(var(--md-focus-ring-shape-end-end, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) - var(--md-focus-ring-inward-offset, 0px));border-end-start-radius:calc(var(--md-focus-ring-shape-end-start, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) - var(--md-focus-ring-inward-offset, 0px));border-start-end-radius:calc(var(--md-focus-ring-shape-start-end, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) - var(--md-focus-ring-inward-offset, 0px));border-start-start-radius:calc(var(--md-focus-ring-shape-start-start, var(--md-focus-ring-shape, var(--md-sys-shape-corner-full, 9999px))) - var(--md-focus-ring-inward-offset, 0px));border:var(--md-focus-ring-width, 3px) solid currentColor;inset:var(--md-focus-ring-inward-offset, 0px)}@keyframes outward-grow{from{outline-width:0}to{outline-width:var(--md-focus-ring-active-width, 8px)}}@keyframes outward-shrink{from{outline-width:var(--md-focus-ring-active-width, 8px)}}@keyframes inward-grow{from{border-width:0}to{border-width:var(--md-focus-ring-active-width, 8px)}}@keyframes inward-shrink{from{border-width:var(--md-focus-ring-active-width, 8px)}}@media(prefers-reduced-motion){:host{animation:none}}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdFocusRing = class MdFocusRing2 extends FocusRing {
};
MdFocusRing.styles = [styles$T];
MdFocusRing = __decorate([
  t$3("md-focus-ring")
], MdFocusRing);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 }, e$2 = (t2) => (...e2) => ({ _$litDirective$: t2, values: e2 });
let i$1 = class i {
  constructor(t2) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t2, e2, i3) {
    this._$Ct = t2, this._$AM = e2, this._$Ci = i3;
  }
  _$AS(t2, e2) {
    return this.update(t2, e2);
  }
  update(t2, e2) {
    return this.render(...e2);
  }
};
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e$1 = e$2(class extends i$1 {
  constructor(t$12) {
    if (super(t$12), t$12.type !== t.ATTRIBUTE || "class" !== t$12.name || t$12.strings?.length > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
  }
  render(t2) {
    return " " + Object.keys(t2).filter((s3) => t2[s3]).join(" ") + " ";
  }
  update(s3, [i3]) {
    if (void 0 === this.st) {
      this.st = /* @__PURE__ */ new Set(), void 0 !== s3.strings && (this.nt = new Set(s3.strings.join(" ").split(/\s/).filter((t2) => "" !== t2)));
      for (const t2 in i3) i3[t2] && !this.nt?.has(t2) && this.st.add(t2);
      return this.render(i3);
    }
    const r2 = s3.element.classList;
    for (const t2 of this.st) t2 in i3 || (r2.remove(t2), this.st.delete(t2));
    for (const t2 in i3) {
      const s4 = !!i3[t2];
      s4 === this.st.has(t2) || this.nt?.has(t2) || (s4 ? (r2.add(t2), this.st.add(t2)) : (r2.remove(t2), this.st.delete(t2)));
    }
    return w$1;
  }
});
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const EASING = {
  STANDARD: "cubic-bezier(0.2, 0, 0, 1)",
  STANDARD_ACCELERATE: "cubic-bezier(.3,0,1,1)",
  STANDARD_DECELERATE: "cubic-bezier(0,0,0,1)",
  EMPHASIZED: "cubic-bezier(.3,0,0,1)",
  EMPHASIZED_ACCELERATE: "cubic-bezier(.3,0,.8,.15)",
  EMPHASIZED_DECELERATE: "cubic-bezier(.05,.7,.1,1)"
};
function createAnimationSignal() {
  let animationAbortController = null;
  return {
    start() {
      animationAbortController?.abort();
      animationAbortController = new AbortController();
      return animationAbortController.signal;
    },
    finish() {
      animationAbortController = null;
    }
  };
}
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const PRESS_GROW_MS = 450;
const MINIMUM_PRESS_MS = 225;
const INITIAL_ORIGIN_SCALE = 0.2;
const PADDING = 10;
const SOFT_EDGE_MINIMUM_SIZE = 75;
const SOFT_EDGE_CONTAINER_RATIO = 0.35;
const PRESS_PSEUDO = "::after";
const ANIMATION_FILL = "forwards";
var State2;
(function(State3) {
  State3[State3["INACTIVE"] = 0] = "INACTIVE";
  State3[State3["TOUCH_DELAY"] = 1] = "TOUCH_DELAY";
  State3[State3["HOLDING"] = 2] = "HOLDING";
  State3[State3["WAITING_FOR_CLICK"] = 3] = "WAITING_FOR_CLICK";
})(State2 || (State2 = {}));
const EVENTS = [
  "click",
  "contextmenu",
  "pointercancel",
  "pointerdown",
  "pointerenter",
  "pointerleave",
  "pointerup"
];
const TOUCH_DELAY_MS = 150;
const FORCED_COLORS = window.matchMedia("(forced-colors: active)");
class Ripple extends s$1 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.hovered = false;
    this.pressed = false;
    this.rippleSize = "";
    this.rippleScale = "";
    this.initialSize = 0;
    this.state = State2.INACTIVE;
    this.checkBoundsAfterContextMenu = false;
    this.attachableController = new AttachableController(this, this.onControlChange.bind(this));
  }
  get htmlFor() {
    return this.attachableController.htmlFor;
  }
  set htmlFor(htmlFor) {
    this.attachableController.htmlFor = htmlFor;
  }
  get control() {
    return this.attachableController.control;
  }
  set control(control) {
    this.attachableController.control = control;
  }
  attach(control) {
    this.attachableController.attach(control);
  }
  detach() {
    this.attachableController.detach();
  }
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("aria-hidden", "true");
  }
  render() {
    const classes = {
      "hovered": this.hovered,
      "pressed": this.pressed
    };
    return x$1`<div class="surface ${e$1(classes)}"></div>`;
  }
  update(changedProps) {
    if (changedProps.has("disabled") && this.disabled) {
      this.hovered = false;
      this.pressed = false;
    }
    super.update(changedProps);
  }
  /**
   * TODO(b/269799771): make private
   * @private only public for slider
   */
  handlePointerenter(event) {
    if (!this.shouldReactToEvent(event)) {
      return;
    }
    this.hovered = true;
  }
  /**
   * TODO(b/269799771): make private
   * @private only public for slider
   */
  handlePointerleave(event) {
    if (!this.shouldReactToEvent(event)) {
      return;
    }
    this.hovered = false;
    if (this.state !== State2.INACTIVE) {
      this.endPressAnimation();
    }
  }
  handlePointerup(event) {
    if (!this.shouldReactToEvent(event)) {
      return;
    }
    if (this.state === State2.HOLDING) {
      this.state = State2.WAITING_FOR_CLICK;
      return;
    }
    if (this.state === State2.TOUCH_DELAY) {
      this.state = State2.WAITING_FOR_CLICK;
      this.startPressAnimation(this.rippleStartEvent);
      return;
    }
  }
  async handlePointerdown(event) {
    if (!this.shouldReactToEvent(event)) {
      return;
    }
    this.rippleStartEvent = event;
    if (!this.isTouch(event)) {
      this.state = State2.WAITING_FOR_CLICK;
      this.startPressAnimation(event);
      return;
    }
    if (this.checkBoundsAfterContextMenu && !this.inBounds(event)) {
      return;
    }
    this.checkBoundsAfterContextMenu = false;
    this.state = State2.TOUCH_DELAY;
    await new Promise((resolve2) => {
      setTimeout(resolve2, TOUCH_DELAY_MS);
    });
    if (this.state !== State2.TOUCH_DELAY) {
      return;
    }
    this.state = State2.HOLDING;
    this.startPressAnimation(event);
  }
  handleClick() {
    if (this.disabled) {
      return;
    }
    if (this.state === State2.WAITING_FOR_CLICK) {
      this.endPressAnimation();
      return;
    }
    if (this.state === State2.INACTIVE) {
      this.startPressAnimation();
      this.endPressAnimation();
    }
  }
  handlePointercancel(event) {
    if (!this.shouldReactToEvent(event)) {
      return;
    }
    this.endPressAnimation();
  }
  handleContextmenu() {
    if (this.disabled) {
      return;
    }
    this.checkBoundsAfterContextMenu = true;
    this.endPressAnimation();
  }
  determineRippleSize() {
    const { height, width } = this.getBoundingClientRect();
    const maxDim = Math.max(height, width);
    const softEdgeSize = Math.max(SOFT_EDGE_CONTAINER_RATIO * maxDim, SOFT_EDGE_MINIMUM_SIZE);
    const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);
    const hypotenuse = Math.sqrt(width ** 2 + height ** 2);
    const maxRadius = hypotenuse + PADDING;
    this.initialSize = initialSize;
    this.rippleScale = `${(maxRadius + softEdgeSize) / initialSize}`;
    this.rippleSize = `${initialSize}px`;
  }
  getNormalizedPointerEventCoords(pointerEvent) {
    const { scrollX, scrollY } = window;
    const { left: left2, top: top2 } = this.getBoundingClientRect();
    const documentX = scrollX + left2;
    const documentY = scrollY + top2;
    const { pageX, pageY } = pointerEvent;
    return { x: pageX - documentX, y: pageY - documentY };
  }
  getTranslationCoordinates(positionEvent) {
    const { height, width } = this.getBoundingClientRect();
    const endPoint = {
      x: (width - this.initialSize) / 2,
      y: (height - this.initialSize) / 2
    };
    let startPoint;
    if (positionEvent instanceof PointerEvent) {
      startPoint = this.getNormalizedPointerEventCoords(positionEvent);
    } else {
      startPoint = {
        x: width / 2,
        y: height / 2
      };
    }
    startPoint = {
      x: startPoint.x - this.initialSize / 2,
      y: startPoint.y - this.initialSize / 2
    };
    return { startPoint, endPoint };
  }
  startPressAnimation(positionEvent) {
    if (!this.mdRoot) {
      return;
    }
    this.pressed = true;
    this.growAnimation?.cancel();
    this.determineRippleSize();
    const { startPoint, endPoint } = this.getTranslationCoordinates(positionEvent);
    const translateStart = `${startPoint.x}px, ${startPoint.y}px`;
    const translateEnd = `${endPoint.x}px, ${endPoint.y}px`;
    this.growAnimation = this.mdRoot.animate({
      top: [0, 0],
      left: [0, 0],
      height: [this.rippleSize, this.rippleSize],
      width: [this.rippleSize, this.rippleSize],
      transform: [
        `translate(${translateStart}) scale(1)`,
        `translate(${translateEnd}) scale(${this.rippleScale})`
      ]
    }, {
      pseudoElement: PRESS_PSEUDO,
      duration: PRESS_GROW_MS,
      easing: EASING.STANDARD,
      fill: ANIMATION_FILL
    });
  }
  async endPressAnimation() {
    this.rippleStartEvent = void 0;
    this.state = State2.INACTIVE;
    const animation = this.growAnimation;
    let pressAnimationPlayState = Infinity;
    if (typeof animation?.currentTime === "number") {
      pressAnimationPlayState = animation.currentTime;
    } else if (animation?.currentTime) {
      pressAnimationPlayState = animation.currentTime.to("ms").value;
    }
    if (pressAnimationPlayState >= MINIMUM_PRESS_MS) {
      this.pressed = false;
      return;
    }
    await new Promise((resolve2) => {
      setTimeout(resolve2, MINIMUM_PRESS_MS - pressAnimationPlayState);
    });
    if (this.growAnimation !== animation) {
      return;
    }
    this.pressed = false;
  }
  /**
   * Returns `true` if
   *  - the ripple element is enabled
   *  - the pointer is primary for the input type
   *  - the pointer is the pointer that started the interaction, or will start
   * the interaction
   *  - the pointer is a touch, or the pointer state has the primary button
   * held, or the pointer is hovering
   */
  shouldReactToEvent(event) {
    if (this.disabled || !event.isPrimary) {
      return false;
    }
    if (this.rippleStartEvent && this.rippleStartEvent.pointerId !== event.pointerId) {
      return false;
    }
    if (event.type === "pointerenter" || event.type === "pointerleave") {
      return !this.isTouch(event);
    }
    const isPrimaryButton = event.buttons === 1;
    return this.isTouch(event) || isPrimaryButton;
  }
  /**
   * Check if the event is within the bounds of the element.
   *
   * This is only needed for the "stuck" contextmenu longpress on Chrome.
   */
  inBounds({ x: x2, y: y2 }) {
    const { top: top2, left: left2, bottom: bottom2, right: right2 } = this.getBoundingClientRect();
    return x2 >= left2 && x2 <= right2 && y2 >= top2 && y2 <= bottom2;
  }
  isTouch({ pointerType }) {
    return pointerType === "touch";
  }
  /** @private */
  async handleEvent(event) {
    if (FORCED_COLORS?.matches) {
      return;
    }
    switch (event.type) {
      case "click":
        this.handleClick();
        break;
      case "contextmenu":
        this.handleContextmenu();
        break;
      case "pointercancel":
        this.handlePointercancel(event);
        break;
      case "pointerdown":
        await this.handlePointerdown(event);
        break;
      case "pointerenter":
        this.handlePointerenter(event);
        break;
      case "pointerleave":
        this.handlePointerleave(event);
        break;
      case "pointerup":
        this.handlePointerup(event);
        break;
    }
  }
  onControlChange(prev, next) {
    for (const event of EVENTS) {
      prev?.removeEventListener(event, this);
      next?.addEventListener(event, this);
    }
  }
}
__decorate([
  n$5({ type: Boolean, reflect: true })
], Ripple.prototype, "disabled", void 0);
__decorate([
  r$4()
], Ripple.prototype, "hovered", void 0);
__decorate([
  r$4()
], Ripple.prototype, "pressed", void 0);
__decorate([
  e$5(".surface")
], Ripple.prototype, "mdRoot", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$S = i$4`:host{display:flex;margin:auto;pointer-events:none}:host([disabled]){display:none}@media(forced-colors: active){:host{display:none}}:host,.surface{border-radius:inherit;position:absolute;inset:0;overflow:hidden}.surface{-webkit-tap-highlight-color:rgba(0,0,0,0)}.surface::before,.surface::after{content:"";opacity:0;position:absolute}.surface::before{background-color:var(--md-ripple-hover-color, var(--md-sys-color-on-surface, #1d1b20));inset:0;transition:opacity 15ms linear,background-color 15ms linear}.surface::after{background:radial-gradient(closest-side, var(--md-ripple-pressed-color, var(--md-sys-color-on-surface, #1d1b20)) max(100% - 70px, 65%), transparent 100%);transform-origin:center center;transition:opacity 375ms linear}.hovered::before{background-color:var(--md-ripple-hover-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-ripple-hover-opacity, 0.08)}.pressed::after{opacity:var(--md-ripple-pressed-opacity, 0.12);transition-duration:105ms}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdRipple = class MdRipple2 extends Ripple {
};
MdRipple.styles = [styles$S];
MdRipple = __decorate([
  t$3("md-ripple")
], MdRipple);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ARIA_PROPERTIES = [
  "role",
  "ariaAtomic",
  "ariaAutoComplete",
  "ariaBusy",
  "ariaChecked",
  "ariaColCount",
  "ariaColIndex",
  "ariaColSpan",
  "ariaCurrent",
  "ariaDisabled",
  "ariaExpanded",
  "ariaHasPopup",
  "ariaHidden",
  "ariaInvalid",
  "ariaKeyShortcuts",
  "ariaLabel",
  "ariaLevel",
  "ariaLive",
  "ariaModal",
  "ariaMultiLine",
  "ariaMultiSelectable",
  "ariaOrientation",
  "ariaPlaceholder",
  "ariaPosInSet",
  "ariaPressed",
  "ariaReadOnly",
  "ariaRequired",
  "ariaRoleDescription",
  "ariaRowCount",
  "ariaRowIndex",
  "ariaRowSpan",
  "ariaSelected",
  "ariaSetSize",
  "ariaSort",
  "ariaValueMax",
  "ariaValueMin",
  "ariaValueNow",
  "ariaValueText"
];
const ARIA_ATTRIBUTES = ARIA_PROPERTIES.map(ariaPropertyToAttribute);
function isAriaAttribute(attribute) {
  return ARIA_ATTRIBUTES.includes(attribute);
}
function ariaPropertyToAttribute(property) {
  return property.replace("aria", "aria-").replace(/Elements?/g, "").toLowerCase();
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const privateIgnoreAttributeChangesFor = Symbol("privateIgnoreAttributeChangesFor");
function mixinDelegatesAria(base) {
  var _a2;
  class WithDelegatesAriaElement extends base {
    constructor() {
      super(...arguments);
      this[_a2] = /* @__PURE__ */ new Set();
    }
    attributeChangedCallback(name2, oldValue, newValue) {
      if (!isAriaAttribute(name2)) {
        super.attributeChangedCallback(name2, oldValue, newValue);
        return;
      }
      if (this[privateIgnoreAttributeChangesFor].has(name2)) {
        return;
      }
      this[privateIgnoreAttributeChangesFor].add(name2);
      this.removeAttribute(name2);
      this[privateIgnoreAttributeChangesFor].delete(name2);
      const dataProperty = ariaAttributeToDataProperty(name2);
      if (newValue === null) {
        delete this.dataset[dataProperty];
      } else {
        this.dataset[dataProperty] = newValue;
      }
      this.requestUpdate(ariaAttributeToDataProperty(name2), oldValue);
    }
    getAttribute(name2) {
      if (isAriaAttribute(name2)) {
        return super.getAttribute(ariaAttributeToDataAttribute(name2));
      }
      return super.getAttribute(name2);
    }
    removeAttribute(name2) {
      super.removeAttribute(name2);
      if (isAriaAttribute(name2)) {
        super.removeAttribute(ariaAttributeToDataAttribute(name2));
        this.requestUpdate();
      }
    }
  }
  _a2 = privateIgnoreAttributeChangesFor;
  setupDelegatesAriaProperties(WithDelegatesAriaElement);
  return WithDelegatesAriaElement;
}
function setupDelegatesAriaProperties(ctor) {
  for (const ariaProperty of ARIA_PROPERTIES) {
    const ariaAttribute = ariaPropertyToAttribute(ariaProperty);
    const dataAttribute = ariaAttributeToDataAttribute(ariaAttribute);
    const dataProperty = ariaAttributeToDataProperty(ariaAttribute);
    ctor.createProperty(ariaProperty, {
      attribute: ariaAttribute,
      noAccessor: true
    });
    ctor.createProperty(Symbol(dataAttribute), {
      attribute: dataAttribute,
      noAccessor: true
    });
    Object.defineProperty(ctor.prototype, ariaProperty, {
      configurable: true,
      enumerable: true,
      get() {
        return this.dataset[dataProperty] ?? null;
      },
      set(value) {
        const prevValue = this.dataset[dataProperty] ?? null;
        if (value === prevValue) {
          return;
        }
        if (value === null) {
          delete this.dataset[dataProperty];
        } else {
          this.dataset[dataProperty] = value;
        }
        this.requestUpdate(ariaProperty, prevValue);
      }
    });
  }
}
function ariaAttributeToDataAttribute(ariaAttribute) {
  return `data-${ariaAttribute}`;
}
function ariaAttributeToDataProperty(ariaAttribute) {
  return ariaAttribute.replace(/-\w/, (dashLetter) => dashLetter[1].toUpperCase());
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const internals = Symbol("internals");
const privateInternals = Symbol("privateInternals");
function mixinElementInternals(base) {
  class WithElementInternalsElement extends base {
    get [internals]() {
      if (!this[privateInternals]) {
        this[privateInternals] = this.attachInternals();
      }
      return this[privateInternals];
    }
  }
  return WithElementInternalsElement;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function setupFormSubmitter(ctor) {
  ctor.addInitializer((instance) => {
    const submitter = instance;
    submitter.addEventListener("click", async (event) => {
      const { type, [internals]: elementInternals } = submitter;
      const { form } = elementInternals;
      if (!form || type === "button") {
        return;
      }
      await new Promise((resolve2) => {
        setTimeout(resolve2);
      });
      if (event.defaultPrevented) {
        return;
      }
      if (type === "reset") {
        form.reset();
        return;
      }
      form.addEventListener("submit", (submitEvent) => {
        Object.defineProperty(submitEvent, "submitter", {
          configurable: true,
          enumerable: true,
          get: () => submitter
        });
      }, { capture: true, once: true });
      elementInternals.setFormValue(submitter.value);
      form.requestSubmit();
    });
  });
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function dispatchActivationClick(element) {
  const event = new MouseEvent("click", { bubbles: true });
  element.dispatchEvent(event);
  return event;
}
function isActivationClick(event) {
  if (event.currentTarget !== event.target) {
    return false;
  }
  if (event.composedPath()[0] !== event.target) {
    return false;
  }
  if (event.target.disabled) {
    return false;
  }
  return !squelchEvent(event);
}
function squelchEvent(event) {
  const squelched = isSquelchingEvents;
  if (squelched) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  squelchEventsForMicrotask();
  return squelched;
}
let isSquelchingEvents = false;
async function squelchEventsForMicrotask() {
  isSquelchingEvents = true;
  await null;
  isSquelchingEvents = false;
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const buttonBaseClass = mixinDelegatesAria(mixinElementInternals(s$1));
let Button$1 = class Button extends buttonBaseClass {
  get name() {
    return this.getAttribute("name") ?? "";
  }
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * The associated form element with which this element's value will submit.
   */
  get form() {
    return this[internals].form;
  }
  constructor() {
    super();
    this.disabled = false;
    this.softDisabled = false;
    this.href = "";
    this.target = "";
    this.trailingIcon = false;
    this.hasIcon = false;
    this.type = "submit";
    this.value = "";
    {
      this.addEventListener("click", this.handleClick.bind(this));
    }
  }
  focus() {
    this.buttonElement?.focus();
  }
  blur() {
    this.buttonElement?.blur();
  }
  render() {
    const isRippleDisabled = !this.href && (this.disabled || this.softDisabled);
    const buttonOrLink = this.href ? this.renderLink() : this.renderButton();
    const buttonId = this.href ? "link" : "button";
    return x$1`
      ${this.renderElevationOrOutline?.()}
      <div class="background"></div>
      <md-focus-ring part="focus-ring" for=${buttonId}></md-focus-ring>
      <md-ripple
        part="ripple"
        for=${buttonId}
        ?disabled="${isRippleDisabled}"></md-ripple>
      ${buttonOrLink}
    `;
  }
  renderButton() {
    const { ariaLabel, ariaHasPopup, ariaExpanded } = this;
    return x$1`<button
      id="button"
      class="button"
      ?disabled=${this.disabled}
      aria-disabled=${this.softDisabled || T$1}
      aria-label="${ariaLabel || T$1}"
      aria-haspopup="${ariaHasPopup || T$1}"
      aria-expanded="${ariaExpanded || T$1}">
      ${this.renderContent()}
    </button>`;
  }
  renderLink() {
    const { ariaLabel, ariaHasPopup, ariaExpanded } = this;
    return x$1`<a
      id="link"
      class="button"
      aria-label="${ariaLabel || T$1}"
      aria-haspopup="${ariaHasPopup || T$1}"
      aria-expanded="${ariaExpanded || T$1}"
      href=${this.href}
      target=${this.target || T$1}
      >${this.renderContent()}
    </a>`;
  }
  renderContent() {
    const icon = x$1`<slot
      name="icon"
      @slotchange="${this.handleSlotChange}"></slot>`;
    return x$1`
      <span class="touch"></span>
      ${this.trailingIcon ? T$1 : icon}
      <span class="label"><slot></slot></span>
      ${this.trailingIcon ? icon : T$1}
    `;
  }
  handleClick(event) {
    if (!this.href && this.softDisabled) {
      event.stopImmediatePropagation();
      event.preventDefault();
      return;
    }
    if (!isActivationClick(event) || !this.buttonElement) {
      return;
    }
    this.focus();
    dispatchActivationClick(this.buttonElement);
  }
  handleSlotChange() {
    this.hasIcon = this.assignedIcons.length > 0;
  }
};
(() => {
  setupFormSubmitter(Button$1);
})();
Button$1.formAssociated = true;
Button$1.shadowRootOptions = {
  mode: "open",
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], Button$1.prototype, "disabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "soft-disabled", reflect: true })
], Button$1.prototype, "softDisabled", void 0);
__decorate([
  n$5()
], Button$1.prototype, "href", void 0);
__decorate([
  n$5()
], Button$1.prototype, "target", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "trailing-icon", reflect: true })
], Button$1.prototype, "trailingIcon", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-icon", reflect: true })
], Button$1.prototype, "hasIcon", void 0);
__decorate([
  n$5()
], Button$1.prototype, "type", void 0);
__decorate([
  n$5({ reflect: true })
], Button$1.prototype, "value", void 0);
__decorate([
  e$5(".button")
], Button$1.prototype, "buttonElement", void 0);
__decorate([
  o$4({ slot: "icon", flatten: true })
], Button$1.prototype, "assignedIcons", void 0);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class ElevatedButton extends Button$1 {
  renderElevationOrOutline() {
    return x$1`<md-elevation part="elevation"></md-elevation>`;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$R = i$4`:host{--_container-color: var(--md-elevated-button-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_container-elevation: var(--md-elevated-button-container-elevation, 1);--_container-height: var(--md-elevated-button-container-height, 40px);--_container-shadow-color: var(--md-elevated-button-container-shadow-color, var(--md-sys-color-shadow, #000));--_disabled-container-color: var(--md-elevated-button-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-elevation: var(--md-elevated-button-disabled-container-elevation, 0);--_disabled-container-opacity: var(--md-elevated-button-disabled-container-opacity, 0.12);--_disabled-label-text-color: var(--md-elevated-button-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-elevated-button-disabled-label-text-opacity, 0.38);--_focus-container-elevation: var(--md-elevated-button-focus-container-elevation, 1);--_focus-label-text-color: var(--md-elevated-button-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-container-elevation: var(--md-elevated-button-hover-container-elevation, 2);--_hover-label-text-color: var(--md-elevated-button-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-elevated-button-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-elevated-button-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-elevated-button-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-font: var(--md-elevated-button-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-elevated-button-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-elevated-button-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-elevated-button-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-container-elevation: var(--md-elevated-button-pressed-container-elevation, 1);--_pressed-label-text-color: var(--md-elevated-button-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-elevated-button-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-elevated-button-pressed-state-layer-opacity, 0.12);--_disabled-icon-color: var(--md-elevated-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-elevated-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-elevated-button-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-icon-color: var(--md-elevated-button-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-color: var(--md-elevated-button-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-elevated-button-icon-size, 18px);--_pressed-icon-color: var(--md-elevated-button-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-elevated-button-container-shape-start-start, var(--md-elevated-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-elevated-button-container-shape-start-end, var(--md-elevated-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-elevated-button-container-shape-end-end, var(--md-elevated-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-elevated-button-container-shape-end-start, var(--md-elevated-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_leading-space: var(--md-elevated-button-leading-space, 24px);--_trailing-space: var(--md-elevated-button-trailing-space, 24px);--_with-leading-icon-leading-space: var(--md-elevated-button-with-leading-icon-leading-space, 16px);--_with-leading-icon-trailing-space: var(--md-elevated-button-with-leading-icon-trailing-space, 24px);--_with-trailing-icon-leading-space: var(--md-elevated-button-with-trailing-icon-leading-space, 24px);--_with-trailing-icon-trailing-space: var(--md-elevated-button-with-trailing-icon-trailing-space, 16px)}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$Q = i$4`md-elevation{transition-duration:280ms}:host(:is([disabled],[soft-disabled])) md-elevation{transition:none}md-elevation{--md-elevation-level: var(--_container-elevation);--md-elevation-shadow-color: var(--_container-shadow-color)}:host(:focus-within) md-elevation{--md-elevation-level: var(--_focus-container-elevation)}:host(:hover) md-elevation{--md-elevation-level: var(--_hover-container-elevation)}:host(:active) md-elevation{--md-elevation-level: var(--_pressed-container-elevation)}:host(:is([disabled],[soft-disabled])) md-elevation{--md-elevation-level: var(--_disabled-container-elevation)}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$P = i$4`:host{border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end);box-sizing:border-box;cursor:pointer;display:inline-flex;gap:8px;min-height:var(--_container-height);outline:none;padding-block:calc((var(--_container-height) - max(var(--_label-text-line-height),var(--_icon-size)))/2);padding-inline-start:var(--_leading-space);padding-inline-end:var(--_trailing-space);place-content:center;place-items:center;position:relative;font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);text-overflow:ellipsis;text-wrap:nowrap;user-select:none;-webkit-tap-highlight-color:rgba(0,0,0,0);vertical-align:top;--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}md-focus-ring{--md-focus-ring-shape-start-start: var(--_container-shape-start-start);--md-focus-ring-shape-start-end: var(--_container-shape-start-end);--md-focus-ring-shape-end-end: var(--_container-shape-end-end);--md-focus-ring-shape-end-start: var(--_container-shape-end-start)}:host(:is([disabled],[soft-disabled])){cursor:default;pointer-events:none}.button{border-radius:inherit;cursor:inherit;display:inline-flex;align-items:center;justify-content:center;border:none;outline:none;-webkit-appearance:none;vertical-align:middle;background:rgba(0,0,0,0);text-decoration:none;min-width:calc(64px - var(--_leading-space) - var(--_trailing-space));width:100%;z-index:0;height:100%;font:inherit;color:var(--_label-text-color);padding:0;gap:inherit;text-transform:inherit}.button::-moz-focus-inner{padding:0;border:0}:host(:hover) .button{color:var(--_hover-label-text-color)}:host(:focus-within) .button{color:var(--_focus-label-text-color)}:host(:active) .button{color:var(--_pressed-label-text-color)}.background{background-color:var(--_container-color);border-radius:inherit;inset:0;position:absolute}.label{overflow:hidden}:is(.button,.label,.label slot),.label ::slotted(*){text-overflow:inherit}:host(:is([disabled],[soft-disabled])) .label{color:var(--_disabled-label-text-color);opacity:var(--_disabled-label-text-opacity)}:host(:is([disabled],[soft-disabled])) .background{background-color:var(--_disabled-container-color);opacity:var(--_disabled-container-opacity)}@media(forced-colors: active){.background{border:1px solid CanvasText}:host(:is([disabled],[soft-disabled])){--_disabled-icon-color: GrayText;--_disabled-icon-opacity: 1;--_disabled-container-opacity: 1;--_disabled-label-text-color: GrayText;--_disabled-label-text-opacity: 1}}:host([has-icon]:not([trailing-icon])){padding-inline-start:var(--_with-leading-icon-leading-space);padding-inline-end:var(--_with-leading-icon-trailing-space)}:host([has-icon][trailing-icon]){padding-inline-start:var(--_with-trailing-icon-leading-space);padding-inline-end:var(--_with-trailing-icon-trailing-space)}::slotted([slot=icon]){display:inline-flex;position:relative;writing-mode:horizontal-tb;fill:currentColor;flex-shrink:0;color:var(--_icon-color);font-size:var(--_icon-size);inline-size:var(--_icon-size);block-size:var(--_icon-size)}:host(:hover) ::slotted([slot=icon]){color:var(--_hover-icon-color)}:host(:focus-within) ::slotted([slot=icon]){color:var(--_focus-icon-color)}:host(:active) ::slotted([slot=icon]){color:var(--_pressed-icon-color)}:host(:is([disabled],[soft-disabled])) ::slotted([slot=icon]){color:var(--_disabled-icon-color);opacity:var(--_disabled-icon-opacity)}.touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--_container-height))/2) 0}:host([touch-target=none]) .touch{display:none}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdElevatedButton = class MdElevatedButton2 extends ElevatedButton {
};
MdElevatedButton.styles = [
  styles$P,
  styles$Q,
  styles$R
];
MdElevatedButton = __decorate([
  t$3("md-elevated-button")
], MdElevatedButton);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class FilledButton extends Button$1 {
  renderElevationOrOutline() {
    return x$1`<md-elevation part="elevation"></md-elevation>`;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$O = i$4`:host{--_container-color: var(--md-filled-button-container-color, var(--md-sys-color-primary, #6750a4));--_container-elevation: var(--md-filled-button-container-elevation, 0);--_container-height: var(--md-filled-button-container-height, 40px);--_container-shadow-color: var(--md-filled-button-container-shadow-color, var(--md-sys-color-shadow, #000));--_disabled-container-color: var(--md-filled-button-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-elevation: var(--md-filled-button-disabled-container-elevation, 0);--_disabled-container-opacity: var(--md-filled-button-disabled-container-opacity, 0.12);--_disabled-label-text-color: var(--md-filled-button-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-filled-button-disabled-label-text-opacity, 0.38);--_focus-container-elevation: var(--md-filled-button-focus-container-elevation, 0);--_focus-label-text-color: var(--md-filled-button-focus-label-text-color, var(--md-sys-color-on-primary, #fff));--_hover-container-elevation: var(--md-filled-button-hover-container-elevation, 1);--_hover-label-text-color: var(--md-filled-button-hover-label-text-color, var(--md-sys-color-on-primary, #fff));--_hover-state-layer-color: var(--md-filled-button-hover-state-layer-color, var(--md-sys-color-on-primary, #fff));--_hover-state-layer-opacity: var(--md-filled-button-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-filled-button-label-text-color, var(--md-sys-color-on-primary, #fff));--_label-text-font: var(--md-filled-button-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-filled-button-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-filled-button-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-filled-button-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-container-elevation: var(--md-filled-button-pressed-container-elevation, 0);--_pressed-label-text-color: var(--md-filled-button-pressed-label-text-color, var(--md-sys-color-on-primary, #fff));--_pressed-state-layer-color: var(--md-filled-button-pressed-state-layer-color, var(--md-sys-color-on-primary, #fff));--_pressed-state-layer-opacity: var(--md-filled-button-pressed-state-layer-opacity, 0.12);--_disabled-icon-color: var(--md-filled-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-filled-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-filled-button-focus-icon-color, var(--md-sys-color-on-primary, #fff));--_hover-icon-color: var(--md-filled-button-hover-icon-color, var(--md-sys-color-on-primary, #fff));--_icon-color: var(--md-filled-button-icon-color, var(--md-sys-color-on-primary, #fff));--_icon-size: var(--md-filled-button-icon-size, 18px);--_pressed-icon-color: var(--md-filled-button-pressed-icon-color, var(--md-sys-color-on-primary, #fff));--_container-shape-start-start: var(--md-filled-button-container-shape-start-start, var(--md-filled-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-filled-button-container-shape-start-end, var(--md-filled-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-filled-button-container-shape-end-end, var(--md-filled-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-filled-button-container-shape-end-start, var(--md-filled-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_leading-space: var(--md-filled-button-leading-space, 24px);--_trailing-space: var(--md-filled-button-trailing-space, 24px);--_with-leading-icon-leading-space: var(--md-filled-button-with-leading-icon-leading-space, 16px);--_with-leading-icon-trailing-space: var(--md-filled-button-with-leading-icon-trailing-space, 24px);--_with-trailing-icon-leading-space: var(--md-filled-button-with-trailing-icon-leading-space, 24px);--_with-trailing-icon-trailing-space: var(--md-filled-button-with-trailing-icon-trailing-space, 16px)}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdFilledButton = class MdFilledButton2 extends FilledButton {
};
MdFilledButton.styles = [
  styles$P,
  styles$Q,
  styles$O
];
MdFilledButton = __decorate([
  t$3("md-filled-button")
], MdFilledButton);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class FilledTonalButton extends Button$1 {
  renderElevationOrOutline() {
    return x$1`<md-elevation part="elevation"></md-elevation>`;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$N = i$4`:host{--_container-color: var(--md-filled-tonal-button-container-color, var(--md-sys-color-secondary-container, #e8def8));--_container-elevation: var(--md-filled-tonal-button-container-elevation, 0);--_container-height: var(--md-filled-tonal-button-container-height, 40px);--_container-shadow-color: var(--md-filled-tonal-button-container-shadow-color, var(--md-sys-color-shadow, #000));--_disabled-container-color: var(--md-filled-tonal-button-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-elevation: var(--md-filled-tonal-button-disabled-container-elevation, 0);--_disabled-container-opacity: var(--md-filled-tonal-button-disabled-container-opacity, 0.12);--_disabled-label-text-color: var(--md-filled-tonal-button-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-filled-tonal-button-disabled-label-text-opacity, 0.38);--_focus-container-elevation: var(--md-filled-tonal-button-focus-container-elevation, 0);--_focus-label-text-color: var(--md-filled-tonal-button-focus-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-container-elevation: var(--md-filled-tonal-button-hover-container-elevation, 1);--_hover-label-text-color: var(--md-filled-tonal-button-hover-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-state-layer-color: var(--md-filled-tonal-button-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-state-layer-opacity: var(--md-filled-tonal-button-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-filled-tonal-button-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_label-text-font: var(--md-filled-tonal-button-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-filled-tonal-button-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-filled-tonal-button-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-filled-tonal-button-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-container-elevation: var(--md-filled-tonal-button-pressed-container-elevation, 0);--_pressed-label-text-color: var(--md-filled-tonal-button-pressed-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_pressed-state-layer-color: var(--md-filled-tonal-button-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_pressed-state-layer-opacity: var(--md-filled-tonal-button-pressed-state-layer-opacity, 0.12);--_disabled-icon-color: var(--md-filled-tonal-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-filled-tonal-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-filled-tonal-button-focus-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-icon-color: var(--md-filled-tonal-button-hover-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_icon-color: var(--md-filled-tonal-button-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_icon-size: var(--md-filled-tonal-button-icon-size, 18px);--_pressed-icon-color: var(--md-filled-tonal-button-pressed-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_container-shape-start-start: var(--md-filled-tonal-button-container-shape-start-start, var(--md-filled-tonal-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-filled-tonal-button-container-shape-start-end, var(--md-filled-tonal-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-filled-tonal-button-container-shape-end-end, var(--md-filled-tonal-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-filled-tonal-button-container-shape-end-start, var(--md-filled-tonal-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_leading-space: var(--md-filled-tonal-button-leading-space, 24px);--_trailing-space: var(--md-filled-tonal-button-trailing-space, 24px);--_with-leading-icon-leading-space: var(--md-filled-tonal-button-with-leading-icon-leading-space, 16px);--_with-leading-icon-trailing-space: var(--md-filled-tonal-button-with-leading-icon-trailing-space, 24px);--_with-trailing-icon-leading-space: var(--md-filled-tonal-button-with-trailing-icon-leading-space, 24px);--_with-trailing-icon-trailing-space: var(--md-filled-tonal-button-with-trailing-icon-trailing-space, 16px)}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdFilledTonalButton = class MdFilledTonalButton2 extends FilledTonalButton {
};
MdFilledTonalButton.styles = [
  styles$P,
  styles$Q,
  styles$N
];
MdFilledTonalButton = __decorate([
  t$3("md-filled-tonal-button")
], MdFilledTonalButton);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class OutlinedButton extends Button$1 {
  renderElevationOrOutline() {
    return x$1`<div class="outline"></div>`;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$M = i$4`:host{--_container-height: var(--md-outlined-button-container-height, 40px);--_disabled-label-text-color: var(--md-outlined-button-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-outlined-button-disabled-label-text-opacity, 0.38);--_disabled-outline-color: var(--md-outlined-button-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-outlined-button-disabled-outline-opacity, 0.12);--_focus-label-text-color: var(--md-outlined-button-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-label-text-color: var(--md-outlined-button-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-outlined-button-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-outlined-button-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-outlined-button-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-font: var(--md-outlined-button-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-outlined-button-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-outlined-button-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-outlined-button-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_outline-color: var(--md-outlined-button-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-outlined-button-outline-width, 1px);--_pressed-label-text-color: var(--md-outlined-button-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_pressed-outline-color: var(--md-outlined-button-pressed-outline-color, var(--md-sys-color-outline, #79747e));--_pressed-state-layer-color: var(--md-outlined-button-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-outlined-button-pressed-state-layer-opacity, 0.12);--_disabled-icon-color: var(--md-outlined-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-outlined-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-outlined-button-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-icon-color: var(--md-outlined-button-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-color: var(--md-outlined-button-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-outlined-button-icon-size, 18px);--_pressed-icon-color: var(--md-outlined-button-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-outlined-button-container-shape-start-start, var(--md-outlined-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-outlined-button-container-shape-start-end, var(--md-outlined-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-outlined-button-container-shape-end-end, var(--md-outlined-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-outlined-button-container-shape-end-start, var(--md-outlined-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_leading-space: var(--md-outlined-button-leading-space, 24px);--_trailing-space: var(--md-outlined-button-trailing-space, 24px);--_with-leading-icon-leading-space: var(--md-outlined-button-with-leading-icon-leading-space, 16px);--_with-leading-icon-trailing-space: var(--md-outlined-button-with-leading-icon-trailing-space, 24px);--_with-trailing-icon-leading-space: var(--md-outlined-button-with-trailing-icon-leading-space, 24px);--_with-trailing-icon-trailing-space: var(--md-outlined-button-with-trailing-icon-trailing-space, 16px);--_container-color: none;--_disabled-container-color: none;--_disabled-container-opacity: 0}.outline{inset:0;border-style:solid;position:absolute;box-sizing:border-box;border-color:var(--_outline-color);border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end)}:host(:active) .outline{border-color:var(--_pressed-outline-color)}:host(:is([disabled],[soft-disabled])) .outline{border-color:var(--_disabled-outline-color);opacity:var(--_disabled-outline-opacity)}@media(forced-colors: active){:host(:is([disabled],[soft-disabled])) .background{border-color:GrayText}:host(:is([disabled],[soft-disabled])) .outline{opacity:1}}.outline,md-ripple{border-width:var(--_outline-width)}md-ripple{inline-size:calc(100% - 2*var(--_outline-width));block-size:calc(100% - 2*var(--_outline-width));border-style:solid;border-color:rgba(0,0,0,0)}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdOutlinedButton = class MdOutlinedButton2 extends OutlinedButton {
};
MdOutlinedButton.styles = [styles$P, styles$M];
MdOutlinedButton = __decorate([
  t$3("md-outlined-button")
], MdOutlinedButton);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class TextButton extends Button$1 {
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$L = i$4`:host{--_container-height: var(--md-text-button-container-height, 40px);--_disabled-label-text-color: var(--md-text-button-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-text-button-disabled-label-text-opacity, 0.38);--_focus-label-text-color: var(--md-text-button-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-label-text-color: var(--md-text-button-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-text-button-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-text-button-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-text-button-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-font: var(--md-text-button-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-text-button-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-text-button-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-text-button-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-label-text-color: var(--md-text-button-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-text-button-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-text-button-pressed-state-layer-opacity, 0.12);--_disabled-icon-color: var(--md-text-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-text-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-text-button-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-icon-color: var(--md-text-button-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-color: var(--md-text-button-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-text-button-icon-size, 18px);--_pressed-icon-color: var(--md-text-button-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-text-button-container-shape-start-start, var(--md-text-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-text-button-container-shape-start-end, var(--md-text-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-text-button-container-shape-end-end, var(--md-text-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-text-button-container-shape-end-start, var(--md-text-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_leading-space: var(--md-text-button-leading-space, 12px);--_trailing-space: var(--md-text-button-trailing-space, 12px);--_with-leading-icon-leading-space: var(--md-text-button-with-leading-icon-leading-space, 12px);--_with-leading-icon-trailing-space: var(--md-text-button-with-leading-icon-trailing-space, 16px);--_with-trailing-icon-leading-space: var(--md-text-button-with-trailing-icon-leading-space, 16px);--_with-trailing-icon-trailing-space: var(--md-text-button-with-trailing-icon-trailing-space, 12px);--_container-color: none;--_disabled-container-color: none;--_disabled-container-opacity: 0}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdTextButton = class MdTextButton2 extends TextButton {
};
MdTextButton.styles = [styles$P, styles$L];
MdTextButton = __decorate([
  t$3("md-text-button")
], MdTextButton);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function redispatchEvent(element, event) {
  if (event.bubbles && (!element.shadowRoot || event.composed)) {
    event.stopPropagation();
  }
  const copy = Reflect.construct(event.constructor, [event.type, event]);
  const dispatched = element.dispatchEvent(copy);
  if (!dispatched) {
    event.preventDefault();
  }
  return dispatched;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const createValidator = Symbol("createValidator");
const getValidityAnchor = Symbol("getValidityAnchor");
const privateValidator = Symbol("privateValidator");
const privateSyncValidity = Symbol("privateSyncValidity");
const privateCustomValidationMessage = Symbol("privateCustomValidationMessage");
function mixinConstraintValidation(base) {
  var _a2;
  class ConstraintValidationElement extends base {
    constructor() {
      super(...arguments);
      this[_a2] = "";
    }
    get validity() {
      this[privateSyncValidity]();
      return this[internals].validity;
    }
    get validationMessage() {
      this[privateSyncValidity]();
      return this[internals].validationMessage;
    }
    get willValidate() {
      this[privateSyncValidity]();
      return this[internals].willValidate;
    }
    checkValidity() {
      this[privateSyncValidity]();
      return this[internals].checkValidity();
    }
    reportValidity() {
      this[privateSyncValidity]();
      return this[internals].reportValidity();
    }
    setCustomValidity(error2) {
      this[privateCustomValidationMessage] = error2;
      this[privateSyncValidity]();
    }
    requestUpdate(name2, oldValue, options) {
      super.requestUpdate(name2, oldValue, options);
      this[privateSyncValidity]();
    }
    firstUpdated(changed) {
      super.firstUpdated(changed);
      this[privateSyncValidity]();
    }
    [(_a2 = privateCustomValidationMessage, privateSyncValidity)]() {
      if (!this[privateValidator]) {
        this[privateValidator] = this[createValidator]();
      }
      const { validity, validationMessage: nonCustomValidationMessage } = this[privateValidator].getValidity();
      const customError = !!this[privateCustomValidationMessage];
      const validationMessage = this[privateCustomValidationMessage] || nonCustomValidationMessage;
      this[internals].setValidity({ ...validity, customError }, validationMessage, this[getValidityAnchor]() ?? void 0);
    }
    [createValidator]() {
      throw new Error("Implement [createValidator]");
    }
    [getValidityAnchor]() {
      throw new Error("Implement [getValidityAnchor]");
    }
  }
  return ConstraintValidationElement;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const getFormValue = Symbol("getFormValue");
const getFormState = Symbol("getFormState");
function mixinFormAssociated(base) {
  class FormAssociatedElement extends base {
    get form() {
      return this[internals].form;
    }
    get labels() {
      return this[internals].labels;
    }
    // Use @property for the `name` and `disabled` properties to add them to the
    // `observedAttributes` array and trigger `attributeChangedCallback()`.
    //
    // We don't use Lit's default getter/setter (`noAccessor: true`) because
    // the attributes need to be updated synchronously to work with synchronous
    // form APIs, and Lit updates attributes async by default.
    get name() {
      return this.getAttribute("name") ?? "";
    }
    set name(name2) {
      this.setAttribute("name", name2);
    }
    get disabled() {
      return this.hasAttribute("disabled");
    }
    set disabled(disabled) {
      this.toggleAttribute("disabled", disabled);
    }
    attributeChangedCallback(name2, old, value) {
      if (name2 === "name" || name2 === "disabled") {
        const oldValue = name2 === "disabled" ? old !== null : old;
        this.requestUpdate(name2, oldValue);
        return;
      }
      super.attributeChangedCallback(name2, old, value);
    }
    requestUpdate(name2, oldValue, options) {
      super.requestUpdate(name2, oldValue, options);
      this[internals].setFormValue(this[getFormValue](), this[getFormState]());
    }
    [getFormValue]() {
      throw new Error("Implement [getFormValue]");
    }
    [getFormState]() {
      return this[getFormValue]();
    }
    formDisabledCallback(disabled) {
      this.disabled = disabled;
    }
  }
  FormAssociatedElement.formAssociated = true;
  __decorate([
    n$5({ noAccessor: true })
  ], FormAssociatedElement.prototype, "name", null);
  __decorate([
    n$5({ type: Boolean, noAccessor: true })
  ], FormAssociatedElement.prototype, "disabled", null);
  return FormAssociatedElement;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Validator {
  /**
   * Creates a new validator.
   *
   * @param getCurrentState A callback that returns the current state of
   *     constraint validation-related properties.
   */
  constructor(getCurrentState) {
    this.getCurrentState = getCurrentState;
    this.currentValidity = {
      validity: {},
      validationMessage: ""
    };
  }
  /**
   * Returns the current `ValidityStateFlags` and validation message for the
   * validator.
   *
   * If the constraint validation state has not changed, this will return a
   * cached result. This is important since `getValidity()` can be called
   * frequently in response to synchronous property changes.
   *
   * @return The current validity and validation message.
   */
  getValidity() {
    const state = this.getCurrentState();
    const hasStateChanged = !this.prevState || !this.equals(this.prevState, state);
    if (!hasStateChanged) {
      return this.currentValidity;
    }
    const { validity, validationMessage } = this.computeValidity(state);
    this.prevState = this.copy(state);
    this.currentValidity = {
      validationMessage,
      validity: {
        // Change any `ValidityState` instances into `ValidityStateFlags` since
        // `ValidityState` cannot be easily `{...spread}`.
        badInput: validity.badInput,
        customError: validity.customError,
        patternMismatch: validity.patternMismatch,
        rangeOverflow: validity.rangeOverflow,
        rangeUnderflow: validity.rangeUnderflow,
        stepMismatch: validity.stepMismatch,
        tooLong: validity.tooLong,
        tooShort: validity.tooShort,
        typeMismatch: validity.typeMismatch,
        valueMissing: validity.valueMissing
      }
    };
    return this.currentValidity;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class CheckboxValidator extends Validator {
  computeValidity(state) {
    if (!this.checkboxControl) {
      this.checkboxControl = document.createElement("input");
      this.checkboxControl.type = "checkbox";
    }
    this.checkboxControl.checked = state.checked;
    this.checkboxControl.required = state.required;
    return {
      validity: this.checkboxControl.validity,
      validationMessage: this.checkboxControl.validationMessage
    };
  }
  equals(prev, next) {
    return prev.checked === next.checked && prev.required === next.required;
  }
  copy({ checked, required }) {
    return { checked, required };
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const checkboxBaseClass = mixinDelegatesAria(mixinConstraintValidation(mixinFormAssociated(mixinElementInternals(s$1))));
class Checkbox extends checkboxBaseClass {
  constructor() {
    super();
    this.checked = false;
    this.indeterminate = false;
    this.required = false;
    this.value = "on";
    this.prevChecked = false;
    this.prevDisabled = false;
    this.prevIndeterminate = false;
    {
      this.addEventListener("click", (event) => {
        if (!isActivationClick(event) || !this.input) {
          return;
        }
        this.focus();
        dispatchActivationClick(this.input);
      });
    }
  }
  update(changed) {
    if (changed.has("checked") || changed.has("disabled") || changed.has("indeterminate")) {
      this.prevChecked = changed.get("checked") ?? this.checked;
      this.prevDisabled = changed.get("disabled") ?? this.disabled;
      this.prevIndeterminate = changed.get("indeterminate") ?? this.indeterminate;
    }
    super.update(changed);
  }
  render() {
    const prevNone = !this.prevChecked && !this.prevIndeterminate;
    const prevChecked = this.prevChecked && !this.prevIndeterminate;
    const prevIndeterminate = this.prevIndeterminate;
    const isChecked = this.checked && !this.indeterminate;
    const isIndeterminate = this.indeterminate;
    const containerClasses = e$1({
      "disabled": this.disabled,
      "selected": isChecked || isIndeterminate,
      "unselected": !isChecked && !isIndeterminate,
      "checked": isChecked,
      "indeterminate": isIndeterminate,
      "prev-unselected": prevNone,
      "prev-checked": prevChecked,
      "prev-indeterminate": prevIndeterminate,
      "prev-disabled": this.prevDisabled
    });
    const { ariaLabel, ariaInvalid } = this;
    return x$1`
      <div class="container ${containerClasses}">
        <input
          type="checkbox"
          id="input"
          aria-checked=${isIndeterminate ? "mixed" : T$1}
          aria-label=${ariaLabel || T$1}
          aria-invalid=${ariaInvalid || T$1}
          ?disabled=${this.disabled}
          ?required=${this.required}
          .indeterminate=${this.indeterminate}
          .checked=${this.checked}
          @input=${this.handleInput}
          @change=${this.handleChange} />

        <div class="outline"></div>
        <div class="background"></div>
        <md-focus-ring part="focus-ring" for="input"></md-focus-ring>
        <md-ripple for="input" ?disabled=${this.disabled}></md-ripple>
        <svg class="icon" viewBox="0 0 18 18" aria-hidden="true">
          <rect class="mark short" />
          <rect class="mark long" />
        </svg>
      </div>
    `;
  }
  handleInput(event) {
    const target = event.target;
    this.checked = target.checked;
    this.indeterminate = target.indeterminate;
  }
  handleChange(event) {
    redispatchEvent(this, event);
  }
  [getFormValue]() {
    if (!this.checked || this.indeterminate) {
      return null;
    }
    return this.value;
  }
  [getFormState]() {
    return String(this.checked);
  }
  formResetCallback() {
    this.checked = this.hasAttribute("checked");
  }
  formStateRestoreCallback(state) {
    this.checked = state === "true";
  }
  [createValidator]() {
    return new CheckboxValidator(() => this);
  }
  [getValidityAnchor]() {
    return this.input;
  }
}
Checkbox.shadowRootOptions = {
  ...s$1.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean })
], Checkbox.prototype, "checked", void 0);
__decorate([
  n$5({ type: Boolean })
], Checkbox.prototype, "indeterminate", void 0);
__decorate([
  n$5({ type: Boolean })
], Checkbox.prototype, "required", void 0);
__decorate([
  n$5()
], Checkbox.prototype, "value", void 0);
__decorate([
  r$4()
], Checkbox.prototype, "prevChecked", void 0);
__decorate([
  r$4()
], Checkbox.prototype, "prevDisabled", void 0);
__decorate([
  r$4()
], Checkbox.prototype, "prevIndeterminate", void 0);
__decorate([
  e$5("input")
], Checkbox.prototype, "input", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$K = i$4`:host{border-start-start-radius:var(--md-checkbox-container-shape-start-start, var(--md-checkbox-container-shape, 2px));border-start-end-radius:var(--md-checkbox-container-shape-start-end, var(--md-checkbox-container-shape, 2px));border-end-end-radius:var(--md-checkbox-container-shape-end-end, var(--md-checkbox-container-shape, 2px));border-end-start-radius:var(--md-checkbox-container-shape-end-start, var(--md-checkbox-container-shape, 2px));display:inline-flex;height:var(--md-checkbox-container-size, 18px);position:relative;vertical-align:top;width:var(--md-checkbox-container-size, 18px);-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer}:host([disabled]){cursor:default}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--md-checkbox-container-size, 18px))/2)}md-focus-ring{height:44px;inset:unset;width:44px}input{appearance:none;height:48px;margin:0;opacity:0;outline:none;position:absolute;width:48px;z-index:1;cursor:inherit}:host([touch-target=none]) input{height:100%;width:100%}.container{border-radius:inherit;display:flex;height:100%;place-content:center;place-items:center;position:relative;width:100%}.outline,.background,.icon{inset:0;position:absolute}.outline,.background{border-radius:inherit}.outline{border-color:var(--md-checkbox-outline-color, var(--md-sys-color-on-surface-variant, #49454f));border-style:solid;border-width:var(--md-checkbox-outline-width, 2px);box-sizing:border-box}.background{background-color:var(--md-checkbox-selected-container-color, var(--md-sys-color-primary, #6750a4))}.background,.icon{opacity:0;transition-duration:150ms,50ms;transition-property:transform,opacity;transition-timing-function:cubic-bezier(0.3, 0, 0.8, 0.15),linear;transform:scale(0.6)}:where(.selected) :is(.background,.icon){opacity:1;transition-duration:350ms,50ms;transition-timing-function:cubic-bezier(0.05, 0.7, 0.1, 1),linear;transform:scale(1)}md-ripple{border-radius:var(--md-checkbox-state-layer-shape, var(--md-sys-shape-corner-full, 9999px));height:var(--md-checkbox-state-layer-size, 40px);inset:unset;width:var(--md-checkbox-state-layer-size, 40px);--md-ripple-hover-color: var(--md-checkbox-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-hover-opacity: var(--md-checkbox-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-checkbox-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-pressed-opacity: var(--md-checkbox-pressed-state-layer-opacity, 0.12)}.selected md-ripple{--md-ripple-hover-color: var(--md-checkbox-selected-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-hover-opacity: var(--md-checkbox-selected-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-checkbox-selected-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-pressed-opacity: var(--md-checkbox-selected-pressed-state-layer-opacity, 0.12)}.icon{fill:var(--md-checkbox-selected-icon-color, var(--md-sys-color-on-primary, #fff));height:var(--md-checkbox-icon-size, 18px);width:var(--md-checkbox-icon-size, 18px)}.mark.short{height:2px;transition-property:transform,height;width:2px}.mark.long{height:2px;transition-property:transform,width;width:10px}.mark{animation-duration:150ms;animation-timing-function:cubic-bezier(0.3, 0, 0.8, 0.15);transition-duration:150ms;transition-timing-function:cubic-bezier(0.3, 0, 0.8, 0.15)}.selected .mark{animation-duration:350ms;animation-timing-function:cubic-bezier(0.05, 0.7, 0.1, 1);transition-duration:350ms;transition-timing-function:cubic-bezier(0.05, 0.7, 0.1, 1)}.checked .mark,.prev-checked.unselected .mark{transform:scaleY(-1) translate(7px, -14px) rotate(45deg)}.checked .mark.short,.prev-checked.unselected .mark.short{height:5.6568542495px}.checked .mark.long,.prev-checked.unselected .mark.long{width:11.313708499px}.indeterminate .mark,.prev-indeterminate.unselected .mark{transform:scaleY(-1) translate(4px, -10px) rotate(0deg)}.prev-unselected .mark{transition-property:none}.prev-unselected.checked .mark.long{animation-name:prev-unselected-to-checked}@keyframes prev-unselected-to-checked{from{width:0}}:where(:hover) .outline{border-color:var(--md-checkbox-hover-outline-color, var(--md-sys-color-on-surface, #1d1b20));border-width:var(--md-checkbox-hover-outline-width, 2px)}:where(:hover) .background{background:var(--md-checkbox-selected-hover-container-color, var(--md-sys-color-primary, #6750a4))}:where(:hover) .icon{fill:var(--md-checkbox-selected-hover-icon-color, var(--md-sys-color-on-primary, #fff))}:where(:focus-within) .outline{border-color:var(--md-checkbox-focus-outline-color, var(--md-sys-color-on-surface, #1d1b20));border-width:var(--md-checkbox-focus-outline-width, 2px)}:where(:focus-within) .background{background:var(--md-checkbox-selected-focus-container-color, var(--md-sys-color-primary, #6750a4))}:where(:focus-within) .icon{fill:var(--md-checkbox-selected-focus-icon-color, var(--md-sys-color-on-primary, #fff))}:where(:active) .outline{border-color:var(--md-checkbox-pressed-outline-color, var(--md-sys-color-on-surface, #1d1b20));border-width:var(--md-checkbox-pressed-outline-width, 2px)}:where(:active) .background{background:var(--md-checkbox-selected-pressed-container-color, var(--md-sys-color-primary, #6750a4))}:where(:active) .icon{fill:var(--md-checkbox-selected-pressed-icon-color, var(--md-sys-color-on-primary, #fff))}:where(.disabled,.prev-disabled) :is(.background,.icon,.mark){animation-duration:0s;transition-duration:0s}:where(.disabled) .outline{border-color:var(--md-checkbox-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));border-width:var(--md-checkbox-disabled-outline-width, 2px);opacity:var(--md-checkbox-disabled-container-opacity, 0.38)}:where(.selected.disabled) .outline{visibility:hidden}:where(.selected.disabled) .background{background:var(--md-checkbox-selected-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-checkbox-selected-disabled-container-opacity, 0.38)}:where(.disabled) .icon{fill:var(--md-checkbox-selected-disabled-icon-color, var(--md-sys-color-surface, #fef7ff))}@media(forced-colors: active){.background{background-color:CanvasText}.selected.disabled .background{background-color:GrayText;opacity:1}.outline{border-color:CanvasText}.disabled .outline{border-color:GrayText;opacity:1}.icon{fill:Canvas}}
`;
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdCheckbox = class MdCheckbox2 extends Checkbox {
};
MdCheckbox.styles = [styles$K];
MdCheckbox = __decorate([
  t$3("md-checkbox")
], MdCheckbox);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const chipBaseClass = mixinDelegatesAria(s$1);
class Chip extends chipBaseClass {
  /**
   * Whether or not the primary ripple is disabled (defaults to `disabled`).
   * Some chip actions such as links cannot be disabled.
   */
  get rippleDisabled() {
    return this.disabled || this.softDisabled;
  }
  constructor() {
    super();
    this.disabled = false;
    this.softDisabled = false;
    this.alwaysFocusable = false;
    this.label = "";
    this.hasIcon = false;
    {
      this.addEventListener("click", this.handleClick.bind(this));
    }
  }
  focus(options) {
    if (this.disabled && !this.alwaysFocusable) {
      return;
    }
    super.focus(options);
  }
  render() {
    return x$1`
      <div class="container ${e$1(this.getContainerClasses())}">
        ${this.renderContainerContent()}
      </div>
    `;
  }
  updated(changed) {
    if (changed.has("disabled") && changed.get("disabled") !== void 0) {
      this.dispatchEvent(new Event("update-focus", { bubbles: true }));
    }
  }
  getContainerClasses() {
    return {
      "disabled": this.disabled || this.softDisabled,
      "has-icon": this.hasIcon
    };
  }
  renderContainerContent() {
    return x$1`
      ${this.renderOutline()}
      <md-focus-ring part="focus-ring" for=${this.primaryId}></md-focus-ring>
      <md-ripple
        for=${this.primaryId}
        ?disabled=${this.rippleDisabled}></md-ripple>
      ${this.renderPrimaryAction(this.renderPrimaryContent())}
    `;
  }
  renderOutline() {
    return x$1`<span class="outline"></span>`;
  }
  renderLeadingIcon() {
    return x$1`<slot name="icon" @slotchange=${this.handleIconChange}></slot>`;
  }
  renderPrimaryContent() {
    return x$1`
      <span class="leading icon" aria-hidden="true">
        ${this.renderLeadingIcon()}
      </span>
      <span class="label">
        <span class="label-text" id="label">
          ${this.label ? this.label : x$1`<slot></slot>`}
        </span>
      </span>
      <span class="touch"></span>
    `;
  }
  handleIconChange(event) {
    const slot = event.target;
    this.hasIcon = slot.assignedElements({ flatten: true }).length > 0;
  }
  handleClick(event) {
    if (this.softDisabled || this.disabled && this.alwaysFocusable) {
      event.stopImmediatePropagation();
      event.preventDefault();
      return;
    }
  }
}
Chip.shadowRootOptions = {
  ...s$1.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], Chip.prototype, "disabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "soft-disabled", reflect: true })
], Chip.prototype, "softDisabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "always-focusable" })
], Chip.prototype, "alwaysFocusable", void 0);
__decorate([
  n$5()
], Chip.prototype, "label", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "has-icon" })
], Chip.prototype, "hasIcon", void 0);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class AssistChip extends Chip {
  constructor() {
    super(...arguments);
    this.elevated = false;
    this.href = "";
    this.target = "";
  }
  get primaryId() {
    return this.href ? "link" : "button";
  }
  get rippleDisabled() {
    return !this.href && (this.disabled || this.softDisabled);
  }
  getContainerClasses() {
    return {
      ...super.getContainerClasses(),
      // Link chips cannot be disabled
      disabled: !this.href && (this.disabled || this.softDisabled),
      elevated: this.elevated,
      link: !!this.href
    };
  }
  renderPrimaryAction(content) {
    const { ariaLabel } = this;
    if (this.href) {
      return x$1`
        <a
          class="primary action"
          id="link"
          aria-label=${ariaLabel || T$1}
          href=${this.href}
          target=${this.target || T$1}
          >${content}</a
        >
      `;
    }
    return x$1`
      <button
        class="primary action"
        id="button"
        aria-label=${ariaLabel || T$1}
        aria-disabled=${this.softDisabled || T$1}
        ?disabled=${this.disabled && !this.alwaysFocusable}
        type="button"
        >${content}</button
      >
    `;
  }
  renderOutline() {
    if (this.elevated) {
      return x$1`<md-elevation part="elevation"></md-elevation>`;
    }
    return super.renderOutline();
  }
}
__decorate([
  n$5({ type: Boolean })
], AssistChip.prototype, "elevated", void 0);
__decorate([
  n$5()
], AssistChip.prototype, "href", void 0);
__decorate([
  n$5()
], AssistChip.prototype, "target", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$J = i$4`:host{--_container-height: var(--md-assist-chip-container-height, 32px);--_disabled-label-text-color: var(--md-assist-chip-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-assist-chip-disabled-label-text-opacity, 0.38);--_elevated-container-color: var(--md-assist-chip-elevated-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_elevated-container-elevation: var(--md-assist-chip-elevated-container-elevation, 1);--_elevated-container-shadow-color: var(--md-assist-chip-elevated-container-shadow-color, var(--md-sys-color-shadow, #000));--_elevated-disabled-container-color: var(--md-assist-chip-elevated-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_elevated-disabled-container-elevation: var(--md-assist-chip-elevated-disabled-container-elevation, 0);--_elevated-disabled-container-opacity: var(--md-assist-chip-elevated-disabled-container-opacity, 0.12);--_elevated-focus-container-elevation: var(--md-assist-chip-elevated-focus-container-elevation, 1);--_elevated-hover-container-elevation: var(--md-assist-chip-elevated-hover-container-elevation, 2);--_elevated-pressed-container-elevation: var(--md-assist-chip-elevated-pressed-container-elevation, 1);--_focus-label-text-color: var(--md-assist-chip-focus-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-assist-chip-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-color: var(--md-assist-chip-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-opacity: var(--md-assist-chip-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-assist-chip-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_label-text-font: var(--md-assist-chip-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-assist-chip-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-assist-chip-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-assist-chip-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-label-text-color: var(--md-assist-chip-pressed-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_pressed-state-layer-color: var(--md-assist-chip-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_pressed-state-layer-opacity: var(--md-assist-chip-pressed-state-layer-opacity, 0.12);--_disabled-outline-color: var(--md-assist-chip-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-assist-chip-disabled-outline-opacity, 0.12);--_focus-outline-color: var(--md-assist-chip-focus-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_outline-color: var(--md-assist-chip-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-assist-chip-outline-width, 1px);--_disabled-leading-icon-color: var(--md-assist-chip-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-assist-chip-disabled-leading-icon-opacity, 0.38);--_focus-leading-icon-color: var(--md-assist-chip-focus-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-leading-icon-color: var(--md-assist-chip-hover-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_leading-icon-color: var(--md-assist-chip-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-assist-chip-icon-size, 18px);--_pressed-leading-icon-color: var(--md-assist-chip-pressed-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-assist-chip-container-shape-start-start, var(--md-assist-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-start-end: var(--md-assist-chip-container-shape-start-end, var(--md-assist-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-end: var(--md-assist-chip-container-shape-end-end, var(--md-assist-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-start: var(--md-assist-chip-container-shape-end-start, var(--md-assist-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_leading-space: var(--md-assist-chip-leading-space, 16px);--_trailing-space: var(--md-assist-chip-trailing-space, 16px);--_icon-label-space: var(--md-assist-chip-icon-label-space, 8px);--_with-leading-icon-leading-space: var(--md-assist-chip-with-leading-icon-leading-space, 8px)}@media(forced-colors: active){.link .outline{border-color:ActiveText}}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$I = i$4`.elevated{--md-elevation-level: var(--_elevated-container-elevation);--md-elevation-shadow-color: var(--_elevated-container-shadow-color)}.elevated::before{background:var(--_elevated-container-color)}.elevated:hover{--md-elevation-level: var(--_elevated-hover-container-elevation)}.elevated:focus-within{--md-elevation-level: var(--_elevated-focus-container-elevation)}.elevated:active{--md-elevation-level: var(--_elevated-pressed-container-elevation)}.elevated.disabled{--md-elevation-level: var(--_elevated-disabled-container-elevation)}.elevated.disabled::before{background:var(--_elevated-disabled-container-color);opacity:var(--_elevated-disabled-container-opacity)}@media(forced-colors: active){.elevated md-elevation{border:1px solid CanvasText}.elevated.disabled md-elevation{border-color:GrayText}}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$H = i$4`:host{border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end);display:inline-flex;height:var(--_container-height);cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}:host(:is([disabled],[soft-disabled])){pointer-events:none}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--_container-height))/2) 0}md-focus-ring{--md-focus-ring-shape-start-start: var(--_container-shape-start-start);--md-focus-ring-shape-start-end: var(--_container-shape-start-end);--md-focus-ring-shape-end-end: var(--_container-shape-end-end);--md-focus-ring-shape-end-start: var(--_container-shape-end-start)}.container{border-radius:inherit;box-sizing:border-box;display:flex;height:100%;position:relative;width:100%}.container::before{border-radius:inherit;content:"";inset:0;pointer-events:none;position:absolute}.container:not(.disabled){cursor:pointer}.container.disabled{pointer-events:none}.cell{display:flex}.action{align-items:baseline;appearance:none;background:none;border:none;border-radius:inherit;display:flex;outline:none;padding:0;position:relative;text-decoration:none}.primary.action{min-width:0;padding-inline-start:var(--_leading-space);padding-inline-end:var(--_trailing-space)}.has-icon .primary.action{padding-inline-start:var(--_with-leading-icon-leading-space)}.touch{height:48px;inset:50% 0 0;position:absolute;transform:translateY(-50%);width:100%}:host([touch-target=none]) .touch{display:none}.outline{border:var(--_outline-width) solid var(--_outline-color);border-radius:inherit;inset:0;pointer-events:none;position:absolute}:where(:focus) .outline{border-color:var(--_focus-outline-color)}:where(.disabled) .outline{border-color:var(--_disabled-outline-color);opacity:var(--_disabled-outline-opacity)}md-ripple{border-radius:inherit}.label,.icon,.touch{z-index:1}.label{align-items:center;color:var(--_label-text-color);display:flex;font-family:var(--_label-text-font);font-size:var(--_label-text-size);font-weight:var(--_label-text-weight);height:100%;line-height:var(--_label-text-line-height);overflow:hidden;user-select:none}.label-text{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(:hover) .label{color:var(--_hover-label-text-color)}:where(:focus) .label{color:var(--_focus-label-text-color)}:where(:active) .label{color:var(--_pressed-label-text-color)}:where(.disabled) .label{color:var(--_disabled-label-text-color);opacity:var(--_disabled-label-text-opacity)}.icon{align-self:center;display:flex;fill:currentColor;position:relative}.icon ::slotted(:first-child){font-size:var(--_icon-size);height:var(--_icon-size);width:var(--_icon-size)}.leading.icon{color:var(--_leading-icon-color)}.leading.icon ::slotted(*),.leading.icon svg{margin-inline-end:var(--_icon-label-space)}:where(:hover) .leading.icon{color:var(--_hover-leading-icon-color)}:where(:focus) .leading.icon{color:var(--_focus-leading-icon-color)}:where(:active) .leading.icon{color:var(--_pressed-leading-icon-color)}:where(.disabled) .leading.icon{color:var(--_disabled-leading-icon-color);opacity:var(--_disabled-leading-icon-opacity)}@media(forced-colors: active){:where(.disabled) :is(.label,.outline,.leading.icon){color:GrayText;opacity:1}}a,button{text-transform:inherit}a,button:not(:disabled,[aria-disabled=true]){cursor:inherit}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdAssistChip = class MdAssistChip2 extends AssistChip {
};
MdAssistChip.styles = [styles$H, styles$I, styles$J];
MdAssistChip = __decorate([
  t$3("md-assist-chip")
], MdAssistChip);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class ChipSet extends s$1 {
  get chips() {
    return this.childElements.filter((child) => child instanceof Chip);
  }
  constructor() {
    super();
    this.internals = // Cast needed for closure
    this.attachInternals();
    {
      this.addEventListener("focusin", this.updateTabIndices.bind(this));
      this.addEventListener("update-focus", this.updateTabIndices.bind(this));
      this.addEventListener("keydown", this.handleKeyDown.bind(this));
      this.internals.role = "toolbar";
    }
  }
  render() {
    return x$1`<slot @slotchange=${this.updateTabIndices}></slot>`;
  }
  handleKeyDown(event) {
    const isLeft = event.key === "ArrowLeft";
    const isRight = event.key === "ArrowRight";
    const isHome = event.key === "Home";
    const isEnd = event.key === "End";
    if (!isLeft && !isRight && !isHome && !isEnd) {
      return;
    }
    const { chips } = this;
    if (chips.length < 2) {
      return;
    }
    event.preventDefault();
    if (isHome || isEnd) {
      const index = isHome ? 0 : chips.length - 1;
      chips[index].focus({ trailing: isEnd });
      this.updateTabIndices();
      return;
    }
    const isRtl2 = getComputedStyle(this).direction === "rtl";
    const forwards = isRtl2 ? isLeft : isRight;
    const focusedChip = chips.find((chip) => chip.matches(":focus-within"));
    if (!focusedChip) {
      const nextChip = forwards ? chips[0] : chips[chips.length - 1];
      nextChip.focus({ trailing: !forwards });
      this.updateTabIndices();
      return;
    }
    const currentIndex = chips.indexOf(focusedChip);
    let nextIndex = forwards ? currentIndex + 1 : currentIndex - 1;
    while (nextIndex !== currentIndex) {
      if (nextIndex >= chips.length) {
        nextIndex = 0;
      } else if (nextIndex < 0) {
        nextIndex = chips.length - 1;
      }
      const nextChip = chips[nextIndex];
      if (nextChip.disabled && !nextChip.alwaysFocusable) {
        if (forwards) {
          nextIndex++;
        } else {
          nextIndex--;
        }
        continue;
      }
      nextChip.focus({ trailing: !forwards });
      this.updateTabIndices();
      break;
    }
  }
  updateTabIndices() {
    const { chips } = this;
    let chipToFocus;
    for (const chip of chips) {
      const isChipFocusable = chip.alwaysFocusable || !chip.disabled;
      const chipIsFocused = chip.matches(":focus-within");
      if (chipIsFocused && isChipFocusable) {
        chipToFocus = chip;
        continue;
      }
      if (isChipFocusable && !chipToFocus) {
        chipToFocus = chip;
      }
      chip.tabIndex = -1;
    }
    if (chipToFocus) {
      chipToFocus.tabIndex = 0;
    }
  }
}
__decorate([
  o$4()
], ChipSet.prototype, "childElements", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$G = i$4`:host{display:flex;flex-wrap:wrap;gap:8px}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdChipSet = class MdChipSet2 extends ChipSet {
};
MdChipSet.styles = [styles$G];
MdChipSet = __decorate([
  t$3("md-chip-set")
], MdChipSet);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const ARIA_LABEL_REMOVE = "aria-label-remove";
class MultiActionChip extends Chip {
  get ariaLabelRemove() {
    if (this.hasAttribute(ARIA_LABEL_REMOVE)) {
      return this.getAttribute(ARIA_LABEL_REMOVE);
    }
    const { ariaLabel } = this;
    if (ariaLabel || this.label) {
      return `Remove ${ariaLabel || this.label}`;
    }
    return null;
  }
  set ariaLabelRemove(ariaLabel) {
    const prev = this.ariaLabelRemove;
    if (ariaLabel === prev) {
      return;
    }
    if (ariaLabel === null) {
      this.removeAttribute(ARIA_LABEL_REMOVE);
    } else {
      this.setAttribute(ARIA_LABEL_REMOVE, ariaLabel);
    }
    this.requestUpdate();
  }
  constructor() {
    super();
    this.handleTrailingActionFocus = this.handleTrailingActionFocus.bind(this);
    {
      this.addEventListener("keydown", this.handleKeyDown.bind(this));
    }
  }
  focus(options) {
    const isFocusable2 = this.alwaysFocusable || !this.disabled;
    if (isFocusable2 && options?.trailing && this.trailingAction) {
      this.trailingAction.focus(options);
      return;
    }
    super.focus(options);
  }
  renderContainerContent() {
    return x$1`
      ${super.renderContainerContent()}
      ${this.renderTrailingAction(this.handleTrailingActionFocus)}
    `;
  }
  handleKeyDown(event) {
    const isLeft = event.key === "ArrowLeft";
    const isRight = event.key === "ArrowRight";
    if (!isLeft && !isRight) {
      return;
    }
    if (!this.primaryAction || !this.trailingAction) {
      return;
    }
    const isRtl2 = getComputedStyle(this).direction === "rtl";
    const forwards = isRtl2 ? isLeft : isRight;
    const isPrimaryFocused = this.primaryAction?.matches(":focus-within");
    const isTrailingFocused = this.trailingAction?.matches(":focus-within");
    if (forwards && isTrailingFocused || !forwards && isPrimaryFocused) {
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    const actionToFocus = forwards ? this.trailingAction : this.primaryAction;
    actionToFocus.focus();
  }
  handleTrailingActionFocus() {
    const { primaryAction, trailingAction } = this;
    if (!primaryAction || !trailingAction) {
      return;
    }
    primaryAction.tabIndex = -1;
    trailingAction.addEventListener("focusout", () => {
      primaryAction.tabIndex = 0;
    }, { once: true });
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function renderRemoveButton({ ariaLabel, disabled, focusListener, tabbable = false }) {
  return x$1`
    <span id="remove-label" hidden aria-hidden="true">Remove</span>
    <button
      class="trailing action"
      aria-label=${ariaLabel || T$1}
      aria-labelledby=${!ariaLabel ? "remove-label label" : T$1}
      tabindex=${!tabbable ? -1 : T$1}
      @click=${handleRemoveClick}
      @focus=${focusListener}>
      <md-focus-ring part="trailing-focus-ring"></md-focus-ring>
      <md-ripple ?disabled=${disabled}></md-ripple>
      <span class="trailing icon" aria-hidden="true">
        <slot name="remove-trailing-icon">
          <svg viewBox="0 96 960 960">
            <path
              d="m249 849-42-42 231-231-231-231 42-42 231 231 231-231 42 42-231 231 231 231-42 42-231-231-231 231Z" />
          </svg>
        </slot>
      </span>
      <span class="touch"></span>
    </button>
  `;
}
function handleRemoveClick(event) {
  if (this.disabled || this.softDisabled) {
    return;
  }
  event.stopPropagation();
  const preventDefault = !this.dispatchEvent(new Event("remove", { cancelable: true }));
  if (preventDefault) {
    return;
  }
  this.remove();
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class FilterChip extends MultiActionChip {
  constructor() {
    super(...arguments);
    this.elevated = false;
    this.removable = false;
    this.selected = false;
    this.hasSelectedIcon = false;
  }
  get primaryId() {
    return "button";
  }
  getContainerClasses() {
    return {
      ...super.getContainerClasses(),
      elevated: this.elevated,
      selected: this.selected,
      "has-trailing": this.removable,
      "has-icon": this.hasIcon || this.selected
    };
  }
  renderPrimaryAction(content) {
    const { ariaLabel } = this;
    return x$1`
      <button
        class="primary action"
        id="button"
        aria-label=${ariaLabel || T$1}
        aria-pressed=${this.selected}
        aria-disabled=${this.softDisabled || T$1}
        ?disabled=${this.disabled && !this.alwaysFocusable}
        @click=${this.handleClickOnChild}
        >${content}</button
      >
    `;
  }
  renderLeadingIcon() {
    if (!this.selected) {
      return super.renderLeadingIcon();
    }
    return x$1`
      <slot name="selected-icon">
        <svg class="checkmark" viewBox="0 0 18 18" aria-hidden="true">
          <path
            d="M6.75012 12.1274L3.62262 8.99988L2.55762 10.0574L6.75012 14.2499L15.7501 5.24988L14.6926 4.19238L6.75012 12.1274Z" />
        </svg>
      </slot>
    `;
  }
  renderTrailingAction(focusListener) {
    if (this.removable) {
      return renderRemoveButton({
        focusListener,
        ariaLabel: this.ariaLabelRemove,
        disabled: this.disabled || this.softDisabled
      });
    }
    return T$1;
  }
  renderOutline() {
    if (this.elevated) {
      return x$1`<md-elevation part="elevation"></md-elevation>`;
    }
    return super.renderOutline();
  }
  handleClickOnChild(event) {
    if (this.disabled || this.softDisabled) {
      return;
    }
    const prevValue = this.selected;
    this.selected = !this.selected;
    const preventDefault = !redispatchEvent(this, event);
    if (preventDefault) {
      this.selected = prevValue;
      return;
    }
  }
}
__decorate([
  n$5({ type: Boolean })
], FilterChip.prototype, "elevated", void 0);
__decorate([
  n$5({ type: Boolean })
], FilterChip.prototype, "removable", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], FilterChip.prototype, "selected", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "has-selected-icon" })
], FilterChip.prototype, "hasSelectedIcon", void 0);
__decorate([
  e$5(".primary.action")
], FilterChip.prototype, "primaryAction", void 0);
__decorate([
  e$5(".trailing.action")
], FilterChip.prototype, "trailingAction", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$F = i$4`:host{--_container-height: var(--md-filter-chip-container-height, 32px);--_disabled-label-text-color: var(--md-filter-chip-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-filter-chip-disabled-label-text-opacity, 0.38);--_elevated-container-elevation: var(--md-filter-chip-elevated-container-elevation, 1);--_elevated-container-shadow-color: var(--md-filter-chip-elevated-container-shadow-color, var(--md-sys-color-shadow, #000));--_elevated-disabled-container-color: var(--md-filter-chip-elevated-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_elevated-disabled-container-elevation: var(--md-filter-chip-elevated-disabled-container-elevation, 0);--_elevated-disabled-container-opacity: var(--md-filter-chip-elevated-disabled-container-opacity, 0.12);--_elevated-focus-container-elevation: var(--md-filter-chip-elevated-focus-container-elevation, 1);--_elevated-hover-container-elevation: var(--md-filter-chip-elevated-hover-container-elevation, 2);--_elevated-pressed-container-elevation: var(--md-filter-chip-elevated-pressed-container-elevation, 1);--_elevated-selected-container-color: var(--md-filter-chip-elevated-selected-container-color, var(--md-sys-color-secondary-container, #e8def8));--_label-text-font: var(--md-filter-chip-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-filter-chip-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-filter-chip-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-filter-chip-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_selected-focus-label-text-color: var(--md-filter-chip-selected-focus-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-label-text-color: var(--md-filter-chip-selected-hover-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-state-layer-color: var(--md-filter-chip-selected-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-state-layer-opacity: var(--md-filter-chip-selected-hover-state-layer-opacity, 0.08);--_selected-label-text-color: var(--md-filter-chip-selected-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-label-text-color: var(--md-filter-chip-selected-pressed-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-state-layer-color: var(--md-filter-chip-selected-pressed-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_selected-pressed-state-layer-opacity: var(--md-filter-chip-selected-pressed-state-layer-opacity, 0.12);--_elevated-container-color: var(--md-filter-chip-elevated-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_disabled-outline-color: var(--md-filter-chip-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-filter-chip-disabled-outline-opacity, 0.12);--_disabled-selected-container-color: var(--md-filter-chip-disabled-selected-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-selected-container-opacity: var(--md-filter-chip-disabled-selected-container-opacity, 0.12);--_focus-outline-color: var(--md-filter-chip-focus-outline-color, var(--md-sys-color-on-surface-variant, #49454f));--_outline-color: var(--md-filter-chip-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-filter-chip-outline-width, 1px);--_selected-container-color: var(--md-filter-chip-selected-container-color, var(--md-sys-color-secondary-container, #e8def8));--_selected-outline-width: var(--md-filter-chip-selected-outline-width, 0px);--_focus-label-text-color: var(--md-filter-chip-focus-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-label-text-color: var(--md-filter-chip-hover-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-filter-chip-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-opacity: var(--md-filter-chip-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-filter-chip-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-label-text-color: var(--md-filter-chip-pressed-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-color: var(--md-filter-chip-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_pressed-state-layer-opacity: var(--md-filter-chip-pressed-state-layer-opacity, 0.12);--_icon-size: var(--md-filter-chip-icon-size, 18px);--_disabled-leading-icon-color: var(--md-filter-chip-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-filter-chip-disabled-leading-icon-opacity, 0.38);--_selected-focus-leading-icon-color: var(--md-filter-chip-selected-focus-leading-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-leading-icon-color: var(--md-filter-chip-selected-hover-leading-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-leading-icon-color: var(--md-filter-chip-selected-leading-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-leading-icon-color: var(--md-filter-chip-selected-pressed-leading-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_focus-leading-icon-color: var(--md-filter-chip-focus-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-leading-icon-color: var(--md-filter-chip-hover-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_leading-icon-color: var(--md-filter-chip-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_pressed-leading-icon-color: var(--md-filter-chip-pressed-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_disabled-trailing-icon-color: var(--md-filter-chip-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-icon-opacity: var(--md-filter-chip-disabled-trailing-icon-opacity, 0.38);--_selected-focus-trailing-icon-color: var(--md-filter-chip-selected-focus-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-trailing-icon-color: var(--md-filter-chip-selected-hover-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-trailing-icon-color: var(--md-filter-chip-selected-pressed-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-trailing-icon-color: var(--md-filter-chip-selected-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_focus-trailing-icon-color: var(--md-filter-chip-focus-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-icon-color: var(--md-filter-chip-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-trailing-icon-color: var(--md-filter-chip-pressed-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-icon-color: var(--md-filter-chip-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_container-shape-start-start: var(--md-filter-chip-container-shape-start-start, var(--md-filter-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-start-end: var(--md-filter-chip-container-shape-start-end, var(--md-filter-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-end: var(--md-filter-chip-container-shape-end-end, var(--md-filter-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-start: var(--md-filter-chip-container-shape-end-start, var(--md-filter-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_leading-space: var(--md-filter-chip-leading-space, 16px);--_trailing-space: var(--md-filter-chip-trailing-space, 16px);--_icon-label-space: var(--md-filter-chip-icon-label-space, 8px);--_with-leading-icon-leading-space: var(--md-filter-chip-with-leading-icon-leading-space, 8px);--_with-trailing-icon-trailing-space: var(--md-filter-chip-with-trailing-icon-trailing-space, 8px)}.selected.elevated::before{background:var(--_elevated-selected-container-color)}.checkmark{height:var(--_icon-size);width:var(--_icon-size)}.disabled .checkmark{opacity:var(--_disabled-leading-icon-opacity)}@media(forced-colors: active){.disabled .checkmark{opacity:1}}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$E = i$4`.selected{--md-ripple-hover-color: var(--_selected-hover-state-layer-color);--md-ripple-hover-opacity: var(--_selected-hover-state-layer-opacity);--md-ripple-pressed-color: var(--_selected-pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_selected-pressed-state-layer-opacity)}:where(.selected)::before{background:var(--_selected-container-color)}:where(.selected) .outline{border-width:var(--_selected-outline-width)}:where(.selected.disabled)::before{background:var(--_disabled-selected-container-color);opacity:var(--_disabled-selected-container-opacity)}:where(.selected) .label{color:var(--_selected-label-text-color)}:where(.selected:hover) .label{color:var(--_selected-hover-label-text-color)}:where(.selected:focus) .label{color:var(--_selected-focus-label-text-color)}:where(.selected:active) .label{color:var(--_selected-pressed-label-text-color)}:where(.selected) .leading.icon{color:var(--_selected-leading-icon-color)}:where(.selected:hover) .leading.icon{color:var(--_selected-hover-leading-icon-color)}:where(.selected:focus) .leading.icon{color:var(--_selected-focus-leading-icon-color)}:where(.selected:active) .leading.icon{color:var(--_selected-pressed-leading-icon-color)}@media(forced-colors: active){:where(.selected:not(.elevated))::before{border:1px solid CanvasText}:where(.selected) .outline{border-width:1px}}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$D = i$4`.trailing.action{align-items:center;justify-content:center;padding-inline-start:var(--_icon-label-space);padding-inline-end:var(--_with-trailing-icon-trailing-space)}.trailing.action :is(md-ripple,md-focus-ring){border-radius:50%;height:calc(1.3333333333*var(--_icon-size));width:calc(1.3333333333*var(--_icon-size))}.trailing.action md-focus-ring{inset:unset}.has-trailing .primary.action{padding-inline-end:0}.trailing.icon{color:var(--_trailing-icon-color);height:var(--_icon-size);width:var(--_icon-size)}:where(:hover) .trailing.icon{color:var(--_hover-trailing-icon-color)}:where(:focus) .trailing.icon{color:var(--_focus-trailing-icon-color)}:where(:active) .trailing.icon{color:var(--_pressed-trailing-icon-color)}:where(.disabled) .trailing.icon{color:var(--_disabled-trailing-icon-color);opacity:var(--_disabled-trailing-icon-opacity)}:where(.selected) .trailing.icon{color:var(--_selected-trailing-icon-color)}:where(.selected:hover) .trailing.icon{color:var(--_selected-hover-trailing-icon-color)}:where(.selected:focus) .trailing.icon{color:var(--_selected-focus-trailing-icon-color)}:where(.selected:active) .trailing.icon{color:var(--_selected-pressed-trailing-icon-color)}@media(forced-colors: active){.trailing.icon{color:ButtonText}:where(.disabled) .trailing.icon{color:GrayText;opacity:1}}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdFilterChip = class MdFilterChip2 extends FilterChip {
};
MdFilterChip.styles = [
  styles$H,
  styles$I,
  styles$D,
  styles$E,
  styles$F
];
MdFilterChip = __decorate([
  t$3("md-filter-chip")
], MdFilterChip);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class InputChip extends MultiActionChip {
  constructor() {
    super(...arguments);
    this.avatar = false;
    this.href = "";
    this.target = "";
    this.removeOnly = false;
    this.selected = false;
  }
  get primaryId() {
    if (this.href) {
      return "link";
    }
    if (this.removeOnly) {
      return "";
    }
    return "button";
  }
  get rippleDisabled() {
    return !this.href && (this.disabled || this.softDisabled);
  }
  get primaryAction() {
    if (this.removeOnly) {
      return null;
    }
    return this.renderRoot.querySelector(".primary.action");
  }
  getContainerClasses() {
    return {
      ...super.getContainerClasses(),
      avatar: this.avatar,
      // Link chips cannot be disabled
      disabled: !this.href && (this.disabled || this.softDisabled),
      link: !!this.href,
      selected: this.selected,
      "has-trailing": true
    };
  }
  renderPrimaryAction(content) {
    const { ariaLabel } = this;
    if (this.href) {
      return x$1`
        <a
          class="primary action"
          id="link"
          aria-label=${ariaLabel || T$1}
          href=${this.href}
          target=${this.target || T$1}
          >${content}</a
        >
      `;
    }
    if (this.removeOnly) {
      return x$1`
        <span class="primary action" aria-label=${ariaLabel || T$1}>
          ${content}
        </span>
      `;
    }
    return x$1`
      <button
        class="primary action"
        id="button"
        aria-label=${ariaLabel || T$1}
        aria-disabled=${this.softDisabled || T$1}
        ?disabled=${this.disabled && !this.alwaysFocusable}
        type="button"
        >${content}</button
      >
    `;
  }
  renderTrailingAction(focusListener) {
    return renderRemoveButton({
      focusListener,
      ariaLabel: this.ariaLabelRemove,
      disabled: !this.href && (this.disabled || this.softDisabled),
      tabbable: this.removeOnly
    });
  }
}
__decorate([
  n$5({ type: Boolean })
], InputChip.prototype, "avatar", void 0);
__decorate([
  n$5()
], InputChip.prototype, "href", void 0);
__decorate([
  n$5()
], InputChip.prototype, "target", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "remove-only" })
], InputChip.prototype, "removeOnly", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], InputChip.prototype, "selected", void 0);
__decorate([
  e$5(".trailing.action")
], InputChip.prototype, "trailingAction", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$C = i$4`:host{--_container-height: var(--md-input-chip-container-height, 32px);--_disabled-label-text-color: var(--md-input-chip-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-input-chip-disabled-label-text-opacity, 0.38);--_disabled-selected-container-color: var(--md-input-chip-disabled-selected-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-selected-container-opacity: var(--md-input-chip-disabled-selected-container-opacity, 0.12);--_label-text-font: var(--md-input-chip-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-input-chip-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-input-chip-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-input-chip-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_selected-container-color: var(--md-input-chip-selected-container-color, var(--md-sys-color-secondary-container, #e8def8));--_selected-focus-label-text-color: var(--md-input-chip-selected-focus-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-label-text-color: var(--md-input-chip-selected-hover-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-state-layer-color: var(--md-input-chip-selected-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-state-layer-opacity: var(--md-input-chip-selected-hover-state-layer-opacity, 0.08);--_selected-label-text-color: var(--md-input-chip-selected-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-outline-width: var(--md-input-chip-selected-outline-width, 0px);--_selected-pressed-label-text-color: var(--md-input-chip-selected-pressed-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-state-layer-color: var(--md-input-chip-selected-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-state-layer-opacity: var(--md-input-chip-selected-pressed-state-layer-opacity, 0.12);--_disabled-outline-color: var(--md-input-chip-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-input-chip-disabled-outline-opacity, 0.12);--_focus-label-text-color: var(--md-input-chip-focus-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-outline-color: var(--md-input-chip-focus-outline-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-label-text-color: var(--md-input-chip-hover-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-input-chip-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-opacity: var(--md-input-chip-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-input-chip-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_outline-color: var(--md-input-chip-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-input-chip-outline-width, 1px);--_pressed-label-text-color: var(--md-input-chip-pressed-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-color: var(--md-input-chip-pressed-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-opacity: var(--md-input-chip-pressed-state-layer-opacity, 0.12);--_avatar-shape: var(--md-input-chip-avatar-shape, var(--md-sys-shape-corner-full, 9999px));--_avatar-size: var(--md-input-chip-avatar-size, 24px);--_disabled-avatar-opacity: var(--md-input-chip-disabled-avatar-opacity, 0.38);--_disabled-leading-icon-color: var(--md-input-chip-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-input-chip-disabled-leading-icon-opacity, 0.38);--_icon-size: var(--md-input-chip-icon-size, 18px);--_selected-focus-leading-icon-color: var(--md-input-chip-selected-focus-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-hover-leading-icon-color: var(--md-input-chip-selected-hover-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-leading-icon-color: var(--md-input-chip-selected-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-pressed-leading-icon-color: var(--md-input-chip-selected-pressed-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_focus-leading-icon-color: var(--md-input-chip-focus-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-leading-icon-color: var(--md-input-chip-hover-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_leading-icon-color: var(--md-input-chip-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_pressed-leading-icon-color: var(--md-input-chip-pressed-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_disabled-trailing-icon-color: var(--md-input-chip-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-icon-opacity: var(--md-input-chip-disabled-trailing-icon-opacity, 0.38);--_selected-focus-trailing-icon-color: var(--md-input-chip-selected-focus-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-hover-trailing-icon-color: var(--md-input-chip-selected-hover-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-pressed-trailing-icon-color: var(--md-input-chip-selected-pressed-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_selected-trailing-icon-color: var(--md-input-chip-selected-trailing-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_focus-trailing-icon-color: var(--md-input-chip-focus-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-icon-color: var(--md-input-chip-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-trailing-icon-color: var(--md-input-chip-pressed-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-icon-color: var(--md-input-chip-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_container-shape-start-start: var(--md-input-chip-container-shape-start-start, var(--md-input-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-start-end: var(--md-input-chip-container-shape-start-end, var(--md-input-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-end: var(--md-input-chip-container-shape-end-end, var(--md-input-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-start: var(--md-input-chip-container-shape-end-start, var(--md-input-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_leading-space: var(--md-input-chip-leading-space, 16px);--_trailing-space: var(--md-input-chip-trailing-space, 16px);--_icon-label-space: var(--md-input-chip-icon-label-space, 8px);--_with-leading-icon-leading-space: var(--md-input-chip-with-leading-icon-leading-space, 8px);--_with-trailing-icon-trailing-space: var(--md-input-chip-with-trailing-icon-trailing-space, 8px)}:host([avatar]){--_container-shape-start-start: var( --md-input-chip-container-shape-start-start, var(--md-input-chip-container-shape, calc(var(--_container-height) / 2)) );--_container-shape-start-end: var( --md-input-chip-container-shape-start-end, var(--md-input-chip-container-shape, calc(var(--_container-height) / 2)) );--_container-shape-end-end: var( --md-input-chip-container-shape-end-end, var(--md-input-chip-container-shape, calc(var(--_container-height) / 2)) );--_container-shape-end-start: var( --md-input-chip-container-shape-end-start, var(--md-input-chip-container-shape, calc(var(--_container-height) / 2)) )}.avatar .primary.action{padding-inline-start:4px}.avatar .leading.icon ::slotted(:first-child){border-radius:var(--_avatar-shape);height:var(--_avatar-size);width:var(--_avatar-size)}.disabled.avatar .leading.icon{opacity:var(--_disabled-avatar-opacity)}@media(forced-colors: active){.link .outline{border-color:ActiveText}.disabled.avatar .leading.icon{opacity:1}}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdInputChip = class MdInputChip2 extends InputChip {
};
MdInputChip.styles = [
  styles$H,
  styles$D,
  styles$E,
  styles$C
];
MdInputChip = __decorate([
  t$3("md-input-chip")
], MdInputChip);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class SuggestionChip extends AssistChip {
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$B = i$4`:host{--_container-height: var(--md-suggestion-chip-container-height, 32px);--_disabled-label-text-color: var(--md-suggestion-chip-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-suggestion-chip-disabled-label-text-opacity, 0.38);--_elevated-container-color: var(--md-suggestion-chip-elevated-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_elevated-container-elevation: var(--md-suggestion-chip-elevated-container-elevation, 1);--_elevated-container-shadow-color: var(--md-suggestion-chip-elevated-container-shadow-color, var(--md-sys-color-shadow, #000));--_elevated-disabled-container-color: var(--md-suggestion-chip-elevated-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_elevated-disabled-container-elevation: var(--md-suggestion-chip-elevated-disabled-container-elevation, 0);--_elevated-disabled-container-opacity: var(--md-suggestion-chip-elevated-disabled-container-opacity, 0.12);--_elevated-focus-container-elevation: var(--md-suggestion-chip-elevated-focus-container-elevation, 1);--_elevated-hover-container-elevation: var(--md-suggestion-chip-elevated-hover-container-elevation, 2);--_elevated-pressed-container-elevation: var(--md-suggestion-chip-elevated-pressed-container-elevation, 1);--_focus-label-text-color: var(--md-suggestion-chip-focus-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-label-text-color: var(--md-suggestion-chip-hover-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-suggestion-chip-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-opacity: var(--md-suggestion-chip-hover-state-layer-opacity, 0.08);--_label-text-color: var(--md-suggestion-chip-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-font: var(--md-suggestion-chip-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-suggestion-chip-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-suggestion-chip-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-suggestion-chip-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-label-text-color: var(--md-suggestion-chip-pressed-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-color: var(--md-suggestion-chip-pressed-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-opacity: var(--md-suggestion-chip-pressed-state-layer-opacity, 0.12);--_disabled-outline-color: var(--md-suggestion-chip-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-suggestion-chip-disabled-outline-opacity, 0.12);--_focus-outline-color: var(--md-suggestion-chip-focus-outline-color, var(--md-sys-color-on-surface-variant, #49454f));--_outline-color: var(--md-suggestion-chip-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-suggestion-chip-outline-width, 1px);--_disabled-leading-icon-color: var(--md-suggestion-chip-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-suggestion-chip-disabled-leading-icon-opacity, 0.38);--_focus-leading-icon-color: var(--md-suggestion-chip-focus-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-leading-icon-color: var(--md-suggestion-chip-hover-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_leading-icon-color: var(--md-suggestion-chip-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_pressed-leading-icon-color: var(--md-suggestion-chip-pressed-leading-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-suggestion-chip-icon-size, 18px);--_container-shape-start-start: var(--md-suggestion-chip-container-shape-start-start, var(--md-suggestion-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-start-end: var(--md-suggestion-chip-container-shape-start-end, var(--md-suggestion-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-end: var(--md-suggestion-chip-container-shape-end-end, var(--md-suggestion-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_container-shape-end-start: var(--md-suggestion-chip-container-shape-end-start, var(--md-suggestion-chip-container-shape, var(--md-sys-shape-corner-small, 8px)));--_leading-space: var(--md-suggestion-chip-leading-space, 16px);--_trailing-space: var(--md-suggestion-chip-trailing-space, 16px);--_icon-label-space: var(--md-suggestion-chip-icon-label-space, 8px);--_with-leading-icon-leading-space: var(--md-suggestion-chip-with-leading-icon-leading-space, 8px)}@media(forced-colors: active){.link .outline{border-color:ActiveText}}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdSuggestionChip = class MdSuggestionChip2 extends SuggestionChip {
};
MdSuggestionChip.styles = [styles$H, styles$I, styles$B];
MdSuggestionChip = __decorate([
  t$3("md-suggestion-chip")
], MdSuggestionChip);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Divider extends s$1 {
  constructor() {
    super(...arguments);
    this.inset = false;
    this.insetStart = false;
    this.insetEnd = false;
  }
}
__decorate([
  n$5({ type: Boolean, reflect: true })
], Divider.prototype, "inset", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "inset-start" })
], Divider.prototype, "insetStart", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "inset-end" })
], Divider.prototype, "insetEnd", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$A = i$4`:host{box-sizing:border-box;color:var(--md-divider-color, var(--md-sys-color-outline-variant, #cac4d0));display:flex;height:var(--md-divider-thickness, 1px);width:100%}:host([inset]),:host([inset-start]){padding-inline-start:16px}:host([inset]),:host([inset-end]){padding-inline-end:16px}:host::before{background:currentColor;content:"";height:100%;width:100%}@media(forced-colors: active){:host::before{background:CanvasText}}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdDivider = class MdDivider2 extends Divider {
};
MdDivider.styles = [styles$A];
MdDivider = __decorate([
  t$3("md-divider")
], MdDivider);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const DIALOG_DEFAULT_OPEN_ANIMATION = {
  dialog: [
    [
      // Dialog slide down
      [{ "transform": "translateY(-50px)" }, { "transform": "translateY(0)" }],
      { duration: 500, easing: EASING.EMPHASIZED }
    ]
  ],
  scrim: [
    [
      // Scrim fade in
      [{ "opacity": 0 }, { "opacity": 0.32 }],
      { duration: 500, easing: "linear" }
    ]
  ],
  container: [
    [
      // Container fade in
      [{ "opacity": 0 }, { "opacity": 1 }],
      { duration: 50, easing: "linear", pseudoElement: "::before" }
    ],
    [
      // Container grow
      // Note: current spec says to grow from 0dp->100% and shrink from
      // 100%->35%. We change this to 35%->100% to simplify the animation that
      // is supposed to clip content as it grows. From 0dp it's possible to see
      // text/actions appear before the container has fully grown.
      [{ "height": "35%" }, { "height": "100%" }],
      { duration: 500, easing: EASING.EMPHASIZED, pseudoElement: "::before" }
    ]
  ],
  headline: [
    [
      // Headline fade in
      [{ "opacity": 0 }, { "opacity": 0, offset: 0.2 }, { "opacity": 1 }],
      { duration: 250, easing: "linear", fill: "forwards" }
    ]
  ],
  content: [
    [
      // Content fade in
      [{ "opacity": 0 }, { "opacity": 0, offset: 0.2 }, { "opacity": 1 }],
      { duration: 250, easing: "linear", fill: "forwards" }
    ]
  ],
  actions: [
    [
      // Actions fade in
      [{ "opacity": 0 }, { "opacity": 0, offset: 0.5 }, { "opacity": 1 }],
      { duration: 300, easing: "linear", fill: "forwards" }
    ]
  ]
};
const DIALOG_DEFAULT_CLOSE_ANIMATION = {
  dialog: [
    [
      // Dialog slide up
      [{ "transform": "translateY(0)" }, { "transform": "translateY(-50px)" }],
      { duration: 150, easing: EASING.EMPHASIZED_ACCELERATE }
    ]
  ],
  scrim: [
    [
      // Scrim fade out
      [{ "opacity": 0.32 }, { "opacity": 0 }],
      { duration: 150, easing: "linear" }
    ]
  ],
  container: [
    [
      // Container shrink
      [{ "height": "100%" }, { "height": "35%" }],
      {
        duration: 150,
        easing: EASING.EMPHASIZED_ACCELERATE,
        pseudoElement: "::before"
      }
    ],
    [
      // Container fade out
      [{ "opacity": "1" }, { "opacity": "0" }],
      { delay: 100, duration: 50, easing: "linear", pseudoElement: "::before" }
    ]
  ],
  headline: [
    [
      // Headline fade out
      [{ "opacity": 1 }, { "opacity": 0 }],
      { duration: 100, easing: "linear", fill: "forwards" }
    ]
  ],
  content: [
    [
      // Content fade out
      [{ "opacity": 1 }, { "opacity": 0 }],
      { duration: 100, easing: "linear", fill: "forwards" }
    ]
  ],
  actions: [
    [
      // Actions fade out
      [{ "opacity": 1 }, { "opacity": 0 }],
      { duration: 100, easing: "linear", fill: "forwards" }
    ]
  ]
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const dialogBaseClass = mixinDelegatesAria(s$1);
class Dialog extends dialogBaseClass {
  // We do not use `delegatesFocus: true` due to a Chromium bug with
  // selecting text.
  // See https://bugs.chromium.org/p/chromium/issues/detail?id=950357
  /**
   * Opens the dialog when set to `true` and closes it when set to `false`.
   */
  get open() {
    return this.isOpen;
  }
  set open(open) {
    if (open === this.isOpen) {
      return;
    }
    this.isOpen = open;
    if (open) {
      this.setAttribute("open", "");
      this.show();
    } else {
      this.removeAttribute("open");
      this.close();
    }
  }
  constructor() {
    super();
    this.quick = false;
    this.returnValue = "";
    this.noFocusTrap = false;
    this.getOpenAnimation = () => DIALOG_DEFAULT_OPEN_ANIMATION;
    this.getCloseAnimation = () => DIALOG_DEFAULT_CLOSE_ANIMATION;
    this.isOpen = false;
    this.isOpening = false;
    this.isConnectedPromise = this.getIsConnectedPromise();
    this.isAtScrollTop = false;
    this.isAtScrollBottom = false;
    this.nextClickIsFromContent = false;
    this.hasHeadline = false;
    this.hasActions = false;
    this.hasIcon = false;
    this.escapePressedWithoutCancel = false;
    this.treewalker = document.createTreeWalker(this, NodeFilter.SHOW_ELEMENT);
    {
      this.addEventListener("submit", this.handleSubmit);
    }
  }
  /**
   * Opens the dialog and fires a cancelable `open` event. After a dialog's
   * animation, an `opened` event is fired.
   *
   * Add an `autofocus` attribute to a child of the dialog that should
   * receive focus after opening.
   *
   * @return A Promise that resolves after the animation is finished and the
   *     `opened` event was fired.
   */
  async show() {
    this.isOpening = true;
    await this.isConnectedPromise;
    await this.updateComplete;
    const dialog = this.dialog;
    if (dialog.open || !this.isOpening) {
      this.isOpening = false;
      return;
    }
    const preventOpen = !this.dispatchEvent(new Event("open", { cancelable: true }));
    if (preventOpen) {
      this.open = false;
      this.isOpening = false;
      return;
    }
    dialog.showModal();
    this.open = true;
    if (this.scroller) {
      this.scroller.scrollTop = 0;
    }
    this.querySelector("[autofocus]")?.focus();
    await this.animateDialog(this.getOpenAnimation());
    this.dispatchEvent(new Event("opened"));
    this.isOpening = false;
  }
  /**
   * Closes the dialog and fires a cancelable `close` event. After a dialog's
   * animation, a `closed` event is fired.
   *
   * @param returnValue A return value usually indicating which button was used
   *     to close a dialog. If a dialog is canceled by clicking the scrim or
   *     pressing Escape, it will not change the return value after closing.
   * @return A Promise that resolves after the animation is finished and the
   *     `closed` event was fired.
   */
  async close(returnValue = this.returnValue) {
    this.isOpening = false;
    if (!this.isConnected) {
      this.open = false;
      return;
    }
    await this.updateComplete;
    const dialog = this.dialog;
    if (!dialog.open || this.isOpening) {
      this.open = false;
      return;
    }
    const prevReturnValue = this.returnValue;
    this.returnValue = returnValue;
    const preventClose = !this.dispatchEvent(new Event("close", { cancelable: true }));
    if (preventClose) {
      this.returnValue = prevReturnValue;
      return;
    }
    await this.animateDialog(this.getCloseAnimation());
    dialog.close(returnValue);
    this.open = false;
    this.dispatchEvent(new Event("closed"));
  }
  connectedCallback() {
    super.connectedCallback();
    this.isConnectedPromiseResolve();
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.isConnectedPromise = this.getIsConnectedPromise();
  }
  render() {
    const scrollable = this.open && !(this.isAtScrollTop && this.isAtScrollBottom);
    const classes = {
      "has-headline": this.hasHeadline,
      "has-actions": this.hasActions,
      "has-icon": this.hasIcon,
      "scrollable": scrollable,
      "show-top-divider": scrollable && !this.isAtScrollTop,
      "show-bottom-divider": scrollable && !this.isAtScrollBottom
    };
    const showFocusTrap = this.open && !this.noFocusTrap;
    const focusTrap = x$1`
      <div
        class="focus-trap"
        tabindex="0"
        aria-hidden="true"
        @focus=${this.handleFocusTrapFocus}></div>
    `;
    const { ariaLabel } = this;
    return x$1`
      <div class="scrim"></div>
      <dialog
        class=${e$1(classes)}
        aria-label=${ariaLabel || T$1}
        aria-labelledby=${this.hasHeadline ? "headline" : T$1}
        role=${this.type === "alert" ? "alertdialog" : T$1}
        @cancel=${this.handleCancel}
        @click=${this.handleDialogClick}
        @close=${this.handleClose}
        @keydown=${this.handleKeydown}
        .returnValue=${this.returnValue || T$1}>
        ${showFocusTrap ? focusTrap : T$1}
        <div class="container" @click=${this.handleContentClick}>
          <div class="headline">
            <div class="icon" aria-hidden="true">
              <slot name="icon" @slotchange=${this.handleIconChange}></slot>
            </div>
            <h2 id="headline" aria-hidden=${!this.hasHeadline || T$1}>
              <slot
                name="headline"
                @slotchange=${this.handleHeadlineChange}></slot>
            </h2>
            <md-divider></md-divider>
          </div>
          <div class="scroller">
            <div class="content">
              <div class="top anchor"></div>
              <slot name="content"></slot>
              <div class="bottom anchor"></div>
            </div>
          </div>
          <div class="actions">
            <md-divider></md-divider>
            <slot name="actions" @slotchange=${this.handleActionsChange}></slot>
          </div>
        </div>
        ${showFocusTrap ? focusTrap : T$1}
      </dialog>
    `;
  }
  firstUpdated() {
    this.intersectionObserver = new IntersectionObserver((entries) => {
      for (const entry of entries) {
        this.handleAnchorIntersection(entry);
      }
    }, { root: this.scroller });
    this.intersectionObserver.observe(this.topAnchor);
    this.intersectionObserver.observe(this.bottomAnchor);
  }
  handleDialogClick() {
    if (this.nextClickIsFromContent) {
      this.nextClickIsFromContent = false;
      return;
    }
    const preventDefault = !this.dispatchEvent(new Event("cancel", { cancelable: true }));
    if (preventDefault) {
      return;
    }
    this.close();
  }
  handleContentClick() {
    this.nextClickIsFromContent = true;
  }
  handleSubmit(event) {
    const form = event.target;
    const { submitter } = event;
    if (form.method !== "dialog" || !submitter) {
      return;
    }
    this.close(submitter.getAttribute("value") ?? this.returnValue);
  }
  handleCancel(event) {
    if (event.target !== this.dialog) {
      return;
    }
    this.escapePressedWithoutCancel = false;
    const preventDefault = !redispatchEvent(this, event);
    event.preventDefault();
    if (preventDefault) {
      return;
    }
    this.close();
  }
  handleClose() {
    if (!this.escapePressedWithoutCancel) {
      return;
    }
    this.escapePressedWithoutCancel = false;
    this.dialog?.dispatchEvent(new Event("cancel", { cancelable: true }));
  }
  handleKeydown(event) {
    if (event.key !== "Escape") {
      return;
    }
    this.escapePressedWithoutCancel = true;
    setTimeout(() => {
      this.escapePressedWithoutCancel = false;
    });
  }
  async animateDialog(animation) {
    this.cancelAnimations?.abort();
    this.cancelAnimations = new AbortController();
    if (this.quick) {
      return;
    }
    const { dialog, scrim, container, headline, content, actions } = this;
    if (!dialog || !scrim || !container || !headline || !content || !actions) {
      return;
    }
    const { container: containerAnimate, dialog: dialogAnimate, scrim: scrimAnimate, headline: headlineAnimate, content: contentAnimate, actions: actionsAnimate } = animation;
    const elementAndAnimation = [
      [dialog, dialogAnimate ?? []],
      [scrim, scrimAnimate ?? []],
      [container, containerAnimate ?? []],
      [headline, headlineAnimate ?? []],
      [content, contentAnimate ?? []],
      [actions, actionsAnimate ?? []]
    ];
    const animations = [];
    for (const [element, animation2] of elementAndAnimation) {
      for (const animateArgs of animation2) {
        const animation3 = element.animate(...animateArgs);
        this.cancelAnimations.signal.addEventListener("abort", () => {
          animation3.cancel();
        });
        animations.push(animation3);
      }
    }
    await Promise.all(animations.map((animation2) => animation2.finished.catch(() => {
    })));
  }
  handleHeadlineChange(event) {
    const slot = event.target;
    this.hasHeadline = slot.assignedElements().length > 0;
  }
  handleActionsChange(event) {
    const slot = event.target;
    this.hasActions = slot.assignedElements().length > 0;
  }
  handleIconChange(event) {
    const slot = event.target;
    this.hasIcon = slot.assignedElements().length > 0;
  }
  handleAnchorIntersection(entry) {
    const { target, isIntersecting } = entry;
    if (target === this.topAnchor) {
      this.isAtScrollTop = isIntersecting;
    }
    if (target === this.bottomAnchor) {
      this.isAtScrollBottom = isIntersecting;
    }
  }
  getIsConnectedPromise() {
    return new Promise((resolve2) => {
      this.isConnectedPromiseResolve = resolve2;
    });
  }
  handleFocusTrapFocus(event) {
    const [firstFocusableChild, lastFocusableChild] = this.getFirstAndLastFocusableChildren();
    if (!firstFocusableChild || !lastFocusableChild) {
      this.dialog?.focus();
      return;
    }
    const isFirstFocusTrap = event.target === this.firstFocusTrap;
    const isLastFocusTrap = !isFirstFocusTrap;
    const focusCameFromFirstChild = event.relatedTarget === firstFocusableChild;
    const focusCameFromLastChild = event.relatedTarget === lastFocusableChild;
    const focusCameFromOutsideDialog = !focusCameFromFirstChild && !focusCameFromLastChild;
    const shouldFocusFirstChild = isLastFocusTrap && focusCameFromLastChild || isFirstFocusTrap && focusCameFromOutsideDialog;
    if (shouldFocusFirstChild) {
      firstFocusableChild.focus();
      return;
    }
    const shouldFocusLastChild = isFirstFocusTrap && focusCameFromFirstChild || isLastFocusTrap && focusCameFromOutsideDialog;
    if (shouldFocusLastChild) {
      lastFocusableChild.focus();
      return;
    }
  }
  getFirstAndLastFocusableChildren() {
    if (!this.treewalker) {
      return [null, null];
    }
    let firstFocusableChild = null;
    let lastFocusableChild = null;
    this.treewalker.currentNode = this.treewalker.root;
    while (this.treewalker.nextNode()) {
      const nextChild = this.treewalker.currentNode;
      if (!isFocusable$1(nextChild)) {
        continue;
      }
      if (!firstFocusableChild) {
        firstFocusableChild = nextChild;
      }
      lastFocusableChild = nextChild;
    }
    return [firstFocusableChild, lastFocusableChild];
  }
}
__decorate([
  n$5({ type: Boolean })
], Dialog.prototype, "open", null);
__decorate([
  n$5({ type: Boolean })
], Dialog.prototype, "quick", void 0);
__decorate([
  n$5({ attribute: false })
], Dialog.prototype, "returnValue", void 0);
__decorate([
  n$5()
], Dialog.prototype, "type", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-focus-trap" })
], Dialog.prototype, "noFocusTrap", void 0);
__decorate([
  e$5("dialog")
], Dialog.prototype, "dialog", void 0);
__decorate([
  e$5(".scrim")
], Dialog.prototype, "scrim", void 0);
__decorate([
  e$5(".container")
], Dialog.prototype, "container", void 0);
__decorate([
  e$5(".headline")
], Dialog.prototype, "headline", void 0);
__decorate([
  e$5(".content")
], Dialog.prototype, "content", void 0);
__decorate([
  e$5(".actions")
], Dialog.prototype, "actions", void 0);
__decorate([
  r$4()
], Dialog.prototype, "isAtScrollTop", void 0);
__decorate([
  r$4()
], Dialog.prototype, "isAtScrollBottom", void 0);
__decorate([
  e$5(".scroller")
], Dialog.prototype, "scroller", void 0);
__decorate([
  e$5(".top.anchor")
], Dialog.prototype, "topAnchor", void 0);
__decorate([
  e$5(".bottom.anchor")
], Dialog.prototype, "bottomAnchor", void 0);
__decorate([
  e$5(".focus-trap")
], Dialog.prototype, "firstFocusTrap", void 0);
__decorate([
  r$4()
], Dialog.prototype, "hasHeadline", void 0);
__decorate([
  r$4()
], Dialog.prototype, "hasActions", void 0);
__decorate([
  r$4()
], Dialog.prototype, "hasIcon", void 0);
function isFocusable$1(element) {
  const knownFocusableElements = ":is(button,input,select,textarea,object,:is(a,area)[href],[tabindex],[contenteditable=true])";
  const notDisabled = ":not(:disabled,[disabled])";
  const notNegativeTabIndex = ':not([tabindex^="-"])';
  if (element.matches(knownFocusableElements + notDisabled + notNegativeTabIndex)) {
    return true;
  }
  const isCustomElement = element.localName.includes("-");
  if (!isCustomElement) {
    return false;
  }
  if (!element.matches(notDisabled)) {
    return false;
  }
  return element.shadowRoot?.delegatesFocus ?? false;
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$z = i$4`:host{border-start-start-radius:var(--md-dialog-container-shape-start-start, var(--md-dialog-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));border-start-end-radius:var(--md-dialog-container-shape-start-end, var(--md-dialog-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));border-end-end-radius:var(--md-dialog-container-shape-end-end, var(--md-dialog-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));border-end-start-radius:var(--md-dialog-container-shape-end-start, var(--md-dialog-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));display:contents;margin:auto;max-height:min(560px,100% - 48px);max-width:min(560px,100% - 48px);min-height:140px;min-width:280px;position:fixed;height:fit-content;width:fit-content}dialog{background:rgba(0,0,0,0);border:none;border-radius:inherit;flex-direction:column;height:inherit;margin:inherit;max-height:inherit;max-width:inherit;min-height:inherit;min-width:inherit;outline:none;overflow:visible;padding:0;width:inherit}dialog[open]{display:flex}::backdrop{background:none}.scrim{background:var(--md-sys-color-scrim, #000);display:none;inset:0;opacity:32%;pointer-events:none;position:fixed;z-index:1}:host([open]) .scrim{display:flex}h2{all:unset;align-self:stretch}.headline{align-items:center;color:var(--md-dialog-headline-color, var(--md-sys-color-on-surface, #1d1b20));display:flex;flex-direction:column;font-family:var(--md-dialog-headline-font, var(--md-sys-typescale-headline-small-font, var(--md-ref-typeface-brand, Roboto)));font-size:var(--md-dialog-headline-size, var(--md-sys-typescale-headline-small-size, 1.5rem));line-height:var(--md-dialog-headline-line-height, var(--md-sys-typescale-headline-small-line-height, 2rem));font-weight:var(--md-dialog-headline-weight, var(--md-sys-typescale-headline-small-weight, var(--md-ref-typeface-weight-regular, 400)));position:relative}slot[name=headline]::slotted(*){align-items:center;align-self:stretch;box-sizing:border-box;display:flex;gap:8px;padding:24px 24px 0}.icon{display:flex}slot[name=icon]::slotted(*){color:var(--md-dialog-icon-color, var(--md-sys-color-secondary, #625b71));fill:currentColor;font-size:var(--md-dialog-icon-size, 24px);margin-top:24px;height:var(--md-dialog-icon-size, 24px);width:var(--md-dialog-icon-size, 24px)}.has-icon slot[name=headline]::slotted(*){justify-content:center;padding-top:16px}.scrollable slot[name=headline]::slotted(*){padding-bottom:16px}.scrollable.has-headline slot[name=content]::slotted(*){padding-top:8px}.container{border-radius:inherit;display:flex;flex-direction:column;flex-grow:1;overflow:hidden;position:relative;transform-origin:top}.container::before{background:var(--md-dialog-container-color, var(--md-sys-color-surface-container-high, #ece6f0));border-radius:inherit;content:"";inset:0;position:absolute}.scroller{display:flex;flex:1;flex-direction:column;overflow:hidden;z-index:1}.scrollable .scroller{overflow-y:scroll}.content{color:var(--md-dialog-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));font-family:var(--md-dialog-supporting-text-font, var(--md-sys-typescale-body-medium-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-dialog-supporting-text-size, var(--md-sys-typescale-body-medium-size, 0.875rem));line-height:var(--md-dialog-supporting-text-line-height, var(--md-sys-typescale-body-medium-line-height, 1.25rem));flex:1;font-weight:var(--md-dialog-supporting-text-weight, var(--md-sys-typescale-body-medium-weight, var(--md-ref-typeface-weight-regular, 400)));height:min-content;position:relative}slot[name=content]::slotted(*){box-sizing:border-box;padding:24px}.anchor{position:absolute}.top.anchor{top:0}.bottom.anchor{bottom:0}.actions{position:relative}slot[name=actions]::slotted(*){box-sizing:border-box;display:flex;gap:8px;justify-content:flex-end;padding:16px 24px 24px}.has-actions slot[name=content]::slotted(*){padding-bottom:8px}md-divider{display:none;position:absolute}.has-headline.show-top-divider .headline md-divider,.has-actions.show-bottom-divider .actions md-divider{display:flex}.headline md-divider{bottom:0}.actions md-divider{top:0}@media(forced-colors: active){dialog{outline:2px solid WindowText}}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdDialog = class MdDialog2 extends Dialog {
};
MdDialog.styles = [styles$z];
MdDialog = __decorate([
  t$3("md-dialog")
], MdDialog);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const fabBaseClass = mixinDelegatesAria(s$1);
class SharedFab extends fabBaseClass {
  constructor() {
    super(...arguments);
    this.size = "medium";
    this.label = "";
    this.lowered = false;
  }
  render() {
    const { ariaLabel } = this;
    return x$1`
      <button
        class="fab ${e$1(this.getRenderClasses())}"
        aria-label=${ariaLabel || T$1}>
        <md-elevation part="elevation"></md-elevation>
        <md-focus-ring part="focus-ring"></md-focus-ring>
        <md-ripple class="ripple"></md-ripple>
        ${this.renderTouchTarget()} ${this.renderIcon()} ${this.renderLabel()}
      </button>
    `;
  }
  getRenderClasses() {
    const isExtended = !!this.label;
    return {
      "lowered": this.lowered,
      "small": this.size === "small" && !isExtended,
      "large": this.size === "large" && !isExtended,
      "extended": isExtended
    };
  }
  renderTouchTarget() {
    return x$1`<div class="touch-target"></div>`;
  }
  renderLabel() {
    return this.label ? x$1`<span class="label">${this.label}</span>` : "";
  }
  renderIcon() {
    const { ariaLabel } = this;
    return x$1`<span class="icon">
      <slot
        name="icon"
        aria-hidden=${ariaLabel || this.label ? "true" : T$1}>
        <span></span>
      </slot>
    </span>`;
  }
}
SharedFab.shadowRootOptions = {
  mode: "open",
  delegatesFocus: true
};
__decorate([
  n$5({ reflect: true })
], SharedFab.prototype, "size", void 0);
__decorate([
  n$5()
], SharedFab.prototype, "label", void 0);
__decorate([
  n$5({ type: Boolean })
], SharedFab.prototype, "lowered", void 0);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Fab extends SharedFab {
  constructor() {
    super(...arguments);
    this.variant = "surface";
  }
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "primary": this.variant === "primary",
      "secondary": this.variant === "secondary",
      "tertiary": this.variant === "tertiary"
    };
  }
}
__decorate([
  n$5()
], Fab.prototype, "variant", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$y = i$4`:host{--_container-color: var(--md-fab-branded-container-color, var(--md-sys-color-surface-container-high, #ece6f0));--_container-elevation: var(--md-fab-branded-container-elevation, 3);--_container-height: var(--md-fab-branded-container-height, 56px);--_container-shadow-color: var(--md-fab-branded-container-shadow-color, var(--md-sys-color-shadow, #000));--_container-width: var(--md-fab-branded-container-width, 56px);--_focus-container-elevation: var(--md-fab-branded-focus-container-elevation, 3);--_hover-container-elevation: var(--md-fab-branded-hover-container-elevation, 4);--_hover-state-layer-color: var(--md-fab-branded-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-fab-branded-hover-state-layer-opacity, 0.08);--_icon-size: var(--md-fab-branded-icon-size, 36px);--_lowered-container-color: var(--md-fab-branded-lowered-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_lowered-container-elevation: var(--md-fab-branded-lowered-container-elevation, 1);--_lowered-focus-container-elevation: var(--md-fab-branded-lowered-focus-container-elevation, 1);--_lowered-hover-container-elevation: var(--md-fab-branded-lowered-hover-container-elevation, 2);--_lowered-pressed-container-elevation: var(--md-fab-branded-lowered-pressed-container-elevation, 1);--_pressed-container-elevation: var(--md-fab-branded-pressed-container-elevation, 3);--_pressed-state-layer-color: var(--md-fab-branded-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-fab-branded-pressed-state-layer-opacity, 0.12);--_focus-label-text-color: var(--md-fab-branded-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-label-text-color: var(--md-fab-branded-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-color: var(--md-fab-branded-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_label-text-font: var(--md-fab-branded-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-size: var(--md-fab-branded-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-line-height: var(--md-fab-branded-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-weight: var(--md-fab-branded-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_large-container-height: var(--md-fab-branded-large-container-height, 96px);--_large-container-width: var(--md-fab-branded-large-container-width, 96px);--_large-icon-size: var(--md-fab-branded-large-icon-size, 48px);--_pressed-label-text-color: var(--md-fab-branded-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-fab-branded-container-shape-start-start, var(--md-fab-branded-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-start-end: var(--md-fab-branded-container-shape-start-end, var(--md-fab-branded-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-end-end: var(--md-fab-branded-container-shape-end-end, var(--md-fab-branded-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-end-start: var(--md-fab-branded-container-shape-end-start, var(--md-fab-branded-container-shape, var(--md-sys-shape-corner-large, 16px)));--_large-container-shape-start-start: var(--md-fab-branded-large-container-shape-start-start, var(--md-fab-branded-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-start-end: var(--md-fab-branded-large-container-shape-start-end, var(--md-fab-branded-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-end-end: var(--md-fab-branded-large-container-shape-end-end, var(--md-fab-branded-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-end-start: var(--md-fab-branded-large-container-shape-end-start, var(--md-fab-branded-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)))}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$x = i$4`@media(forced-colors: active){.fab{border:1px solid ButtonText}.fab.extended{padding-inline-start:15px;padding-inline-end:19px}md-focus-ring{--md-focus-ring-outward-offset: 3px}}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$w = i$4`:host{--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity);display:inline-flex;-webkit-tap-highlight-color:rgba(0,0,0,0)}:host([size=medium][touch-target=wrapper]){margin:max(0px,48px - var(--_container-height))}:host([size=large][touch-target=wrapper]){margin:max(0px,48px - var(--_large-container-height))}.fab,.icon,.icon ::slotted(*){display:flex}.fab{align-items:center;justify-content:center;vertical-align:middle;padding:0;position:relative;height:var(--_container-height);transition-property:background-color;border-width:0px;outline:none;z-index:0;text-transform:inherit;--md-elevation-level: var(--_container-elevation);--md-elevation-shadow-color: var(--_container-shadow-color);background-color:var(--_container-color);--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-pressed-color: var(--_pressed-state-layer-color)}.fab.extended{width:inherit;box-sizing:border-box;padding-inline-start:16px;padding-inline-end:20px}.fab:not(.extended){width:var(--_container-width)}.fab.large{width:var(--_large-container-width);height:var(--_large-container-height)}.fab.large .icon ::slotted(*){width:var(--_large-icon-size);height:var(--_large-icon-size);font-size:var(--_large-icon-size)}.fab.large,.fab.large .ripple{border-start-start-radius:var(--_large-container-shape-start-start);border-start-end-radius:var(--_large-container-shape-start-end);border-end-start-radius:var(--_large-container-shape-end-start);border-end-end-radius:var(--_large-container-shape-end-end)}.fab.large md-focus-ring{--md-focus-ring-shape-start-start: var(--_large-container-shape-start-start);--md-focus-ring-shape-start-end: var(--_large-container-shape-start-end);--md-focus-ring-shape-end-end: var(--_large-container-shape-end-end);--md-focus-ring-shape-end-start: var(--_large-container-shape-end-start)}.fab:focus{--md-elevation-level: var(--_focus-container-elevation)}.fab:hover{--md-elevation-level: var(--_hover-container-elevation)}.fab:active{--md-elevation-level: var(--_pressed-container-elevation)}.fab.lowered{background-color:var(--_lowered-container-color);--md-elevation-level: var(--_lowered-container-elevation)}.fab.lowered:focus{--md-elevation-level: var(--_lowered-focus-container-elevation)}.fab.lowered:hover{--md-elevation-level: var(--_lowered-hover-container-elevation)}.fab.lowered:active{--md-elevation-level: var(--_lowered-pressed-container-elevation)}.fab .label{color:var(--_label-text-color)}.fab:hover .fab .label{color:var(--_hover-label-text-color)}.fab:focus .fab .label{color:var(--_focus-label-text-color)}.fab:active .fab .label{color:var(--_pressed-label-text-color)}.label{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight)}.fab.extended .icon ::slotted(*){margin-inline-end:12px}.ripple{overflow:hidden}.ripple,md-elevation{z-index:-1}.touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}:host([touch-target=none]) .touch-target{display:none}md-elevation,.fab{transition-duration:280ms;transition-timing-function:cubic-bezier(0.2, 0, 0, 1)}.fab,.ripple{border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end)}md-focus-ring{--md-focus-ring-shape-start-start: var(--_container-shape-start-start);--md-focus-ring-shape-start-end: var(--_container-shape-start-end);--md-focus-ring-shape-end-end: var(--_container-shape-end-end);--md-focus-ring-shape-end-start: var(--_container-shape-end-start)}.icon ::slotted(*){width:var(--_icon-size);height:var(--_icon-size);font-size:var(--_icon-size)}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdBrandedFab = class MdBrandedFab2 extends Fab {
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "primary": false,
      "secondary": false,
      "tertiary": false,
      "small": false
    };
  }
};
MdBrandedFab.styles = [
  styles$w,
  styles$y,
  styles$x
];
MdBrandedFab = __decorate([
  t$3("md-branded-fab")
], MdBrandedFab);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$v = i$4`:host{--_container-color: var(--md-fab-container-color, var(--md-sys-color-surface-container-high, #ece6f0));--_container-elevation: var(--md-fab-container-elevation, 3);--_container-height: var(--md-fab-container-height, 56px);--_container-shadow-color: var(--md-fab-container-shadow-color, var(--md-sys-color-shadow, #000));--_container-width: var(--md-fab-container-width, 56px);--_focus-container-elevation: var(--md-fab-focus-container-elevation, 3);--_focus-icon-color: var(--md-fab-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-container-elevation: var(--md-fab-hover-container-elevation, 4);--_hover-icon-color: var(--md-fab-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-fab-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-fab-hover-state-layer-opacity, 0.08);--_icon-color: var(--md-fab-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-fab-icon-size, 24px);--_lowered-container-color: var(--md-fab-lowered-container-color, var(--md-sys-color-surface-container-low, #f7f2fa));--_lowered-container-elevation: var(--md-fab-lowered-container-elevation, 1);--_lowered-focus-container-elevation: var(--md-fab-lowered-focus-container-elevation, 1);--_lowered-hover-container-elevation: var(--md-fab-lowered-hover-container-elevation, 2);--_lowered-pressed-container-elevation: var(--md-fab-lowered-pressed-container-elevation, 1);--_pressed-container-elevation: var(--md-fab-pressed-container-elevation, 3);--_pressed-icon-color: var(--md-fab-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-fab-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-fab-pressed-state-layer-opacity, 0.12);--_focus-label-text-color: var(--md-fab-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_hover-label-text-color: var(--md-fab-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-color: var(--md-fab-label-text-color, var(--md-sys-color-primary, #6750a4));--_label-text-font: var(--md-fab-label-text-font, var(--md-sys-typescale-label-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-fab-label-text-line-height, var(--md-sys-typescale-label-large-line-height, 1.25rem));--_label-text-size: var(--md-fab-label-text-size, var(--md-sys-typescale-label-large-size, 0.875rem));--_label-text-weight: var(--md-fab-label-text-weight, var(--md-sys-typescale-label-large-weight, var(--md-ref-typeface-weight-medium, 500)));--_large-container-height: var(--md-fab-large-container-height, 96px);--_large-container-width: var(--md-fab-large-container-width, 96px);--_large-icon-size: var(--md-fab-large-icon-size, 36px);--_pressed-label-text-color: var(--md-fab-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_primary-container-color: var(--md-fab-primary-container-color, var(--md-sys-color-primary-container, #eaddff));--_primary-focus-icon-color: var(--md-fab-primary-focus-icon-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-focus-label-text-color: var(--md-fab-primary-focus-label-text-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-hover-icon-color: var(--md-fab-primary-hover-icon-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-hover-label-text-color: var(--md-fab-primary-hover-label-text-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-hover-state-layer-color: var(--md-fab-primary-hover-state-layer-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-icon-color: var(--md-fab-primary-icon-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-label-text-color: var(--md-fab-primary-label-text-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-pressed-icon-color: var(--md-fab-primary-pressed-icon-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-pressed-label-text-color: var(--md-fab-primary-pressed-label-text-color, var(--md-sys-color-on-primary-container, #21005d));--_primary-pressed-state-layer-color: var(--md-fab-primary-pressed-state-layer-color, var(--md-sys-color-on-primary-container, #21005d));--_secondary-container-color: var(--md-fab-secondary-container-color, var(--md-sys-color-secondary-container, #e8def8));--_secondary-focus-icon-color: var(--md-fab-secondary-focus-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-focus-label-text-color: var(--md-fab-secondary-focus-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-hover-icon-color: var(--md-fab-secondary-hover-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-hover-label-text-color: var(--md-fab-secondary-hover-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-hover-state-layer-color: var(--md-fab-secondary-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-icon-color: var(--md-fab-secondary-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-label-text-color: var(--md-fab-secondary-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-pressed-icon-color: var(--md-fab-secondary-pressed-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-pressed-label-text-color: var(--md-fab-secondary-pressed-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b));--_secondary-pressed-state-layer-color: var(--md-fab-secondary-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_small-container-height: var(--md-fab-small-container-height, 40px);--_small-container-width: var(--md-fab-small-container-width, 40px);--_small-icon-size: var(--md-fab-small-icon-size, 24px);--_tertiary-container-color: var(--md-fab-tertiary-container-color, var(--md-sys-color-tertiary-container, #ffd8e4));--_tertiary-focus-icon-color: var(--md-fab-tertiary-focus-icon-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-focus-label-text-color: var(--md-fab-tertiary-focus-label-text-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-hover-icon-color: var(--md-fab-tertiary-hover-icon-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-hover-label-text-color: var(--md-fab-tertiary-hover-label-text-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-hover-state-layer-color: var(--md-fab-tertiary-hover-state-layer-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-icon-color: var(--md-fab-tertiary-icon-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-label-text-color: var(--md-fab-tertiary-label-text-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-pressed-icon-color: var(--md-fab-tertiary-pressed-icon-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-pressed-label-text-color: var(--md-fab-tertiary-pressed-label-text-color, var(--md-sys-color-on-tertiary-container, #31111d));--_tertiary-pressed-state-layer-color: var(--md-fab-tertiary-pressed-state-layer-color, var(--md-sys-color-on-tertiary-container, #31111d));--_container-shape-start-start: var(--md-fab-container-shape-start-start, var(--md-fab-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-start-end: var(--md-fab-container-shape-start-end, var(--md-fab-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-end-end: var(--md-fab-container-shape-end-end, var(--md-fab-container-shape, var(--md-sys-shape-corner-large, 16px)));--_container-shape-end-start: var(--md-fab-container-shape-end-start, var(--md-fab-container-shape, var(--md-sys-shape-corner-large, 16px)));--_large-container-shape-start-start: var(--md-fab-large-container-shape-start-start, var(--md-fab-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-start-end: var(--md-fab-large-container-shape-start-end, var(--md-fab-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-end-end: var(--md-fab-large-container-shape-end-end, var(--md-fab-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_large-container-shape-end-start: var(--md-fab-large-container-shape-end-start, var(--md-fab-large-container-shape, var(--md-sys-shape-corner-extra-large, 28px)));--_small-container-shape-start-start: var(--md-fab-small-container-shape-start-start, var(--md-fab-small-container-shape, var(--md-sys-shape-corner-medium, 12px)));--_small-container-shape-start-end: var(--md-fab-small-container-shape-start-end, var(--md-fab-small-container-shape, var(--md-sys-shape-corner-medium, 12px)));--_small-container-shape-end-end: var(--md-fab-small-container-shape-end-end, var(--md-fab-small-container-shape, var(--md-sys-shape-corner-medium, 12px)));--_small-container-shape-end-start: var(--md-fab-small-container-shape-end-start, var(--md-fab-small-container-shape, var(--md-sys-shape-corner-medium, 12px)));cursor:pointer}:host([size=small][touch-target=wrapper]){margin:max(0px,48px - var(--_small-container-height))}.fab{cursor:inherit}.fab .icon ::slotted(*){color:var(--_icon-color)}.fab:focus{color:var(--_focus-icon-color)}.fab:hover{color:var(--_hover-icon-color)}.fab:active{color:var(--_pressed-icon-color)}.fab.primary{background-color:var(--_primary-container-color);--md-ripple-hover-color: var(--_primary-hover-state-layer-color);--md-ripple-pressed-color: var(--_primary-pressed-state-layer-color)}.fab.primary .icon ::slotted(*){color:var(--_primary-icon-color)}.fab.primary:focus{color:var(--_primary-focus-icon-color)}.fab.primary:hover{color:var(--_primary-hover-icon-color)}.fab.primary:active{color:var(--_primary-pressed-icon-color)}.fab.primary .label{color:var(--_primary-label-text-color)}.fab:hover .fab.primary .label{color:var(--_primary-hover-label-text-color)}.fab:focus .fab.primary .label{color:var(--_primary-focus-label-text-color)}.fab:active .fab.primary .label{color:var(--_primary-pressed-label-text-color)}.fab.secondary{background-color:var(--_secondary-container-color);--md-ripple-hover-color: var(--_secondary-hover-state-layer-color);--md-ripple-pressed-color: var(--_secondary-pressed-state-layer-color)}.fab.secondary .icon ::slotted(*){color:var(--_secondary-icon-color)}.fab.secondary:focus{color:var(--_secondary-focus-icon-color)}.fab.secondary:hover{color:var(--_secondary-hover-icon-color)}.fab.secondary:active{color:var(--_secondary-pressed-icon-color)}.fab.secondary .label{color:var(--_secondary-label-text-color)}.fab:hover .fab.secondary .label{color:var(--_secondary-hover-label-text-color)}.fab:focus .fab.secondary .label{color:var(--_secondary-focus-label-text-color)}.fab:active .fab.secondary .label{color:var(--_secondary-pressed-label-text-color)}.fab.tertiary{background-color:var(--_tertiary-container-color);--md-ripple-hover-color: var(--_tertiary-hover-state-layer-color);--md-ripple-pressed-color: var(--_tertiary-pressed-state-layer-color)}.fab.tertiary .icon ::slotted(*){color:var(--_tertiary-icon-color)}.fab.tertiary:focus{color:var(--_tertiary-focus-icon-color)}.fab.tertiary:hover{color:var(--_tertiary-hover-icon-color)}.fab.tertiary:active{color:var(--_tertiary-pressed-icon-color)}.fab.tertiary .label{color:var(--_tertiary-label-text-color)}.fab:hover .fab.tertiary .label{color:var(--_tertiary-hover-label-text-color)}.fab:focus .fab.tertiary .label{color:var(--_tertiary-focus-label-text-color)}.fab:active .fab.tertiary .label{color:var(--_tertiary-pressed-label-text-color)}.fab.extended slot span{padding-inline-start:4px}.fab.small{width:var(--_small-container-width);height:var(--_small-container-height)}.fab.small .icon ::slotted(*){width:var(--_small-icon-size);height:var(--_small-icon-size);font-size:var(--_small-icon-size)}.fab.small,.fab.small .ripple{border-start-start-radius:var(--_small-container-shape-start-start);border-start-end-radius:var(--_small-container-shape-start-end);border-end-start-radius:var(--_small-container-shape-end-start);border-end-end-radius:var(--_small-container-shape-end-end)}.fab.small md-focus-ring{--md-focus-ring-shape-start-start: var(--_small-container-shape-start-start);--md-focus-ring-shape-start-end: var(--_small-container-shape-start-end);--md-focus-ring-shape-end-end: var(--_small-container-shape-end-end);--md-focus-ring-shape-end-start: var(--_small-container-shape-end-start)}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdFab = class MdFab2 extends Fab {
};
MdFab.styles = [styles$w, styles$v, styles$x];
MdFab = __decorate([
  t$3("md-fab")
], MdFab);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Field extends s$1 {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.error = false;
    this.focused = false;
    this.label = "";
    this.noAsterisk = false;
    this.populated = false;
    this.required = false;
    this.resizable = false;
    this.supportingText = "";
    this.errorText = "";
    this.count = -1;
    this.max = -1;
    this.hasStart = false;
    this.hasEnd = false;
    this.isAnimating = false;
    this.refreshErrorAlert = false;
    this.disableTransitions = false;
  }
  get counterText() {
    const countAsNumber = this.count ?? -1;
    const maxAsNumber = this.max ?? -1;
    if (countAsNumber < 0 || maxAsNumber <= 0) {
      return "";
    }
    return `${countAsNumber} / ${maxAsNumber}`;
  }
  get supportingOrErrorText() {
    return this.error && this.errorText ? this.errorText : this.supportingText;
  }
  /**
   * Re-announces the field's error supporting text to screen readers.
   *
   * Error text announces to screen readers anytime it is visible and changes.
   * Use the method to re-announce the message when the text has not changed,
   * but announcement is still needed (such as for `reportValidity()`).
   */
  reannounceError() {
    this.refreshErrorAlert = true;
  }
  update(props2) {
    const isDisabledChanging = props2.has("disabled") && props2.get("disabled") !== void 0;
    if (isDisabledChanging) {
      this.disableTransitions = true;
    }
    if (this.disabled && this.focused) {
      props2.set("focused", true);
      this.focused = false;
    }
    this.animateLabelIfNeeded({
      wasFocused: props2.get("focused"),
      wasPopulated: props2.get("populated")
    });
    super.update(props2);
  }
  render() {
    const floatingLabel = this.renderLabel(
      /*isFloating*/
      true
    );
    const restingLabel = this.renderLabel(
      /*isFloating*/
      false
    );
    const outline = this.renderOutline?.(floatingLabel);
    const classes = {
      "disabled": this.disabled,
      "disable-transitions": this.disableTransitions,
      "error": this.error && !this.disabled,
      "focused": this.focused,
      "with-start": this.hasStart,
      "with-end": this.hasEnd,
      "populated": this.populated,
      "resizable": this.resizable,
      "required": this.required,
      "no-label": !this.label
    };
    return x$1`
      <div class="field ${e$1(classes)}">
        <div class="container-overflow">
          ${this.renderBackground?.()}
          <slot name="container"></slot>
          ${this.renderStateLayer?.()} ${this.renderIndicator?.()} ${outline}
          <div class="container">
            <div class="start">
              <slot name="start"></slot>
            </div>
            <div class="middle">
              <div class="label-wrapper">
                ${restingLabel} ${outline ? T$1 : floatingLabel}
              </div>
              <div class="content">
                <slot></slot>
              </div>
            </div>
            <div class="end">
              <slot name="end"></slot>
            </div>
          </div>
        </div>
        ${this.renderSupportingText()}
      </div>
    `;
  }
  updated(changed) {
    if (changed.has("supportingText") || changed.has("errorText") || changed.has("count") || changed.has("max")) {
      this.updateSlottedAriaDescribedBy();
    }
    if (this.refreshErrorAlert) {
      requestAnimationFrame(() => {
        this.refreshErrorAlert = false;
      });
    }
    if (this.disableTransitions) {
      requestAnimationFrame(() => {
        this.disableTransitions = false;
      });
    }
  }
  renderSupportingText() {
    const { supportingOrErrorText, counterText } = this;
    if (!supportingOrErrorText && !counterText) {
      return T$1;
    }
    const start2 = x$1`<span>${supportingOrErrorText}</span>`;
    const end2 = counterText ? x$1`<span class="counter">${counterText}</span>` : T$1;
    const shouldErrorAnnounce = this.error && this.errorText && !this.refreshErrorAlert;
    const role = shouldErrorAnnounce ? "alert" : T$1;
    return x$1`
      <div class="supporting-text" role=${role}>${start2}${end2}</div>
      <slot
        name="aria-describedby"
        @slotchange=${this.updateSlottedAriaDescribedBy}></slot>
    `;
  }
  updateSlottedAriaDescribedBy() {
    for (const element of this.slottedAriaDescribedBy) {
      j$1(x$1`${this.supportingOrErrorText} ${this.counterText}`, element);
      element.setAttribute("hidden", "");
    }
  }
  renderLabel(isFloating) {
    if (!this.label) {
      return T$1;
    }
    let visible;
    if (isFloating) {
      visible = this.focused || this.populated || this.isAnimating;
    } else {
      visible = !this.focused && !this.populated && !this.isAnimating;
    }
    const classes = {
      "hidden": !visible,
      "floating": isFloating,
      "resting": !isFloating
    };
    const labelText = `${this.label}${this.required && !this.noAsterisk ? "*" : ""}`;
    return x$1`
      <span class="label ${e$1(classes)}" aria-hidden=${!visible}
        >${labelText}</span
      >
    `;
  }
  animateLabelIfNeeded({ wasFocused, wasPopulated }) {
    if (!this.label) {
      return;
    }
    wasFocused ??= this.focused;
    wasPopulated ??= this.populated;
    const wasFloating = wasFocused || wasPopulated;
    const shouldBeFloating = this.focused || this.populated;
    if (wasFloating === shouldBeFloating) {
      return;
    }
    this.isAnimating = true;
    this.labelAnimation?.cancel();
    this.labelAnimation = this.floatingLabelEl?.animate(this.getLabelKeyframes(), { duration: 150, easing: EASING.STANDARD });
    this.labelAnimation?.addEventListener("finish", () => {
      this.isAnimating = false;
    });
  }
  getLabelKeyframes() {
    const { floatingLabelEl, restingLabelEl } = this;
    if (!floatingLabelEl || !restingLabelEl) {
      return [];
    }
    const { x: floatingX, y: floatingY, height: floatingHeight } = floatingLabelEl.getBoundingClientRect();
    const { x: restingX, y: restingY, height: restingHeight } = restingLabelEl.getBoundingClientRect();
    const floatingScrollWidth = floatingLabelEl.scrollWidth;
    const restingScrollWidth = restingLabelEl.scrollWidth;
    const scale = restingScrollWidth / floatingScrollWidth;
    const xDelta = restingX - floatingX;
    const yDelta = restingY - floatingY + Math.round((restingHeight - floatingHeight * scale) / 2);
    const restTransform = `translateX(${xDelta}px) translateY(${yDelta}px) scale(${scale})`;
    const floatTransform = `translateX(0) translateY(0) scale(1)`;
    const restingClientWidth = restingLabelEl.clientWidth;
    const isRestingClipped = restingScrollWidth > restingClientWidth;
    const width = isRestingClipped ? `${restingClientWidth / scale}px` : "";
    if (this.focused || this.populated) {
      return [
        { transform: restTransform, width },
        { transform: floatTransform, width }
      ];
    }
    return [
      { transform: floatTransform, width },
      { transform: restTransform, width }
    ];
  }
  getSurfacePositionClientRect() {
    return this.containerEl.getBoundingClientRect();
  }
}
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "disabled", void 0);
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "error", void 0);
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "focused", void 0);
__decorate([
  n$5()
], Field.prototype, "label", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-asterisk" })
], Field.prototype, "noAsterisk", void 0);
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "populated", void 0);
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "required", void 0);
__decorate([
  n$5({ type: Boolean })
], Field.prototype, "resizable", void 0);
__decorate([
  n$5({ attribute: "supporting-text" })
], Field.prototype, "supportingText", void 0);
__decorate([
  n$5({ attribute: "error-text" })
], Field.prototype, "errorText", void 0);
__decorate([
  n$5({ type: Number })
], Field.prototype, "count", void 0);
__decorate([
  n$5({ type: Number })
], Field.prototype, "max", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-start" })
], Field.prototype, "hasStart", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-end" })
], Field.prototype, "hasEnd", void 0);
__decorate([
  o$4({ slot: "aria-describedby" })
], Field.prototype, "slottedAriaDescribedBy", void 0);
__decorate([
  r$4()
], Field.prototype, "isAnimating", void 0);
__decorate([
  r$4()
], Field.prototype, "refreshErrorAlert", void 0);
__decorate([
  r$4()
], Field.prototype, "disableTransitions", void 0);
__decorate([
  e$5(".label.floating")
], Field.prototype, "floatingLabelEl", void 0);
__decorate([
  e$5(".label.resting")
], Field.prototype, "restingLabelEl", void 0);
__decorate([
  e$5(".container")
], Field.prototype, "containerEl", void 0);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class FilledField extends Field {
  renderBackground() {
    return x$1` <div class="background"></div> `;
  }
  renderStateLayer() {
    return x$1` <div class="state-layer"></div> `;
  }
  renderIndicator() {
    return x$1`<div class="active-indicator"></div>`;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$u = i$4`@layer styles{:host{--_active-indicator-color: var(--md-filled-field-active-indicator-color, var(--md-sys-color-on-surface-variant, #49454f));--_active-indicator-height: var(--md-filled-field-active-indicator-height, 1px);--_bottom-space: var(--md-filled-field-bottom-space, 16px);--_container-color: var(--md-filled-field-container-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_content-color: var(--md-filled-field-content-color, var(--md-sys-color-on-surface, #1d1b20));--_content-font: var(--md-filled-field-content-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_content-line-height: var(--md-filled-field-content-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_content-size: var(--md-filled-field-content-size, var(--md-sys-typescale-body-large-size, 1rem));--_content-space: var(--md-filled-field-content-space, 16px);--_content-weight: var(--md-filled-field-content-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_disabled-active-indicator-color: var(--md-filled-field-disabled-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-active-indicator-height: var(--md-filled-field-disabled-active-indicator-height, 1px);--_disabled-active-indicator-opacity: var(--md-filled-field-disabled-active-indicator-opacity, 0.38);--_disabled-container-color: var(--md-filled-field-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-opacity: var(--md-filled-field-disabled-container-opacity, 0.04);--_disabled-content-color: var(--md-filled-field-disabled-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-content-opacity: var(--md-filled-field-disabled-content-opacity, 0.38);--_disabled-label-text-color: var(--md-filled-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-filled-field-disabled-label-text-opacity, 0.38);--_disabled-leading-content-color: var(--md-filled-field-disabled-leading-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-content-opacity: var(--md-filled-field-disabled-leading-content-opacity, 0.38);--_disabled-supporting-text-color: var(--md-filled-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-supporting-text-opacity: var(--md-filled-field-disabled-supporting-text-opacity, 0.38);--_disabled-trailing-content-color: var(--md-filled-field-disabled-trailing-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-content-opacity: var(--md-filled-field-disabled-trailing-content-opacity, 0.38);--_error-active-indicator-color: var(--md-filled-field-error-active-indicator-color, var(--md-sys-color-error, #b3261e));--_error-content-color: var(--md-filled-field-error-content-color, var(--md-sys-color-on-surface, #1d1b20));--_error-focus-active-indicator-color: var(--md-filled-field-error-focus-active-indicator-color, var(--md-sys-color-error, #b3261e));--_error-focus-content-color: var(--md-filled-field-error-focus-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-focus-label-text-color: var(--md-filled-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-leading-content-color: var(--md-filled-field-error-focus-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-focus-supporting-text-color: var(--md-filled-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-trailing-content-color: var(--md-filled-field-error-focus-trailing-content-color, var(--md-sys-color-error, #b3261e));--_error-hover-active-indicator-color: var(--md-filled-field-error-hover-active-indicator-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-content-color: var(--md-filled-field-error-hover-content-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-label-text-color: var(--md-filled-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-leading-content-color: var(--md-filled-field-error-hover-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-hover-state-layer-color: var(--md-filled-field-error-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-state-layer-opacity: var(--md-filled-field-error-hover-state-layer-opacity, 0.08);--_error-hover-supporting-text-color: var(--md-filled-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-hover-trailing-content-color: var(--md-filled-field-error-hover-trailing-content-color, var(--md-sys-color-on-error-container, #410e0b));--_error-label-text-color: var(--md-filled-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_error-leading-content-color: var(--md-filled-field-error-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-supporting-text-color: var(--md-filled-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-trailing-content-color: var(--md-filled-field-error-trailing-content-color, var(--md-sys-color-error, #b3261e));--_focus-active-indicator-color: var(--md-filled-field-focus-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_focus-active-indicator-height: var(--md-filled-field-focus-active-indicator-height, 3px);--_focus-content-color: var(--md-filled-field-focus-content-color, var(--md-sys-color-on-surface, #1d1b20));--_focus-label-text-color: var(--md-filled-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_focus-leading-content-color: var(--md-filled-field-focus-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-supporting-text-color: var(--md-filled-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-trailing-content-color: var(--md-filled-field-focus-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-active-indicator-color: var(--md-filled-field-hover-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-active-indicator-height: var(--md-filled-field-hover-active-indicator-height, 1px);--_hover-content-color: var(--md-filled-field-hover-content-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-filled-field-hover-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-leading-content-color: var(--md-filled-field-hover-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-filled-field-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-opacity: var(--md-filled-field-hover-state-layer-opacity, 0.08);--_hover-supporting-text-color: var(--md-filled-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-content-color: var(--md-filled-field-hover-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-color: var(--md-filled-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-font: var(--md-filled-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-filled-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_label-text-populated-line-height: var(--md-filled-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_label-text-populated-size: var(--md-filled-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_label-text-size: var(--md-filled-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_label-text-weight: var(--md-filled-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_leading-content-color: var(--md-filled-field-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_leading-space: var(--md-filled-field-leading-space, 16px);--_supporting-text-color: var(--md-filled-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_supporting-text-font: var(--md-filled-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_supporting-text-leading-space: var(--md-filled-field-supporting-text-leading-space, 16px);--_supporting-text-line-height: var(--md-filled-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_supporting-text-size: var(--md-filled-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_supporting-text-top-space: var(--md-filled-field-supporting-text-top-space, 4px);--_supporting-text-trailing-space: var(--md-filled-field-supporting-text-trailing-space, 16px);--_supporting-text-weight: var(--md-filled-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_top-space: var(--md-filled-field-top-space, 16px);--_trailing-content-color: var(--md-filled-field-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-space: var(--md-filled-field-trailing-space, 16px);--_with-label-bottom-space: var(--md-filled-field-with-label-bottom-space, 8px);--_with-label-top-space: var(--md-filled-field-with-label-top-space, 8px);--_with-leading-content-leading-space: var(--md-filled-field-with-leading-content-leading-space, 12px);--_with-trailing-content-trailing-space: var(--md-filled-field-with-trailing-content-trailing-space, 12px);--_container-shape-start-start: var(--md-filled-field-container-shape-start-start, var(--md-filled-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-start-end: var(--md-filled-field-container-shape-start-end, var(--md-filled-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-end: var(--md-filled-field-container-shape-end-end, var(--md-filled-field-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-start: var(--md-filled-field-container-shape-end-start, var(--md-filled-field-container-shape, var(--md-sys-shape-corner-none, 0px)))}.background,.state-layer{border-radius:inherit;inset:0;pointer-events:none;position:absolute}.background{background:var(--_container-color)}.state-layer{visibility:hidden}.field:not(.disabled):hover .state-layer{visibility:visible}.label.floating{position:absolute;top:var(--_with-label-top-space)}.field:not(.with-start) .label-wrapper{margin-inline-start:var(--_leading-space)}.field:not(.with-end) .label-wrapper{margin-inline-end:var(--_trailing-space)}.active-indicator{inset:auto 0 0 0;pointer-events:none;position:absolute;width:100%;z-index:1}.active-indicator::before,.active-indicator::after{border-bottom:var(--_active-indicator-height) solid var(--_active-indicator-color);inset:auto 0 0 0;content:"";position:absolute;width:100%}.active-indicator::after{opacity:0;transition:opacity 150ms cubic-bezier(0.2, 0, 0, 1)}.focused .active-indicator::after{opacity:1}.field:not(.with-start) .content ::slotted(*){padding-inline-start:var(--_leading-space)}.field:not(.with-end) .content ::slotted(*){padding-inline-end:var(--_trailing-space)}.field:not(.no-label) .content ::slotted(:not(textarea)){padding-bottom:var(--_with-label-bottom-space);padding-top:calc(var(--_with-label-top-space) + var(--_label-text-populated-line-height))}.field:not(.no-label) .content ::slotted(textarea){margin-bottom:var(--_with-label-bottom-space);margin-top:calc(var(--_with-label-top-space) + var(--_label-text-populated-line-height))}:hover .active-indicator::before{border-bottom-color:var(--_hover-active-indicator-color);border-bottom-width:var(--_hover-active-indicator-height)}.active-indicator::after{border-bottom-color:var(--_focus-active-indicator-color);border-bottom-width:var(--_focus-active-indicator-height)}:hover .state-layer{background:var(--_hover-state-layer-color);opacity:var(--_hover-state-layer-opacity)}.disabled .active-indicator::before{border-bottom-color:var(--_disabled-active-indicator-color);border-bottom-width:var(--_disabled-active-indicator-height);opacity:var(--_disabled-active-indicator-opacity)}.disabled .background{background:var(--_disabled-container-color);opacity:var(--_disabled-container-opacity)}.error .active-indicator::before{border-bottom-color:var(--_error-active-indicator-color)}.error:hover .active-indicator::before{border-bottom-color:var(--_error-hover-active-indicator-color)}.error:hover .state-layer{background:var(--_error-hover-state-layer-color);opacity:var(--_error-hover-state-layer-opacity)}.error .active-indicator::after{border-bottom-color:var(--_error-focus-active-indicator-color)}.resizable .container{bottom:var(--_focus-active-indicator-height);clip-path:inset(var(--_focus-active-indicator-height) 0 0 0)}.resizable .container>*{top:var(--_focus-active-indicator-height)}}@layer hcm{@media(forced-colors: active){.disabled .active-indicator::before{border-color:GrayText;opacity:1}}}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$t = i$4`:host{display:inline-flex;resize:both}.field{display:flex;flex:1;flex-direction:column;writing-mode:horizontal-tb;max-width:100%}.container-overflow{border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-end-radius:var(--_container-shape-end-end);border-end-start-radius:var(--_container-shape-end-start);display:flex;height:100%;position:relative}.container{align-items:center;border-radius:inherit;display:flex;flex:1;max-height:100%;min-height:100%;min-width:min-content;position:relative}.field,.container-overflow{resize:inherit}.resizable:not(.disabled) .container{resize:inherit;overflow:hidden}.disabled{pointer-events:none}slot[name=container]{border-radius:inherit}slot[name=container]::slotted(*){border-radius:inherit;inset:0;pointer-events:none;position:absolute}@layer styles{.start,.middle,.end{display:flex;box-sizing:border-box;height:100%;position:relative}.start{color:var(--_leading-content-color)}.end{color:var(--_trailing-content-color)}.start,.end{align-items:center;justify-content:center}.with-start .start{margin-inline:var(--_with-leading-content-leading-space) var(--_content-space)}.with-end .end{margin-inline:var(--_content-space) var(--_with-trailing-content-trailing-space)}.middle{align-items:stretch;align-self:baseline;flex:1}.content{color:var(--_content-color);display:flex;flex:1;opacity:0;transition:opacity 83ms cubic-bezier(0.2, 0, 0, 1)}.no-label .content,.focused .content,.populated .content{opacity:1;transition-delay:67ms}:is(.disabled,.disable-transitions) .content{transition:none}.content ::slotted(*){all:unset;color:currentColor;font-family:var(--_content-font);font-size:var(--_content-size);line-height:var(--_content-line-height);font-weight:var(--_content-weight);width:100%;overflow-wrap:revert;white-space:revert}.content ::slotted(:not(textarea)){padding-top:var(--_top-space);padding-bottom:var(--_bottom-space)}.content ::slotted(textarea){margin-top:var(--_top-space);margin-bottom:var(--_bottom-space)}:hover .content{color:var(--_hover-content-color)}:hover .start{color:var(--_hover-leading-content-color)}:hover .end{color:var(--_hover-trailing-content-color)}.focused .content{color:var(--_focus-content-color)}.focused .start{color:var(--_focus-leading-content-color)}.focused .end{color:var(--_focus-trailing-content-color)}.disabled .content{color:var(--_disabled-content-color)}.disabled.no-label .content,.disabled.focused .content,.disabled.populated .content{opacity:var(--_disabled-content-opacity)}.disabled .start{color:var(--_disabled-leading-content-color);opacity:var(--_disabled-leading-content-opacity)}.disabled .end{color:var(--_disabled-trailing-content-color);opacity:var(--_disabled-trailing-content-opacity)}.error .content{color:var(--_error-content-color)}.error .start{color:var(--_error-leading-content-color)}.error .end{color:var(--_error-trailing-content-color)}.error:hover .content{color:var(--_error-hover-content-color)}.error:hover .start{color:var(--_error-hover-leading-content-color)}.error:hover .end{color:var(--_error-hover-trailing-content-color)}.error.focused .content{color:var(--_error-focus-content-color)}.error.focused .start{color:var(--_error-focus-leading-content-color)}.error.focused .end{color:var(--_error-focus-trailing-content-color)}}@layer hcm{@media(forced-colors: active){.disabled :is(.start,.content,.end){color:GrayText;opacity:1}}}@layer styles{.label{box-sizing:border-box;color:var(--_label-text-color);overflow:hidden;max-width:100%;text-overflow:ellipsis;white-space:nowrap;z-index:1;font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);width:min-content}.label-wrapper{inset:0;pointer-events:none;position:absolute}.label.resting{position:absolute;top:var(--_top-space)}.label.floating{font-size:var(--_label-text-populated-size);line-height:var(--_label-text-populated-line-height);transform-origin:top left}.label.hidden{opacity:0}.no-label .label{display:none}.label-wrapper{inset:0;position:absolute;text-align:initial}:hover .label{color:var(--_hover-label-text-color)}.focused .label{color:var(--_focus-label-text-color)}.disabled .label{color:var(--_disabled-label-text-color)}.disabled .label:not(.hidden){opacity:var(--_disabled-label-text-opacity)}.error .label{color:var(--_error-label-text-color)}.error:hover .label{color:var(--_error-hover-label-text-color)}.error.focused .label{color:var(--_error-focus-label-text-color)}}@layer hcm{@media(forced-colors: active){.disabled .label:not(.hidden){color:GrayText;opacity:1}}}@layer styles{.supporting-text{color:var(--_supporting-text-color);display:flex;font-family:var(--_supporting-text-font);font-size:var(--_supporting-text-size);line-height:var(--_supporting-text-line-height);font-weight:var(--_supporting-text-weight);gap:16px;justify-content:space-between;padding-inline-start:var(--_supporting-text-leading-space);padding-inline-end:var(--_supporting-text-trailing-space);padding-top:var(--_supporting-text-top-space)}.supporting-text :nth-child(2){flex-shrink:0}:hover .supporting-text{color:var(--_hover-supporting-text-color)}.focus .supporting-text{color:var(--_focus-supporting-text-color)}.disabled .supporting-text{color:var(--_disabled-supporting-text-color);opacity:var(--_disabled-supporting-text-opacity)}.error .supporting-text{color:var(--_error-supporting-text-color)}.error:hover .supporting-text{color:var(--_error-hover-supporting-text-color)}.error.focus .supporting-text{color:var(--_error-focus-supporting-text-color)}}@layer hcm{@media(forced-colors: active){.disabled .supporting-text{color:GrayText;opacity:1}}}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdFilledField = class MdFilledField2 extends FilledField {
};
MdFilledField.styles = [styles$t, styles$u];
MdFilledField = __decorate([
  t$3("md-filled-field")
], MdFilledField);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class OutlinedField extends Field {
  renderOutline(floatingLabel) {
    return x$1`
      <div class="outline">
        <div class="outline-start"></div>
        <div class="outline-notch">
          <div class="outline-panel-inactive"></div>
          <div class="outline-panel-active"></div>
          <div class="outline-label">${floatingLabel}</div>
        </div>
        <div class="outline-end"></div>
      </div>
    `;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$s = i$4`@layer styles{:host{--_bottom-space: var(--md-outlined-field-bottom-space, 16px);--_content-color: var(--md-outlined-field-content-color, var(--md-sys-color-on-surface, #1d1b20));--_content-font: var(--md-outlined-field-content-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_content-line-height: var(--md-outlined-field-content-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_content-size: var(--md-outlined-field-content-size, var(--md-sys-typescale-body-large-size, 1rem));--_content-space: var(--md-outlined-field-content-space, 16px);--_content-weight: var(--md-outlined-field-content-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_disabled-content-color: var(--md-outlined-field-disabled-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-content-opacity: var(--md-outlined-field-disabled-content-opacity, 0.38);--_disabled-label-text-color: var(--md-outlined-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-outlined-field-disabled-label-text-opacity, 0.38);--_disabled-leading-content-color: var(--md-outlined-field-disabled-leading-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-content-opacity: var(--md-outlined-field-disabled-leading-content-opacity, 0.38);--_disabled-outline-color: var(--md-outlined-field-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-outlined-field-disabled-outline-opacity, 0.12);--_disabled-outline-width: var(--md-outlined-field-disabled-outline-width, 1px);--_disabled-supporting-text-color: var(--md-outlined-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-supporting-text-opacity: var(--md-outlined-field-disabled-supporting-text-opacity, 0.38);--_disabled-trailing-content-color: var(--md-outlined-field-disabled-trailing-content-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-content-opacity: var(--md-outlined-field-disabled-trailing-content-opacity, 0.38);--_error-content-color: var(--md-outlined-field-error-content-color, var(--md-sys-color-on-surface, #1d1b20));--_error-focus-content-color: var(--md-outlined-field-error-focus-content-color, var(--md-sys-color-on-surface, #1d1b20));--_error-focus-label-text-color: var(--md-outlined-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-leading-content-color: var(--md-outlined-field-error-focus-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-focus-outline-color: var(--md-outlined-field-error-focus-outline-color, var(--md-sys-color-error, #b3261e));--_error-focus-supporting-text-color: var(--md-outlined-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-trailing-content-color: var(--md-outlined-field-error-focus-trailing-content-color, var(--md-sys-color-error, #b3261e));--_error-hover-content-color: var(--md-outlined-field-error-hover-content-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-label-text-color: var(--md-outlined-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-leading-content-color: var(--md-outlined-field-error-hover-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-hover-outline-color: var(--md-outlined-field-error-hover-outline-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-supporting-text-color: var(--md-outlined-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-hover-trailing-content-color: var(--md-outlined-field-error-hover-trailing-content-color, var(--md-sys-color-on-error-container, #410e0b));--_error-label-text-color: var(--md-outlined-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_error-leading-content-color: var(--md-outlined-field-error-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-outline-color: var(--md-outlined-field-error-outline-color, var(--md-sys-color-error, #b3261e));--_error-supporting-text-color: var(--md-outlined-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-trailing-content-color: var(--md-outlined-field-error-trailing-content-color, var(--md-sys-color-error, #b3261e));--_focus-content-color: var(--md-outlined-field-focus-content-color, var(--md-sys-color-on-surface, #1d1b20));--_focus-label-text-color: var(--md-outlined-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_focus-leading-content-color: var(--md-outlined-field-focus-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-outline-color: var(--md-outlined-field-focus-outline-color, var(--md-sys-color-primary, #6750a4));--_focus-outline-width: var(--md-outlined-field-focus-outline-width, 3px);--_focus-supporting-text-color: var(--md-outlined-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-trailing-content-color: var(--md-outlined-field-focus-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-content-color: var(--md-outlined-field-hover-content-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-outlined-field-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-leading-content-color: var(--md-outlined-field-hover-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-outline-color: var(--md-outlined-field-hover-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-outline-width: var(--md-outlined-field-hover-outline-width, 1px);--_hover-supporting-text-color: var(--md-outlined-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-content-color: var(--md-outlined-field-hover-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-color: var(--md-outlined-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-font: var(--md-outlined-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-outlined-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_label-text-padding-bottom: var(--md-outlined-field-label-text-padding-bottom, 8px);--_label-text-populated-line-height: var(--md-outlined-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_label-text-populated-size: var(--md-outlined-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_label-text-size: var(--md-outlined-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_label-text-weight: var(--md-outlined-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_leading-content-color: var(--md-outlined-field-leading-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_leading-space: var(--md-outlined-field-leading-space, 16px);--_outline-color: var(--md-outlined-field-outline-color, var(--md-sys-color-outline, #79747e));--_outline-label-padding: var(--md-outlined-field-outline-label-padding, 4px);--_outline-width: var(--md-outlined-field-outline-width, 1px);--_supporting-text-color: var(--md-outlined-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_supporting-text-font: var(--md-outlined-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_supporting-text-leading-space: var(--md-outlined-field-supporting-text-leading-space, 16px);--_supporting-text-line-height: var(--md-outlined-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_supporting-text-size: var(--md-outlined-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_supporting-text-top-space: var(--md-outlined-field-supporting-text-top-space, 4px);--_supporting-text-trailing-space: var(--md-outlined-field-supporting-text-trailing-space, 16px);--_supporting-text-weight: var(--md-outlined-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_top-space: var(--md-outlined-field-top-space, 16px);--_trailing-content-color: var(--md-outlined-field-trailing-content-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-space: var(--md-outlined-field-trailing-space, 16px);--_with-leading-content-leading-space: var(--md-outlined-field-with-leading-content-leading-space, 12px);--_with-trailing-content-trailing-space: var(--md-outlined-field-with-trailing-content-trailing-space, 12px);--_container-shape-start-start: var(--md-outlined-field-container-shape-start-start, var(--md-outlined-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-start-end: var(--md-outlined-field-container-shape-start-end, var(--md-outlined-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-end: var(--md-outlined-field-container-shape-end-end, var(--md-outlined-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-start: var(--md-outlined-field-container-shape-end-start, var(--md-outlined-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)))}.outline{border-color:var(--_outline-color);border-radius:inherit;display:flex;pointer-events:none;height:100%;position:absolute;width:100%;z-index:1}.outline-start::before,.outline-start::after,.outline-panel-inactive::before,.outline-panel-inactive::after,.outline-panel-active::before,.outline-panel-active::after,.outline-end::before,.outline-end::after{border:inherit;content:"";inset:0;position:absolute}.outline-start,.outline-end{border:inherit;border-radius:inherit;box-sizing:border-box;position:relative}.outline-start::before,.outline-start::after,.outline-end::before,.outline-end::after{border-bottom-style:solid;border-top-style:solid}.outline-start::after,.outline-end::after{opacity:0;transition:opacity 150ms cubic-bezier(0.2, 0, 0, 1)}.focused .outline-start::after,.focused .outline-end::after{opacity:1}.outline-start::before,.outline-start::after{border-inline-start-style:solid;border-inline-end-style:none;border-start-start-radius:inherit;border-start-end-radius:0;border-end-start-radius:inherit;border-end-end-radius:0;margin-inline-end:var(--_outline-label-padding)}.outline-end{flex-grow:1;margin-inline-start:calc(-1*var(--_outline-label-padding))}.outline-end::before,.outline-end::after{border-inline-start-style:none;border-inline-end-style:solid;border-start-start-radius:0;border-start-end-radius:inherit;border-end-start-radius:0;border-end-end-radius:inherit}.outline-notch{align-items:flex-start;border:inherit;display:flex;margin-inline-start:calc(-1*var(--_outline-label-padding));margin-inline-end:var(--_outline-label-padding);max-width:calc(100% - var(--_leading-space) - var(--_trailing-space));padding:0 var(--_outline-label-padding);position:relative}.no-label .outline-notch{display:none}.outline-panel-inactive,.outline-panel-active{border:inherit;border-bottom-style:solid;inset:0;position:absolute}.outline-panel-inactive::before,.outline-panel-inactive::after,.outline-panel-active::before,.outline-panel-active::after{border-top-style:solid;border-bottom:none;bottom:auto;transform:scaleX(1);transition:transform 150ms cubic-bezier(0.2, 0, 0, 1)}.outline-panel-inactive::before,.outline-panel-active::before{right:50%;transform-origin:top left}.outline-panel-inactive::after,.outline-panel-active::after{left:50%;transform-origin:top right}.populated .outline-panel-inactive::before,.populated .outline-panel-inactive::after,.populated .outline-panel-active::before,.populated .outline-panel-active::after,.focused .outline-panel-inactive::before,.focused .outline-panel-inactive::after,.focused .outline-panel-active::before,.focused .outline-panel-active::after{transform:scaleX(0)}.outline-panel-active{opacity:0;transition:opacity 150ms cubic-bezier(0.2, 0, 0, 1)}.focused .outline-panel-active{opacity:1}.outline-label{display:flex;max-width:100%;transform:translateY(calc(-100% + var(--_label-text-padding-bottom)))}.outline-start,.field:not(.with-start) .content ::slotted(*){padding-inline-start:max(var(--_leading-space),max(var(--_container-shape-start-start),var(--_container-shape-end-start)) + var(--_outline-label-padding))}.field:not(.with-start) .label-wrapper{margin-inline-start:max(var(--_leading-space),max(var(--_container-shape-start-start),var(--_container-shape-end-start)) + var(--_outline-label-padding))}.field:not(.with-end) .content ::slotted(*){padding-inline-end:max(var(--_trailing-space),max(var(--_container-shape-start-end),var(--_container-shape-end-end)))}.field:not(.with-end) .label-wrapper{margin-inline-end:max(var(--_trailing-space),max(var(--_container-shape-start-end),var(--_container-shape-end-end)))}.outline-start::before,.outline-end::before,.outline-panel-inactive,.outline-panel-inactive::before,.outline-panel-inactive::after{border-width:var(--_outline-width)}:hover .outline{border-color:var(--_hover-outline-color);color:var(--_hover-outline-color)}:hover .outline-start::before,:hover .outline-end::before,:hover .outline-panel-inactive,:hover .outline-panel-inactive::before,:hover .outline-panel-inactive::after{border-width:var(--_hover-outline-width)}.focused .outline{border-color:var(--_focus-outline-color);color:var(--_focus-outline-color)}.outline-start::after,.outline-end::after,.outline-panel-active,.outline-panel-active::before,.outline-panel-active::after{border-width:var(--_focus-outline-width)}.disabled .outline{border-color:var(--_disabled-outline-color);color:var(--_disabled-outline-color)}.disabled .outline-start,.disabled .outline-end,.disabled .outline-panel-inactive{opacity:var(--_disabled-outline-opacity)}.disabled .outline-start::before,.disabled .outline-end::before,.disabled .outline-panel-inactive,.disabled .outline-panel-inactive::before,.disabled .outline-panel-inactive::after{border-width:var(--_disabled-outline-width)}.error .outline{border-color:var(--_error-outline-color);color:var(--_error-outline-color)}.error:hover .outline{border-color:var(--_error-hover-outline-color);color:var(--_error-hover-outline-color)}.error.focused .outline{border-color:var(--_error-focus-outline-color);color:var(--_error-focus-outline-color)}.resizable .container{bottom:var(--_focus-outline-width);inset-inline-end:var(--_focus-outline-width);clip-path:inset(var(--_focus-outline-width) 0 0 var(--_focus-outline-width))}.resizable .container>*{top:var(--_focus-outline-width);inset-inline-start:var(--_focus-outline-width)}.resizable .container:dir(rtl){clip-path:inset(var(--_focus-outline-width) var(--_focus-outline-width) 0 0)}}@layer hcm{@media(forced-colors: active){.disabled .outline{border-color:GrayText;color:GrayText}.disabled :is(.outline-start,.outline-end,.outline-panel-inactive){opacity:1}}}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdOutlinedField = class MdOutlinedField2 extends OutlinedField {
};
MdOutlinedField.styles = [styles$t, styles$s];
MdOutlinedField = __decorate([
  t$3("md-outlined-field")
], MdOutlinedField);
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Icon extends s$1 {
  render() {
    return x$1`<slot></slot>`;
  }
  connectedCallback() {
    super.connectedCallback();
    const ariaHidden = this.getAttribute("aria-hidden");
    if (ariaHidden === "false") {
      this.removeAttribute("aria-hidden");
      return;
    }
    this.setAttribute("aria-hidden", "true");
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$r = i$4`:host{font-size:var(--md-icon-size, 24px);width:var(--md-icon-size, 24px);height:var(--md-icon-size, 24px);color:inherit;font-variation-settings:inherit;font-weight:400;font-family:var(--md-icon-font, Material Symbols Outlined);display:inline-flex;font-style:normal;place-items:center;place-content:center;line-height:1;overflow:hidden;letter-spacing:normal;text-transform:none;user-select:none;white-space:nowrap;word-wrap:normal;flex-shrink:0;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale}::slotted(svg){fill:currentColor}::slotted(*){height:100%;width:100%}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdIcon = class MdIcon2 extends Icon {
};
MdIcon.styles = [styles$r];
MdIcon = __decorate([
  t$3("md-icon")
], MdIcon);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$q = i$4`:host{--_container-color: var(--md-filled-icon-button-container-color, var(--md-sys-color-primary, #6750a4));--_container-height: var(--md-filled-icon-button-container-height, 40px);--_container-width: var(--md-filled-icon-button-container-width, 40px);--_disabled-container-color: var(--md-filled-icon-button-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-opacity: var(--md-filled-icon-button-disabled-container-opacity, 0.12);--_disabled-icon-color: var(--md-filled-icon-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-filled-icon-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-filled-icon-button-focus-icon-color, var(--md-sys-color-on-primary, #fff));--_hover-icon-color: var(--md-filled-icon-button-hover-icon-color, var(--md-sys-color-on-primary, #fff));--_hover-state-layer-color: var(--md-filled-icon-button-hover-state-layer-color, var(--md-sys-color-on-primary, #fff));--_hover-state-layer-opacity: var(--md-filled-icon-button-hover-state-layer-opacity, 0.08);--_icon-color: var(--md-filled-icon-button-icon-color, var(--md-sys-color-on-primary, #fff));--_icon-size: var(--md-filled-icon-button-icon-size, 24px);--_pressed-icon-color: var(--md-filled-icon-button-pressed-icon-color, var(--md-sys-color-on-primary, #fff));--_pressed-state-layer-color: var(--md-filled-icon-button-pressed-state-layer-color, var(--md-sys-color-on-primary, #fff));--_pressed-state-layer-opacity: var(--md-filled-icon-button-pressed-state-layer-opacity, 0.12);--_selected-container-color: var(--md-filled-icon-button-selected-container-color, var(--md-sys-color-primary, #6750a4));--_toggle-selected-focus-icon-color: var(--md-filled-icon-button-toggle-selected-focus-icon-color, var(--md-sys-color-on-primary, #fff));--_toggle-selected-hover-icon-color: var(--md-filled-icon-button-toggle-selected-hover-icon-color, var(--md-sys-color-on-primary, #fff));--_toggle-selected-hover-state-layer-color: var(--md-filled-icon-button-toggle-selected-hover-state-layer-color, var(--md-sys-color-on-primary, #fff));--_toggle-selected-icon-color: var(--md-filled-icon-button-toggle-selected-icon-color, var(--md-sys-color-on-primary, #fff));--_toggle-selected-pressed-icon-color: var(--md-filled-icon-button-toggle-selected-pressed-icon-color, var(--md-sys-color-on-primary, #fff));--_toggle-selected-pressed-state-layer-color: var(--md-filled-icon-button-toggle-selected-pressed-state-layer-color, var(--md-sys-color-on-primary, #fff));--_unselected-container-color: var(--md-filled-icon-button-unselected-container-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_toggle-focus-icon-color: var(--md-filled-icon-button-toggle-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_toggle-hover-icon-color: var(--md-filled-icon-button-toggle-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_toggle-hover-state-layer-color: var(--md-filled-icon-button-toggle-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_toggle-icon-color: var(--md-filled-icon-button-toggle-icon-color, var(--md-sys-color-primary, #6750a4));--_toggle-pressed-icon-color: var(--md-filled-icon-button-toggle-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_toggle-pressed-state-layer-color: var(--md-filled-icon-button-toggle-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_container-shape-start-start: var(--md-filled-icon-button-container-shape-start-start, var(--md-filled-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-filled-icon-button-container-shape-start-end, var(--md-filled-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-filled-icon-button-container-shape-end-end, var(--md-filled-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-filled-icon-button-container-shape-end-start, var(--md-filled-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)))}.icon-button{color:var(--_icon-color);--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}.icon-button:hover{color:var(--_hover-icon-color)}.icon-button:focus{color:var(--_focus-icon-color)}.icon-button:active{color:var(--_pressed-icon-color)}.icon-button:is(:disabled,[aria-disabled=true]){color:var(--_disabled-icon-color)}.icon-button::before{background-color:var(--_container-color);border-radius:inherit;content:"";inset:0;position:absolute;z-index:-1}.icon-button:is(:disabled,[aria-disabled=true])::before{background-color:var(--_disabled-container-color);opacity:var(--_disabled-container-opacity)}.icon-button:is(:disabled,[aria-disabled=true]) .icon{opacity:var(--_disabled-icon-opacity)}.toggle-filled{--md-ripple-hover-color: var(--_toggle-hover-state-layer-color);--md-ripple-pressed-color: var(--_toggle-pressed-state-layer-color)}.toggle-filled:not(:disabled,[aria-disabled=true]){color:var(--_toggle-icon-color)}.toggle-filled:not(:disabled,[aria-disabled=true]):hover{color:var(--_toggle-hover-icon-color)}.toggle-filled:not(:disabled,[aria-disabled=true]):focus{color:var(--_toggle-focus-icon-color)}.toggle-filled:not(:disabled,[aria-disabled=true]):active{color:var(--_toggle-pressed-icon-color)}.toggle-filled:not(:disabled,[aria-disabled=true])::before{background-color:var(--_unselected-container-color)}.selected{--md-ripple-hover-color: var(--_toggle-selected-hover-state-layer-color);--md-ripple-pressed-color: var(--_toggle-selected-pressed-state-layer-color)}.selected:not(:disabled,[aria-disabled=true]){color:var(--_toggle-selected-icon-color)}.selected:not(:disabled,[aria-disabled=true]):hover{color:var(--_toggle-selected-hover-icon-color)}.selected:not(:disabled,[aria-disabled=true]):focus{color:var(--_toggle-selected-focus-icon-color)}.selected:not(:disabled,[aria-disabled=true]):active{color:var(--_toggle-selected-pressed-icon-color)}.selected:not(:disabled,[aria-disabled=true])::before{background-color:var(--_selected-container-color)}
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e = Symbol.for(""), o$1 = (t2) => {
  if (t2?.r === e) return t2?._$litStatic$;
}, s2 = (t2, ...r2) => ({ _$litStatic$: r2.reduce((r3, e2, o2) => r3 + ((t3) => {
  if (void 0 !== t3._$litStatic$) return t3._$litStatic$;
  throw Error(`Value passed to 'literal' function must be a 'literal' result: ${t3}. Use 'unsafeStatic' to pass non-literal values, but
            take care to ensure page security.`);
})(e2) + t2[o2 + 1], t2[0]), r: e }), a = /* @__PURE__ */ new Map(), l$1 = (t2) => (r2, ...e2) => {
  const i3 = e2.length;
  let s3, l2;
  const n3 = [], u2 = [];
  let c2, $2 = 0, f2 = false;
  for (; $2 < i3; ) {
    for (c2 = r2[$2]; $2 < i3 && void 0 !== (l2 = e2[$2], s3 = o$1(l2)); ) c2 += s3 + r2[++$2], f2 = true;
    $2 !== i3 && u2.push(l2), n3.push(c2), $2++;
  }
  if ($2 === i3 && n3.push(r2[i3]), f2) {
    const t3 = n3.join("$$lit$$");
    void 0 === (r2 = a.get(t3)) && (n3.raw = n3, a.set(t3, r2 = n3)), e2 = u2;
  }
  return t2(r2, ...e2);
}, n$2 = l$1(x$1);
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function isRtl(el, shouldCheck = true) {
  return shouldCheck && getComputedStyle(el).getPropertyValue("direction").trim() === "rtl";
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const iconButtonBaseClass = mixinDelegatesAria(mixinElementInternals(s$1));
class IconButton extends iconButtonBaseClass {
  get name() {
    return this.getAttribute("name") ?? "";
  }
  set name(name2) {
    this.setAttribute("name", name2);
  }
  /**
   * The associated form element with which this element's value will submit.
   */
  get form() {
    return this[internals].form;
  }
  /**
   * The labels this element is associated with.
   */
  get labels() {
    return this[internals].labels;
  }
  constructor() {
    super();
    this.disabled = false;
    this.softDisabled = false;
    this.flipIconInRtl = false;
    this.href = "";
    this.target = "";
    this.ariaLabelSelected = "";
    this.toggle = false;
    this.selected = false;
    this.type = "submit";
    this.value = "";
    this.flipIcon = isRtl(this, this.flipIconInRtl);
    {
      this.addEventListener("click", this.handleClick.bind(this));
    }
  }
  willUpdate() {
    if (this.href) {
      this.disabled = false;
      this.softDisabled = false;
    }
  }
  render() {
    const tag = this.href ? s2`div` : s2`button`;
    const { ariaLabel, ariaHasPopup, ariaExpanded } = this;
    const hasToggledAriaLabel = ariaLabel && this.ariaLabelSelected;
    const ariaPressedValue = !this.toggle ? T$1 : this.selected;
    let ariaLabelValue = T$1;
    if (!this.href) {
      ariaLabelValue = hasToggledAriaLabel && this.selected ? this.ariaLabelSelected : ariaLabel;
    }
    return n$2`<${tag}
        class="icon-button ${e$1(this.getRenderClasses())}"
        id="button"
        aria-label="${ariaLabelValue || T$1}"
        aria-haspopup="${!this.href && ariaHasPopup || T$1}"
        aria-expanded="${!this.href && ariaExpanded || T$1}"
        aria-pressed="${ariaPressedValue}"
        aria-disabled=${!this.href && this.softDisabled || T$1}
        ?disabled="${!this.href && this.disabled}"
        @click="${this.handleClickOnChild}">
        ${this.renderFocusRing()}
        ${this.renderRipple()}
        ${!this.selected ? this.renderIcon() : T$1}
        ${this.selected ? this.renderSelectedIcon() : T$1}
        ${this.renderTouchTarget()}
        ${this.href && this.renderLink()}
  </${tag}>`;
  }
  renderLink() {
    const { ariaLabel } = this;
    return x$1`
      <a
        class="link"
        id="link"
        href="${this.href}"
        target="${this.target || T$1}"
        aria-label="${ariaLabel || T$1}"></a>
    `;
  }
  getRenderClasses() {
    return {
      "flip-icon": this.flipIcon,
      "selected": this.toggle && this.selected
    };
  }
  renderIcon() {
    return x$1`<span class="icon"><slot></slot></span>`;
  }
  renderSelectedIcon() {
    return x$1`<span class="icon icon--selected"
      ><slot name="selected"><slot></slot></slot
    ></span>`;
  }
  renderTouchTarget() {
    return x$1`<span class="touch"></span>`;
  }
  renderFocusRing() {
    return x$1`<md-focus-ring
      part="focus-ring"
      for=${this.href ? "link" : "button"}></md-focus-ring>`;
  }
  renderRipple() {
    const isRippleDisabled = !this.href && (this.disabled || this.softDisabled);
    return x$1`<md-ripple
      for=${this.href ? "link" : T$1}
      ?disabled="${isRippleDisabled}"></md-ripple>`;
  }
  connectedCallback() {
    this.flipIcon = isRtl(this, this.flipIconInRtl);
    super.connectedCallback();
  }
  /** Handles a click on this element. */
  handleClick(event) {
    if (!this.href && this.softDisabled) {
      event.stopImmediatePropagation();
      event.preventDefault();
      return;
    }
  }
  /**
   * Handles a click on the child <div> or <button> element within this
   * element's shadow DOM.
   */
  async handleClickOnChild(event) {
    await 0;
    if (!this.toggle || this.disabled || this.softDisabled || event.defaultPrevented) {
      return;
    }
    this.selected = !this.selected;
    this.dispatchEvent(new InputEvent("input", { bubbles: true, composed: true }));
    this.dispatchEvent(new Event("change", { bubbles: true }));
  }
}
(() => {
  setupFormSubmitter(IconButton);
})();
IconButton.formAssociated = true;
IconButton.shadowRootOptions = {
  mode: "open",
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], IconButton.prototype, "disabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "soft-disabled", reflect: true })
], IconButton.prototype, "softDisabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "flip-icon-in-rtl" })
], IconButton.prototype, "flipIconInRtl", void 0);
__decorate([
  n$5()
], IconButton.prototype, "href", void 0);
__decorate([
  n$5()
], IconButton.prototype, "target", void 0);
__decorate([
  n$5({ attribute: "aria-label-selected" })
], IconButton.prototype, "ariaLabelSelected", void 0);
__decorate([
  n$5({ type: Boolean })
], IconButton.prototype, "toggle", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], IconButton.prototype, "selected", void 0);
__decorate([
  n$5()
], IconButton.prototype, "type", void 0);
__decorate([
  n$5({ reflect: true })
], IconButton.prototype, "value", void 0);
__decorate([
  r$4()
], IconButton.prototype, "flipIcon", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$p = i$4`:host{display:inline-flex;outline:none;-webkit-tap-highlight-color:rgba(0,0,0,0);height:var(--_container-height);width:var(--_container-width);justify-content:center}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--_container-height))/2) max(0px,(48px - var(--_container-width))/2)}md-focus-ring{--md-focus-ring-shape-start-start: var(--_container-shape-start-start);--md-focus-ring-shape-start-end: var(--_container-shape-start-end);--md-focus-ring-shape-end-end: var(--_container-shape-end-end);--md-focus-ring-shape-end-start: var(--_container-shape-end-start)}:host(:is([disabled],[soft-disabled])){pointer-events:none}.icon-button{place-items:center;background:none;border:none;box-sizing:border-box;cursor:pointer;display:flex;place-content:center;outline:none;padding:0;position:relative;text-decoration:none;user-select:none;z-index:0;flex:1;border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end)}.icon ::slotted(*){font-size:var(--_icon-size);height:var(--_icon-size);width:var(--_icon-size);font-weight:inherit}md-ripple{z-index:-1;border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-start-radius:var(--_container-shape-end-start);border-end-end-radius:var(--_container-shape-end-end)}.flip-icon .icon{transform:scaleX(-1)}.icon{display:inline-flex}.link{height:100%;outline:none;position:absolute;width:100%}.touch{position:absolute;height:max(48px,100%);width:max(48px,100%)}:host([touch-target=none]) .touch{display:none}@media(forced-colors: active){:host(:is([disabled],[soft-disabled])){--_disabled-icon-color: GrayText;--_disabled-icon-opacity: 1}}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdFilledIconButton = class MdFilledIconButton2 extends IconButton {
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "filled": true,
      "toggle-filled": this.toggle
    };
  }
};
MdFilledIconButton.styles = [styles$p, styles$q];
MdFilledIconButton = __decorate([
  t$3("md-filled-icon-button")
], MdFilledIconButton);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$o = i$4`:host{--_container-color: var(--md-filled-tonal-icon-button-container-color, var(--md-sys-color-secondary-container, #e8def8));--_container-height: var(--md-filled-tonal-icon-button-container-height, 40px);--_container-width: var(--md-filled-tonal-icon-button-container-width, 40px);--_disabled-container-color: var(--md-filled-tonal-icon-button-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-opacity: var(--md-filled-tonal-icon-button-disabled-container-opacity, 0.12);--_disabled-icon-color: var(--md-filled-tonal-icon-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-filled-tonal-icon-button-disabled-icon-opacity, 0.38);--_focus-icon-color: var(--md-filled-tonal-icon-button-focus-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-icon-color: var(--md-filled-tonal-icon-button-hover-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-state-layer-color: var(--md-filled-tonal-icon-button-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_hover-state-layer-opacity: var(--md-filled-tonal-icon-button-hover-state-layer-opacity, 0.08);--_icon-color: var(--md-filled-tonal-icon-button-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_icon-size: var(--md-filled-tonal-icon-button-icon-size, 24px);--_pressed-icon-color: var(--md-filled-tonal-icon-button-pressed-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_pressed-state-layer-color: var(--md-filled-tonal-icon-button-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_pressed-state-layer-opacity: var(--md-filled-tonal-icon-button-pressed-state-layer-opacity, 0.12);--_selected-container-color: var(--md-filled-tonal-icon-button-selected-container-color, var(--md-sys-color-secondary-container, #e8def8));--_toggle-selected-focus-icon-color: var(--md-filled-tonal-icon-button-toggle-selected-focus-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_toggle-selected-hover-icon-color: var(--md-filled-tonal-icon-button-toggle-selected-hover-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_toggle-selected-hover-state-layer-color: var(--md-filled-tonal-icon-button-toggle-selected-hover-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_toggle-selected-icon-color: var(--md-filled-tonal-icon-button-toggle-selected-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_toggle-selected-pressed-icon-color: var(--md-filled-tonal-icon-button-toggle-selected-pressed-icon-color, var(--md-sys-color-on-secondary-container, #1d192b));--_toggle-selected-pressed-state-layer-color: var(--md-filled-tonal-icon-button-toggle-selected-pressed-state-layer-color, var(--md-sys-color-on-secondary-container, #1d192b));--_unselected-container-color: var(--md-filled-tonal-icon-button-unselected-container-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_toggle-focus-icon-color: var(--md-filled-tonal-icon-button-toggle-focus-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_toggle-hover-icon-color: var(--md-filled-tonal-icon-button-toggle-hover-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_toggle-hover-state-layer-color: var(--md-filled-tonal-icon-button-toggle-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_toggle-icon-color: var(--md-filled-tonal-icon-button-toggle-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_toggle-pressed-icon-color: var(--md-filled-tonal-icon-button-toggle-pressed-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_toggle-pressed-state-layer-color: var(--md-filled-tonal-icon-button-toggle-pressed-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_container-shape-start-start: var(--md-filled-tonal-icon-button-container-shape-start-start, var(--md-filled-tonal-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-filled-tonal-icon-button-container-shape-start-end, var(--md-filled-tonal-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-filled-tonal-icon-button-container-shape-end-end, var(--md-filled-tonal-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-filled-tonal-icon-button-container-shape-end-start, var(--md-filled-tonal-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)))}.icon-button{color:var(--_icon-color);--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}.icon-button:hover{color:var(--_hover-icon-color)}.icon-button:focus{color:var(--_focus-icon-color)}.icon-button:active{color:var(--_pressed-icon-color)}.icon-button:is(:disabled,[aria-disabled=true]){color:var(--_disabled-icon-color)}.icon-button::before{background-color:var(--_container-color);border-radius:inherit;content:"";inset:0;position:absolute;z-index:-1}.icon-button:is(:disabled,[aria-disabled=true])::before{background-color:var(--_disabled-container-color);opacity:var(--_disabled-container-opacity)}.icon-button:is(:disabled,[aria-disabled=true]) .icon{opacity:var(--_disabled-icon-opacity)}.toggle-filled-tonal{--md-ripple-hover-color: var(--_toggle-hover-state-layer-color);--md-ripple-pressed-color: var(--_toggle-pressed-state-layer-color)}.toggle-filled-tonal:not(:disabled,[aria-disabled=true]){color:var(--_toggle-icon-color)}.toggle-filled-tonal:not(:disabled,[aria-disabled=true]):hover{color:var(--_toggle-hover-icon-color)}.toggle-filled-tonal:not(:disabled,[aria-disabled=true]):focus{color:var(--_toggle-focus-icon-color)}.toggle-filled-tonal:not(:disabled,[aria-disabled=true]):active{color:var(--_toggle-pressed-icon-color)}.toggle-filled-tonal:not(:disabled,[aria-disabled=true])::before{background-color:var(--_unselected-container-color)}.selected{--md-ripple-hover-color: var(--_toggle-selected-hover-state-layer-color);--md-ripple-pressed-color: var(--_toggle-selected-pressed-state-layer-color)}.selected:not(:disabled,[aria-disabled=true]){color:var(--_toggle-selected-icon-color)}.selected:not(:disabled,[aria-disabled=true]):hover{color:var(--_toggle-selected-hover-icon-color)}.selected:not(:disabled,[aria-disabled=true]):focus{color:var(--_toggle-selected-focus-icon-color)}.selected:not(:disabled,[aria-disabled=true]):active{color:var(--_toggle-selected-pressed-icon-color)}.selected:not(:disabled,[aria-disabled=true])::before{background-color:var(--_selected-container-color)}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdFilledTonalIconButton = class MdFilledTonalIconButton2 extends IconButton {
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "filled-tonal": true,
      "toggle-filled-tonal": this.toggle
    };
  }
};
MdFilledTonalIconButton.styles = [styles$p, styles$o];
MdFilledTonalIconButton = __decorate([
  t$3("md-filled-tonal-icon-button")
], MdFilledTonalIconButton);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$n = i$4`:host{--_disabled-icon-color: var(--md-icon-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-icon-button-disabled-icon-opacity, 0.38);--_icon-size: var(--md-icon-button-icon-size, 24px);--_selected-focus-icon-color: var(--md-icon-button-selected-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-hover-icon-color: var(--md-icon-button-selected-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-hover-state-layer-color: var(--md-icon-button-selected-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_selected-hover-state-layer-opacity: var(--md-icon-button-selected-hover-state-layer-opacity, 0.08);--_selected-icon-color: var(--md-icon-button-selected-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-pressed-icon-color: var(--md-icon-button-selected-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_selected-pressed-state-layer-color: var(--md-icon-button-selected-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_selected-pressed-state-layer-opacity: var(--md-icon-button-selected-pressed-state-layer-opacity, 0.12);--_state-layer-height: var(--md-icon-button-state-layer-height, 40px);--_state-layer-shape: var(--md-icon-button-state-layer-shape, var(--md-sys-shape-corner-full, 9999px));--_state-layer-width: var(--md-icon-button-state-layer-width, 40px);--_focus-icon-color: var(--md-icon-button-focus-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-icon-color: var(--md-icon-button-hover-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-icon-button-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-opacity: var(--md-icon-button-hover-state-layer-opacity, 0.08);--_icon-color: var(--md-icon-button-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-icon-color: var(--md-icon-button-pressed-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-color: var(--md-icon-button-pressed-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-state-layer-opacity: var(--md-icon-button-pressed-state-layer-opacity, 0.12);--_container-shape-start-start: 0;--_container-shape-start-end: 0;--_container-shape-end-end: 0;--_container-shape-end-start: 0;--_container-height: 0;--_container-width: 0;height:var(--_state-layer-height);width:var(--_state-layer-width)}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--_state-layer-height))/2) max(0px,(48px - var(--_state-layer-width))/2)}md-focus-ring{--md-focus-ring-shape-start-start: var(--_state-layer-shape);--md-focus-ring-shape-start-end: var(--_state-layer-shape);--md-focus-ring-shape-end-end: var(--_state-layer-shape);--md-focus-ring-shape-end-start: var(--_state-layer-shape)}.standard{background-color:rgba(0,0,0,0);color:var(--_icon-color);--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}.standard:hover{color:var(--_hover-icon-color)}.standard:focus{color:var(--_focus-icon-color)}.standard:active{color:var(--_pressed-icon-color)}.standard:is(:disabled,[aria-disabled=true]){color:var(--_disabled-icon-color)}md-ripple{border-radius:var(--_state-layer-shape)}.standard:is(:disabled,[aria-disabled=true]){opacity:var(--_disabled-icon-opacity)}.selected{--md-ripple-hover-color: var(--_selected-hover-state-layer-color);--md-ripple-hover-opacity: var(--_selected-hover-state-layer-opacity);--md-ripple-pressed-color: var(--_selected-pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_selected-pressed-state-layer-opacity)}.selected:not(:disabled,[aria-disabled=true]){color:var(--_selected-icon-color)}.selected:not(:disabled,[aria-disabled=true]):hover{color:var(--_selected-hover-icon-color)}.selected:not(:disabled,[aria-disabled=true]):focus{color:var(--_selected-focus-icon-color)}.selected:not(:disabled,[aria-disabled=true]):active{color:var(--_selected-pressed-icon-color)}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdIconButton = class MdIconButton2 extends IconButton {
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "standard": true
    };
  }
};
MdIconButton.styles = [styles$p, styles$n];
MdIconButton = __decorate([
  t$3("md-icon-button")
], MdIconButton);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$m = i$4`:host{--_container-height: var(--md-outlined-icon-button-container-height, 40px);--_container-width: var(--md-outlined-icon-button-container-width, 40px);--_disabled-icon-color: var(--md-outlined-icon-button-disabled-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-icon-opacity: var(--md-outlined-icon-button-disabled-icon-opacity, 0.38);--_disabled-selected-container-color: var(--md-outlined-icon-button-disabled-selected-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-selected-container-opacity: var(--md-outlined-icon-button-disabled-selected-container-opacity, 0.12);--_hover-state-layer-opacity: var(--md-outlined-icon-button-hover-state-layer-opacity, 0.08);--_icon-size: var(--md-outlined-icon-button-icon-size, 24px);--_pressed-state-layer-opacity: var(--md-outlined-icon-button-pressed-state-layer-opacity, 0.12);--_selected-container-color: var(--md-outlined-icon-button-selected-container-color, var(--md-sys-color-inverse-surface, #322f35));--_selected-focus-icon-color: var(--md-outlined-icon-button-selected-focus-icon-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_selected-hover-icon-color: var(--md-outlined-icon-button-selected-hover-icon-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_selected-hover-state-layer-color: var(--md-outlined-icon-button-selected-hover-state-layer-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_selected-icon-color: var(--md-outlined-icon-button-selected-icon-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_selected-pressed-icon-color: var(--md-outlined-icon-button-selected-pressed-icon-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_selected-pressed-state-layer-color: var(--md-outlined-icon-button-selected-pressed-state-layer-color, var(--md-sys-color-inverse-on-surface, #f5eff7));--_disabled-outline-color: var(--md-outlined-icon-button-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-outlined-icon-button-disabled-outline-opacity, 0.12);--_focus-icon-color: var(--md-outlined-icon-button-focus-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-icon-color: var(--md-outlined-icon-button-hover-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-outlined-icon-button-hover-state-layer-color, var(--md-sys-color-on-surface-variant, #49454f));--_icon-color: var(--md-outlined-icon-button-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_outline-color: var(--md-outlined-icon-button-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-outlined-icon-button-outline-width, 1px);--_pressed-icon-color: var(--md-outlined-icon-button-pressed-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_pressed-state-layer-color: var(--md-outlined-icon-button-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_container-shape-start-start: var(--md-outlined-icon-button-container-shape-start-start, var(--md-outlined-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-start-end: var(--md-outlined-icon-button-container-shape-start-end, var(--md-outlined-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-end: var(--md-outlined-icon-button-container-shape-end-end, var(--md-outlined-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)));--_container-shape-end-start: var(--md-outlined-icon-button-container-shape-end-start, var(--md-outlined-icon-button-container-shape, var(--md-sys-shape-corner-full, 9999px)))}.outlined{background-color:rgba(0,0,0,0);color:var(--_icon-color);--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}.outlined::before{border-color:var(--_outline-color);border-width:var(--_outline-width)}.outlined:hover{color:var(--_hover-icon-color)}.outlined:focus{color:var(--_focus-icon-color)}.outlined:active{color:var(--_pressed-icon-color)}.outlined:is(:disabled,[aria-disabled=true]){color:var(--_disabled-icon-color)}.outlined:is(:disabled,[aria-disabled=true])::before{border-color:var(--_disabled-outline-color);opacity:var(--_disabled-outline-opacity)}.outlined:is(:disabled,[aria-disabled=true]) .icon{opacity:var(--_disabled-icon-opacity)}.outlined::before{block-size:100%;border-style:solid;border-radius:inherit;box-sizing:border-box;content:"";inline-size:100%;inset:0;pointer-events:none;position:absolute;z-index:-1}.outlined.selected::before{border-width:0}.selected{--md-ripple-hover-color: var(--_selected-hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_selected-pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}.selected:not(:disabled,[aria-disabled=true]){color:var(--_selected-icon-color)}.selected:not(:disabled,[aria-disabled=true]):hover{color:var(--_selected-hover-icon-color)}.selected:not(:disabled,[aria-disabled=true]):focus{color:var(--_selected-focus-icon-color)}.selected:not(:disabled,[aria-disabled=true]):active{color:var(--_selected-pressed-icon-color)}.selected:not(:disabled,[aria-disabled=true])::before{background-color:var(--_selected-container-color)}.selected:is(:disabled,[aria-disabled=true])::before{background-color:var(--_disabled-selected-container-color);opacity:var(--_disabled-selected-container-opacity)}@media(forced-colors: active){:host(:is([disabled],[soft-disabled])){--_disabled-outline-opacity: 1}.selected::before{border-color:CanvasText;border-width:var(--_outline-width)}.selected:is(:disabled,[aria-disabled=true])::before{border-color:GrayText;opacity:1}}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdOutlinedIconButton = class MdOutlinedIconButton2 extends IconButton {
  getRenderClasses() {
    return {
      ...super.getRenderClasses(),
      "outlined": true
    };
  }
};
MdOutlinedIconButton.styles = [styles$p, styles$m];
MdOutlinedIconButton = __decorate([
  t$3("md-outlined-icon-button")
], MdOutlinedIconButton);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function activateFirstItem(items, isActivatable = isItemNotDisabled) {
  const firstItem = getFirstActivatableItem(items, isActivatable);
  if (firstItem) {
    firstItem.tabIndex = 0;
    firstItem.focus();
  }
  return firstItem;
}
function activateLastItem(items, isActivatable = isItemNotDisabled) {
  const lastItem = getLastActivatableItem(items, isActivatable);
  if (lastItem) {
    lastItem.tabIndex = 0;
    lastItem.focus();
  }
  return lastItem;
}
function deactivateActiveItem(items, isActivatable = isItemNotDisabled) {
  const activeItem = getActiveItem(items, isActivatable);
  if (activeItem) {
    activeItem.item.tabIndex = -1;
  }
  return activeItem;
}
function getActiveItem(items, isActivatable = isItemNotDisabled) {
  for (let i3 = 0; i3 < items.length; i3++) {
    const item = items[i3];
    if (item.tabIndex === 0 && isActivatable(item)) {
      return {
        item,
        index: i3
      };
    }
  }
  return null;
}
function getFirstActivatableItem(items, isActivatable = isItemNotDisabled) {
  for (const item of items) {
    if (isActivatable(item)) {
      return item;
    }
  }
  return null;
}
function getLastActivatableItem(items, isActivatable = isItemNotDisabled) {
  for (let i3 = items.length - 1; i3 >= 0; i3--) {
    const item = items[i3];
    if (isActivatable(item)) {
      return item;
    }
  }
  return null;
}
function getNextItem(items, index, isActivatable = isItemNotDisabled, wrap2 = true) {
  for (let i3 = 1; i3 < items.length; i3++) {
    const nextIndex = (i3 + index) % items.length;
    if (nextIndex < index && !wrap2) {
      return null;
    }
    const item = items[nextIndex];
    if (isActivatable(item)) {
      return item;
    }
  }
  return items[index] ? items[index] : null;
}
function getPrevItem(items, index, isActivatable = isItemNotDisabled, wrap2 = true) {
  for (let i3 = 1; i3 < items.length; i3++) {
    const prevIndex = (index - i3 + items.length) % items.length;
    if (prevIndex > index && !wrap2) {
      return null;
    }
    const item = items[prevIndex];
    if (isActivatable(item)) {
      return item;
    }
  }
  return items[index] ? items[index] : null;
}
function activateNextItem(items, activeItemRecord, isActivatable = isItemNotDisabled, wrap2 = true) {
  if (activeItemRecord) {
    const next = getNextItem(items, activeItemRecord.index, isActivatable, wrap2);
    if (next) {
      next.tabIndex = 0;
      next.focus();
    }
    return next;
  } else {
    return activateFirstItem(items, isActivatable);
  }
}
function activatePreviousItem(items, activeItemRecord, isActivatable = isItemNotDisabled, wrap2 = true) {
  if (activeItemRecord) {
    const prev = getPrevItem(items, activeItemRecord.index, isActivatable, wrap2);
    if (prev) {
      prev.tabIndex = 0;
      prev.focus();
    }
    return prev;
  } else {
    return activateLastItem(items, isActivatable);
  }
}
function createDeactivateItemsEvent() {
  return new Event("deactivate-items", { bubbles: true, composed: true });
}
function createRequestActivationEvent() {
  return new Event("request-activation", { bubbles: true, composed: true });
}
function isItemNotDisabled(item) {
  return !item.disabled;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const NavigableKeys = {
  ArrowDown: "ArrowDown",
  ArrowLeft: "ArrowLeft",
  ArrowUp: "ArrowUp",
  ArrowRight: "ArrowRight",
  Home: "Home",
  End: "End"
};
class ListController {
  constructor(config) {
    this.handleKeydown = (event) => {
      const key = event.key;
      if (event.defaultPrevented || !this.isNavigableKey(key)) {
        return;
      }
      const items = this.items;
      if (!items.length) {
        return;
      }
      const activeItemRecord = getActiveItem(items, this.isActivatable);
      event.preventDefault();
      const isRtl3 = this.isRtl();
      const inlinePrevious = isRtl3 ? NavigableKeys.ArrowRight : NavigableKeys.ArrowLeft;
      const inlineNext = isRtl3 ? NavigableKeys.ArrowLeft : NavigableKeys.ArrowRight;
      let nextActiveItem = null;
      switch (key) {
        case NavigableKeys.ArrowDown:
        case inlineNext:
          nextActiveItem = activateNextItem(items, activeItemRecord, this.isActivatable, this.wrapNavigation());
          break;
        case NavigableKeys.ArrowUp:
        case inlinePrevious:
          nextActiveItem = activatePreviousItem(items, activeItemRecord, this.isActivatable, this.wrapNavigation());
          break;
        case NavigableKeys.Home:
          nextActiveItem = activateFirstItem(items, this.isActivatable);
          break;
        case NavigableKeys.End:
          nextActiveItem = activateLastItem(items, this.isActivatable);
          break;
      }
      if (nextActiveItem && activeItemRecord && activeItemRecord.item !== nextActiveItem) {
        activeItemRecord.item.tabIndex = -1;
      }
    };
    this.onDeactivateItems = () => {
      const items = this.items;
      for (const item of items) {
        this.deactivateItem(item);
      }
    };
    this.onRequestActivation = (event) => {
      this.onDeactivateItems();
      const target = event.target;
      this.activateItem(target);
      target.focus();
    };
    this.onSlotchange = () => {
      const items = this.items;
      let encounteredActivated = false;
      for (const item of items) {
        const isActivated = !item.disabled && item.tabIndex > -1;
        if (isActivated && !encounteredActivated) {
          encounteredActivated = true;
          item.tabIndex = 0;
          continue;
        }
        item.tabIndex = -1;
      }
      if (encounteredActivated) {
        return;
      }
      const firstActivatableItem = getFirstActivatableItem(items, this.isActivatable);
      if (!firstActivatableItem) {
        return;
      }
      firstActivatableItem.tabIndex = 0;
    };
    const { isItem, getPossibleItems, isRtl: isRtl2, deactivateItem, activateItem, isNavigableKey, isActivatable, wrapNavigation } = config;
    this.isItem = isItem;
    this.getPossibleItems = getPossibleItems;
    this.isRtl = isRtl2;
    this.deactivateItem = deactivateItem;
    this.activateItem = activateItem;
    this.isNavigableKey = isNavigableKey;
    this.isActivatable = isActivatable;
    this.wrapNavigation = wrapNavigation ?? (() => true);
  }
  /**
   * The items being managed by the list. Additionally, attempts to see if the
   * object has a sub-item in the `.item` property.
   */
  get items() {
    const maybeItems = this.getPossibleItems();
    const items = [];
    for (const itemOrParent of maybeItems) {
      const isItem = this.isItem(itemOrParent);
      if (isItem) {
        items.push(itemOrParent);
        continue;
      }
      const subItem = itemOrParent.item;
      if (subItem && this.isItem(subItem)) {
        items.push(subItem);
      }
    }
    return items;
  }
  /**
   * Activates the next item in the list. If at the end of the list, the first
   * item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activateNextItem() {
    const items = this.items;
    const activeItemRecord = getActiveItem(items, this.isActivatable);
    if (activeItemRecord) {
      activeItemRecord.item.tabIndex = -1;
    }
    return activateNextItem(items, activeItemRecord, this.isActivatable, this.wrapNavigation());
  }
  /**
   * Activates the previous item in the list. If at the start of the list, the
   * last item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activatePreviousItem() {
    const items = this.items;
    const activeItemRecord = getActiveItem(items, this.isActivatable);
    if (activeItemRecord) {
      activeItemRecord.item.tabIndex = -1;
    }
    return activatePreviousItem(items, activeItemRecord, this.isActivatable, this.wrapNavigation());
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const NAVIGABLE_KEY_SET = new Set(Object.values(NavigableKeys));
class List extends s$1 {
  /** @export */
  get items() {
    return this.listController.items;
  }
  constructor() {
    super();
    this.listController = new ListController({
      isItem: (item) => item.hasAttribute("md-list-item"),
      getPossibleItems: () => this.slotItems,
      isRtl: () => getComputedStyle(this).direction === "rtl",
      deactivateItem: (item) => {
        item.tabIndex = -1;
      },
      activateItem: (item) => {
        item.tabIndex = 0;
      },
      isNavigableKey: (key) => NAVIGABLE_KEY_SET.has(key),
      isActivatable: (item) => !item.disabled && item.type !== "text"
    });
    this.internals = // Cast needed for closure
    this.attachInternals();
    {
      this.internals.role = "list";
      this.addEventListener("keydown", this.listController.handleKeydown);
    }
  }
  render() {
    return x$1`
      <slot
        @deactivate-items=${this.listController.onDeactivateItems}
        @request-activation=${this.listController.onRequestActivation}
        @slotchange=${this.listController.onSlotchange}>
      </slot>
    `;
  }
  /**
   * Activates the next item in the list. If at the end of the list, the first
   * item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activateNextItem() {
    return this.listController.activateNextItem();
  }
  /**
   * Activates the previous item in the list. If at the start of the list, the
   * last item will be activated.
   *
   * @return The activated list item or `null` if there are no items.
   */
  activatePreviousItem() {
    return this.listController.activatePreviousItem();
  }
}
__decorate([
  o$4({ flatten: true })
], List.prototype, "slotItems", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$l = i$4`:host{background:var(--md-list-container-color, var(--md-sys-color-surface, #fef7ff));color:unset;display:flex;flex-direction:column;outline:none;padding:8px 0;position:relative}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdList = class MdList2 extends List {
};
MdList.styles = [styles$l];
MdList = __decorate([
  t$3("md-list")
], MdList);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Item extends s$1 {
  constructor() {
    super(...arguments);
    this.multiline = false;
  }
  render() {
    return x$1`
      <slot name="container"></slot>
      <slot class="non-text" name="start"></slot>
      <div class="text">
        <slot name="overline" @slotchange=${this.handleTextSlotChange}></slot>
        <slot
          class="default-slot"
          @slotchange=${this.handleTextSlotChange}></slot>
        <slot name="headline" @slotchange=${this.handleTextSlotChange}></slot>
        <slot
          name="supporting-text"
          @slotchange=${this.handleTextSlotChange}></slot>
      </div>
      <slot class="non-text" name="trailing-supporting-text"></slot>
      <slot class="non-text" name="end"></slot>
    `;
  }
  handleTextSlotChange() {
    let isMultiline = false;
    let slotsWithContent = 0;
    for (const slot of this.textSlots) {
      if (slotHasContent(slot)) {
        slotsWithContent += 1;
      }
      if (slotsWithContent > 1) {
        isMultiline = true;
        break;
      }
    }
    this.multiline = isMultiline;
  }
}
__decorate([
  n$5({ type: Boolean, reflect: true })
], Item.prototype, "multiline", void 0);
__decorate([
  r$3(".text slot")
], Item.prototype, "textSlots", void 0);
function slotHasContent(slot) {
  for (const node of slot.assignedNodes({ flatten: true })) {
    const isElement2 = node.nodeType === Node.ELEMENT_NODE;
    const isTextWithContent = node.nodeType === Node.TEXT_NODE && node.textContent?.match(/\S/);
    if (isElement2 || isTextWithContent) {
      return true;
    }
  }
  return false;
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$k = i$4`:host{color:var(--md-sys-color-on-surface, #1d1b20);font-family:var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto));font-size:var(--md-sys-typescale-body-large-size, 1rem);font-weight:var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400));line-height:var(--md-sys-typescale-body-large-line-height, 1.5rem);align-items:center;box-sizing:border-box;display:flex;gap:16px;min-height:56px;overflow:hidden;padding:12px 16px;position:relative;text-overflow:ellipsis}:host([multiline]){min-height:72px}[name=overline]{color:var(--md-sys-color-on-surface-variant, #49454f);font-family:var(--md-sys-typescale-label-small-font, var(--md-ref-typeface-plain, Roboto));font-size:var(--md-sys-typescale-label-small-size, 0.6875rem);font-weight:var(--md-sys-typescale-label-small-weight, var(--md-ref-typeface-weight-medium, 500));line-height:var(--md-sys-typescale-label-small-line-height, 1rem)}[name=supporting-text]{color:var(--md-sys-color-on-surface-variant, #49454f);font-family:var(--md-sys-typescale-body-medium-font, var(--md-ref-typeface-plain, Roboto));font-size:var(--md-sys-typescale-body-medium-size, 0.875rem);font-weight:var(--md-sys-typescale-body-medium-weight, var(--md-ref-typeface-weight-regular, 400));line-height:var(--md-sys-typescale-body-medium-line-height, 1.25rem)}[name=trailing-supporting-text]{color:var(--md-sys-color-on-surface-variant, #49454f);font-family:var(--md-sys-typescale-label-small-font, var(--md-ref-typeface-plain, Roboto));font-size:var(--md-sys-typescale-label-small-size, 0.6875rem);font-weight:var(--md-sys-typescale-label-small-weight, var(--md-ref-typeface-weight-medium, 500));line-height:var(--md-sys-typescale-label-small-line-height, 1rem)}[name=container]::slotted(*){inset:0;position:absolute}.default-slot{display:inline}.default-slot,.text ::slotted(*){overflow:hidden;text-overflow:ellipsis}.text{display:flex;flex:1;flex-direction:column;overflow:hidden}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdItem = class MdItem2 extends Item {
};
MdItem.styles = [styles$k];
MdItem = __decorate([
  t$3("md-item")
], MdItem);
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const listItemBaseClass = mixinDelegatesAria(s$1);
class ListItemEl extends listItemBaseClass {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.type = "text";
    this.isListItem = true;
    this.href = "";
    this.target = "";
  }
  get isDisabled() {
    return this.disabled && this.type !== "link";
  }
  willUpdate(changed) {
    if (this.href) {
      this.type = "link";
    }
    super.willUpdate(changed);
  }
  render() {
    return this.renderListItem(x$1`
      <md-item>
        <div slot="container">
          ${this.renderRipple()} ${this.renderFocusRing()}
        </div>
        <slot name="start" slot="start"></slot>
        <slot name="end" slot="end"></slot>
        ${this.renderBody()}
      </md-item>
    `);
  }
  /**
   * Renders the root list item.
   *
   * @param content the child content of the list item.
   */
  renderListItem(content) {
    const isAnchor = this.type === "link";
    let tag;
    switch (this.type) {
      case "link":
        tag = s2`a`;
        break;
      case "button":
        tag = s2`button`;
        break;
      default:
      case "text":
        tag = s2`li`;
        break;
    }
    const isInteractive = this.type !== "text";
    const target = isAnchor && !!this.target ? this.target : T$1;
    return n$2`
      <${tag}
        id="item"
        tabindex="${this.isDisabled || !isInteractive ? -1 : 0}"
        ?disabled=${this.isDisabled}
        role="listitem"
        aria-selected=${this.ariaSelected || T$1}
        aria-checked=${this.ariaChecked || T$1}
        aria-expanded=${this.ariaExpanded || T$1}
        aria-haspopup=${this.ariaHasPopup || T$1}
        class="list-item ${e$1(this.getRenderClasses())}"
        href=${this.href || T$1}
        target=${target}
        @focus=${this.onFocus}
      >${content}</${tag}>
    `;
  }
  /**
   * Handles rendering of the ripple element.
   */
  renderRipple() {
    if (this.type === "text") {
      return T$1;
    }
    return x$1` <md-ripple
      part="ripple"
      for="item"
      ?disabled=${this.isDisabled}></md-ripple>`;
  }
  /**
   * Handles rendering of the focus ring.
   */
  renderFocusRing() {
    if (this.type === "text") {
      return T$1;
    }
    return x$1` <md-focus-ring
      @visibility-changed=${this.onFocusRingVisibilityChanged}
      part="focus-ring"
      for="item"
      inward></md-focus-ring>`;
  }
  onFocusRingVisibilityChanged(e2) {
  }
  /**
   * Classes applied to the list item root.
   */
  getRenderClasses() {
    return { "disabled": this.isDisabled };
  }
  /**
   * Handles rendering the headline and supporting text.
   */
  renderBody() {
    return x$1`
      <slot></slot>
      <slot name="overline" slot="overline"></slot>
      <slot name="headline" slot="headline"></slot>
      <slot name="supporting-text" slot="supporting-text"></slot>
      <slot
        name="trailing-supporting-text"
        slot="trailing-supporting-text"></slot>
    `;
  }
  onFocus() {
    if (this.tabIndex !== -1) {
      return;
    }
    this.dispatchEvent(createRequestActivationEvent());
  }
  focus() {
    this.listItemRoot?.focus();
  }
}
ListItemEl.shadowRootOptions = {
  ...s$1.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], ListItemEl.prototype, "disabled", void 0);
__decorate([
  n$5({ reflect: true })
], ListItemEl.prototype, "type", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "md-list-item", reflect: true })
], ListItemEl.prototype, "isListItem", void 0);
__decorate([
  n$5()
], ListItemEl.prototype, "href", void 0);
__decorate([
  n$5()
], ListItemEl.prototype, "target", void 0);
__decorate([
  e$5(".list-item")
], ListItemEl.prototype, "listItemRoot", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$j = i$4`:host{display:flex;-webkit-tap-highlight-color:rgba(0,0,0,0);--md-ripple-hover-color: var(--md-list-item-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-hover-opacity: var(--md-list-item-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-list-item-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-pressed-opacity: var(--md-list-item-pressed-state-layer-opacity, 0.12)}:host(:is([type=button]:not([disabled]),[type=link])){cursor:pointer}md-focus-ring{z-index:1;--md-focus-ring-shape: 8px}a,button,li{background:none;border:none;cursor:inherit;padding:0;margin:0;text-align:unset;text-decoration:none}.list-item{border-radius:inherit;display:flex;flex:1;max-width:inherit;min-width:inherit;outline:none;-webkit-tap-highlight-color:rgba(0,0,0,0);width:100%}.list-item.interactive{cursor:pointer}.list-item.disabled{opacity:var(--md-list-item-disabled-opacity, 0.3);pointer-events:none}[slot=container]{pointer-events:none}md-ripple{border-radius:inherit}md-item{border-radius:inherit;flex:1;height:100%;color:var(--md-list-item-label-text-color, var(--md-sys-color-on-surface, #1d1b20));font-family:var(--md-list-item-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-list-item-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));line-height:var(--md-list-item-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));font-weight:var(--md-list-item-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));min-height:var(--md-list-item-one-line-container-height, 56px);padding-top:var(--md-list-item-top-space, 12px);padding-bottom:var(--md-list-item-bottom-space, 12px);padding-inline-start:var(--md-list-item-leading-space, 16px);padding-inline-end:var(--md-list-item-trailing-space, 16px)}md-item[multiline]{min-height:var(--md-list-item-two-line-container-height, 72px)}[slot=supporting-text]{color:var(--md-list-item-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));font-family:var(--md-list-item-supporting-text-font, var(--md-sys-typescale-body-medium-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-list-item-supporting-text-size, var(--md-sys-typescale-body-medium-size, 0.875rem));line-height:var(--md-list-item-supporting-text-line-height, var(--md-sys-typescale-body-medium-line-height, 1.25rem));font-weight:var(--md-list-item-supporting-text-weight, var(--md-sys-typescale-body-medium-weight, var(--md-ref-typeface-weight-regular, 400)))}[slot=trailing-supporting-text]{color:var(--md-list-item-trailing-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));font-family:var(--md-list-item-trailing-supporting-text-font, var(--md-sys-typescale-label-small-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-list-item-trailing-supporting-text-size, var(--md-sys-typescale-label-small-size, 0.6875rem));line-height:var(--md-list-item-trailing-supporting-text-line-height, var(--md-sys-typescale-label-small-line-height, 1rem));font-weight:var(--md-list-item-trailing-supporting-text-weight, var(--md-sys-typescale-label-small-weight, var(--md-ref-typeface-weight-medium, 500)))}:is([slot=start],[slot=end])::slotted(*){fill:currentColor}[slot=start]{color:var(--md-list-item-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f))}[slot=end]{color:var(--md-list-item-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f))}@media(forced-colors: active){.disabled slot{color:GrayText}.list-item.disabled{color:GrayText;opacity:1}}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdListItem = class MdListItem2 extends ListItemEl {
};
MdListItem.styles = [styles$j];
MdListItem = __decorate([
  t$3("md-list-item")
], MdListItem);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const n$1 = "important", i2 = " !" + n$1, o = e$2(class extends i$1 {
  constructor(t$12) {
    if (super(t$12), t$12.type !== t.ATTRIBUTE || "style" !== t$12.name || t$12.strings?.length > 2) throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(t2) {
    return Object.keys(t2).reduce((e2, r2) => {
      const s3 = t2[r2];
      return null == s3 ? e2 : e2 + `${r2 = r2.includes("-") ? r2 : r2.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s3};`;
    }, "");
  }
  update(e2, [r2]) {
    const { style: s3 } = e2.element;
    if (void 0 === this.ft) return this.ft = new Set(Object.keys(r2)), this.render(r2);
    for (const t2 of this.ft) null == r2[t2] && (this.ft.delete(t2), t2.includes("-") ? s3.removeProperty(t2) : s3[t2] = null);
    for (const t2 in r2) {
      const e3 = r2[t2];
      if (null != e3) {
        this.ft.add(t2);
        const r3 = "string" == typeof e3 && e3.endsWith(i2);
        t2.includes("-") || r3 ? s3.setProperty(t2, r3 ? e3.slice(0, -11) : e3, r3 ? n$1 : "") : s3[t2] = e3;
      }
    }
    return w$1;
  }
});
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function createCloseMenuEvent(initiator, reason) {
  return new CustomEvent("close-menu", {
    bubbles: true,
    composed: true,
    detail: { initiator, reason, itemPath: [initiator] }
  });
}
const createDefaultCloseMenuEvent = createCloseMenuEvent;
function createDeactivateTypeaheadEvent() {
  return new Event("deactivate-typeahead", { bubbles: true, composed: true });
}
function createActivateTypeaheadEvent() {
  return new Event("activate-typeahead", { bubbles: true, composed: true });
}
const NavigableKey = {
  UP: "ArrowUp",
  DOWN: "ArrowDown",
  RIGHT: "ArrowRight",
  LEFT: "ArrowLeft"
};
const SelectionKey = {
  SPACE: "Space",
  ENTER: "Enter"
};
const CloseReason$1 = {
  CLICK_SELECTION: "click-selection",
  KEYDOWN: "keydown"
};
const KeydownCloseKey = {
  ESCAPE: "Escape",
  SPACE: SelectionKey.SPACE,
  ENTER: SelectionKey.ENTER
};
function isClosableKey(code) {
  return Object.values(KeydownCloseKey).some((value) => value === code);
}
function isSelectableKey(code) {
  return Object.values(SelectionKey).some((value) => value === code);
}
function isElementInSubtree(target, container) {
  const focusEv = new Event("md-contains", { bubbles: true, composed: true });
  let composedPath = [];
  const listener = (ev) => {
    composedPath = ev.composedPath();
  };
  container.addEventListener("md-contains", listener);
  target.dispatchEvent(focusEv);
  container.removeEventListener("md-contains", listener);
  const isContained = composedPath.length > 0;
  return isContained;
}
const FocusState = {
  NONE: "none",
  LIST_ROOT: "list-root",
  FIRST_ITEM: "first-item",
  LAST_ITEM: "last-item"
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const Corner = {
  END_START: "end-start",
  END_END: "end-end",
  START_START: "start-start",
  START_END: "start-end"
};
class SurfacePositionController {
  /**
   * @param host The host to connect the controller to.
   * @param getProperties A function that returns the properties for the
   * controller.
   */
  constructor(host, getProperties) {
    this.host = host;
    this.getProperties = getProperties;
    this.surfaceStylesInternal = {
      "display": "none"
    };
    this.lastValues = {
      isOpen: false
    };
    this.host.addController(this);
  }
  /**
   * The StyleInfo map to apply to the surface via Lit's stylemap
   */
  get surfaceStyles() {
    return this.surfaceStylesInternal;
  }
  /**
   * Calculates the surface's new position required so that the surface's
   * `surfaceCorner` aligns to the anchor's `anchorCorner` while keeping the
   * surface inside the window viewport. This positioning also respects RTL by
   * checking `getComputedStyle()` on the surface element.
   */
  async position() {
    const { surfaceEl, anchorEl, anchorCorner: anchorCornerRaw, surfaceCorner: surfaceCornerRaw, positioning, xOffset, yOffset, disableBlockFlip, disableInlineFlip, repositionStrategy } = this.getProperties();
    const anchorCorner = anchorCornerRaw.toLowerCase().trim();
    const surfaceCorner = surfaceCornerRaw.toLowerCase().trim();
    if (!surfaceEl || !anchorEl) {
      return;
    }
    const windowInnerWidth = window.innerWidth;
    const windowInnerHeight = window.innerHeight;
    const div = document.createElement("div");
    div.style.opacity = "0";
    div.style.position = "fixed";
    div.style.display = "block";
    div.style.inset = "0";
    document.body.appendChild(div);
    const scrollbarTestRect = div.getBoundingClientRect();
    div.remove();
    const blockScrollbarHeight = window.innerHeight - scrollbarTestRect.bottom;
    const inlineScrollbarWidth = window.innerWidth - scrollbarTestRect.right;
    this.surfaceStylesInternal = {
      "display": "block",
      "opacity": "0"
    };
    this.host.requestUpdate();
    await this.host.updateComplete;
    if (surfaceEl.popover && surfaceEl.isConnected) {
      surfaceEl.showPopover();
    }
    const surfaceRect = surfaceEl.getSurfacePositionClientRect ? surfaceEl.getSurfacePositionClientRect() : surfaceEl.getBoundingClientRect();
    const anchorRect = anchorEl.getSurfacePositionClientRect ? anchorEl.getSurfacePositionClientRect() : anchorEl.getBoundingClientRect();
    const [surfaceBlock, surfaceInline] = surfaceCorner.split("-");
    const [anchorBlock, anchorInline] = anchorCorner.split("-");
    const isLTR = getComputedStyle(surfaceEl).direction === "ltr";
    let { blockInset, blockOutOfBoundsCorrection, surfaceBlockProperty } = this.calculateBlock({
      surfaceRect,
      anchorRect,
      anchorBlock,
      surfaceBlock,
      yOffset,
      positioning,
      windowInnerHeight,
      blockScrollbarHeight
    });
    if (blockOutOfBoundsCorrection && !disableBlockFlip) {
      const flippedSurfaceBlock = surfaceBlock === "start" ? "end" : "start";
      const flippedAnchorBlock = anchorBlock === "start" ? "end" : "start";
      const flippedBlock = this.calculateBlock({
        surfaceRect,
        anchorRect,
        anchorBlock: flippedAnchorBlock,
        surfaceBlock: flippedSurfaceBlock,
        yOffset,
        positioning,
        windowInnerHeight,
        blockScrollbarHeight
      });
      if (blockOutOfBoundsCorrection > flippedBlock.blockOutOfBoundsCorrection) {
        blockInset = flippedBlock.blockInset;
        blockOutOfBoundsCorrection = flippedBlock.blockOutOfBoundsCorrection;
        surfaceBlockProperty = flippedBlock.surfaceBlockProperty;
      }
    }
    let { inlineInset, inlineOutOfBoundsCorrection, surfaceInlineProperty } = this.calculateInline({
      surfaceRect,
      anchorRect,
      anchorInline,
      surfaceInline,
      xOffset,
      positioning,
      isLTR,
      windowInnerWidth,
      inlineScrollbarWidth
    });
    if (inlineOutOfBoundsCorrection && !disableInlineFlip) {
      const flippedSurfaceInline = surfaceInline === "start" ? "end" : "start";
      const flippedAnchorInline = anchorInline === "start" ? "end" : "start";
      const flippedInline = this.calculateInline({
        surfaceRect,
        anchorRect,
        anchorInline: flippedAnchorInline,
        surfaceInline: flippedSurfaceInline,
        xOffset,
        positioning,
        isLTR,
        windowInnerWidth,
        inlineScrollbarWidth
      });
      if (Math.abs(inlineOutOfBoundsCorrection) > Math.abs(flippedInline.inlineOutOfBoundsCorrection)) {
        inlineInset = flippedInline.inlineInset;
        inlineOutOfBoundsCorrection = flippedInline.inlineOutOfBoundsCorrection;
        surfaceInlineProperty = flippedInline.surfaceInlineProperty;
      }
    }
    if (repositionStrategy === "move") {
      blockInset = blockInset - blockOutOfBoundsCorrection;
      inlineInset = inlineInset - inlineOutOfBoundsCorrection;
    }
    this.surfaceStylesInternal = {
      "display": "block",
      "opacity": "1",
      [surfaceBlockProperty]: `${blockInset}px`,
      [surfaceInlineProperty]: `${inlineInset}px`
    };
    if (repositionStrategy === "resize") {
      if (blockOutOfBoundsCorrection) {
        this.surfaceStylesInternal["height"] = `${surfaceRect.height - blockOutOfBoundsCorrection}px`;
      }
      if (inlineOutOfBoundsCorrection) {
        this.surfaceStylesInternal["width"] = `${surfaceRect.width - inlineOutOfBoundsCorrection}px`;
      }
    }
    this.host.requestUpdate();
  }
  /**
   * Calculates the css property, the inset, and the out of bounds correction
   * for the surface in the block direction.
   */
  calculateBlock(config) {
    const { surfaceRect, anchorRect, anchorBlock, surfaceBlock, yOffset, positioning, windowInnerHeight, blockScrollbarHeight } = config;
    const relativeToWindow = positioning === "fixed" || positioning === "document" ? 1 : 0;
    const relativeToDocument = positioning === "document" ? 1 : 0;
    const isSurfaceBlockStart = surfaceBlock === "start" ? 1 : 0;
    const isSurfaceBlockEnd = surfaceBlock === "end" ? 1 : 0;
    const isOneBlockEnd = anchorBlock !== surfaceBlock ? 1 : 0;
    const blockAnchorOffset = isOneBlockEnd * anchorRect.height + yOffset;
    const blockTopLayerOffset = isSurfaceBlockStart * anchorRect.top + isSurfaceBlockEnd * (windowInnerHeight - anchorRect.bottom - blockScrollbarHeight);
    const blockDocumentOffset = isSurfaceBlockStart * window.scrollY - isSurfaceBlockEnd * window.scrollY;
    const blockOutOfBoundsCorrection = Math.abs(Math.min(0, windowInnerHeight - blockTopLayerOffset - blockAnchorOffset - surfaceRect.height));
    const blockInset = relativeToWindow * blockTopLayerOffset + relativeToDocument * blockDocumentOffset + blockAnchorOffset;
    const surfaceBlockProperty = surfaceBlock === "start" ? "inset-block-start" : "inset-block-end";
    return { blockInset, blockOutOfBoundsCorrection, surfaceBlockProperty };
  }
  /**
   * Calculates the css property, the inset, and the out of bounds correction
   * for the surface in the inline direction.
   */
  calculateInline(config) {
    const { isLTR: isLTRBool, surfaceInline, anchorInline, anchorRect, surfaceRect, xOffset, positioning, windowInnerWidth, inlineScrollbarWidth } = config;
    const relativeToWindow = positioning === "fixed" || positioning === "document" ? 1 : 0;
    const relativeToDocument = positioning === "document" ? 1 : 0;
    const isLTR = isLTRBool ? 1 : 0;
    const isRTL2 = isLTRBool ? 0 : 1;
    const isSurfaceInlineStart = surfaceInline === "start" ? 1 : 0;
    const isSurfaceInlineEnd = surfaceInline === "end" ? 1 : 0;
    const isOneInlineEnd = anchorInline !== surfaceInline ? 1 : 0;
    const inlineAnchorOffset = isOneInlineEnd * anchorRect.width + xOffset;
    const inlineTopLayerOffsetLTR = isSurfaceInlineStart * anchorRect.left + isSurfaceInlineEnd * (windowInnerWidth - anchorRect.right - inlineScrollbarWidth);
    const inlineTopLayerOffsetRTL = isSurfaceInlineStart * (windowInnerWidth - anchorRect.right - inlineScrollbarWidth) + isSurfaceInlineEnd * anchorRect.left;
    const inlineTopLayerOffset = isLTR * inlineTopLayerOffsetLTR + isRTL2 * inlineTopLayerOffsetRTL;
    const inlineDocumentOffsetLTR = isSurfaceInlineStart * window.scrollX - isSurfaceInlineEnd * window.scrollX;
    const inlineDocumentOffsetRTL = isSurfaceInlineEnd * window.scrollX - isSurfaceInlineStart * window.scrollX;
    const inlineDocumentOffset = isLTR * inlineDocumentOffsetLTR + isRTL2 * inlineDocumentOffsetRTL;
    const inlineOutOfBoundsCorrection = Math.abs(Math.min(0, windowInnerWidth - inlineTopLayerOffset - inlineAnchorOffset - surfaceRect.width));
    const inlineInset = relativeToWindow * inlineTopLayerOffset + inlineAnchorOffset + relativeToDocument * inlineDocumentOffset;
    let surfaceInlineProperty = surfaceInline === "start" ? "inset-inline-start" : "inset-inline-end";
    if (positioning === "document" || positioning === "fixed") {
      if (surfaceInline === "start" && isLTRBool || surfaceInline === "end" && !isLTRBool) {
        surfaceInlineProperty = "left";
      } else {
        surfaceInlineProperty = "right";
      }
    }
    return {
      inlineInset,
      inlineOutOfBoundsCorrection,
      surfaceInlineProperty
    };
  }
  hostUpdate() {
    this.onUpdate();
  }
  hostUpdated() {
    this.onUpdate();
  }
  /**
   * Checks whether the properties passed into the controller have changed since
   * the last positioning. If so, it will reposition if the surface is open or
   * close it if the surface should close.
   */
  async onUpdate() {
    const props2 = this.getProperties();
    let hasChanged = false;
    for (const [key, value] of Object.entries(props2)) {
      hasChanged = hasChanged || value !== this.lastValues[key];
      if (hasChanged)
        break;
    }
    const openChanged = this.lastValues.isOpen !== props2.isOpen;
    const hasAnchor = !!props2.anchorEl;
    const hasSurface = !!props2.surfaceEl;
    if (hasChanged && hasAnchor && hasSurface) {
      this.lastValues.isOpen = props2.isOpen;
      if (props2.isOpen) {
        this.lastValues = props2;
        await this.position();
        props2.onOpen();
      } else if (openChanged) {
        await props2.beforeClose();
        this.close();
        props2.onClose();
      }
    }
  }
  /**
   * Hides the surface.
   */
  close() {
    this.surfaceStylesInternal = {
      "display": "none"
    };
    this.host.requestUpdate();
    const surfaceEl = this.getProperties().surfaceEl;
    if (surfaceEl?.popover && surfaceEl?.isConnected) {
      surfaceEl.hidePopover();
    }
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const TYPEAHEAD_RECORD = {
  INDEX: 0,
  ITEM: 1,
  TEXT: 2
};
class TypeaheadController {
  /**
   * @param getProperties A function that returns the options of the typeahead
   * controller:
   *
   * {
   *   getItems: A function that returns an array of menu items to be searched.
   *   typeaheadBufferTime: The maximum time between each keystroke to keep the
   *       current type buffer alive.
   * }
   */
  constructor(getProperties) {
    this.getProperties = getProperties;
    this.typeaheadRecords = [];
    this.typaheadBuffer = "";
    this.cancelTypeaheadTimeout = 0;
    this.isTypingAhead = false;
    this.lastActiveRecord = null;
    this.onKeydown = (event) => {
      if (this.isTypingAhead) {
        this.typeahead(event);
      } else {
        this.beginTypeahead(event);
      }
    };
    this.endTypeahead = () => {
      this.isTypingAhead = false;
      this.typaheadBuffer = "";
      this.typeaheadRecords = [];
    };
  }
  get items() {
    return this.getProperties().getItems();
  }
  get active() {
    return this.getProperties().active;
  }
  /**
   * Sets up typingahead
   */
  beginTypeahead(event) {
    if (!this.active) {
      return;
    }
    if (event.code === "Space" || event.code === "Enter" || event.code.startsWith("Arrow") || event.code === "Escape") {
      return;
    }
    this.isTypingAhead = true;
    this.typeaheadRecords = this.items.map((el, index) => [
      index,
      el,
      el.typeaheadText.trim().toLowerCase()
    ]);
    this.lastActiveRecord = this.typeaheadRecords.find((record) => record[TYPEAHEAD_RECORD.ITEM].tabIndex === 0) ?? null;
    if (this.lastActiveRecord) {
      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
    }
    this.typeahead(event);
  }
  /**
   * Performs the typeahead. Based on the normalized items and the current text
   * buffer, finds the _next_ item with matching text and activates it.
   *
   * @example
   *
   * items: Apple, Banana, Olive, Orange, Cucumber
   * buffer: ''
   * user types: o
   *
   * activates Olive
   *
   * @example
   *
   * items: Apple, Banana, Olive (active), Orange, Cucumber
   * buffer: 'o'
   * user types: l
   *
   * activates Olive
   *
   * @example
   *
   * items: Apple, Banana, Olive (active), Orange, Cucumber
   * buffer: ''
   * user types: o
   *
   * activates Orange
   *
   * @example
   *
   * items: Apple, Banana, Olive, Orange (active), Cucumber
   * buffer: ''
   * user types: o
   *
   * activates Olive
   */
  typeahead(event) {
    if (event.defaultPrevented)
      return;
    clearTimeout(this.cancelTypeaheadTimeout);
    if (event.code === "Enter" || event.code.startsWith("Arrow") || event.code === "Escape") {
      this.endTypeahead();
      if (this.lastActiveRecord) {
        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
      }
      return;
    }
    if (event.code === "Space") {
      event.preventDefault();
    }
    this.cancelTypeaheadTimeout = setTimeout(this.endTypeahead, this.getProperties().typeaheadBufferTime);
    this.typaheadBuffer += event.key.toLowerCase();
    const lastActiveIndex = this.lastActiveRecord ? this.lastActiveRecord[TYPEAHEAD_RECORD.INDEX] : -1;
    const numRecords = this.typeaheadRecords.length;
    const rebaseIndexOnActive = (record) => {
      return (record[TYPEAHEAD_RECORD.INDEX] + numRecords - lastActiveIndex) % numRecords;
    };
    const matchingRecords = this.typeaheadRecords.filter((record) => !record[TYPEAHEAD_RECORD.ITEM].disabled && record[TYPEAHEAD_RECORD.TEXT].startsWith(this.typaheadBuffer)).sort((a2, b3) => rebaseIndexOnActive(a2) - rebaseIndexOnActive(b3));
    if (matchingRecords.length === 0) {
      clearTimeout(this.cancelTypeaheadTimeout);
      if (this.lastActiveRecord) {
        this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
      }
      this.endTypeahead();
      return;
    }
    const isNewQuery = this.typaheadBuffer.length === 1;
    let nextRecord;
    if (this.lastActiveRecord === matchingRecords[0] && isNewQuery) {
      nextRecord = matchingRecords[1] ?? matchingRecords[0];
    } else {
      nextRecord = matchingRecords[0];
    }
    if (this.lastActiveRecord) {
      this.lastActiveRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = -1;
    }
    this.lastActiveRecord = nextRecord;
    nextRecord[TYPEAHEAD_RECORD.ITEM].tabIndex = 0;
    nextRecord[TYPEAHEAD_RECORD.ITEM].focus();
    return;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const DEFAULT_TYPEAHEAD_BUFFER_TIME = 200;
const submenuNavKeys = /* @__PURE__ */ new Set([
  NavigableKeys.ArrowDown,
  NavigableKeys.ArrowUp,
  NavigableKeys.Home,
  NavigableKeys.End
]);
const menuNavKeys = /* @__PURE__ */ new Set([
  NavigableKeys.ArrowLeft,
  NavigableKeys.ArrowRight,
  ...submenuNavKeys
]);
function getFocusedElement(activeDoc = document) {
  let activeEl = activeDoc.activeElement;
  while (activeEl && activeEl?.shadowRoot?.activeElement) {
    activeEl = activeEl.shadowRoot.activeElement;
  }
  return activeEl;
}
class Menu extends s$1 {
  /**
   * Whether the menu is animating upwards or downwards when opening. This is
   * helpful for calculating some animation calculations.
   */
  get openDirection() {
    const menuCornerBlock = this.menuCorner.split("-")[0];
    return menuCornerBlock === "start" ? "DOWN" : "UP";
  }
  /**
   * The element which the menu should align to. If `anchor` is set to a
   * non-empty idref string, then `anchorEl` will resolve to the element with
   * the given id in the same root node. Otherwise, `null`.
   */
  get anchorElement() {
    if (this.anchor) {
      return this.getRootNode().querySelector(`#${this.anchor}`);
    }
    return this.currentAnchorElement;
  }
  set anchorElement(element) {
    this.currentAnchorElement = element;
    this.requestUpdate("anchorElement");
  }
  constructor() {
    super();
    this.anchor = "";
    this.positioning = "absolute";
    this.quick = false;
    this.hasOverflow = false;
    this.open = false;
    this.xOffset = 0;
    this.yOffset = 0;
    this.noHorizontalFlip = false;
    this.noVerticalFlip = false;
    this.typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;
    this.anchorCorner = Corner.END_START;
    this.menuCorner = Corner.START_START;
    this.stayOpenOnOutsideClick = false;
    this.stayOpenOnFocusout = false;
    this.skipRestoreFocus = false;
    this.defaultFocus = FocusState.FIRST_ITEM;
    this.noNavigationWrap = false;
    this.typeaheadActive = true;
    this.isSubmenu = false;
    this.pointerPath = [];
    this.isRepositioning = false;
    this.openCloseAnimationSignal = createAnimationSignal();
    this.listController = new ListController({
      isItem: (maybeItem) => {
        return maybeItem.hasAttribute("md-menu-item");
      },
      getPossibleItems: () => this.slotItems,
      isRtl: () => getComputedStyle(this).direction === "rtl",
      deactivateItem: (item) => {
        item.selected = false;
        item.tabIndex = -1;
      },
      activateItem: (item) => {
        item.selected = true;
        item.tabIndex = 0;
      },
      isNavigableKey: (key) => {
        if (!this.isSubmenu) {
          return menuNavKeys.has(key);
        }
        const isRtl2 = getComputedStyle(this).direction === "rtl";
        const arrowOpen = isRtl2 ? NavigableKeys.ArrowLeft : NavigableKeys.ArrowRight;
        if (key === arrowOpen) {
          return true;
        }
        return submenuNavKeys.has(key);
      },
      wrapNavigation: () => !this.noNavigationWrap
    });
    this.lastFocusedElement = null;
    this.typeaheadController = new TypeaheadController(() => {
      return {
        getItems: () => this.items,
        typeaheadBufferTime: this.typeaheadDelay,
        active: this.typeaheadActive
      };
    });
    this.currentAnchorElement = null;
    this.internals = // Cast needed for closure
    this.attachInternals();
    this.menuPositionController = new SurfacePositionController(this, () => {
      return {
        anchorCorner: this.anchorCorner,
        surfaceCorner: this.menuCorner,
        surfaceEl: this.surfaceEl,
        anchorEl: this.anchorElement,
        positioning: this.positioning === "popover" ? "document" : this.positioning,
        isOpen: this.open,
        xOffset: this.xOffset,
        yOffset: this.yOffset,
        disableBlockFlip: this.noVerticalFlip,
        disableInlineFlip: this.noHorizontalFlip,
        onOpen: this.onOpened,
        beforeClose: this.beforeClose,
        onClose: this.onClosed,
        // We can't resize components that have overflow like menus with
        // submenus because the overflow-y will show menu items / content
        // outside the bounds of the menu. Popover API fixes this because each
        // submenu is hoisted to the top-layer and are not considered overflow
        // content.
        repositionStrategy: this.hasOverflow && this.positioning !== "popover" ? "move" : "resize"
      };
    });
    this.onWindowResize = () => {
      if (this.isRepositioning || this.positioning !== "document" && this.positioning !== "fixed" && this.positioning !== "popover") {
        return;
      }
      this.isRepositioning = true;
      this.reposition();
      this.isRepositioning = false;
    };
    this.handleFocusout = async (event) => {
      const anchorEl = this.anchorElement;
      if (this.stayOpenOnFocusout || !this.open || this.pointerPath.includes(anchorEl)) {
        return;
      }
      if (event.relatedTarget) {
        if (isElementInSubtree(event.relatedTarget, this) || this.pointerPath.length !== 0 && isElementInSubtree(event.relatedTarget, anchorEl)) {
          return;
        }
      } else if (this.pointerPath.includes(this)) {
        return;
      }
      const oldRestoreFocus = this.skipRestoreFocus;
      this.skipRestoreFocus = true;
      this.close();
      await this.updateComplete;
      this.skipRestoreFocus = oldRestoreFocus;
    };
    this.onOpened = async () => {
      this.lastFocusedElement = getFocusedElement();
      const items = this.items;
      const activeItemRecord = getActiveItem(items);
      if (activeItemRecord && this.defaultFocus !== FocusState.NONE) {
        activeItemRecord.item.tabIndex = -1;
      }
      let animationAborted = !this.quick;
      if (this.quick) {
        this.dispatchEvent(new Event("opening"));
      } else {
        animationAborted = !!await this.animateOpen();
      }
      switch (this.defaultFocus) {
        case FocusState.FIRST_ITEM:
          const first = getFirstActivatableItem(items);
          if (first) {
            first.tabIndex = 0;
            first.focus();
            await first.updateComplete;
          }
          break;
        case FocusState.LAST_ITEM:
          const last = getLastActivatableItem(items);
          if (last) {
            last.tabIndex = 0;
            last.focus();
            await last.updateComplete;
          }
          break;
        case FocusState.LIST_ROOT:
          this.focus();
          break;
        default:
        case FocusState.NONE:
          break;
      }
      if (!animationAborted) {
        this.dispatchEvent(new Event("opened"));
      }
    };
    this.beforeClose = async () => {
      this.open = false;
      if (!this.skipRestoreFocus) {
        this.lastFocusedElement?.focus?.();
      }
      if (!this.quick) {
        await this.animateClose();
      }
    };
    this.onClosed = () => {
      if (this.quick) {
        this.dispatchEvent(new Event("closing"));
        this.dispatchEvent(new Event("closed"));
      }
    };
    this.onWindowPointerdown = (event) => {
      this.pointerPath = event.composedPath();
    };
    this.onDocumentClick = (event) => {
      if (!this.open) {
        return;
      }
      const path = event.composedPath();
      if (!this.stayOpenOnOutsideClick && !path.includes(this) && !path.includes(this.anchorElement)) {
        this.open = false;
      }
    };
    {
      this.internals.role = "menu";
      this.addEventListener("keydown", this.handleKeydown);
      this.addEventListener("keydown", this.captureKeydown, { capture: true });
      this.addEventListener("focusout", this.handleFocusout);
    }
  }
  /**
   * The menu items associated with this menu. The items must be `MenuItem`s and
   * have both the `md-menu-item` and `md-list-item` attributes.
   */
  get items() {
    return this.listController.items;
  }
  willUpdate(changed) {
    if (!changed.has("open")) {
      return;
    }
    if (this.open) {
      this.removeAttribute("aria-hidden");
      return;
    }
    this.setAttribute("aria-hidden", "true");
  }
  update(changed) {
    if (changed.has("open")) {
      if (this.open) {
        this.setUpGlobalEventListeners();
      } else {
        this.cleanUpGlobalEventListeners();
      }
    }
    if (changed.has("positioning") && this.positioning === "popover" && // type required for Google JS conformance
    !this.showPopover) {
      this.positioning = "fixed";
    }
    super.update(changed);
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.open) {
      this.setUpGlobalEventListeners();
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.cleanUpGlobalEventListeners();
  }
  getBoundingClientRect() {
    if (!this.surfaceEl) {
      return super.getBoundingClientRect();
    }
    return this.surfaceEl.getBoundingClientRect();
  }
  getClientRects() {
    if (!this.surfaceEl) {
      return super.getClientRects();
    }
    return this.surfaceEl.getClientRects();
  }
  render() {
    return this.renderSurface();
  }
  /**
   * Renders the positionable surface element and its contents.
   */
  renderSurface() {
    return x$1`
      <div
        class="menu ${e$1(this.getSurfaceClasses())}"
        style=${o(this.menuPositionController.surfaceStyles)}
        popover=${this.positioning === "popover" ? "manual" : T$1}>
        ${this.renderElevation()}
        <div class="items">
          <div class="item-padding"> ${this.renderMenuItems()} </div>
        </div>
      </div>
    `;
  }
  /**
   * Renders the menu items' slot
   */
  renderMenuItems() {
    return x$1`<slot
      @close-menu=${this.onCloseMenu}
      @deactivate-items=${this.onDeactivateItems}
      @request-activation=${this.onRequestActivation}
      @deactivate-typeahead=${this.handleDeactivateTypeahead}
      @activate-typeahead=${this.handleActivateTypeahead}
      @stay-open-on-focusout=${this.handleStayOpenOnFocusout}
      @close-on-focusout=${this.handleCloseOnFocusout}
      @slotchange=${this.listController.onSlotchange}></slot>`;
  }
  /**
   * Renders the elevation component.
   */
  renderElevation() {
    return x$1`<md-elevation part="elevation"></md-elevation>`;
  }
  getSurfaceClasses() {
    return {
      open: this.open,
      fixed: this.positioning === "fixed",
      "has-overflow": this.hasOverflow
    };
  }
  captureKeydown(event) {
    if (event.target === this && !event.defaultPrevented && isClosableKey(event.code)) {
      event.preventDefault();
      this.close();
    }
    this.typeaheadController.onKeydown(event);
  }
  /**
   * Performs the opening animation:
   *
   * https://direct.googleplex.com/#/spec/295000003+271060003
   *
   * @return A promise that resolve to `true` if the animation was aborted,
   *     `false` if it was not aborted.
   */
  async animateOpen() {
    const surfaceEl = this.surfaceEl;
    const slotEl = this.slotEl;
    if (!surfaceEl || !slotEl)
      return true;
    const openDirection = this.openDirection;
    this.dispatchEvent(new Event("opening"));
    surfaceEl.classList.toggle("animating", true);
    const signal = this.openCloseAnimationSignal.start();
    const height = surfaceEl.offsetHeight;
    const openingUpwards = openDirection === "UP";
    const children = this.items;
    const FULL_DURATION = 500;
    const SURFACE_OPACITY_DURATION = 50;
    const ITEM_OPACITY_DURATION = 250;
    const DELAY_BETWEEN_ITEMS = (FULL_DURATION - ITEM_OPACITY_DURATION) / children.length;
    const surfaceHeightAnimation = surfaceEl.animate([{ height: "0px" }, { height: `${height}px` }], {
      duration: FULL_DURATION,
      easing: EASING.EMPHASIZED
    });
    const upPositionCorrectionAnimation = slotEl.animate([
      { transform: openingUpwards ? `translateY(-${height}px)` : "" },
      { transform: "" }
    ], { duration: FULL_DURATION, easing: EASING.EMPHASIZED });
    const surfaceOpacityAnimation = surfaceEl.animate([{ opacity: 0 }, { opacity: 1 }], SURFACE_OPACITY_DURATION);
    const childrenAnimations = [];
    for (let i3 = 0; i3 < children.length; i3++) {
      const directionalIndex = openingUpwards ? children.length - 1 - i3 : i3;
      const child = children[directionalIndex];
      const animation = child.animate([{ opacity: 0 }, { opacity: 1 }], {
        duration: ITEM_OPACITY_DURATION,
        delay: DELAY_BETWEEN_ITEMS * i3
      });
      child.classList.toggle("md-menu-hidden", true);
      animation.addEventListener("finish", () => {
        child.classList.toggle("md-menu-hidden", false);
      });
      childrenAnimations.push([child, animation]);
    }
    let resolveAnimation = (value) => {
    };
    const animationFinished = new Promise((resolve2) => {
      resolveAnimation = resolve2;
    });
    signal.addEventListener("abort", () => {
      surfaceHeightAnimation.cancel();
      upPositionCorrectionAnimation.cancel();
      surfaceOpacityAnimation.cancel();
      childrenAnimations.forEach(([child, animation]) => {
        child.classList.toggle("md-menu-hidden", false);
        animation.cancel();
      });
      resolveAnimation(true);
    });
    surfaceHeightAnimation.addEventListener("finish", () => {
      surfaceEl.classList.toggle("animating", false);
      this.openCloseAnimationSignal.finish();
      resolveAnimation(false);
    });
    return await animationFinished;
  }
  /**
   * Performs the closing animation:
   *
   * https://direct.googleplex.com/#/spec/295000003+271060003
   */
  animateClose() {
    let resolve2;
    const animationEnded = new Promise((res) => {
      resolve2 = res;
    });
    const surfaceEl = this.surfaceEl;
    const slotEl = this.slotEl;
    if (!surfaceEl || !slotEl) {
      resolve2(false);
      return animationEnded;
    }
    const openDirection = this.openDirection;
    const closingDownwards = openDirection === "UP";
    this.dispatchEvent(new Event("closing"));
    surfaceEl.classList.toggle("animating", true);
    const signal = this.openCloseAnimationSignal.start();
    const height = surfaceEl.offsetHeight;
    const children = this.items;
    const FULL_DURATION = 150;
    const SURFACE_OPACITY_DURATION = 50;
    const SURFACE_OPACITY_DELAY = FULL_DURATION - SURFACE_OPACITY_DURATION;
    const ITEM_OPACITY_DURATION = 50;
    const ITEM_OPACITY_INITIAL_DELAY = 50;
    const END_HEIGHT_PERCENTAGE = 0.35;
    const DELAY_BETWEEN_ITEMS = (FULL_DURATION - ITEM_OPACITY_INITIAL_DELAY - ITEM_OPACITY_DURATION) / children.length;
    const surfaceHeightAnimation = surfaceEl.animate([
      { height: `${height}px` },
      { height: `${height * END_HEIGHT_PERCENTAGE}px` }
    ], {
      duration: FULL_DURATION,
      easing: EASING.EMPHASIZED_ACCELERATE
    });
    const downPositionCorrectionAnimation = slotEl.animate([
      { transform: "" },
      {
        transform: closingDownwards ? `translateY(-${height * (1 - END_HEIGHT_PERCENTAGE)}px)` : ""
      }
    ], { duration: FULL_DURATION, easing: EASING.EMPHASIZED_ACCELERATE });
    const surfaceOpacityAnimation = surfaceEl.animate([{ opacity: 1 }, { opacity: 0 }], { duration: SURFACE_OPACITY_DURATION, delay: SURFACE_OPACITY_DELAY });
    const childrenAnimations = [];
    for (let i3 = 0; i3 < children.length; i3++) {
      const directionalIndex = closingDownwards ? i3 : children.length - 1 - i3;
      const child = children[directionalIndex];
      const animation = child.animate([{ opacity: 1 }, { opacity: 0 }], {
        duration: ITEM_OPACITY_DURATION,
        delay: ITEM_OPACITY_INITIAL_DELAY + DELAY_BETWEEN_ITEMS * i3
      });
      animation.addEventListener("finish", () => {
        child.classList.toggle("md-menu-hidden", true);
      });
      childrenAnimations.push([child, animation]);
    }
    signal.addEventListener("abort", () => {
      surfaceHeightAnimation.cancel();
      downPositionCorrectionAnimation.cancel();
      surfaceOpacityAnimation.cancel();
      childrenAnimations.forEach(([child, animation]) => {
        animation.cancel();
        child.classList.toggle("md-menu-hidden", false);
      });
      resolve2(false);
    });
    surfaceHeightAnimation.addEventListener("finish", () => {
      surfaceEl.classList.toggle("animating", false);
      childrenAnimations.forEach(([child]) => {
        child.classList.toggle("md-menu-hidden", false);
      });
      this.openCloseAnimationSignal.finish();
      this.dispatchEvent(new Event("closed"));
      resolve2(true);
    });
    return animationEnded;
  }
  handleKeydown(event) {
    this.pointerPath = [];
    this.listController.handleKeydown(event);
  }
  setUpGlobalEventListeners() {
    document.addEventListener("click", this.onDocumentClick, { capture: true });
    window.addEventListener("pointerdown", this.onWindowPointerdown);
    document.addEventListener("resize", this.onWindowResize, { passive: true });
    window.addEventListener("resize", this.onWindowResize, { passive: true });
  }
  cleanUpGlobalEventListeners() {
    document.removeEventListener("click", this.onDocumentClick, {
      capture: true
    });
    window.removeEventListener("pointerdown", this.onWindowPointerdown);
    document.removeEventListener("resize", this.onWindowResize);
    window.removeEventListener("resize", this.onWindowResize);
  }
  onCloseMenu() {
    this.close();
  }
  onDeactivateItems(event) {
    event.stopPropagation();
    this.listController.onDeactivateItems();
  }
  onRequestActivation(event) {
    event.stopPropagation();
    this.listController.onRequestActivation(event);
  }
  handleDeactivateTypeahead(event) {
    event.stopPropagation();
    this.typeaheadActive = false;
  }
  handleActivateTypeahead(event) {
    event.stopPropagation();
    this.typeaheadActive = true;
  }
  handleStayOpenOnFocusout(event) {
    event.stopPropagation();
    this.stayOpenOnFocusout = true;
  }
  handleCloseOnFocusout(event) {
    event.stopPropagation();
    this.stayOpenOnFocusout = false;
  }
  close() {
    this.open = false;
    const maybeSubmenu = this.slotItems;
    maybeSubmenu.forEach((item) => {
      item.close?.();
    });
  }
  show() {
    this.open = true;
  }
  /**
   * Activates the next item in the menu. If at the end of the menu, the first
   * item will be activated.
   *
   * @return The activated menu item or `null` if there are no items.
   */
  activateNextItem() {
    return this.listController.activateNextItem() ?? null;
  }
  /**
   * Activates the previous item in the menu. If at the start of the menu, the
   * last item will be activated.
   *
   * @return The activated menu item or `null` if there are no items.
   */
  activatePreviousItem() {
    return this.listController.activatePreviousItem() ?? null;
  }
  /**
   * Repositions the menu if it is open.
   *
   * Useful for the case where document or window-positioned menus have their
   * anchors moved while open.
   */
  reposition() {
    if (this.open) {
      this.menuPositionController.position();
    }
  }
}
__decorate([
  e$5(".menu")
], Menu.prototype, "surfaceEl", void 0);
__decorate([
  e$5("slot")
], Menu.prototype, "slotEl", void 0);
__decorate([
  n$5()
], Menu.prototype, "anchor", void 0);
__decorate([
  n$5()
], Menu.prototype, "positioning", void 0);
__decorate([
  n$5({ type: Boolean })
], Menu.prototype, "quick", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-overflow" })
], Menu.prototype, "hasOverflow", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], Menu.prototype, "open", void 0);
__decorate([
  n$5({ type: Number, attribute: "x-offset" })
], Menu.prototype, "xOffset", void 0);
__decorate([
  n$5({ type: Number, attribute: "y-offset" })
], Menu.prototype, "yOffset", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-horizontal-flip" })
], Menu.prototype, "noHorizontalFlip", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-vertical-flip" })
], Menu.prototype, "noVerticalFlip", void 0);
__decorate([
  n$5({ type: Number, attribute: "typeahead-delay" })
], Menu.prototype, "typeaheadDelay", void 0);
__decorate([
  n$5({ attribute: "anchor-corner" })
], Menu.prototype, "anchorCorner", void 0);
__decorate([
  n$5({ attribute: "menu-corner" })
], Menu.prototype, "menuCorner", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "stay-open-on-outside-click" })
], Menu.prototype, "stayOpenOnOutsideClick", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "stay-open-on-focusout" })
], Menu.prototype, "stayOpenOnFocusout", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "skip-restore-focus" })
], Menu.prototype, "skipRestoreFocus", void 0);
__decorate([
  n$5({ attribute: "default-focus" })
], Menu.prototype, "defaultFocus", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-navigation-wrap" })
], Menu.prototype, "noNavigationWrap", void 0);
__decorate([
  o$4({ flatten: true })
], Menu.prototype, "slotItems", void 0);
__decorate([
  r$4()
], Menu.prototype, "typeaheadActive", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$i = i$4`:host{--md-elevation-level: var(--md-menu-container-elevation, 2);--md-elevation-shadow-color: var(--md-menu-container-shadow-color, var(--md-sys-color-shadow, #000));min-width:112px;color:unset;display:contents}md-focus-ring{--md-focus-ring-shape: var(--md-menu-container-shape, var(--md-sys-shape-corner-extra-small, 4px))}.menu{border-radius:var(--md-menu-container-shape, var(--md-sys-shape-corner-extra-small, 4px));display:none;inset:auto;border:none;padding:0px;overflow:visible;background-color:rgba(0,0,0,0);color:inherit;opacity:0;z-index:20;position:absolute;user-select:none;max-height:inherit;height:inherit;min-width:inherit;max-width:inherit;scrollbar-width:inherit}.menu::backdrop{display:none}.fixed{position:fixed}.items{display:block;list-style-type:none;margin:0;outline:none;box-sizing:border-box;background-color:var(--md-menu-container-color, var(--md-sys-color-surface-container, #f3edf7));height:inherit;max-height:inherit;overflow:auto;min-width:inherit;max-width:inherit;border-radius:inherit;scrollbar-width:inherit}.item-padding{padding-block:8px}.has-overflow:not([popover]) .items{overflow:visible}.has-overflow.animating .items,.animating .items{overflow:hidden}.has-overflow.animating .items{pointer-events:none}.animating ::slotted(.md-menu-hidden){opacity:0}slot{display:block;height:inherit;max-height:inherit}::slotted(:is(md-divider,[role=separator])){margin:8px 0}@media(forced-colors: active){.menu{border-style:solid;border-color:CanvasText;border-width:1px}}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdMenu = class MdMenu2 extends Menu {
};
MdMenu.styles = [styles$i];
MdMenu = __decorate([
  t$3("md-menu")
], MdMenu);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class MenuItemController {
  /**
   * @param host The MenuItem in which to attach this controller to.
   * @param config The object that configures this controller's behavior.
   */
  constructor(host, config) {
    this.host = host;
    this.internalTypeaheadText = null;
    this.onClick = () => {
      if (this.host.keepOpen)
        return;
      this.host.dispatchEvent(createDefaultCloseMenuEvent(this.host, {
        kind: CloseReason$1.CLICK_SELECTION
      }));
    };
    this.onKeydown = (event) => {
      if (this.host.href && event.code === "Enter") {
        const interactiveElement = this.getInteractiveElement();
        if (interactiveElement instanceof HTMLAnchorElement) {
          interactiveElement.click();
        }
      }
      if (event.defaultPrevented)
        return;
      const keyCode = event.code;
      if (this.host.keepOpen && keyCode !== "Escape")
        return;
      if (isClosableKey(keyCode)) {
        event.preventDefault();
        this.host.dispatchEvent(createDefaultCloseMenuEvent(this.host, {
          kind: CloseReason$1.KEYDOWN,
          key: keyCode
        }));
      }
    };
    this.getHeadlineElements = config.getHeadlineElements;
    this.getSupportingTextElements = config.getSupportingTextElements;
    this.getDefaultElements = config.getDefaultElements;
    this.getInteractiveElement = config.getInteractiveElement;
    this.host.addController(this);
  }
  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot, and if there are
   * no slotted elements into headline, then it checks the _default_ slot, and
   * then the `"supporting-text"` slot if nothing is in _default_.
   */
  get typeaheadText() {
    if (this.internalTypeaheadText !== null) {
      return this.internalTypeaheadText;
    }
    const headlineElements = this.getHeadlineElements();
    const textParts = [];
    headlineElements.forEach((headlineElement) => {
      if (headlineElement.textContent && headlineElement.textContent.trim()) {
        textParts.push(headlineElement.textContent.trim());
      }
    });
    if (textParts.length === 0) {
      this.getDefaultElements().forEach((defaultElement) => {
        if (defaultElement.textContent && defaultElement.textContent.trim()) {
          textParts.push(defaultElement.textContent.trim());
        }
      });
    }
    if (textParts.length === 0) {
      this.getSupportingTextElements().forEach((supportingTextElement) => {
        if (supportingTextElement.textContent && supportingTextElement.textContent.trim()) {
          textParts.push(supportingTextElement.textContent.trim());
        }
      });
    }
    return textParts.join(" ");
  }
  /**
   * The recommended tag name to render as the list item.
   */
  get tagName() {
    const type = this.host.type;
    switch (type) {
      case "link":
        return "a";
      case "button":
        return "button";
      default:
      case "menuitem":
      case "option":
        return "li";
    }
  }
  /**
   * The recommended role of the menu item.
   */
  get role() {
    return this.host.type === "option" ? "option" : "menuitem";
  }
  hostConnected() {
    this.host.toggleAttribute("md-menu-item", true);
  }
  hostUpdate() {
    if (this.host.href) {
      this.host.type = "link";
    }
  }
  /**
   * Use to set the typeaheadText when it changes.
   */
  setTypeaheadText(text) {
    this.internalTypeaheadText = text;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const menuItemBaseClass = mixinDelegatesAria(s$1);
class MenuItemEl extends menuItemBaseClass {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.type = "menuitem";
    this.href = "";
    this.target = "";
    this.keepOpen = false;
    this.selected = false;
    this.menuItemController = new MenuItemController(this, {
      getHeadlineElements: () => {
        return this.headlineElements;
      },
      getSupportingTextElements: () => {
        return this.supportingTextElements;
      },
      getDefaultElements: () => {
        return this.defaultElements;
      },
      getInteractiveElement: () => this.listItemRoot
    });
  }
  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot.
   */
  get typeaheadText() {
    return this.menuItemController.typeaheadText;
  }
  set typeaheadText(text) {
    this.menuItemController.setTypeaheadText(text);
  }
  render() {
    return this.renderListItem(x$1`
      <md-item>
        <div slot="container">
          ${this.renderRipple()} ${this.renderFocusRing()}
        </div>
        <slot name="start" slot="start"></slot>
        <slot name="end" slot="end"></slot>
        ${this.renderBody()}
      </md-item>
    `);
  }
  /**
   * Renders the root list item.
   *
   * @param content the child content of the list item.
   */
  renderListItem(content) {
    const isAnchor = this.type === "link";
    let tag;
    switch (this.menuItemController.tagName) {
      case "a":
        tag = s2`a`;
        break;
      case "button":
        tag = s2`button`;
        break;
      default:
      case "li":
        tag = s2`li`;
        break;
    }
    const target = isAnchor && !!this.target ? this.target : T$1;
    return n$2`
      <${tag}
        id="item"
        tabindex=${this.disabled && !isAnchor ? -1 : 0}
        role=${this.menuItemController.role}
        aria-label=${this.ariaLabel || T$1}
        aria-selected=${this.ariaSelected || T$1}
        aria-checked=${this.ariaChecked || T$1}
        aria-expanded=${this.ariaExpanded || T$1}
        aria-haspopup=${this.ariaHasPopup || T$1}
        class="list-item ${e$1(this.getRenderClasses())}"
        href=${this.href || T$1}
        target=${target}
        @click=${this.menuItemController.onClick}
        @keydown=${this.menuItemController.onKeydown}
      >${content}</${tag}>
    `;
  }
  /**
   * Handles rendering of the ripple element.
   */
  renderRipple() {
    return x$1` <md-ripple
      part="ripple"
      for="item"
      ?disabled=${this.disabled}></md-ripple>`;
  }
  /**
   * Handles rendering of the focus ring.
   */
  renderFocusRing() {
    return x$1` <md-focus-ring
      part="focus-ring"
      for="item"
      inward></md-focus-ring>`;
  }
  /**
   * Classes applied to the list item root.
   */
  getRenderClasses() {
    return {
      "disabled": this.disabled,
      "selected": this.selected
    };
  }
  /**
   * Handles rendering the headline and supporting text.
   */
  renderBody() {
    return x$1`
      <slot></slot>
      <slot name="overline" slot="overline"></slot>
      <slot name="headline" slot="headline"></slot>
      <slot name="supporting-text" slot="supporting-text"></slot>
      <slot
        name="trailing-supporting-text"
        slot="trailing-supporting-text"></slot>
    `;
  }
  focus() {
    this.listItemRoot?.focus();
  }
}
MenuItemEl.shadowRootOptions = {
  ...s$1.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], MenuItemEl.prototype, "disabled", void 0);
__decorate([
  n$5()
], MenuItemEl.prototype, "type", void 0);
__decorate([
  n$5()
], MenuItemEl.prototype, "href", void 0);
__decorate([
  n$5()
], MenuItemEl.prototype, "target", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "keep-open" })
], MenuItemEl.prototype, "keepOpen", void 0);
__decorate([
  n$5({ type: Boolean })
], MenuItemEl.prototype, "selected", void 0);
__decorate([
  e$5(".list-item")
], MenuItemEl.prototype, "listItemRoot", void 0);
__decorate([
  o$4({ slot: "headline" })
], MenuItemEl.prototype, "headlineElements", void 0);
__decorate([
  o$4({ slot: "supporting-text" })
], MenuItemEl.prototype, "supportingTextElements", void 0);
__decorate([
  n$4({ slot: "" })
], MenuItemEl.prototype, "defaultElements", void 0);
__decorate([
  n$5({ attribute: "typeahead-text" })
], MenuItemEl.prototype, "typeaheadText", null);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$h = i$4`:host{display:flex;--md-ripple-hover-color: var(--md-menu-item-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-hover-opacity: var(--md-menu-item-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-menu-item-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-pressed-opacity: var(--md-menu-item-pressed-state-layer-opacity, 0.12)}:host([disabled]){opacity:var(--md-menu-item-disabled-opacity, 0.3);pointer-events:none}md-focus-ring{z-index:1;--md-focus-ring-shape: 8px}a,button,li{background:none;border:none;padding:0;margin:0;text-align:unset;text-decoration:none}.list-item{border-radius:inherit;display:flex;flex:1;max-width:inherit;min-width:inherit;outline:none;-webkit-tap-highlight-color:rgba(0,0,0,0)}.list-item:not(.disabled){cursor:pointer}[slot=container]{pointer-events:none}md-ripple{border-radius:inherit}md-item{border-radius:inherit;flex:1;color:var(--md-menu-item-label-text-color, var(--md-sys-color-on-surface, #1d1b20));font-family:var(--md-menu-item-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-menu-item-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));line-height:var(--md-menu-item-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));font-weight:var(--md-menu-item-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));min-height:var(--md-menu-item-one-line-container-height, 56px);padding-top:var(--md-menu-item-top-space, 12px);padding-bottom:var(--md-menu-item-bottom-space, 12px);padding-inline-start:var(--md-menu-item-leading-space, 16px);padding-inline-end:var(--md-menu-item-trailing-space, 16px)}md-item[multiline]{min-height:var(--md-menu-item-two-line-container-height, 72px)}[slot=supporting-text]{color:var(--md-menu-item-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));font-family:var(--md-menu-item-supporting-text-font, var(--md-sys-typescale-body-medium-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-menu-item-supporting-text-size, var(--md-sys-typescale-body-medium-size, 0.875rem));line-height:var(--md-menu-item-supporting-text-line-height, var(--md-sys-typescale-body-medium-line-height, 1.25rem));font-weight:var(--md-menu-item-supporting-text-weight, var(--md-sys-typescale-body-medium-weight, var(--md-ref-typeface-weight-regular, 400)))}[slot=trailing-supporting-text]{color:var(--md-menu-item-trailing-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));font-family:var(--md-menu-item-trailing-supporting-text-font, var(--md-sys-typescale-label-small-font, var(--md-ref-typeface-plain, Roboto)));font-size:var(--md-menu-item-trailing-supporting-text-size, var(--md-sys-typescale-label-small-size, 0.6875rem));line-height:var(--md-menu-item-trailing-supporting-text-line-height, var(--md-sys-typescale-label-small-line-height, 1rem));font-weight:var(--md-menu-item-trailing-supporting-text-weight, var(--md-sys-typescale-label-small-weight, var(--md-ref-typeface-weight-medium, 500)))}:is([slot=start],[slot=end])::slotted(*){fill:currentColor}[slot=start]{color:var(--md-menu-item-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f))}[slot=end]{color:var(--md-menu-item-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f))}.list-item{background-color:var(--md-menu-item-container-color, transparent)}.list-item.selected{background-color:var(--md-menu-item-selected-container-color, var(--md-sys-color-secondary-container, #e8def8))}.selected:not(.disabled) ::slotted(*){color:var(--md-menu-item-selected-label-text-color, var(--md-sys-color-on-secondary-container, #1d192b))}@media(forced-colors: active){:host([disabled]),:host([disabled]) slot{color:GrayText;opacity:1}.list-item{position:relative}.list-item.selected::before{content:"";position:absolute;inset:0;box-sizing:border-box;border-radius:inherit;pointer-events:none;border:3px double CanvasText}}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdMenuItem = class MdMenuItem2 extends MenuItemEl {
};
MdMenuItem.styles = [styles$h];
MdMenuItem = __decorate([
  t$3("md-menu-item")
], MdMenuItem);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class SubMenu extends s$1 {
  get item() {
    return this.items[0] ?? null;
  }
  get menu() {
    return this.menus[0] ?? null;
  }
  constructor() {
    super();
    this.anchorCorner = Corner.START_END;
    this.menuCorner = Corner.START_START;
    this.hoverOpenDelay = 400;
    this.hoverCloseDelay = 400;
    this.isSubMenu = true;
    this.previousOpenTimeout = 0;
    this.previousCloseTimeout = 0;
    this.onMouseenter = () => {
      clearTimeout(this.previousOpenTimeout);
      clearTimeout(this.previousCloseTimeout);
      if (this.menu?.open)
        return;
      if (!this.hoverOpenDelay) {
        this.show();
      } else {
        this.previousOpenTimeout = setTimeout(() => {
          this.show();
        }, this.hoverOpenDelay);
      }
    };
    this.onMouseleave = () => {
      clearTimeout(this.previousCloseTimeout);
      clearTimeout(this.previousOpenTimeout);
      if (!this.hoverCloseDelay) {
        this.close();
      } else {
        this.previousCloseTimeout = setTimeout(() => {
          this.close();
        }, this.hoverCloseDelay);
      }
    };
    {
      this.addEventListener("mouseenter", this.onMouseenter);
      this.addEventListener("mouseleave", this.onMouseleave);
    }
  }
  render() {
    return x$1`
      <slot
        name="item"
        @click=${this.onClick}
        @keydown=${this.onKeydown}
        @slotchange=${this.onSlotchange}>
      </slot>
      <slot
        name="menu"
        @keydown=${this.onSubMenuKeydown}
        @close-menu=${this.onCloseSubmenu}
        @slotchange=${this.onSlotchange}>
      </slot>
    `;
  }
  firstUpdated() {
    this.onSlotchange();
  }
  /**
   * Shows the submenu.
   */
  async show() {
    const menu = this.menu;
    if (!menu || menu.open)
      return;
    menu.addEventListener("closed", () => {
      this.item.ariaExpanded = "false";
      this.dispatchEvent(createActivateTypeaheadEvent());
      this.dispatchEvent(createDeactivateItemsEvent());
      menu.ariaHidden = "true";
    }, { once: true });
    if (menu.positioning === "document") {
      menu.positioning = "absolute";
    }
    menu.quick = true;
    menu.hasOverflow = true;
    menu.anchorCorner = this.anchorCorner;
    menu.menuCorner = this.menuCorner;
    menu.anchorElement = this.item;
    menu.defaultFocus = "first-item";
    menu.removeAttribute("aria-hidden");
    menu.skipRestoreFocus = false;
    const menuAlreadyOpen = menu.open;
    menu.show();
    this.item.ariaExpanded = "true";
    this.item.ariaHasPopup = "menu";
    if (menu.id) {
      this.item.setAttribute("aria-controls", menu.id);
    }
    this.dispatchEvent(createDeactivateItemsEvent());
    this.dispatchEvent(createDeactivateTypeaheadEvent());
    this.item.selected = true;
    if (!menuAlreadyOpen) {
      let open = (value) => {
      };
      const opened = new Promise((resolve2) => {
        open = resolve2;
      });
      menu.addEventListener("opened", open, { once: true });
      await opened;
    }
  }
  /**
   * Closes the submenu.
   */
  async close() {
    const menu = this.menu;
    if (!menu || !menu.open)
      return;
    this.dispatchEvent(createActivateTypeaheadEvent());
    menu.quick = true;
    menu.close();
    this.dispatchEvent(createDeactivateItemsEvent());
    let close = (value) => {
    };
    const closed = new Promise((resolve2) => {
      close = resolve2;
    });
    menu.addEventListener("closed", close, { once: true });
    await closed;
  }
  onSlotchange() {
    if (!this.item) {
      return;
    }
    this.item.ariaExpanded = "false";
    this.item.ariaHasPopup = "menu";
    if (this.menu?.id) {
      this.item.setAttribute("aria-controls", this.menu.id);
    }
    this.item.keepOpen = true;
    const menu = this.menu;
    if (!menu)
      return;
    menu.isSubmenu = true;
    menu.ariaHidden = "true";
  }
  onClick() {
    this.show();
  }
  /**
   * On item keydown handles opening the submenu.
   */
  async onKeydown(event) {
    const shouldOpenSubmenu = this.isSubmenuOpenKey(event.code);
    if (event.defaultPrevented)
      return;
    const openedWithLR = shouldOpenSubmenu && (NavigableKey.LEFT === event.code || NavigableKey.RIGHT === event.code);
    if (event.code === SelectionKey.SPACE || openedWithLR) {
      event.preventDefault();
      if (openedWithLR) {
        event.stopPropagation();
      }
    }
    if (!shouldOpenSubmenu) {
      return;
    }
    const submenu = this.menu;
    if (!submenu)
      return;
    const submenuItems = submenu.items;
    const firstActivatableItem = getFirstActivatableItem(submenuItems);
    if (firstActivatableItem) {
      await this.show();
      firstActivatableItem.tabIndex = 0;
      firstActivatableItem.focus();
      return;
    }
  }
  onCloseSubmenu(event) {
    const { itemPath, reason } = event.detail;
    itemPath.push(this.item);
    this.dispatchEvent(createActivateTypeaheadEvent());
    if (reason.kind === CloseReason$1.KEYDOWN && reason.key === KeydownCloseKey.ESCAPE) {
      event.stopPropagation();
      this.item.dispatchEvent(createRequestActivationEvent());
      return;
    }
    this.dispatchEvent(createDeactivateItemsEvent());
  }
  async onSubMenuKeydown(event) {
    if (event.defaultPrevented)
      return;
    const { close: shouldClose, keyCode } = this.isSubmenuCloseKey(event.code);
    if (!shouldClose)
      return;
    event.preventDefault();
    if (keyCode === NavigableKey.LEFT || keyCode === NavigableKey.RIGHT) {
      event.stopPropagation();
    }
    await this.close();
    deactivateActiveItem(this.menu.items);
    this.item?.focus();
    this.item.tabIndex = 0;
    this.item.focus();
  }
  /**
   * Determines whether the given KeyboardEvent code is one that should open
   * the submenu. This is RTL-aware. By default, left, right, space, or enter.
   *
   * @param code The native KeyboardEvent code.
   * @return Whether or not the key code should open the submenu.
   */
  isSubmenuOpenKey(code) {
    const isRtl2 = getComputedStyle(this).direction === "rtl";
    const arrowEnterKey = isRtl2 ? NavigableKey.LEFT : NavigableKey.RIGHT;
    switch (code) {
      case arrowEnterKey:
      case SelectionKey.SPACE:
      case SelectionKey.ENTER:
        return true;
      default:
        return false;
    }
  }
  /**
   * Determines whether the given KeyboardEvent code is one that should close
   * the submenu. This is RTL-aware. By default right, left, or escape.
   *
   * @param code The native KeyboardEvent code.
   * @return Whether or not the key code should close the submenu.
   */
  isSubmenuCloseKey(code) {
    const isRtl2 = getComputedStyle(this).direction === "rtl";
    const arrowEnterKey = isRtl2 ? NavigableKey.RIGHT : NavigableKey.LEFT;
    switch (code) {
      case arrowEnterKey:
      case KeydownCloseKey.ESCAPE:
        return { close: true, keyCode: code };
      default:
        return { close: false };
    }
  }
}
__decorate([
  n$5({ attribute: "anchor-corner" })
], SubMenu.prototype, "anchorCorner", void 0);
__decorate([
  n$5({ attribute: "menu-corner" })
], SubMenu.prototype, "menuCorner", void 0);
__decorate([
  n$5({ type: Number, attribute: "hover-open-delay" })
], SubMenu.prototype, "hoverOpenDelay", void 0);
__decorate([
  n$5({ type: Number, attribute: "hover-close-delay" })
], SubMenu.prototype, "hoverCloseDelay", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "md-sub-menu" })
], SubMenu.prototype, "isSubMenu", void 0);
__decorate([
  o$4({ slot: "item", flatten: true })
], SubMenu.prototype, "items", void 0);
__decorate([
  o$4({ slot: "menu", flatten: true })
], SubMenu.prototype, "menus", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$g = i$4`:host{position:relative;display:flex;flex-direction:column}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdSubMenu = class MdSubMenu2 extends SubMenu {
};
MdSubMenu.styles = [styles$g];
MdSubMenu = __decorate([
  t$3("md-sub-menu")
], MdSubMenu);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const progressBaseClass = mixinDelegatesAria(s$1);
class Progress extends progressBaseClass {
  constructor() {
    super(...arguments);
    this.value = 0;
    this.max = 1;
    this.indeterminate = false;
    this.fourColor = false;
  }
  render() {
    const { ariaLabel } = this;
    return x$1`
      <div
        class="progress ${e$1(this.getRenderClasses())}"
        role="progressbar"
        aria-label="${ariaLabel || T$1}"
        aria-valuemin="0"
        aria-valuemax=${this.max}
        aria-valuenow=${this.indeterminate ? T$1 : this.value}
        >${this.renderIndicator()}</div
      >
    `;
  }
  getRenderClasses() {
    return {
      "indeterminate": this.indeterminate,
      "four-color": this.fourColor
    };
  }
}
__decorate([
  n$5({ type: Number })
], Progress.prototype, "value", void 0);
__decorate([
  n$5({ type: Number })
], Progress.prototype, "max", void 0);
__decorate([
  n$5({ type: Boolean })
], Progress.prototype, "indeterminate", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "four-color" })
], Progress.prototype, "fourColor", void 0);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class CircularProgress extends Progress {
  renderIndicator() {
    if (this.indeterminate) {
      return this.renderIndeterminateContainer();
    }
    return this.renderDeterminateContainer();
  }
  // Determinate mode is rendered with an svg so the progress arc can be
  // easily animated via stroke-dashoffset.
  renderDeterminateContainer() {
    const dashOffset = (1 - this.value / this.max) * 100;
    return x$1`
      <svg viewBox="0 0 4800 4800">
        <circle class="track" pathLength="100"></circle>
        <circle
          class="active-track"
          pathLength="100"
          stroke-dashoffset=${dashOffset}></circle>
      </svg>
    `;
  }
  // Indeterminate mode rendered with 2 bordered-divs. The borders are
  // clipped into half circles by their containers. The divs are then carefully
  // animated to produce changes to the spinner arc size.
  // This approach has 4.5x the FPS of rendering via svg on Chrome 111.
  // See https://lit.dev/playground/#gist=febb773565272f75408ab06a0eb49746.
  renderIndeterminateContainer() {
    return x$1` <div class="spinner">
      <div class="left">
        <div class="circle"></div>
      </div>
      <div class="right">
        <div class="circle"></div>
      </div>
    </div>`;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$f = i$4`:host{--_active-indicator-color: var(--md-circular-progress-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_active-indicator-width: var(--md-circular-progress-active-indicator-width, 10);--_four-color-active-indicator-four-color: var(--md-circular-progress-four-color-active-indicator-four-color, var(--md-sys-color-tertiary-container, #ffd8e4));--_four-color-active-indicator-one-color: var(--md-circular-progress-four-color-active-indicator-one-color, var(--md-sys-color-primary, #6750a4));--_four-color-active-indicator-three-color: var(--md-circular-progress-four-color-active-indicator-three-color, var(--md-sys-color-tertiary, #7d5260));--_four-color-active-indicator-two-color: var(--md-circular-progress-four-color-active-indicator-two-color, var(--md-sys-color-primary-container, #eaddff));--_size: var(--md-circular-progress-size, 48px);display:inline-flex;vertical-align:middle;width:var(--_size);height:var(--_size);position:relative;align-items:center;justify-content:center;contain:strict;content-visibility:auto}.progress{flex:1;align-self:stretch;margin:4px}.progress,.spinner,.left,.right,.circle,svg,.track,.active-track{position:absolute;inset:0}svg{transform:rotate(-90deg)}circle{cx:50%;cy:50%;r:calc(50%*(1 - var(--_active-indicator-width)/100));stroke-width:calc(var(--_active-indicator-width)*1%);stroke-dasharray:100;fill:rgba(0,0,0,0)}.active-track{transition:stroke-dashoffset 500ms cubic-bezier(0, 0, 0.2, 1);stroke:var(--_active-indicator-color)}.track{stroke:rgba(0,0,0,0)}.progress.indeterminate{animation:linear infinite linear-rotate;animation-duration:1568.2352941176ms}.spinner{animation:infinite both rotate-arc;animation-duration:5332ms;animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}.left{overflow:hidden;inset:0 50% 0 0}.right{overflow:hidden;inset:0 0 0 50%}.circle{box-sizing:border-box;border-radius:50%;border:solid calc(var(--_active-indicator-width)/100*(var(--_size) - 8px));border-color:var(--_active-indicator-color) var(--_active-indicator-color) rgba(0,0,0,0) rgba(0,0,0,0);animation:expand-arc;animation-iteration-count:infinite;animation-fill-mode:both;animation-duration:1333ms,5332ms;animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}.four-color .circle{animation-name:expand-arc,four-color}.left .circle{rotate:135deg;inset:0 -100% 0 0}.right .circle{rotate:100deg;inset:0 0 0 -100%;animation-delay:-666.5ms,0ms}@media(forced-colors: active){.active-track{stroke:CanvasText}.circle{border-color:CanvasText CanvasText Canvas Canvas}}@keyframes expand-arc{0%{transform:rotate(265deg)}50%{transform:rotate(130deg)}100%{transform:rotate(265deg)}}@keyframes rotate-arc{12.5%{transform:rotate(135deg)}25%{transform:rotate(270deg)}37.5%{transform:rotate(405deg)}50%{transform:rotate(540deg)}62.5%{transform:rotate(675deg)}75%{transform:rotate(810deg)}87.5%{transform:rotate(945deg)}100%{transform:rotate(1080deg)}}@keyframes linear-rotate{to{transform:rotate(360deg)}}@keyframes four-color{0%{border-top-color:var(--_four-color-active-indicator-one-color);border-right-color:var(--_four-color-active-indicator-one-color)}15%{border-top-color:var(--_four-color-active-indicator-one-color);border-right-color:var(--_four-color-active-indicator-one-color)}25%{border-top-color:var(--_four-color-active-indicator-two-color);border-right-color:var(--_four-color-active-indicator-two-color)}40%{border-top-color:var(--_four-color-active-indicator-two-color);border-right-color:var(--_four-color-active-indicator-two-color)}50%{border-top-color:var(--_four-color-active-indicator-three-color);border-right-color:var(--_four-color-active-indicator-three-color)}65%{border-top-color:var(--_four-color-active-indicator-three-color);border-right-color:var(--_four-color-active-indicator-three-color)}75%{border-top-color:var(--_four-color-active-indicator-four-color);border-right-color:var(--_four-color-active-indicator-four-color)}90%{border-top-color:var(--_four-color-active-indicator-four-color);border-right-color:var(--_four-color-active-indicator-four-color)}100%{border-top-color:var(--_four-color-active-indicator-one-color);border-right-color:var(--_four-color-active-indicator-one-color)}}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdCircularProgress = class MdCircularProgress2 extends CircularProgress {
};
MdCircularProgress.styles = [styles$f];
MdCircularProgress = __decorate([
  t$3("md-circular-progress")
], MdCircularProgress);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class LinearProgress extends Progress {
  constructor() {
    super(...arguments);
    this.buffer = 0;
  }
  // Note, the indeterminate animation is rendered with transform %'s
  // Previously, this was optimized to use px calculated with the resizeObserver
  // due to a now fixed Chrome bug: crbug.com/389359.
  renderIndicator() {
    const progressStyles = {
      transform: `scaleX(${(this.indeterminate ? 1 : this.value / this.max) * 100}%)`
    };
    const bufferValue = this.buffer ?? 0;
    const hasBuffer = bufferValue > 0;
    const dotSize = this.indeterminate || !hasBuffer ? 1 : bufferValue / this.max;
    const dotStyles = {
      transform: `scaleX(${dotSize * 100}%)`
    };
    const hideDots = this.indeterminate || !hasBuffer || bufferValue >= this.max || this.value >= this.max;
    return x$1`
      <div class="dots" ?hidden=${hideDots}></div>
      <div class="inactive-track" style=${o(dotStyles)}></div>
      <div class="bar primary-bar" style=${o(progressStyles)}>
        <div class="bar-inner"></div>
      </div>
      <div class="bar secondary-bar">
        <div class="bar-inner"></div>
      </div>
    `;
  }
}
__decorate([
  n$5({ type: Number })
], LinearProgress.prototype, "buffer", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$e = i$4`:host{--_active-indicator-color: var(--md-linear-progress-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_active-indicator-height: var(--md-linear-progress-active-indicator-height, 4px);--_four-color-active-indicator-four-color: var(--md-linear-progress-four-color-active-indicator-four-color, var(--md-sys-color-tertiary-container, #ffd8e4));--_four-color-active-indicator-one-color: var(--md-linear-progress-four-color-active-indicator-one-color, var(--md-sys-color-primary, #6750a4));--_four-color-active-indicator-three-color: var(--md-linear-progress-four-color-active-indicator-three-color, var(--md-sys-color-tertiary, #7d5260));--_four-color-active-indicator-two-color: var(--md-linear-progress-four-color-active-indicator-two-color, var(--md-sys-color-primary-container, #eaddff));--_track-color: var(--md-linear-progress-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_track-height: var(--md-linear-progress-track-height, 4px);--_track-shape: var(--md-linear-progress-track-shape, var(--md-sys-shape-corner-none, 0px));border-radius:var(--_track-shape);display:flex;position:relative;min-width:80px;height:var(--_track-height);content-visibility:auto;contain:strict}.progress,.dots,.inactive-track,.bar,.bar-inner{position:absolute}.progress{direction:ltr;inset:0;border-radius:inherit;overflow:hidden;display:flex;align-items:center}.bar{animation:none;width:100%;height:var(--_active-indicator-height);transform-origin:left center;transition:transform 250ms cubic-bezier(0.4, 0, 0.6, 1)}.secondary-bar{display:none}.bar-inner{inset:0;animation:none;background:var(--_active-indicator-color)}.inactive-track{background:var(--_track-color);inset:0;transition:transform 250ms cubic-bezier(0.4, 0, 0.6, 1);transform-origin:left center}.dots{inset:0;animation:linear infinite 250ms;animation-name:buffering;background-color:var(--_track-color);background-repeat:repeat-x;-webkit-mask-image:url("data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 5 2' preserveAspectRatio='xMinYMin slice'%3E%3Ccircle cx='1' cy='1' r='1'/%3E%3C/svg%3E");mask-image:url("data:image/svg+xml,%3Csvg version='1.1' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 5 2' preserveAspectRatio='xMinYMin slice'%3E%3Ccircle cx='1' cy='1' r='1'/%3E%3C/svg%3E");z-index:-1}.dots[hidden]{display:none}.indeterminate .bar{transition:none}.indeterminate .primary-bar{inset-inline-start:-145.167%}.indeterminate .secondary-bar{inset-inline-start:-54.8889%;display:block}.indeterminate .primary-bar{animation:linear infinite 2s;animation-name:primary-indeterminate-translate}.indeterminate .primary-bar>.bar-inner{animation:linear infinite 2s primary-indeterminate-scale}.indeterminate.four-color .primary-bar>.bar-inner{animation-name:primary-indeterminate-scale,four-color;animation-duration:2s,4s}.indeterminate .secondary-bar{animation:linear infinite 2s;animation-name:secondary-indeterminate-translate}.indeterminate .secondary-bar>.bar-inner{animation:linear infinite 2s secondary-indeterminate-scale}.indeterminate.four-color .secondary-bar>.bar-inner{animation-name:secondary-indeterminate-scale,four-color;animation-duration:2s,4s}:host(:dir(rtl)){transform:scale(-1)}@keyframes primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.00432);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes buffering{0%{transform:translateX(calc(var(--_track-height) / 2 * 5))}}@keyframes primary-indeterminate-translate{0%{transform:translateX(0px)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0px)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.6714%)}100%{transform:translateX(200.611%)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0px)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.6519%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.3862%)}100%{transform:translateX(160.278%)}}@keyframes four-color{0%{background:var(--_four-color-active-indicator-one-color)}15%{background:var(--_four-color-active-indicator-one-color)}25%{background:var(--_four-color-active-indicator-two-color)}40%{background:var(--_four-color-active-indicator-two-color)}50%{background:var(--_four-color-active-indicator-three-color)}65%{background:var(--_four-color-active-indicator-three-color)}75%{background:var(--_four-color-active-indicator-four-color)}90%{background:var(--_four-color-active-indicator-four-color)}100%{background:var(--_four-color-active-indicator-one-color)}}@media(forced-colors: active){:host{outline:1px solid CanvasText}.bar-inner,.dots{background-color:CanvasText}}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdLinearProgress = class MdLinearProgress2 extends LinearProgress {
};
MdLinearProgress.styles = [styles$e];
MdLinearProgress = __decorate([
  t$3("md-linear-progress")
], MdLinearProgress);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const isFocusable = Symbol("isFocusable");
const privateIsFocusable = Symbol("privateIsFocusable");
const externalTabIndex = Symbol("externalTabIndex");
const isUpdatingTabIndex = Symbol("isUpdatingTabIndex");
const updateTabIndex = Symbol("updateTabIndex");
function mixinFocusable(base) {
  var _a2, _b2, _c2;
  class FocusableElement extends base {
    constructor() {
      super(...arguments);
      this[_a2] = true;
      this[_b2] = null;
      this[_c2] = false;
    }
    get [isFocusable]() {
      return this[privateIsFocusable];
    }
    set [isFocusable](value) {
      if (this[isFocusable] === value) {
        return;
      }
      this[privateIsFocusable] = value;
      this[updateTabIndex]();
    }
    connectedCallback() {
      super.connectedCallback();
      this[updateTabIndex]();
    }
    attributeChangedCallback(name2, old, value) {
      if (name2 !== "tabindex") {
        super.attributeChangedCallback(name2, old, value);
        return;
      }
      this.requestUpdate("tabIndex", Number(old ?? -1));
      if (this[isUpdatingTabIndex]) {
        return;
      }
      if (!this.hasAttribute("tabindex")) {
        this[externalTabIndex] = null;
        this[updateTabIndex]();
        return;
      }
      this[externalTabIndex] = this.tabIndex;
    }
    [(_a2 = privateIsFocusable, _b2 = externalTabIndex, _c2 = isUpdatingTabIndex, updateTabIndex)]() {
      const internalTabIndex = this[isFocusable] ? 0 : -1;
      const computedTabIndex = this[externalTabIndex] ?? internalTabIndex;
      this[isUpdatingTabIndex] = true;
      this.tabIndex = computedTabIndex;
      this[isUpdatingTabIndex] = false;
    }
  }
  __decorate([
    n$5({ noAccessor: true })
  ], FocusableElement.prototype, "tabIndex", void 0);
  return FocusableElement;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class RadioValidator extends Validator {
  computeValidity(states) {
    if (!this.radioElement) {
      this.radioElement = document.createElement("input");
      this.radioElement.type = "radio";
      this.radioElement.name = "group";
    }
    let isRequired = false;
    let isChecked = false;
    for (const { checked, required } of states) {
      if (required) {
        isRequired = true;
      }
      if (checked) {
        isChecked = true;
      }
    }
    this.radioElement.checked = isChecked;
    this.radioElement.required = isRequired;
    return {
      validity: {
        valueMissing: isRequired && !isChecked
      },
      validationMessage: this.radioElement.validationMessage
    };
  }
  equals(prevGroup, nextGroup) {
    if (prevGroup.length !== nextGroup.length) {
      return false;
    }
    for (let i3 = 0; i3 < prevGroup.length; i3++) {
      const prev = prevGroup[i3];
      const next = nextGroup[i3];
      if (prev.checked !== next.checked || prev.required !== next.required) {
        return false;
      }
    }
    return true;
  }
  copy(states) {
    return states.map(({ checked, required }) => ({
      checked,
      required
    }));
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class SingleSelectionController {
  /**
   * All single selection elements in the host element's root with the same
   * `name` attribute, including the host element.
   */
  get controls() {
    const name2 = this.host.getAttribute("name");
    if (!name2 || !this.root || !this.host.isConnected) {
      return [this.host];
    }
    return Array.from(this.root.querySelectorAll(`[name="${name2}"]`));
  }
  constructor(host) {
    this.host = host;
    this.focused = false;
    this.root = null;
    this.handleFocusIn = () => {
      this.focused = true;
      this.updateTabIndices();
    };
    this.handleFocusOut = () => {
      this.focused = false;
      this.updateTabIndices();
    };
    this.handleKeyDown = (event) => {
      const isDown = event.key === "ArrowDown";
      const isUp = event.key === "ArrowUp";
      const isLeft = event.key === "ArrowLeft";
      const isRight = event.key === "ArrowRight";
      if (!isLeft && !isRight && !isDown && !isUp) {
        return;
      }
      const siblings = this.controls;
      if (!siblings.length) {
        return;
      }
      event.preventDefault();
      const isRtl2 = getComputedStyle(this.host).direction === "rtl";
      const forwards = isRtl2 ? isLeft || isDown : isRight || isDown;
      const hostIndex = siblings.indexOf(this.host);
      let nextIndex = forwards ? hostIndex + 1 : hostIndex - 1;
      while (nextIndex !== hostIndex) {
        if (nextIndex >= siblings.length) {
          nextIndex = 0;
        } else if (nextIndex < 0) {
          nextIndex = siblings.length - 1;
        }
        const nextSibling = siblings[nextIndex];
        if (nextSibling.hasAttribute("disabled")) {
          if (forwards) {
            nextIndex++;
          } else {
            nextIndex--;
          }
          continue;
        }
        for (const sibling of siblings) {
          if (sibling !== nextSibling) {
            sibling.checked = false;
            sibling.tabIndex = -1;
            sibling.blur();
          }
        }
        nextSibling.checked = true;
        nextSibling.tabIndex = 0;
        nextSibling.focus();
        nextSibling.dispatchEvent(new Event("change", { bubbles: true }));
        break;
      }
    };
  }
  hostConnected() {
    this.root = this.host.getRootNode();
    this.host.addEventListener("keydown", this.handleKeyDown);
    this.host.addEventListener("focusin", this.handleFocusIn);
    this.host.addEventListener("focusout", this.handleFocusOut);
    if (this.host.checked) {
      this.uncheckSiblings();
    }
    this.updateTabIndices();
  }
  hostDisconnected() {
    this.host.removeEventListener("keydown", this.handleKeyDown);
    this.host.removeEventListener("focusin", this.handleFocusIn);
    this.host.removeEventListener("focusout", this.handleFocusOut);
    this.updateTabIndices();
    this.root = null;
  }
  /**
   * Should be called whenever the host's `checked` property changes
   * synchronously.
   */
  handleCheckedChange() {
    if (!this.host.checked) {
      return;
    }
    this.uncheckSiblings();
    this.updateTabIndices();
  }
  uncheckSiblings() {
    for (const sibling of this.controls) {
      if (sibling !== this.host) {
        sibling.checked = false;
      }
    }
  }
  /**
   * Updates the `tabindex` of the host and its siblings.
   */
  updateTabIndices() {
    const siblings = this.controls;
    const checkedSibling = siblings.find((sibling) => sibling.checked);
    if (checkedSibling || this.focused) {
      const focusable = checkedSibling || this.host;
      focusable.tabIndex = 0;
      for (const sibling of siblings) {
        if (sibling !== focusable) {
          sibling.tabIndex = -1;
        }
      }
      return;
    }
    for (const sibling of siblings) {
      sibling.tabIndex = 0;
    }
  }
}
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a$3;
const CHECKED = Symbol("checked");
let maskId = 0;
const radioBaseClass = mixinConstraintValidation(mixinFormAssociated(mixinElementInternals(mixinFocusable(s$1))));
class Radio extends radioBaseClass {
  /**
   * Whether or not the radio is selected.
   */
  get checked() {
    return this[CHECKED];
  }
  set checked(checked) {
    const wasChecked = this.checked;
    if (wasChecked === checked) {
      return;
    }
    this[CHECKED] = checked;
    this.requestUpdate("checked", wasChecked);
    this.selectionController.handleCheckedChange();
  }
  constructor() {
    super();
    this.maskId = `cutout${++maskId}`;
    this[_a$3] = false;
    this.required = false;
    this.value = "on";
    this.selectionController = new SingleSelectionController(this);
    this.addController(this.selectionController);
    {
      this[internals].role = "radio";
      this.addEventListener("click", this.handleClick.bind(this));
      this.addEventListener("keydown", this.handleKeydown.bind(this));
    }
  }
  render() {
    const classes = { "checked": this.checked };
    return x$1`
      <div class="container ${e$1(classes)}" aria-hidden="true">
        <md-ripple
          part="ripple"
          .control=${this}
          ?disabled=${this.disabled}></md-ripple>
        <md-focus-ring part="focus-ring" .control=${this}></md-focus-ring>
        <svg class="icon" viewBox="0 0 20 20">
          <mask id="${this.maskId}">
            <rect width="100%" height="100%" fill="white" />
            <circle cx="10" cy="10" r="8" fill="black" />
          </mask>
          <circle
            class="outer circle"
            cx="10"
            cy="10"
            r="10"
            mask="url(#${this.maskId})" />
          <circle class="inner circle" cx="10" cy="10" r="5" />
        </svg>

        <div class="touch-target"></div>
      </div>
    `;
  }
  updated() {
    this[internals].ariaChecked = String(this.checked);
  }
  async handleClick(event) {
    if (this.disabled) {
      return;
    }
    await 0;
    if (event.defaultPrevented) {
      return;
    }
    if (isActivationClick(event)) {
      this.focus();
    }
    this.checked = true;
    this.dispatchEvent(new Event("change", { bubbles: true }));
    this.dispatchEvent(new InputEvent("input", { bubbles: true, composed: true }));
  }
  async handleKeydown(event) {
    await 0;
    if (event.key !== " " || event.defaultPrevented) {
      return;
    }
    this.click();
  }
  [(_a$3 = CHECKED, getFormValue)]() {
    return this.checked ? this.value : null;
  }
  [getFormState]() {
    return String(this.checked);
  }
  formResetCallback() {
    this.checked = this.hasAttribute("checked");
  }
  formStateRestoreCallback(state) {
    this.checked = state === "true";
  }
  [createValidator]() {
    return new RadioValidator(() => {
      if (!this.selectionController) {
        return [this];
      }
      return this.selectionController.controls;
    });
  }
  [getValidityAnchor]() {
    return this.container;
  }
}
__decorate([
  n$5({ type: Boolean })
], Radio.prototype, "checked", null);
__decorate([
  n$5({ type: Boolean })
], Radio.prototype, "required", void 0);
__decorate([
  n$5()
], Radio.prototype, "value", void 0);
__decorate([
  e$5(".container")
], Radio.prototype, "container", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$d = i$4`@layer{:host{display:inline-flex;height:var(--md-radio-icon-size, 20px);outline:none;position:relative;vertical-align:top;width:var(--md-radio-icon-size, 20px);-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer;--md-ripple-hover-color: var(--md-radio-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-hover-opacity: var(--md-radio-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-radio-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-pressed-opacity: var(--md-radio-pressed-state-layer-opacity, 0.12)}:host([disabled]){cursor:default}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--md-radio-icon-size, 20px))/2)}.container{display:flex;height:100%;place-content:center;place-items:center;width:100%}md-focus-ring{height:44px;inset:unset;width:44px}.checked{--md-ripple-hover-color: var(--md-radio-selected-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-hover-opacity: var(--md-radio-selected-hover-state-layer-opacity, 0.08);--md-ripple-pressed-color: var(--md-radio-selected-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-pressed-opacity: var(--md-radio-selected-pressed-state-layer-opacity, 0.12)}.touch-target{height:48px;position:absolute;width:48px}:host([touch-target=none]) .touch-target{display:none}md-ripple{border-radius:50%;height:var(--md-radio-state-layer-size, 40px);inset:unset;width:var(--md-radio-state-layer-size, 40px)}.icon{fill:var(--md-radio-icon-color, var(--md-sys-color-on-surface-variant, #49454f));inset:0;position:absolute}.outer.circle{transition:fill 50ms linear}.inner.circle{opacity:0;transform-origin:center;transition:opacity 50ms linear}.checked .icon{fill:var(--md-radio-selected-icon-color, var(--md-sys-color-primary, #6750a4))}.checked .inner.circle{animation:inner-circle-grow 300ms cubic-bezier(0.05, 0.7, 0.1, 1);opacity:1}@keyframes inner-circle-grow{from{transform:scale(0)}to{transform:scale(1)}}:host([disabled]) .circle{animation-duration:0s;transition-duration:0s}:host(:hover) .icon{fill:var(--md-radio-hover-icon-color, var(--md-sys-color-on-surface, #1d1b20))}:host(:focus-within) .icon{fill:var(--md-radio-focus-icon-color, var(--md-sys-color-on-surface, #1d1b20))}:host(:active) .icon{fill:var(--md-radio-pressed-icon-color, var(--md-sys-color-on-surface, #1d1b20))}:host([disabled]) .icon{fill:var(--md-radio-disabled-unselected-icon-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-radio-disabled-unselected-icon-opacity, 0.38)}:host(:hover) .checked .icon{fill:var(--md-radio-selected-hover-icon-color, var(--md-sys-color-primary, #6750a4))}:host(:focus-within) .checked .icon{fill:var(--md-radio-selected-focus-icon-color, var(--md-sys-color-primary, #6750a4))}:host(:active) .checked .icon{fill:var(--md-radio-selected-pressed-icon-color, var(--md-sys-color-primary, #6750a4))}:host([disabled]) .checked .icon{fill:var(--md-radio-disabled-selected-icon-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-radio-disabled-selected-icon-opacity, 0.38)}}@layer hcm{@media(forced-colors: active){.icon{fill:CanvasText}:host([disabled]) .icon{fill:GrayText;opacity:1}}}
`;
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdRadio = class MdRadio2 extends Radio {
};
MdRadio.styles = [styles$d];
MdRadio = __decorate([
  t$3("md-radio")
], MdRadio);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const onReportValidity = Symbol("onReportValidity");
const privateCleanupFormListeners = Symbol("privateCleanupFormListeners");
const privateDoNotReportInvalid = Symbol("privateDoNotReportInvalid");
const privateIsSelfReportingValidity = Symbol("privateIsSelfReportingValidity");
const privateCallOnReportValidity = Symbol("privateCallOnReportValidity");
function mixinOnReportValidity(base) {
  var _a2, _b2, _c2;
  class OnReportValidityElement extends base {
    // Mixins must have a constructor with `...args: any[]`
    // tslint:disable-next-line:no-any
    constructor(...args) {
      super(...args);
      this[_a2] = new AbortController();
      this[_b2] = false;
      this[_c2] = false;
      this.addEventListener("invalid", (invalidEvent) => {
        if (this[privateDoNotReportInvalid] || !invalidEvent.isTrusted) {
          return;
        }
        this.addEventListener("invalid", () => {
          this[privateCallOnReportValidity](invalidEvent);
        }, { once: true });
      }, {
        // Listen during the capture phase, which will happen before the
        // bubbling phase. That way, we can add a final event listener that
        // will run after other event listeners, and we can check if it was
        // default prevented. This works because invalid does not bubble.
        capture: true
      });
    }
    checkValidity() {
      this[privateDoNotReportInvalid] = true;
      const valid = super.checkValidity();
      this[privateDoNotReportInvalid] = false;
      return valid;
    }
    reportValidity() {
      this[privateIsSelfReportingValidity] = true;
      const valid = super.reportValidity();
      if (valid) {
        this[privateCallOnReportValidity](null);
      }
      this[privateIsSelfReportingValidity] = false;
      return valid;
    }
    [(_a2 = privateCleanupFormListeners, _b2 = privateDoNotReportInvalid, _c2 = privateIsSelfReportingValidity, privateCallOnReportValidity)](invalidEvent) {
      const wasCanceled = invalidEvent?.defaultPrevented;
      if (wasCanceled) {
        return;
      }
      this[onReportValidity](invalidEvent);
      const implementationCanceledFocus = !wasCanceled && invalidEvent?.defaultPrevented;
      if (!implementationCanceledFocus) {
        return;
      }
      if (this[privateIsSelfReportingValidity] || isFirstInvalidControlInForm(this[internals].form, this)) {
        this.focus();
      }
    }
    [onReportValidity](invalidEvent) {
      throw new Error("Implement [onReportValidity]");
    }
    formAssociatedCallback(form) {
      if (super.formAssociatedCallback) {
        super.formAssociatedCallback(form);
      }
      this[privateCleanupFormListeners].abort();
      if (!form) {
        return;
      }
      this[privateCleanupFormListeners] = new AbortController();
      addFormReportValidListener(this, form, () => {
        this[privateCallOnReportValidity](null);
      }, this[privateCleanupFormListeners].signal);
    }
  }
  return OnReportValidityElement;
}
function addFormReportValidListener(control, form, onControlValid, cleanup) {
  const validateHooks = getFormValidateHooks(form);
  let controlFiredInvalid = false;
  let cleanupInvalidListener;
  let isNextSubmitFromHook = false;
  validateHooks.addEventListener("before", () => {
    isNextSubmitFromHook = true;
    cleanupInvalidListener = new AbortController();
    controlFiredInvalid = false;
    control.addEventListener("invalid", () => {
      controlFiredInvalid = true;
    }, {
      signal: cleanupInvalidListener.signal
    });
  }, { signal: cleanup });
  validateHooks.addEventListener("after", () => {
    isNextSubmitFromHook = false;
    cleanupInvalidListener?.abort();
    if (controlFiredInvalid) {
      return;
    }
    onControlValid();
  }, { signal: cleanup });
  form.addEventListener("submit", () => {
    if (isNextSubmitFromHook) {
      return;
    }
    onControlValid();
  }, {
    signal: cleanup
  });
}
const FORM_VALIDATE_HOOKS = /* @__PURE__ */ new WeakMap();
function getFormValidateHooks(form) {
  if (!FORM_VALIDATE_HOOKS.has(form)) {
    const hooks = new EventTarget();
    FORM_VALIDATE_HOOKS.set(form, hooks);
    for (const methodName of ["reportValidity", "requestSubmit"]) {
      const superMethod = form[methodName];
      form[methodName] = function() {
        hooks.dispatchEvent(new Event("before"));
        const result = Reflect.apply(superMethod, this, arguments);
        hooks.dispatchEvent(new Event("after"));
        return result;
      };
    }
  }
  return FORM_VALIDATE_HOOKS.get(form);
}
function isFirstInvalidControlInForm(form, control) {
  if (!form) {
    return true;
  }
  let firstInvalidControl;
  for (const element of form.elements) {
    if (element.matches(":invalid")) {
      firstInvalidControl = element;
      break;
    }
  }
  return firstInvalidControl === control;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class SelectValidator extends Validator {
  computeValidity(state) {
    if (!this.selectControl) {
      this.selectControl = document.createElement("select");
    }
    j$1(x$1`<option value=${state.value}></option>`, this.selectControl);
    this.selectControl.value = state.value;
    this.selectControl.required = state.required;
    return {
      validity: this.selectControl.validity,
      validationMessage: this.selectControl.validationMessage
    };
  }
  equals(prev, next) {
    return prev.value === next.value && prev.required === next.required;
  }
  copy({ value, required }) {
    return { value, required };
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function getSelectedItems(items) {
  const selectedItemRecords = [];
  for (let i3 = 0; i3 < items.length; i3++) {
    const item = items[i3];
    if (item.selected) {
      selectedItemRecords.push([item, i3]);
    }
  }
  return selectedItemRecords;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a$2;
const VALUE = Symbol("value");
const selectBaseClass = mixinDelegatesAria(mixinOnReportValidity(mixinConstraintValidation(mixinFormAssociated(mixinElementInternals(s$1)))));
class Select extends selectBaseClass {
  /**
   * The value of the currently selected option.
   *
   * Note: For SSR, set `[selected]` on the requested option and `displayText`
   * rather than setting `value` setting `value` will incur a DOM query.
   */
  get value() {
    return this[VALUE];
  }
  set value(value) {
    this.lastUserSetValue = value;
    this.select(value);
  }
  get options() {
    return this.menu?.items ?? [];
  }
  /**
   * The index of the currently selected option.
   *
   * Note: For SSR, set `[selected]` on the requested option and `displayText`
   * rather than setting `selectedIndex` setting `selectedIndex` will incur a
   * DOM query.
   */
  get selectedIndex() {
    const [_option, index] = (this.getSelectedOptions() ?? [])[0] ?? [];
    return index ?? -1;
  }
  set selectedIndex(index) {
    this.lastUserSetSelectedIndex = index;
    this.selectIndex(index);
  }
  /**
   * Returns an array of selected options.
   *
   * NOTE: md-select only supports single selection.
   */
  get selectedOptions() {
    return (this.getSelectedOptions() ?? []).map(([option]) => option);
  }
  get hasError() {
    return this.error || this.nativeError;
  }
  constructor() {
    super();
    this.quick = false;
    this.required = false;
    this.errorText = "";
    this.label = "";
    this.noAsterisk = false;
    this.supportingText = "";
    this.error = false;
    this.menuPositioning = "popover";
    this.clampMenuWidth = false;
    this.typeaheadDelay = DEFAULT_TYPEAHEAD_BUFFER_TIME;
    this.hasLeadingIcon = false;
    this.displayText = "";
    this.menuAlign = "start";
    this[_a$2] = "";
    this.lastUserSetValue = null;
    this.lastUserSetSelectedIndex = null;
    this.lastSelectedOption = null;
    this.lastSelectedOptionRecords = [];
    this.nativeError = false;
    this.nativeErrorText = "";
    this.focused = false;
    this.open = false;
    this.defaultFocus = FocusState.NONE;
    this.prevOpen = this.open;
    this.selectWidth = 0;
    this.addEventListener("focus", this.handleFocus.bind(this));
    this.addEventListener("blur", this.handleBlur.bind(this));
  }
  /**
   * Selects an option given the value of the option, and updates MdSelect's
   * value.
   */
  select(value) {
    const optionToSelect = this.options.find((option) => option.value === value);
    if (optionToSelect) {
      this.selectItem(optionToSelect);
    }
  }
  /**
   * Selects an option given the index of the option, and updates MdSelect's
   * value.
   */
  selectIndex(index) {
    const optionToSelect = this.options[index];
    if (optionToSelect) {
      this.selectItem(optionToSelect);
    }
  }
  /**
   * Reset the select to its default value.
   */
  reset() {
    for (const option of this.options) {
      option.selected = option.hasAttribute("selected");
    }
    this.updateValueAndDisplayText();
    this.nativeError = false;
    this.nativeErrorText = "";
  }
  [(_a$2 = VALUE, onReportValidity)](invalidEvent) {
    invalidEvent?.preventDefault();
    const prevMessage = this.getErrorText();
    this.nativeError = !!invalidEvent;
    this.nativeErrorText = this.validationMessage;
    if (prevMessage === this.getErrorText()) {
      this.field?.reannounceError();
    }
  }
  update(changed) {
    if (!this.hasUpdated) {
      this.initUserSelection();
    }
    if (this.prevOpen !== this.open && this.open) {
      const selectRect = this.getBoundingClientRect();
      this.selectWidth = selectRect.width;
    }
    this.prevOpen = this.open;
    super.update(changed);
  }
  render() {
    return x$1`
      <span
        class="select ${e$1(this.getRenderClasses())}"
        @focusout=${this.handleFocusout}>
        ${this.renderField()} ${this.renderMenu()}
      </span>
    `;
  }
  async firstUpdated(changed) {
    await this.menu?.updateComplete;
    if (!this.lastSelectedOptionRecords.length) {
      this.initUserSelection();
    }
    if (!this.lastSelectedOptionRecords.length && !o$2 && !this.options.length) {
      setTimeout(() => {
        this.updateValueAndDisplayText();
      });
    }
    super.firstUpdated(changed);
  }
  getRenderClasses() {
    return {
      "disabled": this.disabled,
      "error": this.error,
      "open": this.open
    };
  }
  renderField() {
    return n$2`
      <${this.fieldTag}
          aria-haspopup="listbox"
          role="combobox"
          part="field"
          id="field"
          tabindex=${this.disabled ? "-1" : "0"}
          aria-label=${this.ariaLabel || T$1}
          aria-describedby="description"
          aria-expanded=${this.open ? "true" : "false"}
          aria-controls="listbox"
          class="field"
          label=${this.label}
          ?no-asterisk=${this.noAsterisk}
          .focused=${this.focused || this.open}
          .populated=${!!this.displayText}
          .disabled=${this.disabled}
          .required=${this.required}
          .error=${this.hasError}
          ?has-start=${this.hasLeadingIcon}
          has-end
          supporting-text=${this.supportingText}
          error-text=${this.getErrorText()}
          @keydown=${this.handleKeydown}
          @click=${this.handleClick}>
         ${this.renderFieldContent()}
         <div id="description" slot="aria-describedby"></div>
      </${this.fieldTag}>`;
  }
  renderFieldContent() {
    return [
      this.renderLeadingIcon(),
      this.renderLabel(),
      this.renderTrailingIcon()
    ];
  }
  renderLeadingIcon() {
    return x$1`
      <span class="icon leading" slot="start">
        <slot name="leading-icon" @slotchange=${this.handleIconChange}></slot>
      </span>
    `;
  }
  renderTrailingIcon() {
    return x$1`
      <span class="icon trailing" slot="end">
        <slot name="trailing-icon" @slotchange=${this.handleIconChange}>
          <svg height="5" viewBox="7 10 10 5" focusable="false">
            <polygon
              class="down"
              stroke="none"
              fill-rule="evenodd"
              points="7 10 12 15 17 10"></polygon>
            <polygon
              class="up"
              stroke="none"
              fill-rule="evenodd"
              points="7 15 12 10 17 15"></polygon>
          </svg>
        </slot>
      </span>
    `;
  }
  renderLabel() {
    return x$1`<div id="label">${this.displayText || x$1`&nbsp;`}</div>`;
  }
  renderMenu() {
    const ariaLabel = this.label || this.ariaLabel;
    return x$1`<div class="menu-wrapper">
      <md-menu
        id="listbox"
        .defaultFocus=${this.defaultFocus}
        role="listbox"
        tabindex="-1"
        aria-label=${ariaLabel || T$1}
        stay-open-on-focusout
        part="menu"
        exportparts="focus-ring: menu-focus-ring"
        anchor="field"
        style=${o({
      "--__menu-min-width": `${this.selectWidth}px`,
      "--__menu-max-width": this.clampMenuWidth ? `${this.selectWidth}px` : void 0
    })}
        no-navigation-wrap
        .open=${this.open}
        .quick=${this.quick}
        .positioning=${this.menuPositioning}
        .typeaheadDelay=${this.typeaheadDelay}
        .anchorCorner=${this.menuAlign === "start" ? "end-start" : "end-end"}
        .menuCorner=${this.menuAlign === "start" ? "start-start" : "start-end"}
        @opening=${this.handleOpening}
        @opened=${this.redispatchEvent}
        @closing=${this.redispatchEvent}
        @closed=${this.handleClosed}
        @close-menu=${this.handleCloseMenu}
        @request-selection=${this.handleRequestSelection}
        @request-deselection=${this.handleRequestDeselection}>
        ${this.renderMenuContent()}
      </md-menu>
    </div>`;
  }
  renderMenuContent() {
    return x$1`<slot></slot>`;
  }
  /**
   * Handles opening the select on keydown and typahead selection when the menu
   * is closed.
   */
  handleKeydown(event) {
    if (this.open || this.disabled || !this.menu) {
      return;
    }
    const typeaheadController = this.menu.typeaheadController;
    const isOpenKey = event.code === "Space" || event.code === "ArrowDown" || event.code === "ArrowUp" || event.code === "End" || event.code === "Home" || event.code === "Enter";
    if (!typeaheadController.isTypingAhead && isOpenKey) {
      event.preventDefault();
      this.open = true;
      switch (event.code) {
        case "Space":
        case "ArrowDown":
        case "Enter":
          this.defaultFocus = FocusState.NONE;
          break;
        case "End":
          this.defaultFocus = FocusState.LAST_ITEM;
          break;
        case "ArrowUp":
        case "Home":
          this.defaultFocus = FocusState.FIRST_ITEM;
          break;
      }
      return;
    }
    const isPrintableKey = event.key.length === 1;
    if (isPrintableKey) {
      typeaheadController.onKeydown(event);
      event.preventDefault();
      const { lastActiveRecord } = typeaheadController;
      if (!lastActiveRecord) {
        return;
      }
      this.labelEl?.setAttribute?.("aria-live", "polite");
      const hasChanged = this.selectItem(lastActiveRecord[TYPEAHEAD_RECORD.ITEM]);
      if (hasChanged) {
        this.dispatchInteractionEvents();
      }
    }
  }
  handleClick() {
    this.open = !this.open;
  }
  handleFocus() {
    this.focused = true;
  }
  handleBlur() {
    this.focused = false;
  }
  /**
   * Handles closing the menu when the focus leaves the select's subtree.
   */
  handleFocusout(event) {
    if (event.relatedTarget && isElementInSubtree(event.relatedTarget, this)) {
      return;
    }
    this.open = false;
  }
  /**
   * Gets a list of all selected select options as a list item record array.
   *
   * @return An array of selected list option records.
   */
  getSelectedOptions() {
    if (!this.menu) {
      this.lastSelectedOptionRecords = [];
      return null;
    }
    const items = this.menu.items;
    this.lastSelectedOptionRecords = getSelectedItems(items);
    return this.lastSelectedOptionRecords;
  }
  async getUpdateComplete() {
    await this.menu?.updateComplete;
    return super.getUpdateComplete();
  }
  /**
   * Gets the selected options from the DOM, and updates the value and display
   * text to the first selected option's value and headline respectively.
   *
   * @return Whether or not the selected option has changed since last update.
   */
  updateValueAndDisplayText() {
    const selectedOptions = this.getSelectedOptions() ?? [];
    let hasSelectedOptionChanged = false;
    if (selectedOptions.length) {
      const [firstSelectedOption] = selectedOptions[0];
      hasSelectedOptionChanged = this.lastSelectedOption !== firstSelectedOption;
      this.lastSelectedOption = firstSelectedOption;
      this[VALUE] = firstSelectedOption.value;
      this.displayText = firstSelectedOption.displayText;
    } else {
      hasSelectedOptionChanged = this.lastSelectedOption !== null;
      this.lastSelectedOption = null;
      this[VALUE] = "";
      this.displayText = "";
    }
    return hasSelectedOptionChanged;
  }
  /**
   * Focuses and activates the last selected item upon opening, and resets other
   * active items.
   */
  async handleOpening(e2) {
    this.labelEl?.removeAttribute?.("aria-live");
    this.redispatchEvent(e2);
    if (this.defaultFocus !== FocusState.NONE) {
      return;
    }
    const items = this.menu.items;
    const activeItem = getActiveItem(items)?.item;
    let [selectedItem] = this.lastSelectedOptionRecords[0] ?? [null];
    if (activeItem && activeItem !== selectedItem) {
      activeItem.tabIndex = -1;
    }
    selectedItem = selectedItem ?? items[0];
    if (selectedItem) {
      selectedItem.tabIndex = 0;
      selectedItem.focus();
    }
  }
  redispatchEvent(e2) {
    redispatchEvent(this, e2);
  }
  handleClosed(e2) {
    this.open = false;
    this.redispatchEvent(e2);
  }
  /**
   * Determines the reason for closing, and updates the UI accordingly.
   */
  handleCloseMenu(event) {
    const reason = event.detail.reason;
    const item = event.detail.itemPath[0];
    this.open = false;
    let hasChanged = false;
    if (reason.kind === "click-selection") {
      hasChanged = this.selectItem(item);
    } else if (reason.kind === "keydown" && isSelectableKey(reason.key)) {
      hasChanged = this.selectItem(item);
    } else {
      item.tabIndex = -1;
      item.blur();
    }
    if (hasChanged) {
      this.dispatchInteractionEvents();
    }
  }
  /**
   * Selects a given option, deselects other options, and updates the UI.
   *
   * @return Whether the last selected option has changed.
   */
  selectItem(item) {
    const selectedOptions = this.getSelectedOptions() ?? [];
    selectedOptions.forEach(([option]) => {
      if (item !== option) {
        option.selected = false;
      }
    });
    item.selected = true;
    return this.updateValueAndDisplayText();
  }
  /**
   * Handles updating selection when an option element requests selection via
   * property / attribute change.
   */
  handleRequestSelection(event) {
    const requestingOptionEl = event.target;
    if (this.lastSelectedOptionRecords.some(([option]) => option === requestingOptionEl)) {
      return;
    }
    this.selectItem(requestingOptionEl);
  }
  /**
   * Handles updating selection when an option element requests deselection via
   * property / attribute change.
   */
  handleRequestDeselection(event) {
    const requestingOptionEl = event.target;
    if (!this.lastSelectedOptionRecords.some(([option]) => option === requestingOptionEl)) {
      return;
    }
    this.updateValueAndDisplayText();
  }
  /**
   * Attempts to initialize the selected option from user-settable values like
   * SSR, setting `value`, or `selectedIndex` at startup.
   */
  initUserSelection() {
    if (this.lastUserSetValue && !this.lastSelectedOptionRecords.length) {
      this.select(this.lastUserSetValue);
    } else if (this.lastUserSetSelectedIndex !== null && !this.lastSelectedOptionRecords.length) {
      this.selectIndex(this.lastUserSetSelectedIndex);
    } else {
      this.updateValueAndDisplayText();
    }
  }
  handleIconChange() {
    this.hasLeadingIcon = this.leadingIcons.length > 0;
  }
  /**
   * Dispatches the `input` and `change` events.
   */
  dispatchInteractionEvents() {
    this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    this.dispatchEvent(new Event("change", { bubbles: true }));
  }
  getErrorText() {
    return this.error ? this.errorText : this.nativeErrorText;
  }
  [getFormValue]() {
    return this.value;
  }
  formResetCallback() {
    this.reset();
  }
  formStateRestoreCallback(state) {
    this.value = state;
  }
  click() {
    this.field?.click();
  }
  [createValidator]() {
    return new SelectValidator(() => this);
  }
  [getValidityAnchor]() {
    return this.field;
  }
}
Select.shadowRootOptions = {
  ...s$1.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean })
], Select.prototype, "quick", void 0);
__decorate([
  n$5({ type: Boolean })
], Select.prototype, "required", void 0);
__decorate([
  n$5({ type: String, attribute: "error-text" })
], Select.prototype, "errorText", void 0);
__decorate([
  n$5()
], Select.prototype, "label", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-asterisk" })
], Select.prototype, "noAsterisk", void 0);
__decorate([
  n$5({ type: String, attribute: "supporting-text" })
], Select.prototype, "supportingText", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], Select.prototype, "error", void 0);
__decorate([
  n$5({ attribute: "menu-positioning" })
], Select.prototype, "menuPositioning", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "clamp-menu-width" })
], Select.prototype, "clampMenuWidth", void 0);
__decorate([
  n$5({ type: Number, attribute: "typeahead-delay" })
], Select.prototype, "typeaheadDelay", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-leading-icon" })
], Select.prototype, "hasLeadingIcon", void 0);
__decorate([
  n$5({ attribute: "display-text" })
], Select.prototype, "displayText", void 0);
__decorate([
  n$5({ attribute: "menu-align" })
], Select.prototype, "menuAlign", void 0);
__decorate([
  n$5()
], Select.prototype, "value", null);
__decorate([
  n$5({ type: Number, attribute: "selected-index" })
], Select.prototype, "selectedIndex", null);
__decorate([
  r$4()
], Select.prototype, "nativeError", void 0);
__decorate([
  r$4()
], Select.prototype, "nativeErrorText", void 0);
__decorate([
  r$4()
], Select.prototype, "focused", void 0);
__decorate([
  r$4()
], Select.prototype, "open", void 0);
__decorate([
  r$4()
], Select.prototype, "defaultFocus", void 0);
__decorate([
  e$5(".field")
], Select.prototype, "field", void 0);
__decorate([
  e$5("md-menu")
], Select.prototype, "menu", void 0);
__decorate([
  e$5("#label")
], Select.prototype, "labelEl", void 0);
__decorate([
  o$4({ slot: "leading-icon", flatten: true })
], Select.prototype, "leadingIcons", void 0);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class FilledSelect extends Select {
  constructor() {
    super(...arguments);
    this.fieldTag = s2`md-filled-field`;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$c = i$4`:host{--_text-field-active-indicator-color: var(--md-filled-select-text-field-active-indicator-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-active-indicator-height: var(--md-filled-select-text-field-active-indicator-height, 1px);--_text-field-container-color: var(--md-filled-select-text-field-container-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_text-field-disabled-active-indicator-color: var(--md-filled-select-text-field-disabled-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-active-indicator-height: var(--md-filled-select-text-field-disabled-active-indicator-height, 1px);--_text-field-disabled-active-indicator-opacity: var(--md-filled-select-text-field-disabled-active-indicator-opacity, 0.38);--_text-field-disabled-container-color: var(--md-filled-select-text-field-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-container-opacity: var(--md-filled-select-text-field-disabled-container-opacity, 0.04);--_text-field-disabled-input-text-color: var(--md-filled-select-text-field-disabled-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-input-text-opacity: var(--md-filled-select-text-field-disabled-input-text-opacity, 0.38);--_text-field-disabled-label-text-color: var(--md-filled-select-text-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-label-text-opacity: var(--md-filled-select-text-field-disabled-label-text-opacity, 0.38);--_text-field-disabled-leading-icon-color: var(--md-filled-select-text-field-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-leading-icon-opacity: var(--md-filled-select-text-field-disabled-leading-icon-opacity, 0.38);--_text-field-disabled-supporting-text-color: var(--md-filled-select-text-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-supporting-text-opacity: var(--md-filled-select-text-field-disabled-supporting-text-opacity, 0.38);--_text-field-disabled-trailing-icon-color: var(--md-filled-select-text-field-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-trailing-icon-opacity: var(--md-filled-select-text-field-disabled-trailing-icon-opacity, 0.38);--_text-field-error-active-indicator-color: var(--md-filled-select-text-field-error-active-indicator-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-active-indicator-color: var(--md-filled-select-text-field-error-focus-active-indicator-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-input-text-color: var(--md-filled-select-text-field-error-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-focus-label-text-color: var(--md-filled-select-text-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-leading-icon-color: var(--md-filled-select-text-field-error-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-focus-supporting-text-color: var(--md-filled-select-text-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-trailing-icon-color: var(--md-filled-select-text-field-error-focus-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_text-field-error-hover-active-indicator-color: var(--md-filled-select-text-field-error-hover-active-indicator-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-hover-input-text-color: var(--md-filled-select-text-field-error-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-hover-label-text-color: var(--md-filled-select-text-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-hover-leading-icon-color: var(--md-filled-select-text-field-error-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-hover-state-layer-color: var(--md-filled-select-text-field-error-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-hover-state-layer-opacity: var(--md-filled-select-text-field-error-hover-state-layer-opacity, 0.08);--_text-field-error-hover-supporting-text-color: var(--md-filled-select-text-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-hover-trailing-icon-color: var(--md-filled-select-text-field-error-hover-trailing-icon-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-input-text-color: var(--md-filled-select-text-field-error-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-label-text-color: var(--md-filled-select-text-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-leading-icon-color: var(--md-filled-select-text-field-error-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-supporting-text-color: var(--md-filled-select-text-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-trailing-icon-color: var(--md-filled-select-text-field-error-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_text-field-focus-active-indicator-color: var(--md-filled-select-text-field-focus-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_text-field-focus-active-indicator-height: var(--md-filled-select-text-field-focus-active-indicator-height, 3px);--_text-field-focus-input-text-color: var(--md-filled-select-text-field-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-focus-label-text-color: var(--md-filled-select-text-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_text-field-focus-leading-icon-color: var(--md-filled-select-text-field-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-focus-supporting-text-color: var(--md-filled-select-text-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-focus-trailing-icon-color: var(--md-filled-select-text-field-focus-trailing-icon-color, var(--md-sys-color-primary, #6750a4));--_text-field-hover-active-indicator-color: var(--md-filled-select-text-field-hover-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-active-indicator-height: var(--md-filled-select-text-field-hover-active-indicator-height, 1px);--_text-field-hover-input-text-color: var(--md-filled-select-text-field-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-label-text-color: var(--md-filled-select-text-field-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-leading-icon-color: var(--md-filled-select-text-field-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-hover-state-layer-color: var(--md-filled-select-text-field-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-state-layer-opacity: var(--md-filled-select-text-field-hover-state-layer-opacity, 0.08);--_text-field-hover-supporting-text-color: var(--md-filled-select-text-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-hover-trailing-icon-color: var(--md-filled-select-text-field-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-input-text-color: var(--md-filled-select-text-field-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-input-text-font: var(--md-filled-select-text-field-input-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-input-text-line-height: var(--md-filled-select-text-field-input-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_text-field-input-text-size: var(--md-filled-select-text-field-input-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_text-field-input-text-weight: var(--md-filled-select-text-field-input-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-label-text-color: var(--md-filled-select-text-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-label-text-font: var(--md-filled-select-text-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-label-text-line-height: var(--md-filled-select-text-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_text-field-label-text-populated-line-height: var(--md-filled-select-text-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_text-field-label-text-populated-size: var(--md-filled-select-text-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_text-field-label-text-size: var(--md-filled-select-text-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_text-field-label-text-weight: var(--md-filled-select-text-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-leading-icon-color: var(--md-filled-select-text-field-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-leading-icon-size: var(--md-filled-select-text-field-leading-icon-size, 24px);--_text-field-supporting-text-color: var(--md-filled-select-text-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-supporting-text-font: var(--md-filled-select-text-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-supporting-text-line-height: var(--md-filled-select-text-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_text-field-supporting-text-size: var(--md-filled-select-text-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_text-field-supporting-text-weight: var(--md-filled-select-text-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-trailing-icon-color: var(--md-filled-select-text-field-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-trailing-icon-size: var(--md-filled-select-text-field-trailing-icon-size, 24px);--_text-field-container-shape-start-start: var(--md-filled-select-text-field-container-shape-start-start, var(--md-filled-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_text-field-container-shape-start-end: var(--md-filled-select-text-field-container-shape-start-end, var(--md-filled-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_text-field-container-shape-end-end: var(--md-filled-select-text-field-container-shape-end-end, var(--md-filled-select-text-field-container-shape, var(--md-sys-shape-corner-none, 0px)));--_text-field-container-shape-end-start: var(--md-filled-select-text-field-container-shape-end-start, var(--md-filled-select-text-field-container-shape, var(--md-sys-shape-corner-none, 0px)));--md-filled-field-active-indicator-color: var(--_text-field-active-indicator-color);--md-filled-field-active-indicator-height: var(--_text-field-active-indicator-height);--md-filled-field-container-color: var(--_text-field-container-color);--md-filled-field-container-shape-end-end: var(--_text-field-container-shape-end-end);--md-filled-field-container-shape-end-start: var(--_text-field-container-shape-end-start);--md-filled-field-container-shape-start-end: var(--_text-field-container-shape-start-end);--md-filled-field-container-shape-start-start: var(--_text-field-container-shape-start-start);--md-filled-field-content-color: var(--_text-field-input-text-color);--md-filled-field-content-font: var(--_text-field-input-text-font);--md-filled-field-content-line-height: var(--_text-field-input-text-line-height);--md-filled-field-content-size: var(--_text-field-input-text-size);--md-filled-field-content-weight: var(--_text-field-input-text-weight);--md-filled-field-disabled-active-indicator-color: var(--_text-field-disabled-active-indicator-color);--md-filled-field-disabled-active-indicator-height: var(--_text-field-disabled-active-indicator-height);--md-filled-field-disabled-active-indicator-opacity: var(--_text-field-disabled-active-indicator-opacity);--md-filled-field-disabled-container-color: var(--_text-field-disabled-container-color);--md-filled-field-disabled-container-opacity: var(--_text-field-disabled-container-opacity);--md-filled-field-disabled-content-color: var(--_text-field-disabled-input-text-color);--md-filled-field-disabled-content-opacity: var(--_text-field-disabled-input-text-opacity);--md-filled-field-disabled-label-text-color: var(--_text-field-disabled-label-text-color);--md-filled-field-disabled-label-text-opacity: var(--_text-field-disabled-label-text-opacity);--md-filled-field-disabled-leading-content-color: var(--_text-field-disabled-leading-icon-color);--md-filled-field-disabled-leading-content-opacity: var(--_text-field-disabled-leading-icon-opacity);--md-filled-field-disabled-supporting-text-color: var(--_text-field-disabled-supporting-text-color);--md-filled-field-disabled-supporting-text-opacity: var(--_text-field-disabled-supporting-text-opacity);--md-filled-field-disabled-trailing-content-color: var(--_text-field-disabled-trailing-icon-color);--md-filled-field-disabled-trailing-content-opacity: var(--_text-field-disabled-trailing-icon-opacity);--md-filled-field-error-active-indicator-color: var(--_text-field-error-active-indicator-color);--md-filled-field-error-content-color: var(--_text-field-error-input-text-color);--md-filled-field-error-focus-active-indicator-color: var(--_text-field-error-focus-active-indicator-color);--md-filled-field-error-focus-content-color: var(--_text-field-error-focus-input-text-color);--md-filled-field-error-focus-label-text-color: var(--_text-field-error-focus-label-text-color);--md-filled-field-error-focus-leading-content-color: var(--_text-field-error-focus-leading-icon-color);--md-filled-field-error-focus-supporting-text-color: var(--_text-field-error-focus-supporting-text-color);--md-filled-field-error-focus-trailing-content-color: var(--_text-field-error-focus-trailing-icon-color);--md-filled-field-error-hover-active-indicator-color: var(--_text-field-error-hover-active-indicator-color);--md-filled-field-error-hover-content-color: var(--_text-field-error-hover-input-text-color);--md-filled-field-error-hover-label-text-color: var(--_text-field-error-hover-label-text-color);--md-filled-field-error-hover-leading-content-color: var(--_text-field-error-hover-leading-icon-color);--md-filled-field-error-hover-state-layer-color: var(--_text-field-error-hover-state-layer-color);--md-filled-field-error-hover-state-layer-opacity: var(--_text-field-error-hover-state-layer-opacity);--md-filled-field-error-hover-supporting-text-color: var(--_text-field-error-hover-supporting-text-color);--md-filled-field-error-hover-trailing-content-color: var(--_text-field-error-hover-trailing-icon-color);--md-filled-field-error-label-text-color: var(--_text-field-error-label-text-color);--md-filled-field-error-leading-content-color: var(--_text-field-error-leading-icon-color);--md-filled-field-error-supporting-text-color: var(--_text-field-error-supporting-text-color);--md-filled-field-error-trailing-content-color: var(--_text-field-error-trailing-icon-color);--md-filled-field-focus-active-indicator-color: var(--_text-field-focus-active-indicator-color);--md-filled-field-focus-active-indicator-height: var(--_text-field-focus-active-indicator-height);--md-filled-field-focus-content-color: var(--_text-field-focus-input-text-color);--md-filled-field-focus-label-text-color: var(--_text-field-focus-label-text-color);--md-filled-field-focus-leading-content-color: var(--_text-field-focus-leading-icon-color);--md-filled-field-focus-supporting-text-color: var(--_text-field-focus-supporting-text-color);--md-filled-field-focus-trailing-content-color: var(--_text-field-focus-trailing-icon-color);--md-filled-field-hover-active-indicator-color: var(--_text-field-hover-active-indicator-color);--md-filled-field-hover-active-indicator-height: var(--_text-field-hover-active-indicator-height);--md-filled-field-hover-content-color: var(--_text-field-hover-input-text-color);--md-filled-field-hover-label-text-color: var(--_text-field-hover-label-text-color);--md-filled-field-hover-leading-content-color: var(--_text-field-hover-leading-icon-color);--md-filled-field-hover-state-layer-color: var(--_text-field-hover-state-layer-color);--md-filled-field-hover-state-layer-opacity: var(--_text-field-hover-state-layer-opacity);--md-filled-field-hover-supporting-text-color: var(--_text-field-hover-supporting-text-color);--md-filled-field-hover-trailing-content-color: var(--_text-field-hover-trailing-icon-color);--md-filled-field-label-text-color: var(--_text-field-label-text-color);--md-filled-field-label-text-font: var(--_text-field-label-text-font);--md-filled-field-label-text-line-height: var(--_text-field-label-text-line-height);--md-filled-field-label-text-populated-line-height: var(--_text-field-label-text-populated-line-height);--md-filled-field-label-text-populated-size: var(--_text-field-label-text-populated-size);--md-filled-field-label-text-size: var(--_text-field-label-text-size);--md-filled-field-label-text-weight: var(--_text-field-label-text-weight);--md-filled-field-leading-content-color: var(--_text-field-leading-icon-color);--md-filled-field-supporting-text-color: var(--_text-field-supporting-text-color);--md-filled-field-supporting-text-font: var(--_text-field-supporting-text-font);--md-filled-field-supporting-text-line-height: var(--_text-field-supporting-text-line-height);--md-filled-field-supporting-text-size: var(--_text-field-supporting-text-size);--md-filled-field-supporting-text-weight: var(--_text-field-supporting-text-weight);--md-filled-field-trailing-content-color: var(--_text-field-trailing-icon-color)}[has-start] .icon.leading{font-size:var(--_text-field-leading-icon-size);height:var(--_text-field-leading-icon-size);width:var(--_text-field-leading-icon-size)}.icon.trailing{font-size:var(--_text-field-trailing-icon-size);height:var(--_text-field-trailing-icon-size);width:var(--_text-field-trailing-icon-size)}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$b = i$4`:host{color:unset;min-width:210px;display:flex}.field{cursor:default;outline:none}.select{position:relative;flex-direction:column}.icon.trailing svg,.icon ::slotted(*){fill:currentColor}.icon ::slotted(*){width:inherit;height:inherit;font-size:inherit}.icon slot{display:flex;height:100%;width:100%;align-items:center;justify-content:center}.icon.trailing :is(.up,.down){opacity:0;transition:opacity 75ms linear 75ms}.select:not(.open) .down,.select.open .up{opacity:1}.field,.select,md-menu{min-width:inherit;width:inherit;max-width:inherit;display:flex}md-menu{min-width:var(--__menu-min-width);max-width:var(--__menu-max-width, inherit)}.menu-wrapper{width:0px;height:0px;max-width:inherit}md-menu ::slotted(:not[disabled]){cursor:pointer}.field,.select{width:100%}:host{display:inline-flex}:host([disabled]){pointer-events:none}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdFilledSelect = class MdFilledSelect2 extends FilledSelect {
};
MdFilledSelect.styles = [styles$b, styles$c];
MdFilledSelect = __decorate([
  t$3("md-filled-select")
], MdFilledSelect);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class OutlinedSelect extends Select {
  constructor() {
    super(...arguments);
    this.fieldTag = s2`md-outlined-field`;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$a = i$4`:host{--_text-field-disabled-input-text-color: var(--md-outlined-select-text-field-disabled-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-input-text-opacity: var(--md-outlined-select-text-field-disabled-input-text-opacity, 0.38);--_text-field-disabled-label-text-color: var(--md-outlined-select-text-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-label-text-opacity: var(--md-outlined-select-text-field-disabled-label-text-opacity, 0.38);--_text-field-disabled-leading-icon-color: var(--md-outlined-select-text-field-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-leading-icon-opacity: var(--md-outlined-select-text-field-disabled-leading-icon-opacity, 0.38);--_text-field-disabled-outline-color: var(--md-outlined-select-text-field-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-outline-opacity: var(--md-outlined-select-text-field-disabled-outline-opacity, 0.12);--_text-field-disabled-outline-width: var(--md-outlined-select-text-field-disabled-outline-width, 1px);--_text-field-disabled-supporting-text-color: var(--md-outlined-select-text-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-supporting-text-opacity: var(--md-outlined-select-text-field-disabled-supporting-text-opacity, 0.38);--_text-field-disabled-trailing-icon-color: var(--md-outlined-select-text-field-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-disabled-trailing-icon-opacity: var(--md-outlined-select-text-field-disabled-trailing-icon-opacity, 0.38);--_text-field-error-focus-input-text-color: var(--md-outlined-select-text-field-error-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-focus-label-text-color: var(--md-outlined-select-text-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-leading-icon-color: var(--md-outlined-select-text-field-error-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-focus-outline-color: var(--md-outlined-select-text-field-error-focus-outline-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-supporting-text-color: var(--md-outlined-select-text-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-focus-trailing-icon-color: var(--md-outlined-select-text-field-error-focus-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_text-field-error-hover-input-text-color: var(--md-outlined-select-text-field-error-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-hover-label-text-color: var(--md-outlined-select-text-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-hover-leading-icon-color: var(--md-outlined-select-text-field-error-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-hover-outline-color: var(--md-outlined-select-text-field-error-hover-outline-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-hover-supporting-text-color: var(--md-outlined-select-text-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-hover-trailing-icon-color: var(--md-outlined-select-text-field-error-hover-trailing-icon-color, var(--md-sys-color-on-error-container, #410e0b));--_text-field-error-input-text-color: var(--md-outlined-select-text-field-error-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-error-label-text-color: var(--md-outlined-select-text-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-leading-icon-color: var(--md-outlined-select-text-field-error-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-error-outline-color: var(--md-outlined-select-text-field-error-outline-color, var(--md-sys-color-error, #b3261e));--_text-field-error-supporting-text-color: var(--md-outlined-select-text-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_text-field-error-trailing-icon-color: var(--md-outlined-select-text-field-error-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_text-field-focus-input-text-color: var(--md-outlined-select-text-field-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-focus-label-text-color: var(--md-outlined-select-text-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_text-field-focus-leading-icon-color: var(--md-outlined-select-text-field-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-focus-outline-color: var(--md-outlined-select-text-field-focus-outline-color, var(--md-sys-color-primary, #6750a4));--_text-field-focus-outline-width: var(--md-outlined-select-text-field-focus-outline-width, 3px);--_text-field-focus-supporting-text-color: var(--md-outlined-select-text-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-focus-trailing-icon-color: var(--md-outlined-select-text-field-focus-trailing-icon-color, var(--md-sys-color-primary, #6750a4));--_text-field-hover-input-text-color: var(--md-outlined-select-text-field-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-label-text-color: var(--md-outlined-select-text-field-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-leading-icon-color: var(--md-outlined-select-text-field-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-hover-outline-color: var(--md-outlined-select-text-field-hover-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-hover-outline-width: var(--md-outlined-select-text-field-hover-outline-width, 1px);--_text-field-hover-supporting-text-color: var(--md-outlined-select-text-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-hover-trailing-icon-color: var(--md-outlined-select-text-field-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-input-text-color: var(--md-outlined-select-text-field-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_text-field-input-text-font: var(--md-outlined-select-text-field-input-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-input-text-line-height: var(--md-outlined-select-text-field-input-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_text-field-input-text-size: var(--md-outlined-select-text-field-input-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_text-field-input-text-weight: var(--md-outlined-select-text-field-input-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-label-text-color: var(--md-outlined-select-text-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-label-text-font: var(--md-outlined-select-text-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-label-text-line-height: var(--md-outlined-select-text-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_text-field-label-text-populated-line-height: var(--md-outlined-select-text-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_text-field-label-text-populated-size: var(--md-outlined-select-text-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_text-field-label-text-size: var(--md-outlined-select-text-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_text-field-label-text-weight: var(--md-outlined-select-text-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-leading-icon-color: var(--md-outlined-select-text-field-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-leading-icon-size: var(--md-outlined-select-text-field-leading-icon-size, 24px);--_text-field-outline-color: var(--md-outlined-select-text-field-outline-color, var(--md-sys-color-outline, #79747e));--_text-field-outline-width: var(--md-outlined-select-text-field-outline-width, 1px);--_text-field-supporting-text-color: var(--md-outlined-select-text-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-supporting-text-font: var(--md-outlined-select-text-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_text-field-supporting-text-line-height: var(--md-outlined-select-text-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_text-field-supporting-text-size: var(--md-outlined-select-text-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_text-field-supporting-text-weight: var(--md-outlined-select-text-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_text-field-trailing-icon-color: var(--md-outlined-select-text-field-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_text-field-trailing-icon-size: var(--md-outlined-select-text-field-trailing-icon-size, 24px);--_text-field-container-shape-start-start: var(--md-outlined-select-text-field-container-shape-start-start, var(--md-outlined-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_text-field-container-shape-start-end: var(--md-outlined-select-text-field-container-shape-start-end, var(--md-outlined-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_text-field-container-shape-end-end: var(--md-outlined-select-text-field-container-shape-end-end, var(--md-outlined-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_text-field-container-shape-end-start: var(--md-outlined-select-text-field-container-shape-end-start, var(--md-outlined-select-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--md-outlined-field-container-shape-end-end: var(--_text-field-container-shape-end-end);--md-outlined-field-container-shape-end-start: var(--_text-field-container-shape-end-start);--md-outlined-field-container-shape-start-end: var(--_text-field-container-shape-start-end);--md-outlined-field-container-shape-start-start: var(--_text-field-container-shape-start-start);--md-outlined-field-content-color: var(--_text-field-input-text-color);--md-outlined-field-content-font: var(--_text-field-input-text-font);--md-outlined-field-content-line-height: var(--_text-field-input-text-line-height);--md-outlined-field-content-size: var(--_text-field-input-text-size);--md-outlined-field-content-weight: var(--_text-field-input-text-weight);--md-outlined-field-disabled-content-color: var(--_text-field-disabled-input-text-color);--md-outlined-field-disabled-content-opacity: var(--_text-field-disabled-input-text-opacity);--md-outlined-field-disabled-label-text-color: var(--_text-field-disabled-label-text-color);--md-outlined-field-disabled-label-text-opacity: var(--_text-field-disabled-label-text-opacity);--md-outlined-field-disabled-leading-content-color: var(--_text-field-disabled-leading-icon-color);--md-outlined-field-disabled-leading-content-opacity: var(--_text-field-disabled-leading-icon-opacity);--md-outlined-field-disabled-outline-color: var(--_text-field-disabled-outline-color);--md-outlined-field-disabled-outline-opacity: var(--_text-field-disabled-outline-opacity);--md-outlined-field-disabled-outline-width: var(--_text-field-disabled-outline-width);--md-outlined-field-disabled-supporting-text-color: var(--_text-field-disabled-supporting-text-color);--md-outlined-field-disabled-supporting-text-opacity: var(--_text-field-disabled-supporting-text-opacity);--md-outlined-field-disabled-trailing-content-color: var(--_text-field-disabled-trailing-icon-color);--md-outlined-field-disabled-trailing-content-opacity: var(--_text-field-disabled-trailing-icon-opacity);--md-outlined-field-error-content-color: var(--_text-field-error-input-text-color);--md-outlined-field-error-focus-content-color: var(--_text-field-error-focus-input-text-color);--md-outlined-field-error-focus-label-text-color: var(--_text-field-error-focus-label-text-color);--md-outlined-field-error-focus-leading-content-color: var(--_text-field-error-focus-leading-icon-color);--md-outlined-field-error-focus-outline-color: var(--_text-field-error-focus-outline-color);--md-outlined-field-error-focus-supporting-text-color: var(--_text-field-error-focus-supporting-text-color);--md-outlined-field-error-focus-trailing-content-color: var(--_text-field-error-focus-trailing-icon-color);--md-outlined-field-error-hover-content-color: var(--_text-field-error-hover-input-text-color);--md-outlined-field-error-hover-label-text-color: var(--_text-field-error-hover-label-text-color);--md-outlined-field-error-hover-leading-content-color: var(--_text-field-error-hover-leading-icon-color);--md-outlined-field-error-hover-outline-color: var(--_text-field-error-hover-outline-color);--md-outlined-field-error-hover-supporting-text-color: var(--_text-field-error-hover-supporting-text-color);--md-outlined-field-error-hover-trailing-content-color: var(--_text-field-error-hover-trailing-icon-color);--md-outlined-field-error-label-text-color: var(--_text-field-error-label-text-color);--md-outlined-field-error-leading-content-color: var(--_text-field-error-leading-icon-color);--md-outlined-field-error-outline-color: var(--_text-field-error-outline-color);--md-outlined-field-error-supporting-text-color: var(--_text-field-error-supporting-text-color);--md-outlined-field-error-trailing-content-color: var(--_text-field-error-trailing-icon-color);--md-outlined-field-focus-content-color: var(--_text-field-focus-input-text-color);--md-outlined-field-focus-label-text-color: var(--_text-field-focus-label-text-color);--md-outlined-field-focus-leading-content-color: var(--_text-field-focus-leading-icon-color);--md-outlined-field-focus-outline-color: var(--_text-field-focus-outline-color);--md-outlined-field-focus-outline-width: var(--_text-field-focus-outline-width);--md-outlined-field-focus-supporting-text-color: var(--_text-field-focus-supporting-text-color);--md-outlined-field-focus-trailing-content-color: var(--_text-field-focus-trailing-icon-color);--md-outlined-field-hover-content-color: var(--_text-field-hover-input-text-color);--md-outlined-field-hover-label-text-color: var(--_text-field-hover-label-text-color);--md-outlined-field-hover-leading-content-color: var(--_text-field-hover-leading-icon-color);--md-outlined-field-hover-outline-color: var(--_text-field-hover-outline-color);--md-outlined-field-hover-outline-width: var(--_text-field-hover-outline-width);--md-outlined-field-hover-supporting-text-color: var(--_text-field-hover-supporting-text-color);--md-outlined-field-hover-trailing-content-color: var(--_text-field-hover-trailing-icon-color);--md-outlined-field-label-text-color: var(--_text-field-label-text-color);--md-outlined-field-label-text-font: var(--_text-field-label-text-font);--md-outlined-field-label-text-line-height: var(--_text-field-label-text-line-height);--md-outlined-field-label-text-populated-line-height: var(--_text-field-label-text-populated-line-height);--md-outlined-field-label-text-populated-size: var(--_text-field-label-text-populated-size);--md-outlined-field-label-text-size: var(--_text-field-label-text-size);--md-outlined-field-label-text-weight: var(--_text-field-label-text-weight);--md-outlined-field-leading-content-color: var(--_text-field-leading-icon-color);--md-outlined-field-outline-color: var(--_text-field-outline-color);--md-outlined-field-outline-width: var(--_text-field-outline-width);--md-outlined-field-supporting-text-color: var(--_text-field-supporting-text-color);--md-outlined-field-supporting-text-font: var(--_text-field-supporting-text-font);--md-outlined-field-supporting-text-line-height: var(--_text-field-supporting-text-line-height);--md-outlined-field-supporting-text-size: var(--_text-field-supporting-text-size);--md-outlined-field-supporting-text-weight: var(--_text-field-supporting-text-weight);--md-outlined-field-trailing-content-color: var(--_text-field-trailing-icon-color)}[has-start] .icon.leading{font-size:var(--_text-field-leading-icon-size);height:var(--_text-field-leading-icon-size);width:var(--_text-field-leading-icon-size)}.icon.trailing{font-size:var(--_text-field-trailing-icon-size);height:var(--_text-field-trailing-icon-size);width:var(--_text-field-trailing-icon-size)}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdOutlinedSelect = class MdOutlinedSelect2 extends OutlinedSelect {
};
MdOutlinedSelect.styles = [styles$b, styles$a];
MdOutlinedSelect = __decorate([
  t$3("md-outlined-select")
], MdOutlinedSelect);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
function createRequestSelectionEvent() {
  return new Event("request-selection", {
    bubbles: true,
    composed: true
  });
}
function createRequestDeselectionEvent() {
  return new Event("request-deselection", {
    bubbles: true,
    composed: true
  });
}
class SelectOptionController {
  /**
   * The recommended role of the select option.
   */
  get role() {
    return this.menuItemController.role;
  }
  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot, and if there are
   * no slotted elements into headline, then it checks the _default_ slot, and
   * then the `"supporting-text"` slot if nothing is in _default_.
   */
  get typeaheadText() {
    return this.menuItemController.typeaheadText;
  }
  setTypeaheadText(text) {
    this.menuItemController.setTypeaheadText(text);
  }
  /**
   * The text that is displayed in the select field when selected. If not set,
   * defaults to the textContent of the item slotted into the `"headline"` slot,
   * and if there are no slotted elements into headline, then it checks the
   * _default_ slot, and then the `"supporting-text"` slot if nothing is in
   * _default_.
   */
  get displayText() {
    if (this.internalDisplayText !== null) {
      return this.internalDisplayText;
    }
    return this.menuItemController.typeaheadText;
  }
  setDisplayText(text) {
    this.internalDisplayText = text;
  }
  /**
   * @param host The SelectOption in which to attach this controller to.
   * @param config The object that configures this controller's behavior.
   */
  constructor(host, config) {
    this.host = host;
    this.internalDisplayText = null;
    this.firstUpdate = true;
    this.onClick = () => {
      this.menuItemController.onClick();
    };
    this.onKeydown = (e2) => {
      this.menuItemController.onKeydown(e2);
    };
    this.lastSelected = this.host.selected;
    this.menuItemController = new MenuItemController(host, config);
    host.addController(this);
  }
  hostUpdate() {
    if (this.lastSelected !== this.host.selected) {
      this.host.ariaSelected = this.host.selected ? "true" : "false";
    }
  }
  hostUpdated() {
    if (this.lastSelected !== this.host.selected && !this.firstUpdate) {
      if (this.host.selected) {
        this.host.dispatchEvent(createRequestSelectionEvent());
      } else {
        this.host.dispatchEvent(createRequestDeselectionEvent());
      }
    }
    this.lastSelected = this.host.selected;
    this.firstUpdate = false;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const selectOptionBaseClass = mixinDelegatesAria(s$1);
class SelectOptionEl extends selectOptionBaseClass {
  constructor() {
    super(...arguments);
    this.disabled = false;
    this.isMenuItem = true;
    this.selected = false;
    this.value = "";
    this.type = "option";
    this.selectOptionController = new SelectOptionController(this, {
      getHeadlineElements: () => {
        return this.headlineElements;
      },
      getSupportingTextElements: () => {
        return this.supportingTextElements;
      },
      getDefaultElements: () => {
        return this.defaultElements;
      },
      getInteractiveElement: () => this.listItemRoot
    });
  }
  /**
   * The text that is selectable via typeahead. If not set, defaults to the
   * innerText of the item slotted into the `"headline"` slot.
   */
  get typeaheadText() {
    return this.selectOptionController.typeaheadText;
  }
  set typeaheadText(text) {
    this.selectOptionController.setTypeaheadText(text);
  }
  /**
   * The text that is displayed in the select field when selected. If not set,
   * defaults to the textContent of the item slotted into the `"headline"` slot.
   */
  get displayText() {
    return this.selectOptionController.displayText;
  }
  set displayText(text) {
    this.selectOptionController.setDisplayText(text);
  }
  render() {
    return this.renderListItem(x$1`
      <md-item>
        <div slot="container">
          ${this.renderRipple()} ${this.renderFocusRing()}
        </div>
        <slot name="start" slot="start"></slot>
        <slot name="end" slot="end"></slot>
        ${this.renderBody()}
      </md-item>
    `);
  }
  /**
   * Renders the root list item.
   *
   * @param content the child content of the list item.
   */
  renderListItem(content) {
    return x$1`
      <li
        id="item"
        tabindex=${this.disabled ? -1 : 0}
        role=${this.selectOptionController.role}
        aria-label=${this.ariaLabel || T$1}
        aria-selected=${this.ariaSelected || T$1}
        aria-checked=${this.ariaChecked || T$1}
        aria-expanded=${this.ariaExpanded || T$1}
        aria-haspopup=${this.ariaHasPopup || T$1}
        class="list-item ${e$1(this.getRenderClasses())}"
        @click=${this.selectOptionController.onClick}
        @keydown=${this.selectOptionController.onKeydown}
        >${content}</li
      >
    `;
  }
  /**
   * Handles rendering of the ripple element.
   */
  renderRipple() {
    return x$1` <md-ripple
      part="ripple"
      for="item"
      ?disabled=${this.disabled}></md-ripple>`;
  }
  /**
   * Handles rendering of the focus ring.
   */
  renderFocusRing() {
    return x$1` <md-focus-ring
      part="focus-ring"
      for="item"
      inward></md-focus-ring>`;
  }
  /**
   * Classes applied to the list item root.
   */
  getRenderClasses() {
    return {
      "disabled": this.disabled,
      "selected": this.selected
    };
  }
  /**
   * Handles rendering the headline and supporting text.
   */
  renderBody() {
    return x$1`
      <slot></slot>
      <slot name="overline" slot="overline"></slot>
      <slot name="headline" slot="headline"></slot>
      <slot name="supporting-text" slot="supporting-text"></slot>
      <slot
        name="trailing-supporting-text"
        slot="trailing-supporting-text"></slot>
    `;
  }
  focus() {
    this.listItemRoot?.focus();
  }
}
SelectOptionEl.shadowRootOptions = {
  ...s$1.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], SelectOptionEl.prototype, "disabled", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "md-menu-item", reflect: true })
], SelectOptionEl.prototype, "isMenuItem", void 0);
__decorate([
  n$5({ type: Boolean })
], SelectOptionEl.prototype, "selected", void 0);
__decorate([
  n$5()
], SelectOptionEl.prototype, "value", void 0);
__decorate([
  e$5(".list-item")
], SelectOptionEl.prototype, "listItemRoot", void 0);
__decorate([
  o$4({ slot: "headline" })
], SelectOptionEl.prototype, "headlineElements", void 0);
__decorate([
  o$4({ slot: "supporting-text" })
], SelectOptionEl.prototype, "supportingTextElements", void 0);
__decorate([
  n$4({ slot: "" })
], SelectOptionEl.prototype, "defaultElements", void 0);
__decorate([
  n$5({ attribute: "typeahead-text" })
], SelectOptionEl.prototype, "typeaheadText", null);
__decorate([
  n$5({ attribute: "display-text" })
], SelectOptionEl.prototype, "displayText", null);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdSelectOption = class MdSelectOption2 extends SelectOptionEl {
};
MdSelectOption.styles = [styles$h];
MdSelectOption = __decorate([
  t$3("md-select-option")
], MdSelectOption);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$9 = i$4`@media(forced-colors: active){:host{--md-slider-active-track-color: CanvasText;--md-slider-disabled-active-track-color: GrayText;--md-slider-disabled-active-track-opacity: 1;--md-slider-disabled-handle-color: GrayText;--md-slider-disabled-inactive-track-color: GrayText;--md-slider-disabled-inactive-track-opacity: 1;--md-slider-focus-handle-color: CanvasText;--md-slider-handle-color: CanvasText;--md-slider-handle-shadow-color: Canvas;--md-slider-hover-handle-color: CanvasText;--md-slider-hover-state-layer-color: Canvas;--md-slider-hover-state-layer-opacity: 1;--md-slider-inactive-track-color: Canvas;--md-slider-label-container-color: Canvas;--md-slider-label-text-color: CanvasText;--md-slider-pressed-handle-color: CanvasText;--md-slider-pressed-state-layer-color: Canvas;--md-slider-pressed-state-layer-opacity: 1;--md-slider-with-overlap-handle-outline-color: CanvasText}.label,.label::before{border:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}:host(:not([disabled])) .track::before{border:1px solid var(--_active-track-color)}.tickmarks::before{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='CanvasText'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E")}.tickmarks::after{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2' r='1'/%3E%3C/svg%3E")}:host([disabled]) .tickmarks::before{background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='Canvas'%3E%3Ccircle cx='2' cy='2'  r='1'/%3E%3C/svg%3E")}}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
function n2(n3, r2, t2) {
  return n3 ? r2(n3) : t2?.(n3);
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const sliderBaseClass = mixinDelegatesAria(mixinFormAssociated(mixinElementInternals(s$1)));
class Slider extends sliderBaseClass {
  /**
   * The HTML name to use in form submission for a range slider's starting
   * value. Use `name` instead if both the start and end values should use the
   * same name.
   */
  get nameStart() {
    return this.getAttribute("name-start") ?? this.name;
  }
  set nameStart(name2) {
    this.setAttribute("name-start", name2);
  }
  /**
   * The HTML name to use in form submission for a range slider's ending value.
   * Use `name` instead if both the start and end values should use the same
   * name.
   */
  get nameEnd() {
    return this.getAttribute("name-end") ?? this.nameStart;
  }
  set nameEnd(name2) {
    this.setAttribute("name-end", name2);
  }
  // Note: start aria-* properties are only applied when range=true, which is
  // why they do not need to handle both cases.
  get renderAriaLabelStart() {
    const { ariaLabel } = this;
    return this.ariaLabelStart || ariaLabel && `${ariaLabel} start` || this.valueLabelStart || String(this.valueStart);
  }
  get renderAriaValueTextStart() {
    return this.ariaValueTextStart || this.valueLabelStart || String(this.valueStart);
  }
  // Note: end aria-* properties are applied for single and range sliders, which
  // is why it needs to handle `this.range` (while start aria-* properties do
  // not).
  get renderAriaLabelEnd() {
    const { ariaLabel } = this;
    if (this.range) {
      return this.ariaLabelEnd || ariaLabel && `${ariaLabel} end` || this.valueLabelEnd || String(this.valueEnd);
    }
    return ariaLabel || this.valueLabel || String(this.value);
  }
  get renderAriaValueTextEnd() {
    if (this.range) {
      return this.ariaValueTextEnd || this.valueLabelEnd || String(this.valueEnd);
    }
    const { ariaValueText } = this;
    return ariaValueText || this.valueLabel || String(this.value);
  }
  constructor() {
    super();
    this.min = 0;
    this.max = 100;
    this.valueLabel = "";
    this.valueLabelStart = "";
    this.valueLabelEnd = "";
    this.ariaLabelStart = "";
    this.ariaValueTextStart = "";
    this.ariaLabelEnd = "";
    this.ariaValueTextEnd = "";
    this.step = 1;
    this.ticks = false;
    this.labeled = false;
    this.range = false;
    this.handleStartHover = false;
    this.handleEndHover = false;
    this.startOnTop = false;
    this.handlesOverlapping = false;
    this.ripplePointerId = 1;
    this.isRedispatchingEvent = false;
    {
      this.addEventListener("click", (event) => {
        if (!isActivationClick(event) || !this.inputEnd) {
          return;
        }
        this.focus();
        dispatchActivationClick(this.inputEnd);
      });
    }
  }
  focus() {
    this.inputEnd?.focus();
  }
  willUpdate(changed) {
    this.renderValueStart = changed.has("valueStart") ? this.valueStart : this.inputStart?.valueAsNumber;
    const endValueChanged = changed.has("valueEnd") && this.range || changed.has("value");
    this.renderValueEnd = endValueChanged ? this.range ? this.valueEnd : this.value : this.inputEnd?.valueAsNumber;
    if (changed.get("handleStartHover") !== void 0) {
      this.toggleRippleHover(this.rippleStart, this.handleStartHover);
    } else if (changed.get("handleEndHover") !== void 0) {
      this.toggleRippleHover(this.rippleEnd, this.handleEndHover);
    }
  }
  updated(changed) {
    if (this.range) {
      this.renderValueStart = this.inputStart.valueAsNumber;
    }
    this.renderValueEnd = this.inputEnd.valueAsNumber;
    if (this.range) {
      const segment = (this.max - this.min) / 3;
      if (this.valueStart === void 0) {
        this.inputStart.valueAsNumber = this.min + segment;
        const v2 = this.inputStart.valueAsNumber;
        this.valueStart = this.renderValueStart = v2;
      }
      if (this.valueEnd === void 0) {
        this.inputEnd.valueAsNumber = this.min + 2 * segment;
        const v2 = this.inputEnd.valueAsNumber;
        this.valueEnd = this.renderValueEnd = v2;
      }
    } else {
      this.value ??= this.renderValueEnd;
    }
    if (changed.has("range") || changed.has("renderValueStart") || changed.has("renderValueEnd") || this.isUpdatePending) {
      const startNub = this.handleStart?.querySelector(".handleNub");
      const endNub = this.handleEnd?.querySelector(".handleNub");
      this.handlesOverlapping = isOverlapping(startNub, endNub);
    }
    this.performUpdate();
  }
  render() {
    const step = this.step === 0 ? 1 : this.step;
    const range = Math.max(this.max - this.min, step);
    const startFraction = this.range ? ((this.renderValueStart ?? this.min) - this.min) / range : 0;
    const endFraction = ((this.renderValueEnd ?? this.min) - this.min) / range;
    const containerStyles = {
      // for clipping inputs and active track.
      "--_start-fraction": String(startFraction),
      "--_end-fraction": String(endFraction),
      // for generating tick marks
      "--_tick-count": String(range / step)
    };
    const containerClasses = { ranged: this.range };
    const labelStart = this.valueLabelStart || String(this.renderValueStart);
    const labelEnd = (this.range ? this.valueLabelEnd : this.valueLabel) || String(this.renderValueEnd);
    const inputStartProps = {
      start: true,
      value: this.renderValueStart,
      ariaLabel: this.renderAriaLabelStart,
      ariaValueText: this.renderAriaValueTextStart,
      ariaMin: this.min,
      ariaMax: this.valueEnd ?? this.max
    };
    const inputEndProps = {
      start: false,
      value: this.renderValueEnd,
      ariaLabel: this.renderAriaLabelEnd,
      ariaValueText: this.renderAriaValueTextEnd,
      ariaMin: this.range ? this.valueStart ?? this.min : this.min,
      ariaMax: this.max
    };
    const handleStartProps = {
      start: true,
      hover: this.handleStartHover,
      label: labelStart
    };
    const handleEndProps = {
      start: false,
      hover: this.handleEndHover,
      label: labelEnd
    };
    const handleContainerClasses = {
      hover: this.handleStartHover || this.handleEndHover
    };
    return x$1` <div
      class="container ${e$1(containerClasses)}"
      style=${o(containerStyles)}>
      ${n2(this.range, () => this.renderInput(inputStartProps))}
      ${this.renderInput(inputEndProps)} ${this.renderTrack()}
      <div class="handleContainerPadded">
        <div class="handleContainerBlock">
          <div class="handleContainer ${e$1(handleContainerClasses)}">
            ${n2(this.range, () => this.renderHandle(handleStartProps))}
            ${this.renderHandle(handleEndProps)}
          </div>
        </div>
      </div>
    </div>`;
  }
  renderTrack() {
    return x$1`
      <div class="track"></div>
      ${this.ticks ? x$1`<div class="tickmarks"></div>` : T$1}
    `;
  }
  renderLabel(value) {
    return x$1`<div class="label" aria-hidden="true">
      <span class="labelContent" part="label">${value}</span>
    </div>`;
  }
  renderHandle({ start: start2, hover, label }) {
    const onTop = !this.disabled && start2 === this.startOnTop;
    const isOverlapping2 = !this.disabled && this.handlesOverlapping;
    const name2 = start2 ? "start" : "end";
    return x$1`<div
      class="handle ${e$1({
      [name2]: true,
      hover,
      onTop,
      isOverlapping: isOverlapping2
    })}">
      <md-focus-ring part="focus-ring" for=${name2}></md-focus-ring>
      <md-ripple
        for=${name2}
        class=${name2}
        ?disabled=${this.disabled}></md-ripple>
      <div class="handleNub">
        <md-elevation part="elevation"></md-elevation>
      </div>
      ${n2(this.labeled, () => this.renderLabel(label))}
    </div>`;
  }
  renderInput({ start: start2, value, ariaLabel, ariaValueText, ariaMin, ariaMax }) {
    const name2 = start2 ? `start` : `end`;
    return x$1`<input
      type="range"
      class="${e$1({
      start: start2,
      end: !start2
    })}"
      @focus=${this.handleFocus}
      @pointerdown=${this.handleDown}
      @pointerup=${this.handleUp}
      @pointerenter=${this.handleEnter}
      @pointermove=${this.handleMove}
      @pointerleave=${this.handleLeave}
      @keydown=${this.handleKeydown}
      @keyup=${this.handleKeyup}
      @input=${this.handleInput}
      @change=${this.handleChange}
      id=${name2}
      .disabled=${this.disabled}
      .min=${String(this.min)}
      aria-valuemin=${ariaMin}
      .max=${String(this.max)}
      aria-valuemax=${ariaMax}
      .step=${String(this.step)}
      .value=${String(value)}
      .tabIndex=${start2 ? 1 : 0}
      aria-label=${ariaLabel || T$1}
      aria-valuetext=${ariaValueText} />`;
  }
  async toggleRippleHover(ripple, hovering) {
    const rippleEl = await ripple;
    if (!rippleEl) {
      return;
    }
    if (hovering) {
      rippleEl.handlePointerenter(new PointerEvent("pointerenter", {
        isPrimary: true,
        pointerId: this.ripplePointerId
      }));
    } else {
      rippleEl.handlePointerleave(new PointerEvent("pointerleave", {
        isPrimary: true,
        pointerId: this.ripplePointerId
      }));
    }
  }
  handleFocus(event) {
    this.updateOnTop(event.target);
  }
  startAction(event) {
    const target = event.target;
    const fixed = target === this.inputStart ? this.inputEnd : this.inputStart;
    this.action = {
      canFlip: event.type === "pointerdown",
      flipped: false,
      target,
      fixed,
      values: /* @__PURE__ */ new Map([
        [target, target.valueAsNumber],
        [fixed, fixed?.valueAsNumber]
      ])
    };
  }
  finishAction(event) {
    this.action = void 0;
  }
  handleKeydown(event) {
    this.startAction(event);
  }
  handleKeyup(event) {
    this.finishAction(event);
  }
  handleDown(event) {
    this.startAction(event);
    this.ripplePointerId = event.pointerId;
    const isStart = event.target === this.inputStart;
    this.handleStartHover = !this.disabled && isStart && Boolean(this.handleStart);
    this.handleEndHover = !this.disabled && !isStart && Boolean(this.handleEnd);
  }
  async handleUp(event) {
    if (!this.action) {
      return;
    }
    const { target, values, flipped } = this.action;
    await new Promise(requestAnimationFrame);
    if (target !== void 0) {
      target.focus();
      if (flipped && target.valueAsNumber !== values.get(target)) {
        target.dispatchEvent(new Event("change", { bubbles: true }));
      }
    }
    this.finishAction(event);
  }
  /**
   * The move handler tracks handle hovering to facilitate proper ripple
   * behavior on the slider handle. This is needed because user interaction with
   * the native input is leveraged to position the handle. Because the separate
   * displayed handle element has pointer events disabled (to allow interaction
   * with the input) and the input's handle is a pseudo-element, neither can be
   * the ripple's interactive element. Therefore the input is the ripple's
   * interactive element and has a `ripple` directive; however the ripple
   * is gated on the handle being hovered. In addition, because the ripple
   * hover state is being specially handled, it must be triggered independent
   * of the directive. This is done based on the hover state when the
   * slider is updated.
   */
  handleMove(event) {
    this.handleStartHover = !this.disabled && inBounds(event, this.handleStart);
    this.handleEndHover = !this.disabled && inBounds(event, this.handleEnd);
  }
  handleEnter(event) {
    this.handleMove(event);
  }
  handleLeave() {
    this.handleStartHover = false;
    this.handleEndHover = false;
  }
  updateOnTop(input) {
    this.startOnTop = input.classList.contains("start");
  }
  needsClamping() {
    if (!this.action) {
      return false;
    }
    const { target, fixed } = this.action;
    const isStart = target === this.inputStart;
    return isStart ? target.valueAsNumber > fixed.valueAsNumber : target.valueAsNumber < fixed.valueAsNumber;
  }
  // if start/end start coincident and the first drag input would e.g. move
  // start > end, avoid clamping and "flip" to use the other input
  // as the action target.
  isActionFlipped() {
    const { action } = this;
    if (!action) {
      return false;
    }
    const { target, fixed, values } = action;
    if (action.canFlip) {
      const coincident = values.get(target) === values.get(fixed);
      if (coincident && this.needsClamping()) {
        action.canFlip = false;
        action.flipped = true;
        action.target = fixed;
        action.fixed = target;
      }
    }
    return action.flipped;
  }
  // when flipped, apply the drag input to the flipped target and reset
  // the actual target.
  flipAction() {
    if (!this.action) {
      return false;
    }
    const { target, fixed, values } = this.action;
    const changed = target.valueAsNumber !== fixed.valueAsNumber;
    target.valueAsNumber = fixed.valueAsNumber;
    fixed.valueAsNumber = values.get(fixed);
    return changed;
  }
  // clamp such that start does not move beyond end and visa versa.
  clampAction() {
    if (!this.needsClamping() || !this.action) {
      return false;
    }
    const { target, fixed } = this.action;
    target.valueAsNumber = fixed.valueAsNumber;
    return true;
  }
  handleInput(event) {
    if (this.isRedispatchingEvent) {
      return;
    }
    let stopPropagation = false;
    let redispatch = false;
    if (this.range) {
      if (this.isActionFlipped()) {
        stopPropagation = true;
        redispatch = this.flipAction();
      }
      if (this.clampAction()) {
        stopPropagation = true;
        redispatch = false;
      }
    }
    const target = event.target;
    this.updateOnTop(target);
    if (this.range) {
      this.valueStart = this.inputStart.valueAsNumber;
      this.valueEnd = this.inputEnd.valueAsNumber;
    } else {
      this.value = this.inputEnd.valueAsNumber;
    }
    if (stopPropagation) {
      event.stopPropagation();
    }
    if (redispatch) {
      this.isRedispatchingEvent = true;
      redispatchEvent(target, event);
      this.isRedispatchingEvent = false;
    }
  }
  handleChange(event) {
    const changeTarget = event.target;
    const { target, values } = this.action ?? {};
    const squelch = target && target.valueAsNumber === values.get(changeTarget);
    if (!squelch) {
      redispatchEvent(this, event);
    }
    this.finishAction(event);
  }
  [getFormValue]() {
    if (this.range) {
      const data = new FormData();
      data.append(this.nameStart, String(this.valueStart));
      data.append(this.nameEnd, String(this.valueEnd));
      return data;
    }
    return String(this.value);
  }
  formResetCallback() {
    if (this.range) {
      const valueStart = this.getAttribute("value-start");
      this.valueStart = valueStart !== null ? Number(valueStart) : void 0;
      const valueEnd = this.getAttribute("value-end");
      this.valueEnd = valueEnd !== null ? Number(valueEnd) : void 0;
      return;
    }
    const value = this.getAttribute("value");
    this.value = value !== null ? Number(value) : void 0;
  }
  formStateRestoreCallback(state) {
    if (Array.isArray(state)) {
      const [[, valueStart], [, valueEnd]] = state;
      this.valueStart = Number(valueStart);
      this.valueEnd = Number(valueEnd);
      this.range = true;
      return;
    }
    this.value = Number(state);
    this.range = false;
  }
}
Slider.shadowRootOptions = {
  ...s$1.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Number })
], Slider.prototype, "min", void 0);
__decorate([
  n$5({ type: Number })
], Slider.prototype, "max", void 0);
__decorate([
  n$5({ type: Number })
], Slider.prototype, "value", void 0);
__decorate([
  n$5({ type: Number, attribute: "value-start" })
], Slider.prototype, "valueStart", void 0);
__decorate([
  n$5({ type: Number, attribute: "value-end" })
], Slider.prototype, "valueEnd", void 0);
__decorate([
  n$5({ attribute: "value-label" })
], Slider.prototype, "valueLabel", void 0);
__decorate([
  n$5({ attribute: "value-label-start" })
], Slider.prototype, "valueLabelStart", void 0);
__decorate([
  n$5({ attribute: "value-label-end" })
], Slider.prototype, "valueLabelEnd", void 0);
__decorate([
  n$5({ attribute: "aria-label-start" })
], Slider.prototype, "ariaLabelStart", void 0);
__decorate([
  n$5({ attribute: "aria-valuetext-start" })
], Slider.prototype, "ariaValueTextStart", void 0);
__decorate([
  n$5({ attribute: "aria-label-end" })
], Slider.prototype, "ariaLabelEnd", void 0);
__decorate([
  n$5({ attribute: "aria-valuetext-end" })
], Slider.prototype, "ariaValueTextEnd", void 0);
__decorate([
  n$5({ type: Number })
], Slider.prototype, "step", void 0);
__decorate([
  n$5({ type: Boolean })
], Slider.prototype, "ticks", void 0);
__decorate([
  n$5({ type: Boolean })
], Slider.prototype, "labeled", void 0);
__decorate([
  n$5({ type: Boolean })
], Slider.prototype, "range", void 0);
__decorate([
  e$5("input.start")
], Slider.prototype, "inputStart", void 0);
__decorate([
  e$5(".handle.start")
], Slider.prototype, "handleStart", void 0);
__decorate([
  r$2("md-ripple.start")
], Slider.prototype, "rippleStart", void 0);
__decorate([
  e$5("input.end")
], Slider.prototype, "inputEnd", void 0);
__decorate([
  e$5(".handle.end")
], Slider.prototype, "handleEnd", void 0);
__decorate([
  r$2("md-ripple.end")
], Slider.prototype, "rippleEnd", void 0);
__decorate([
  r$4()
], Slider.prototype, "handleStartHover", void 0);
__decorate([
  r$4()
], Slider.prototype, "handleEndHover", void 0);
__decorate([
  r$4()
], Slider.prototype, "startOnTop", void 0);
__decorate([
  r$4()
], Slider.prototype, "handlesOverlapping", void 0);
__decorate([
  r$4()
], Slider.prototype, "renderValueStart", void 0);
__decorate([
  r$4()
], Slider.prototype, "renderValueEnd", void 0);
function inBounds({ x: x2, y: y2 }, element) {
  if (!element) {
    return false;
  }
  const { top: top2, left: left2, bottom: bottom2, right: right2 } = element.getBoundingClientRect();
  return x2 >= left2 && x2 <= right2 && y2 >= top2 && y2 <= bottom2;
}
function isOverlapping(elA, elB) {
  if (!(elA && elB)) {
    return false;
  }
  const a2 = elA.getBoundingClientRect();
  const b3 = elB.getBoundingClientRect();
  return !(a2.top > b3.bottom || a2.right < b3.left || a2.bottom < b3.top || a2.left > b3.right);
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$8 = i$4`:host{--_active-track-color: var(--md-slider-active-track-color, var(--md-sys-color-primary, #6750a4));--_active-track-height: var(--md-slider-active-track-height, 4px);--_active-track-shape: var(--md-slider-active-track-shape, var(--md-sys-shape-corner-full, 9999px));--_disabled-active-track-color: var(--md-slider-disabled-active-track-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-active-track-opacity: var(--md-slider-disabled-active-track-opacity, 0.38);--_disabled-handle-color: var(--md-slider-disabled-handle-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-handle-elevation: var(--md-slider-disabled-handle-elevation, 0);--_disabled-inactive-track-color: var(--md-slider-disabled-inactive-track-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-inactive-track-opacity: var(--md-slider-disabled-inactive-track-opacity, 0.12);--_focus-handle-color: var(--md-slider-focus-handle-color, var(--md-sys-color-primary, #6750a4));--_handle-color: var(--md-slider-handle-color, var(--md-sys-color-primary, #6750a4));--_handle-elevation: var(--md-slider-handle-elevation, 1);--_handle-height: var(--md-slider-handle-height, 20px);--_handle-shadow-color: var(--md-slider-handle-shadow-color, var(--md-sys-color-shadow, #000));--_handle-shape: var(--md-slider-handle-shape, var(--md-sys-shape-corner-full, 9999px));--_handle-width: var(--md-slider-handle-width, 20px);--_hover-handle-color: var(--md-slider-hover-handle-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-color: var(--md-slider-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_hover-state-layer-opacity: var(--md-slider-hover-state-layer-opacity, 0.08);--_inactive-track-color: var(--md-slider-inactive-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_inactive-track-height: var(--md-slider-inactive-track-height, 4px);--_inactive-track-shape: var(--md-slider-inactive-track-shape, var(--md-sys-shape-corner-full, 9999px));--_label-container-color: var(--md-slider-label-container-color, var(--md-sys-color-primary, #6750a4));--_label-container-height: var(--md-slider-label-container-height, 28px);--_pressed-handle-color: var(--md-slider-pressed-handle-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-color: var(--md-slider-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-slider-pressed-state-layer-opacity, 0.12);--_state-layer-size: var(--md-slider-state-layer-size, 40px);--_with-overlap-handle-outline-color: var(--md-slider-with-overlap-handle-outline-color, var(--md-sys-color-on-primary, #fff));--_with-overlap-handle-outline-width: var(--md-slider-with-overlap-handle-outline-width, 1px);--_with-tick-marks-active-container-color: var(--md-slider-with-tick-marks-active-container-color, var(--md-sys-color-on-primary, #fff));--_with-tick-marks-container-size: var(--md-slider-with-tick-marks-container-size, 2px);--_with-tick-marks-disabled-container-color: var(--md-slider-with-tick-marks-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_with-tick-marks-inactive-container-color: var(--md-slider-with-tick-marks-inactive-container-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-color: var(--md-slider-label-text-color, var(--md-sys-color-on-primary, #fff));--_label-text-font: var(--md-slider-label-text-font, var(--md-sys-typescale-label-medium-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-slider-label-text-line-height, var(--md-sys-typescale-label-medium-line-height, 1rem));--_label-text-size: var(--md-slider-label-text-size, var(--md-sys-typescale-label-medium-size, 0.75rem));--_label-text-weight: var(--md-slider-label-text-weight, var(--md-sys-typescale-label-medium-weight, var(--md-ref-typeface-weight-medium, 500)));--_start-fraction: 0;--_end-fraction: 0;--_tick-count: 0;display:inline-flex;vertical-align:middle;min-inline-size:200px;--md-elevation-level: var(--_handle-elevation);--md-elevation-shadow-color: var(--_handle-shadow-color)}md-focus-ring{height:48px;inset:unset;width:48px}md-elevation{transition-duration:250ms}@media(prefers-reduced-motion){.label{transition-duration:0}}:host([disabled]){opacity:var(--_disabled-active-track-opacity);--md-elevation-level: var(--_disabled-handle-elevation)}.container{flex:1;display:flex;align-items:center;position:relative;block-size:var(--_state-layer-size);pointer-events:none;touch-action:none}.track,.tickmarks{position:absolute;inset:0;display:flex;align-items:center}.track::before,.tickmarks::before,.track::after,.tickmarks::after{position:absolute;content:"";inset-inline-start:calc(var(--_state-layer-size)/2 - var(--_with-tick-marks-container-size));inset-inline-end:calc(var(--_state-layer-size)/2 - var(--_with-tick-marks-container-size));background-size:calc((100% - var(--_with-tick-marks-container-size)*2)/var(--_tick-count)) 100%}.track::before,.tickmarks::before{block-size:var(--_inactive-track-height);border-radius:var(--_inactive-track-shape)}.track::before{background:var(--_inactive-track-color)}.tickmarks::before{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-inactive-container-color) 0, var(--_with-tick-marks-inactive-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}:host([disabled]) .track::before{opacity:calc(1/var(--_disabled-active-track-opacity)*var(--_disabled-inactive-track-opacity));background:var(--_disabled-inactive-track-color)}.track::after,.tickmarks::after{block-size:var(--_active-track-height);border-radius:var(--_active-track-shape);clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))) 0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)))}.track::after{background:var(--_active-track-color)}.tickmarks::after{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-active-container-color) 0, var(--_with-tick-marks-active-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}.track:dir(rtl)::after{clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)) 0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))))}.tickmarks:dir(rtl)::after{clip-path:inset(0 calc(var(--_with-tick-marks-container-size) * min(var(--_start-fraction) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * var(--_start-fraction)) 0 calc(var(--_with-tick-marks-container-size) * min((1 - var(--_end-fraction)) * 1000000000, 1) + (100% - var(--_with-tick-marks-container-size) * 2) * (1 - var(--_end-fraction))))}:host([disabled]) .track::after{background:var(--_disabled-active-track-color)}:host([disabled]) .tickmarks::before{background-image:radial-gradient(circle at var(--_with-tick-marks-container-size) center, var(--_with-tick-marks-disabled-container-color) 0, var(--_with-tick-marks-disabled-container-color) calc(var(--_with-tick-marks-container-size) / 2), transparent calc(var(--_with-tick-marks-container-size) / 2))}.handleContainerPadded{position:relative;block-size:100%;inline-size:100%;padding-inline:calc(var(--_state-layer-size)/2)}.handleContainerBlock{position:relative;block-size:100%;inline-size:100%}.handleContainer{position:absolute;inset-block-start:0;inset-block-end:0;inset-inline-start:calc(100%*var(--_start-fraction));inline-size:calc(100%*(var(--_end-fraction) - var(--_start-fraction)))}.handle{position:absolute;block-size:var(--_state-layer-size);inline-size:var(--_state-layer-size);border-radius:var(--_handle-shape);display:flex;place-content:center;place-items:center}.handleNub{position:absolute;height:var(--_handle-height);width:var(--_handle-width);border-radius:var(--_handle-shape);background:var(--_handle-color)}:host([disabled]) .handleNub{background:var(--_disabled-handle-color)}input.end:focus~.handleContainerPadded .handle.end>.handleNub,input.start:focus~.handleContainerPadded .handle.start>.handleNub{background:var(--_focus-handle-color)}.container>.handleContainerPadded .handle.hover>.handleNub{background:var(--_hover-handle-color)}:host(:not([disabled])) input.end:active~.handleContainerPadded .handle.end>.handleNub,:host(:not([disabled])) input.start:active~.handleContainerPadded .handle.start>.handleNub{background:var(--_pressed-handle-color)}.onTop.isOverlapping .label,.onTop.isOverlapping .label::before{outline:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}.onTop.isOverlapping .handleNub{border:var(--_with-overlap-handle-outline-color) solid var(--_with-overlap-handle-outline-width)}.handle.start{inset-inline-start:calc(0px - var(--_state-layer-size)/2)}.handle.end{inset-inline-end:calc(0px - var(--_state-layer-size)/2)}.label{position:absolute;box-sizing:border-box;display:flex;padding:4px;place-content:center;place-items:center;border-radius:var(--md-sys-shape-corner-full, 9999px);color:var(--_label-text-color);font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);inset-block-end:100%;min-inline-size:var(--_label-container-height);min-block-size:var(--_label-container-height);background:var(--_label-container-color);transition:transform 100ms cubic-bezier(0.2, 0, 0, 1);transform-origin:center bottom;transform:scale(0)}:host(:focus-within) .label,.handleContainer.hover .label,:where(:has(input:active)) .label{transform:scale(1)}.label::before,.label::after{position:absolute;display:block;content:"";background:inherit}.label::before{inline-size:calc(var(--_label-container-height)/2);block-size:calc(var(--_label-container-height)/2);bottom:calc(var(--_label-container-height)/-10);transform:rotate(45deg)}.label::after{inset:0px;border-radius:inherit}.labelContent{z-index:1}input[type=range]{opacity:0;-webkit-tap-highlight-color:rgba(0,0,0,0);position:absolute;box-sizing:border-box;height:100%;width:100%;margin:0;background:rgba(0,0,0,0);cursor:pointer;pointer-events:auto;appearance:none}input[type=range]:focus{outline:none}::-webkit-slider-runnable-track{-webkit-appearance:none}::-moz-range-track{appearance:none}::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;block-size:var(--_handle-height);inline-size:var(--_handle-width);opacity:0;z-index:2}input.end::-webkit-slider-thumb{--_track-and-knob-padding: calc( (var(--_state-layer-size) - var(--_handle-width)) / 2 );--_x-translate: calc( var(--_track-and-knob-padding) - 2 * var(--_end-fraction) * var(--_track-and-knob-padding) );transform:translateX(var(--_x-translate))}input.end:dir(rtl)::-webkit-slider-thumb{transform:translateX(calc(-1 * var(--_x-translate)))}input.start::-webkit-slider-thumb{--_track-and-knob-padding: calc( (var(--_state-layer-size) - var(--_handle-width)) / 2 );--_x-translate: calc( var(--_track-and-knob-padding) - 2 * var(--_start-fraction) * var(--_track-and-knob-padding) );transform:translateX(var(--_x-translate))}input.start:dir(rtl)::-webkit-slider-thumb{transform:translateX(calc(-1 * var(--_x-translate)))}::-moz-range-thumb{appearance:none;block-size:var(--_state-layer-size);inline-size:var(--_state-layer-size);transform:scaleX(0);opacity:0;z-index:2}.ranged input.start{clip-path:inset(0 calc(100% - (var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2))) 0 0)}.ranged input.start:dir(rtl){clip-path:inset(0 0 0 calc(100% - (var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2))))}.ranged input.end{clip-path:inset(0 0 0 calc(var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2)))}.ranged input.end:dir(rtl){clip-path:inset(0 calc(var(--_state-layer-size) / 2 + (100% - var(--_state-layer-size)) * (var(--_start-fraction) + (var(--_end-fraction) - var(--_start-fraction)) / 2)) 0 0)}.onTop{z-index:1}.handle{--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity)}md-ripple{border-radius:50%;height:var(--_state-layer-size);width:var(--_state-layer-size)}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdSlider = class MdSlider2 extends Slider {
};
MdSlider.styles = [styles$8, styles$9];
MdSlider = __decorate([
  t$3("md-slider")
], MdSlider);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const dispatchHooks = Symbol("dispatchHooks");
function afterDispatch(event, callback) {
  const hooks = event[dispatchHooks];
  if (!hooks) {
    throw new Error(`'${event.type}' event needs setupDispatchHooks().`);
  }
  hooks.addEventListener("after", callback);
}
const ELEMENT_DISPATCH_HOOK_TYPES = /* @__PURE__ */ new WeakMap();
function setupDispatchHooks(element, ...eventTypes) {
  let typesAlreadySetUp = ELEMENT_DISPATCH_HOOK_TYPES.get(element);
  if (!typesAlreadySetUp) {
    typesAlreadySetUp = /* @__PURE__ */ new Set();
    ELEMENT_DISPATCH_HOOK_TYPES.set(element, typesAlreadySetUp);
  }
  for (const eventType of eventTypes) {
    if (typesAlreadySetUp.has(eventType)) {
      continue;
    }
    let isRedispatching = false;
    element.addEventListener(eventType, (event) => {
      if (isRedispatching) {
        return;
      }
      event.stopImmediatePropagation();
      const eventCopy = Reflect.construct(event.constructor, [
        event.type,
        event
      ]);
      const hooks = new EventTarget();
      eventCopy[dispatchHooks] = hooks;
      isRedispatching = true;
      const dispatched = element.dispatchEvent(eventCopy);
      isRedispatching = false;
      if (!dispatched) {
        event.preventDefault();
      }
      hooks.dispatchEvent(new Event("after"));
    }, {
      // Ensure this listener runs before other listeners.
      // `setupDispatchHooks()` should be called in constructors to also
      // ensure they run before any other externally-added capture listeners.
      capture: true
    });
    typesAlreadySetUp.add(eventType);
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const switchBaseClass = mixinDelegatesAria(mixinConstraintValidation(mixinFormAssociated(mixinElementInternals(s$1))));
class Switch2 extends switchBaseClass {
  constructor() {
    super();
    this.selected = false;
    this.icons = false;
    this.showOnlySelectedIcon = false;
    this.required = false;
    this.value = "on";
    this.addEventListener("click", (event) => {
      if (!isActivationClick(event) || !this.input) {
        return;
      }
      this.focus();
      dispatchActivationClick(this.input);
    });
    setupDispatchHooks(this, "keydown");
    this.addEventListener("keydown", (event) => {
      afterDispatch(event, () => {
        const ignoreEvent = event.defaultPrevented || event.key !== "Enter";
        if (ignoreEvent || this.disabled || !this.input) {
          return;
        }
        this.input.click();
      });
    });
  }
  render() {
    return x$1`
      <div class="switch ${e$1(this.getRenderClasses())}">
        <input
          id="switch"
          class="touch"
          type="checkbox"
          role="switch"
          aria-label=${this.ariaLabel || T$1}
          ?checked=${this.selected}
          ?disabled=${this.disabled}
          ?required=${this.required}
          @input=${this.handleInput}
          @change=${this.handleChange} />

        <md-focus-ring part="focus-ring" for="switch"></md-focus-ring>
        <span class="track"> ${this.renderHandle()} </span>
      </div>
    `;
  }
  getRenderClasses() {
    return {
      "selected": this.selected,
      "unselected": !this.selected,
      "disabled": this.disabled
    };
  }
  renderHandle() {
    const classes = {
      "with-icon": this.showOnlySelectedIcon ? this.selected : this.icons
    };
    return x$1`
      ${this.renderTouchTarget()}
      <span class="handle-container">
        <md-ripple for="switch" ?disabled="${this.disabled}"></md-ripple>
        <span class="handle ${e$1(classes)}">
          ${this.shouldShowIcons() ? this.renderIcons() : x$1``}
        </span>
      </span>
    `;
  }
  renderIcons() {
    return x$1`
      <div class="icons">
        ${this.renderOnIcon()}
        ${this.showOnlySelectedIcon ? x$1`` : this.renderOffIcon()}
      </div>
    `;
  }
  /**
   * https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Acheck%3AFILL%400%3Bwght%40500%3BGRAD%400%3Bopsz%4024
   */
  renderOnIcon() {
    return x$1`
      <slot class="icon icon--on" name="on-icon">
        <svg viewBox="0 0 24 24">
          <path
            d="M9.55 18.2 3.65 12.3 5.275 10.675 9.55 14.95 18.725 5.775 20.35 7.4Z" />
        </svg>
      </slot>
    `;
  }
  /**
   * https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Aclose%3AFILL%400%3Bwght%40500%3BGRAD%400%3Bopsz%4024
   */
  renderOffIcon() {
    return x$1`
      <slot class="icon icon--off" name="off-icon">
        <svg viewBox="0 0 24 24">
          <path
            d="M6.4 19.2 4.8 17.6 10.4 12 4.8 6.4 6.4 4.8 12 10.4 17.6 4.8 19.2 6.4 13.6 12 19.2 17.6 17.6 19.2 12 13.6Z" />
        </svg>
      </slot>
    `;
  }
  renderTouchTarget() {
    return x$1`<span class="touch"></span>`;
  }
  shouldShowIcons() {
    return this.icons || this.showOnlySelectedIcon;
  }
  handleInput(event) {
    const target = event.target;
    this.selected = target.checked;
  }
  handleChange(event) {
    redispatchEvent(this, event);
  }
  [getFormValue]() {
    return this.selected ? this.value : null;
  }
  [getFormState]() {
    return String(this.selected);
  }
  formResetCallback() {
    this.selected = this.hasAttribute("selected");
  }
  formStateRestoreCallback(state) {
    this.selected = state === "true";
  }
  [createValidator]() {
    return new CheckboxValidator(() => ({
      checked: this.selected,
      required: this.required
    }));
  }
  [getValidityAnchor]() {
    return this.input;
  }
}
Switch2.shadowRootOptions = {
  mode: "open",
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean })
], Switch2.prototype, "selected", void 0);
__decorate([
  n$5({ type: Boolean })
], Switch2.prototype, "icons", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "show-only-selected-icon" })
], Switch2.prototype, "showOnlySelectedIcon", void 0);
__decorate([
  n$5({ type: Boolean })
], Switch2.prototype, "required", void 0);
__decorate([
  n$5()
], Switch2.prototype, "value", void 0);
__decorate([
  e$5("input")
], Switch2.prototype, "input", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$7 = i$4`@layer styles, hcm;@layer styles{:host{display:inline-flex;outline:none;vertical-align:top;-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer}:host([disabled]){cursor:default}:host([touch-target=wrapper]){margin:max(0px,(48px - var(--md-switch-track-height, 32px))/2) 0px}md-focus-ring{--md-focus-ring-shape-start-start: var(--md-switch-track-shape-start-start, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));--md-focus-ring-shape-start-end: var(--md-switch-track-shape-start-end, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));--md-focus-ring-shape-end-end: var(--md-switch-track-shape-end-end, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));--md-focus-ring-shape-end-start: var(--md-switch-track-shape-end-start, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)))}.switch{align-items:center;display:inline-flex;flex-shrink:0;position:relative;width:var(--md-switch-track-width, 52px);height:var(--md-switch-track-height, 32px);border-start-start-radius:var(--md-switch-track-shape-start-start, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));border-start-end-radius:var(--md-switch-track-shape-start-end, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));border-end-end-radius:var(--md-switch-track-shape-end-end, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)));border-end-start-radius:var(--md-switch-track-shape-end-start, var(--md-switch-track-shape, var(--md-sys-shape-corner-full, 9999px)))}input{appearance:none;height:max(100%,var(--md-switch-touch-target-size, 48px));outline:none;margin:0;position:absolute;width:max(100%,var(--md-switch-touch-target-size, 48px));z-index:1;cursor:inherit;top:50%;left:50%;transform:translate(-50%, -50%)}:host([touch-target=none]) input{display:none}}@layer styles{.track{position:absolute;width:100%;height:100%;box-sizing:border-box;border-radius:inherit;display:flex;justify-content:center;align-items:center}.track::before{content:"";display:flex;position:absolute;height:100%;width:100%;border-radius:inherit;box-sizing:border-box;transition-property:opacity,background-color;transition-timing-function:linear;transition-duration:67ms}.disabled .track{background-color:rgba(0,0,0,0);border-color:rgba(0,0,0,0)}.disabled .track::before,.disabled .track::after{transition:none;opacity:var(--md-switch-disabled-track-opacity, 0.12)}.disabled .track::before{background-clip:content-box}.selected .track::before{background-color:var(--md-switch-selected-track-color, var(--md-sys-color-primary, #6750a4))}.selected:hover .track::before{background-color:var(--md-switch-selected-hover-track-color, var(--md-sys-color-primary, #6750a4))}.selected:focus-within .track::before{background-color:var(--md-switch-selected-focus-track-color, var(--md-sys-color-primary, #6750a4))}.selected:active .track::before{background-color:var(--md-switch-selected-pressed-track-color, var(--md-sys-color-primary, #6750a4))}.selected.disabled .track{background-clip:border-box}.selected.disabled .track::before{background-color:var(--md-switch-disabled-selected-track-color, var(--md-sys-color-on-surface, #1d1b20))}.unselected .track::before{background-color:var(--md-switch-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));border-color:var(--md-switch-track-outline-color, var(--md-sys-color-outline, #79747e));border-style:solid;border-width:var(--md-switch-track-outline-width, 2px)}.unselected:hover .track::before{background-color:var(--md-switch-hover-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));border-color:var(--md-switch-hover-track-outline-color, var(--md-sys-color-outline, #79747e))}.unselected:focus-visible .track::before{background-color:var(--md-switch-focus-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));border-color:var(--md-switch-focus-track-outline-color, var(--md-sys-color-outline, #79747e))}.unselected:active .track::before{background-color:var(--md-switch-pressed-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));border-color:var(--md-switch-pressed-track-outline-color, var(--md-sys-color-outline, #79747e))}.unselected.disabled .track::before{background-color:var(--md-switch-disabled-track-color, var(--md-sys-color-surface-container-highest, #e6e0e9));border-color:var(--md-switch-disabled-track-outline-color, var(--md-sys-color-on-surface, #1d1b20))}}@layer hcm{@media(forced-colors: active){.selected .track::before{background:ButtonText;border-color:ButtonText}.disabled .track::before{border-color:GrayText;opacity:1}.disabled.selected .track::before{background:GrayText}}}@layer styles{.handle-container{display:flex;place-content:center;place-items:center;position:relative;transition:margin 300ms cubic-bezier(0.175, 0.885, 0.32, 1.275)}.selected .handle-container{margin-inline-start:calc(var(--md-switch-track-width, 52px) - var(--md-switch-track-height, 32px))}.unselected .handle-container{margin-inline-end:calc(var(--md-switch-track-width, 52px) - var(--md-switch-track-height, 32px))}.disabled .handle-container{transition:none}.handle{border-start-start-radius:var(--md-switch-handle-shape-start-start, var(--md-switch-handle-shape, var(--md-sys-shape-corner-full, 9999px)));border-start-end-radius:var(--md-switch-handle-shape-start-end, var(--md-switch-handle-shape, var(--md-sys-shape-corner-full, 9999px)));border-end-end-radius:var(--md-switch-handle-shape-end-end, var(--md-switch-handle-shape, var(--md-sys-shape-corner-full, 9999px)));border-end-start-radius:var(--md-switch-handle-shape-end-start, var(--md-switch-handle-shape, var(--md-sys-shape-corner-full, 9999px)));height:var(--md-switch-handle-height, 16px);width:var(--md-switch-handle-width, 16px);transform-origin:center;transition-property:height,width;transition-duration:250ms,250ms;transition-timing-function:cubic-bezier(0.2, 0, 0, 1),cubic-bezier(0.2, 0, 0, 1);z-index:0}.handle::before{content:"";display:flex;inset:0;position:absolute;border-radius:inherit;box-sizing:border-box;transition:background-color 67ms linear}.disabled .handle,.disabled .handle::before{transition:none}.selected .handle{height:var(--md-switch-selected-handle-height, 24px);width:var(--md-switch-selected-handle-width, 24px)}.handle.with-icon{height:var(--md-switch-with-icon-handle-height, 24px);width:var(--md-switch-with-icon-handle-width, 24px)}.selected:not(.disabled):active .handle,.unselected:not(.disabled):active .handle{height:var(--md-switch-pressed-handle-height, 28px);width:var(--md-switch-pressed-handle-width, 28px);transition-timing-function:linear;transition-duration:100ms}.selected .handle::before{background-color:var(--md-switch-selected-handle-color, var(--md-sys-color-on-primary, #fff))}.selected:hover .handle::before{background-color:var(--md-switch-selected-hover-handle-color, var(--md-sys-color-primary-container, #eaddff))}.selected:focus-within .handle::before{background-color:var(--md-switch-selected-focus-handle-color, var(--md-sys-color-primary-container, #eaddff))}.selected:active .handle::before{background-color:var(--md-switch-selected-pressed-handle-color, var(--md-sys-color-primary-container, #eaddff))}.selected.disabled .handle::before{background-color:var(--md-switch-disabled-selected-handle-color, var(--md-sys-color-surface, #fef7ff));opacity:var(--md-switch-disabled-selected-handle-opacity, 1)}.unselected .handle::before{background-color:var(--md-switch-handle-color, var(--md-sys-color-outline, #79747e))}.unselected:hover .handle::before{background-color:var(--md-switch-hover-handle-color, var(--md-sys-color-on-surface-variant, #49454f))}.unselected:focus-within .handle::before{background-color:var(--md-switch-focus-handle-color, var(--md-sys-color-on-surface-variant, #49454f))}.unselected:active .handle::before{background-color:var(--md-switch-pressed-handle-color, var(--md-sys-color-on-surface-variant, #49454f))}.unselected.disabled .handle::before{background-color:var(--md-switch-disabled-handle-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-switch-disabled-handle-opacity, 0.38)}md-ripple{border-radius:var(--md-switch-state-layer-shape, var(--md-sys-shape-corner-full, 9999px));height:var(--md-switch-state-layer-size, 40px);inset:unset;width:var(--md-switch-state-layer-size, 40px)}.selected md-ripple{--md-ripple-hover-color: var(--md-switch-selected-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-pressed-color: var(--md-switch-selected-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--md-ripple-hover-opacity: var(--md-switch-selected-hover-state-layer-opacity, 0.08);--md-ripple-pressed-opacity: var(--md-switch-selected-pressed-state-layer-opacity, 0.12)}.unselected md-ripple{--md-ripple-hover-color: var(--md-switch-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-pressed-color: var(--md-switch-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--md-ripple-hover-opacity: var(--md-switch-hover-state-layer-opacity, 0.08);--md-ripple-pressed-opacity: var(--md-switch-pressed-state-layer-opacity, 0.12)}}@layer hcm{@media(forced-colors: active){.unselected .handle::before{background:ButtonText}.disabled .handle::before{opacity:1}.disabled.unselected .handle::before{background:GrayText}}}@layer styles{.icons{position:relative;height:100%;width:100%}.icon{position:absolute;inset:0;margin:auto;display:flex;align-items:center;justify-content:center;fill:currentColor;transition:fill 67ms linear,opacity 33ms linear,transform 167ms cubic-bezier(0.2, 0, 0, 1);opacity:0}.disabled .icon{transition:none}.selected .icon--on,.unselected .icon--off{opacity:1}.unselected .handle:not(.with-icon) .icon--on{transform:rotate(-45deg)}.icon--off{width:var(--md-switch-icon-size, 16px);height:var(--md-switch-icon-size, 16px);color:var(--md-switch-icon-color, var(--md-sys-color-surface-container-highest, #e6e0e9))}.unselected:hover .icon--off{color:var(--md-switch-hover-icon-color, var(--md-sys-color-surface-container-highest, #e6e0e9))}.unselected:focus-within .icon--off{color:var(--md-switch-focus-icon-color, var(--md-sys-color-surface-container-highest, #e6e0e9))}.unselected:active .icon--off{color:var(--md-switch-pressed-icon-color, var(--md-sys-color-surface-container-highest, #e6e0e9))}.unselected.disabled .icon--off{color:var(--md-switch-disabled-icon-color, var(--md-sys-color-surface-container-highest, #e6e0e9));opacity:var(--md-switch-disabled-icon-opacity, 0.38)}.icon--on{width:var(--md-switch-selected-icon-size, 16px);height:var(--md-switch-selected-icon-size, 16px);color:var(--md-switch-selected-icon-color, var(--md-sys-color-on-primary-container, #21005d))}.selected:hover .icon--on{color:var(--md-switch-selected-hover-icon-color, var(--md-sys-color-on-primary-container, #21005d))}.selected:focus-within .icon--on{color:var(--md-switch-selected-focus-icon-color, var(--md-sys-color-on-primary-container, #21005d))}.selected:active .icon--on{color:var(--md-switch-selected-pressed-icon-color, var(--md-sys-color-on-primary-container, #21005d))}.selected.disabled .icon--on{color:var(--md-switch-disabled-selected-icon-color, var(--md-sys-color-on-surface, #1d1b20));opacity:var(--md-switch-disabled-selected-icon-opacity, 0.38)}}@layer hcm{@media(forced-colors: active){.icon--off{fill:Canvas}.icon--on{fill:ButtonText}.disabled.unselected .icon--off,.disabled.selected .icon--on{opacity:1}.disabled .icon--on{fill:GrayText}}}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdSwitch = class MdSwitch2 extends Switch2 {
};
MdSwitch.styles = [styles$7];
MdSwitch = __decorate([
  t$3("md-switch")
], MdSwitch);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
var _a$1;
const INDICATOR = Symbol("indicator");
const ANIMATE_INDICATOR = Symbol("animateIndicator");
const tabBaseClass = mixinFocusable(s$1);
let Tab$1 = class Tab extends tabBaseClass {
  /**
   * @deprecated use `active`
   */
  get selected() {
    return this.active;
  }
  set selected(active) {
    this.active = active;
  }
  constructor() {
    super();
    this.isTab = true;
    this.active = false;
    this.hasIcon = false;
    this.iconOnly = false;
    this.fullWidthIndicator = false;
    this.internals = // Cast needed for closure
    this.attachInternals();
    {
      this.internals.role = "tab";
      this.addEventListener("keydown", this.handleKeydown.bind(this));
    }
  }
  render() {
    const indicator = x$1`<div class="indicator"></div>`;
    return x$1`<div
      class="button"
      role="presentation"
      @click=${this.handleContentClick}>
      <md-focus-ring part="focus-ring" inward .control=${this}></md-focus-ring>
      <md-elevation part="elevation"></md-elevation>
      <md-ripple .control=${this}></md-ripple>
      <div
        class="content ${e$1(this.getContentClasses())}"
        role="presentation">
        <slot name="icon" @slotchange=${this.handleIconSlotChange}></slot>
        <slot @slotchange=${this.handleSlotChange}></slot>
        ${this.fullWidthIndicator ? T$1 : indicator}
      </div>
      ${this.fullWidthIndicator ? indicator : T$1}
    </div>`;
  }
  getContentClasses() {
    return {
      "has-icon": this.hasIcon,
      "has-label": !this.iconOnly
    };
  }
  updated() {
    this.internals.ariaSelected = String(this.active);
  }
  async handleKeydown(event) {
    await 0;
    if (event.defaultPrevented) {
      return;
    }
    if (event.key === "Enter" || event.key === " ") {
      event.preventDefault();
      this.click();
    }
  }
  handleContentClick(event) {
    event.stopPropagation();
    this.click();
  }
  [(_a$1 = INDICATOR, ANIMATE_INDICATOR)](previousTab) {
    if (!this[INDICATOR]) {
      return;
    }
    this[INDICATOR].getAnimations().forEach((a2) => {
      a2.cancel();
    });
    const frames = this.getKeyframes(previousTab);
    if (frames !== null) {
      this[INDICATOR].animate(frames, {
        duration: 250,
        easing: EASING.EMPHASIZED
      });
    }
  }
  getKeyframes(previousTab) {
    const reduceMotion = shouldReduceMotion();
    if (!this.active) {
      return reduceMotion ? [{ "opacity": 1 }, { "transform": "none" }] : null;
    }
    const from = {};
    const fromRect = previousTab[INDICATOR]?.getBoundingClientRect() ?? {};
    const fromPos = fromRect.left;
    const fromExtent = fromRect.width;
    const toRect = this[INDICATOR].getBoundingClientRect();
    const toPos = toRect.left;
    const toExtent = toRect.width;
    const scale = fromExtent / toExtent;
    if (!reduceMotion && fromPos !== void 0 && toPos !== void 0 && !isNaN(scale)) {
      from["transform"] = `translateX(${(fromPos - toPos).toFixed(4)}px) scaleX(${scale.toFixed(4)})`;
    } else {
      from["opacity"] = 0;
    }
    return [from, { "transform": "none" }];
  }
  handleSlotChange() {
    this.iconOnly = false;
    for (const node of this.assignedDefaultNodes) {
      const hasTextContent = node.nodeType === Node.TEXT_NODE && !!node.wholeText.match(/\S/);
      if (node.nodeType === Node.ELEMENT_NODE || hasTextContent) {
        return;
      }
    }
    this.iconOnly = true;
  }
  handleIconSlotChange() {
    this.hasIcon = this.assignedIcons.length > 0;
  }
};
__decorate([
  n$5({ type: Boolean, reflect: true, attribute: "md-tab" })
], Tab$1.prototype, "isTab", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], Tab$1.prototype, "active", void 0);
__decorate([
  n$5({ type: Boolean })
], Tab$1.prototype, "selected", null);
__decorate([
  n$5({ type: Boolean, attribute: "has-icon" })
], Tab$1.prototype, "hasIcon", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "icon-only" })
], Tab$1.prototype, "iconOnly", void 0);
__decorate([
  e$5(".indicator")
], Tab$1.prototype, _a$1, void 0);
__decorate([
  r$4()
], Tab$1.prototype, "fullWidthIndicator", void 0);
__decorate([
  n$4({ flatten: true })
], Tab$1.prototype, "assignedDefaultNodes", void 0);
__decorate([
  o$4({ slot: "icon", flatten: true })
], Tab$1.prototype, "assignedIcons", void 0);
function shouldReduceMotion() {
  return window.matchMedia("(prefers-reduced-motion: reduce)").matches;
}
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class PrimaryTab extends Tab$1 {
  constructor() {
    super(...arguments);
    this.inlineIcon = false;
  }
  getContentClasses() {
    return {
      ...super.getContentClasses(),
      "stacked": !this.inlineIcon
    };
  }
}
__decorate([
  n$5({ type: Boolean, attribute: "inline-icon" })
], PrimaryTab.prototype, "inlineIcon", void 0);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$6 = i$4`:host{--_active-indicator-color: var(--md-primary-tab-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_active-indicator-height: var(--md-primary-tab-active-indicator-height, 3px);--_active-indicator-shape: var(--md-primary-tab-active-indicator-shape, 3px 3px 0px 0px);--_active-hover-state-layer-color: var(--md-primary-tab-active-hover-state-layer-color, var(--md-sys-color-primary, #6750a4));--_active-hover-state-layer-opacity: var(--md-primary-tab-active-hover-state-layer-opacity, 0.08);--_active-pressed-state-layer-color: var(--md-primary-tab-active-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_active-pressed-state-layer-opacity: var(--md-primary-tab-active-pressed-state-layer-opacity, 0.12);--_container-color: var(--md-primary-tab-container-color, var(--md-sys-color-surface, #fef7ff));--_container-elevation: var(--md-primary-tab-container-elevation, 0);--_container-height: var(--md-primary-tab-container-height, 48px);--_with-icon-and-label-text-container-height: var(--md-primary-tab-with-icon-and-label-text-container-height, 64px);--_hover-state-layer-color: var(--md-primary-tab-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-opacity: var(--md-primary-tab-hover-state-layer-opacity, 0.08);--_pressed-state-layer-color: var(--md-primary-tab-pressed-state-layer-color, var(--md-sys-color-primary, #6750a4));--_pressed-state-layer-opacity: var(--md-primary-tab-pressed-state-layer-opacity, 0.12);--_active-focus-icon-color: var(--md-primary-tab-active-focus-icon-color, var(--md-sys-color-primary, #6750a4));--_active-hover-icon-color: var(--md-primary-tab-active-hover-icon-color, var(--md-sys-color-primary, #6750a4));--_active-icon-color: var(--md-primary-tab-active-icon-color, var(--md-sys-color-primary, #6750a4));--_active-pressed-icon-color: var(--md-primary-tab-active-pressed-icon-color, var(--md-sys-color-primary, #6750a4));--_icon-size: var(--md-primary-tab-icon-size, 24px);--_focus-icon-color: var(--md-primary-tab-focus-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-icon-color: var(--md-primary-tab-hover-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_icon-color: var(--md-primary-tab-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-icon-color: var(--md-primary-tab-pressed-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_label-text-font: var(--md-primary-tab-label-text-font, var(--md-sys-typescale-title-small-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-primary-tab-label-text-line-height, var(--md-sys-typescale-title-small-line-height, 1.25rem));--_label-text-size: var(--md-primary-tab-label-text-size, var(--md-sys-typescale-title-small-size, 0.875rem));--_label-text-weight: var(--md-primary-tab-label-text-weight, var(--md-sys-typescale-title-small-weight, var(--md-ref-typeface-weight-medium, 500)));--_active-focus-label-text-color: var(--md-primary-tab-active-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_active-hover-label-text-color: var(--md-primary-tab-active-hover-label-text-color, var(--md-sys-color-primary, #6750a4));--_active-label-text-color: var(--md-primary-tab-active-label-text-color, var(--md-sys-color-primary, #6750a4));--_active-pressed-label-text-color: var(--md-primary-tab-active-pressed-label-text-color, var(--md-sys-color-primary, #6750a4));--_focus-label-text-color: var(--md-primary-tab-focus-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-primary-tab-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_label-text-color: var(--md-primary-tab-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-label-text-color: var(--md-primary-tab-pressed-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_container-shape-start-start: var(--md-primary-tab-container-shape-start-start, var(--md-primary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-start-end: var(--md-primary-tab-container-shape-start-end, var(--md-primary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-end: var(--md-primary-tab-container-shape-end-end, var(--md-primary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-start: var(--md-primary-tab-container-shape-end-start, var(--md-primary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)))}.content.stacked{flex-direction:column;gap:2px}.content.stacked.has-icon.has-label{height:var(--_with-icon-and-label-text-container-height)}
`;
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$5 = i$4`:host{display:inline-flex;align-items:center;justify-content:center;outline:none;padding:0 16px;position:relative;-webkit-tap-highlight-color:rgba(0,0,0,0);vertical-align:middle;user-select:none;font-family:var(--_label-text-font);font-size:var(--_label-text-size);line-height:var(--_label-text-line-height);font-weight:var(--_label-text-weight);color:var(--_label-text-color);z-index:0;--md-ripple-hover-color: var(--_hover-state-layer-color);--md-ripple-hover-opacity: var(--_hover-state-layer-opacity);--md-ripple-pressed-color: var(--_pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_pressed-state-layer-opacity);--md-elevation-level: var(--_container-elevation)}md-focus-ring{--md-focus-ring-shape: 8px}:host([active]) md-focus-ring{margin-bottom:calc(var(--_active-indicator-height) + 1px)}.button::before{background:var(--_container-color);content:"";inset:0;position:absolute;z-index:-1}.button::before,md-ripple,md-elevation{border-start-start-radius:var(--_container-shape-start-start);border-start-end-radius:var(--_container-shape-start-end);border-end-end-radius:var(--_container-shape-end-end);border-end-start-radius:var(--_container-shape-end-start)}.content{position:relative;box-sizing:border-box;display:inline-flex;flex-direction:row;align-items:center;justify-content:center;height:var(--_container-height);gap:8px}.indicator{position:absolute;box-sizing:border-box;z-index:-1;transform-origin:bottom left;background:var(--_active-indicator-color);border-radius:var(--_active-indicator-shape);height:var(--_active-indicator-height);inset:auto 0 0 0;opacity:0}::slotted([slot=icon]){display:inline-flex;position:relative;writing-mode:horizontal-tb;fill:currentColor;color:var(--_icon-color);font-size:var(--_icon-size);width:var(--_icon-size);height:var(--_icon-size)}:host(:hover){color:var(--_hover-label-text-color);cursor:pointer}:host(:hover) ::slotted([slot=icon]){color:var(--_hover-icon-color)}:host(:focus){color:var(--_focus-label-text-color)}:host(:focus) ::slotted([slot=icon]){color:var(--_focus-icon-color)}:host(:active){color:var(--_pressed-label-text-color)}:host(:active) ::slotted([slot=icon]){color:var(--_pressed-icon-color)}:host([active]) .indicator{opacity:1}:host([active]){color:var(--_active-label-text-color);--md-ripple-hover-color: var(--_active-hover-state-layer-color);--md-ripple-hover-opacity: var(--_active-hover-state-layer-opacity);--md-ripple-pressed-color: var(--_active-pressed-state-layer-color);--md-ripple-pressed-opacity: var(--_active-pressed-state-layer-opacity)}:host([active]) ::slotted([slot=icon]){color:var(--_active-icon-color)}:host([active]:hover){color:var(--_active-hover-label-text-color)}:host([active]:hover) ::slotted([slot=icon]){color:var(--_active-hover-icon-color)}:host([active]:focus){color:var(--_active-focus-label-text-color)}:host([active]:focus) ::slotted([slot=icon]){color:var(--_active-focus-icon-color)}:host([active]:active){color:var(--_active-pressed-label-text-color)}:host([active]:active) ::slotted([slot=icon]){color:var(--_active-pressed-icon-color)}:host,::slotted(*){white-space:nowrap}@media(forced-colors: active){.indicator{background:CanvasText}}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdPrimaryTab = class MdPrimaryTab2 extends PrimaryTab {
};
MdPrimaryTab.styles = [styles$5, styles$6];
MdPrimaryTab = __decorate([
  t$3("md-primary-tab")
], MdPrimaryTab);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class SecondaryTab extends Tab$1 {
  constructor() {
    super(...arguments);
    this.fullWidthIndicator = true;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$4 = i$4`:host{--_active-indicator-color: var(--md-secondary-tab-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_active-indicator-height: var(--md-secondary-tab-active-indicator-height, 2px);--_active-label-text-color: var(--md-secondary-tab-active-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_container-color: var(--md-secondary-tab-container-color, var(--md-sys-color-surface, #fef7ff));--_container-elevation: var(--md-secondary-tab-container-elevation, 0);--_container-height: var(--md-secondary-tab-container-height, 48px);--_focus-label-text-color: var(--md-secondary-tab-focus-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-secondary-tab-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-color: var(--md-secondary-tab-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-opacity: var(--md-secondary-tab-hover-state-layer-opacity, 0.08);--_label-text-font: var(--md-secondary-tab-label-text-font, var(--md-sys-typescale-title-small-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-secondary-tab-label-text-line-height, var(--md-sys-typescale-title-small-line-height, 1.25rem));--_label-text-size: var(--md-secondary-tab-label-text-size, var(--md-sys-typescale-title-small-size, 0.875rem));--_label-text-weight: var(--md-secondary-tab-label-text-weight, var(--md-sys-typescale-title-small-weight, var(--md-ref-typeface-weight-medium, 500)));--_pressed-label-text-color: var(--md-secondary-tab-pressed-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_pressed-state-layer-color: var(--md-secondary-tab-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_pressed-state-layer-opacity: var(--md-secondary-tab-pressed-state-layer-opacity, 0.12);--_active-focus-icon-color: var(--md-secondary-tab-active-focus-icon-color, );--_active-focus-label-text-color: var(--md-secondary-tab-active-focus-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_active-hover-icon-color: var(--md-secondary-tab-active-hover-icon-color, );--_active-hover-label-text-color: var(--md-secondary-tab-active-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_active-hover-state-layer-color: var(--md-secondary-tab-active-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_active-hover-state-layer-opacity: var(--md-secondary-tab-active-hover-state-layer-opacity, 0.08);--_active-icon-color: var(--md-secondary-tab-active-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_active-indicator-shape: var(--md-secondary-tab-active-indicator-shape, 0);--_active-pressed-icon-color: var(--md-secondary-tab-active-pressed-icon-color, );--_active-pressed-label-text-color: var(--md-secondary-tab-active-pressed-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_active-pressed-state-layer-color: var(--md-secondary-tab-active-pressed-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_active-pressed-state-layer-opacity: var(--md-secondary-tab-active-pressed-state-layer-opacity, 0.12);--_label-text-color: var(--md-secondary-tab-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-icon-color: var(--md-secondary-tab-focus-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-icon-color: var(--md-secondary-tab-hover-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_icon-size: var(--md-secondary-tab-icon-size, 24px);--_icon-color: var(--md-secondary-tab-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_pressed-icon-color: var(--md-secondary-tab-pressed-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_container-shape-start-start: var(--md-secondary-tab-container-shape-start-start, var(--md-secondary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-start-end: var(--md-secondary-tab-container-shape-start-end, var(--md-secondary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-end: var(--md-secondary-tab-container-shape-end-end, var(--md-secondary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-start: var(--md-secondary-tab-container-shape-end-start, var(--md-secondary-tab-container-shape, var(--md-sys-shape-corner-none, 0px)))}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdSecondaryTab = class MdSecondaryTab2 extends SecondaryTab {
};
MdSecondaryTab.styles = [styles$5, styles$4];
MdSecondaryTab = __decorate([
  t$3("md-secondary-tab")
], MdSecondaryTab);
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class Tabs extends s$1 {
  /**
   * The currently selected tab, `null` only when there are no tab children.
   *
   * @export
   */
  get activeTab() {
    return this.tabs.find((tab) => tab.active) ?? null;
  }
  set activeTab(tab) {
    if (tab) {
      this.activateTab(tab);
    }
  }
  /**
   * The index of the currently selected tab.
   *
   * @export
   */
  get activeTabIndex() {
    return this.tabs.findIndex((tab) => tab.active);
  }
  set activeTabIndex(index) {
    const activateTabAtIndex = () => {
      const tab = this.tabs[index];
      if (tab) {
        this.activateTab(tab);
      }
    };
    if (!this.slotElement) {
      this.updateComplete.then(activateTabAtIndex);
      return;
    }
    activateTabAtIndex();
  }
  get focusedTab() {
    return this.tabs.find((tab) => tab.matches(":focus-within"));
  }
  constructor() {
    super();
    this.autoActivate = false;
    this.internals = // Cast needed for closure
    this.attachInternals();
    {
      this.internals.role = "tablist";
      this.addEventListener("keydown", this.handleKeydown.bind(this));
      this.addEventListener("keyup", this.handleKeyup.bind(this));
      this.addEventListener("focusout", this.handleFocusout.bind(this));
    }
  }
  /**
   * Scrolls the toolbar, if overflowing, to the active tab, or the provided
   * tab.
   *
   * @param tabToScrollTo The tab that should be scrolled to. Defaults to the
   *     active tab.
   * @return A Promise that resolves after the tab has been scrolled to.
   */
  async scrollToTab(tabToScrollTo) {
    await this.updateComplete;
    const { tabs } = this;
    tabToScrollTo ??= this.activeTab;
    if (!tabToScrollTo || !tabs.includes(tabToScrollTo) || !this.tabsScrollerElement) {
      return;
    }
    for (const tab of this.tabs) {
      await tab.updateComplete;
    }
    const offset2 = tabToScrollTo.offsetLeft;
    const extent = tabToScrollTo.offsetWidth;
    const scroll = this.scrollLeft;
    const hostExtent = this.offsetWidth;
    const scrollMargin = 48;
    const min2 = offset2 - scrollMargin;
    const max2 = offset2 + extent - hostExtent + scrollMargin;
    const to = Math.min(min2, Math.max(max2, scroll));
    const behavior = !this.focusedTab ? "instant" : "auto";
    this.tabsScrollerElement.scrollTo({ behavior, top: 0, left: to });
  }
  render() {
    return x$1`
      <div class="tabs">
        <slot
          @slotchange=${this.handleSlotChange}
          @click=${this.handleTabClick}></slot>
      </div>
      <md-divider part="divider"></md-divider>
    `;
  }
  async handleTabClick(event) {
    const tab = event.target;
    await 0;
    if (event.defaultPrevented || !isTab(tab) || tab.active) {
      return;
    }
    this.activateTab(tab);
  }
  activateTab(activeTab) {
    const { tabs } = this;
    const previousTab = this.activeTab;
    if (!tabs.includes(activeTab) || previousTab === activeTab) {
      return;
    }
    for (const tab of tabs) {
      tab.active = tab === activeTab;
    }
    if (previousTab) {
      const defaultPrevented = !this.dispatchEvent(new Event("change", { bubbles: true, cancelable: true }));
      if (defaultPrevented) {
        for (const tab of tabs) {
          tab.active = tab === previousTab;
        }
        return;
      }
      activeTab[ANIMATE_INDICATOR](previousTab);
    }
    this.updateFocusableTab(activeTab);
    this.scrollToTab(activeTab);
  }
  updateFocusableTab(focusableTab) {
    for (const tab of this.tabs) {
      tab.tabIndex = tab === focusableTab ? 0 : -1;
    }
  }
  // focus item on keydown and optionally select it
  async handleKeydown(event) {
    await 0;
    const isLeft = event.key === "ArrowLeft";
    const isRight = event.key === "ArrowRight";
    const isHome = event.key === "Home";
    const isEnd = event.key === "End";
    if (event.defaultPrevented || !isLeft && !isRight && !isHome && !isEnd) {
      return;
    }
    const { tabs } = this;
    if (tabs.length < 2) {
      return;
    }
    event.preventDefault();
    let indexToFocus;
    if (isHome || isEnd) {
      indexToFocus = isHome ? 0 : tabs.length - 1;
    } else {
      const isRtl2 = getComputedStyle(this).direction === "rtl";
      const forwards = isRtl2 ? isLeft : isRight;
      const { focusedTab } = this;
      if (!focusedTab) {
        indexToFocus = forwards ? 0 : tabs.length - 1;
      } else {
        const focusedIndex = this.tabs.indexOf(focusedTab);
        indexToFocus = forwards ? focusedIndex + 1 : focusedIndex - 1;
        if (indexToFocus >= tabs.length) {
          indexToFocus = 0;
        } else if (indexToFocus < 0) {
          indexToFocus = tabs.length - 1;
        }
      }
    }
    const tabToFocus = tabs[indexToFocus];
    tabToFocus.focus();
    if (this.autoActivate) {
      this.activateTab(tabToFocus);
    } else {
      this.updateFocusableTab(tabToFocus);
    }
  }
  // scroll to item on keyup.
  handleKeyup() {
    this.scrollToTab(this.focusedTab ?? this.activeTab);
  }
  handleFocusout() {
    if (this.matches(":focus-within")) {
      return;
    }
    const { activeTab } = this;
    if (activeTab) {
      this.updateFocusableTab(activeTab);
    }
  }
  handleSlotChange() {
    const firstTab = this.tabs[0];
    if (!this.activeTab && firstTab) {
      this.activateTab(firstTab);
    }
    this.scrollToTab(this.activeTab);
  }
}
__decorate([
  o$4({ flatten: true, selector: "[md-tab]" })
], Tabs.prototype, "tabs", void 0);
__decorate([
  n$5({ type: Number, attribute: "active-tab-index" })
], Tabs.prototype, "activeTabIndex", null);
__decorate([
  n$5({ type: Boolean, attribute: "auto-activate" })
], Tabs.prototype, "autoActivate", void 0);
__decorate([
  e$5(".tabs")
], Tabs.prototype, "tabsScrollerElement", void 0);
__decorate([
  e$5("slot")
], Tabs.prototype, "slotElement", void 0);
function isTab(element) {
  return element instanceof HTMLElement && element.hasAttribute("md-tab");
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$3 = i$4`:host{box-sizing:border-box;display:flex;flex-direction:column;overflow:auto;scroll-behavior:smooth;scrollbar-width:none;position:relative}:host([hidden]){display:none}:host::-webkit-scrollbar{display:none}.tabs{align-items:end;display:flex;height:100%;overflow:inherit;scroll-behavior:inherit;scrollbar-width:inherit;justify-content:space-between;width:100%}::slotted(*){flex:1}::slotted([active]){z-index:1}
`;
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdTabs = class MdTabs2 extends Tabs {
};
MdTabs.styles = [styles$3];
MdTabs = __decorate([
  t$3("md-tabs")
], MdTabs);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$2 = i$4`:host{--_active-indicator-color: var(--md-filled-text-field-active-indicator-color, var(--md-sys-color-on-surface-variant, #49454f));--_active-indicator-height: var(--md-filled-text-field-active-indicator-height, 1px);--_caret-color: var(--md-filled-text-field-caret-color, var(--md-sys-color-primary, #6750a4));--_container-color: var(--md-filled-text-field-container-color, var(--md-sys-color-surface-container-highest, #e6e0e9));--_disabled-active-indicator-color: var(--md-filled-text-field-disabled-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-active-indicator-height: var(--md-filled-text-field-disabled-active-indicator-height, 1px);--_disabled-active-indicator-opacity: var(--md-filled-text-field-disabled-active-indicator-opacity, 0.38);--_disabled-container-color: var(--md-filled-text-field-disabled-container-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-container-opacity: var(--md-filled-text-field-disabled-container-opacity, 0.04);--_disabled-input-text-color: var(--md-filled-text-field-disabled-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-input-text-opacity: var(--md-filled-text-field-disabled-input-text-opacity, 0.38);--_disabled-label-text-color: var(--md-filled-text-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-filled-text-field-disabled-label-text-opacity, 0.38);--_disabled-leading-icon-color: var(--md-filled-text-field-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-filled-text-field-disabled-leading-icon-opacity, 0.38);--_disabled-supporting-text-color: var(--md-filled-text-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-supporting-text-opacity: var(--md-filled-text-field-disabled-supporting-text-opacity, 0.38);--_disabled-trailing-icon-color: var(--md-filled-text-field-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-icon-opacity: var(--md-filled-text-field-disabled-trailing-icon-opacity, 0.38);--_error-active-indicator-color: var(--md-filled-text-field-error-active-indicator-color, var(--md-sys-color-error, #b3261e));--_error-focus-active-indicator-color: var(--md-filled-text-field-error-focus-active-indicator-color, var(--md-sys-color-error, #b3261e));--_error-focus-caret-color: var(--md-filled-text-field-error-focus-caret-color, var(--md-sys-color-error, #b3261e));--_error-focus-input-text-color: var(--md-filled-text-field-error-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-focus-label-text-color: var(--md-filled-text-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-leading-icon-color: var(--md-filled-text-field-error-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-focus-supporting-text-color: var(--md-filled-text-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-trailing-icon-color: var(--md-filled-text-field-error-focus-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_error-hover-active-indicator-color: var(--md-filled-text-field-error-hover-active-indicator-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-input-text-color: var(--md-filled-text-field-error-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-label-text-color: var(--md-filled-text-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-leading-icon-color: var(--md-filled-text-field-error-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-hover-state-layer-color: var(--md-filled-text-field-error-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-state-layer-opacity: var(--md-filled-text-field-error-hover-state-layer-opacity, 0.08);--_error-hover-supporting-text-color: var(--md-filled-text-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-hover-trailing-icon-color: var(--md-filled-text-field-error-hover-trailing-icon-color, var(--md-sys-color-on-error-container, #410e0b));--_error-input-text-color: var(--md-filled-text-field-error-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-label-text-color: var(--md-filled-text-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_error-leading-icon-color: var(--md-filled-text-field-error-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-supporting-text-color: var(--md-filled-text-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-trailing-icon-color: var(--md-filled-text-field-error-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_focus-active-indicator-color: var(--md-filled-text-field-focus-active-indicator-color, var(--md-sys-color-primary, #6750a4));--_focus-active-indicator-height: var(--md-filled-text-field-focus-active-indicator-height, 3px);--_focus-input-text-color: var(--md-filled-text-field-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_focus-label-text-color: var(--md-filled-text-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_focus-leading-icon-color: var(--md-filled-text-field-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-supporting-text-color: var(--md-filled-text-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-trailing-icon-color: var(--md-filled-text-field-focus-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-active-indicator-color: var(--md-filled-text-field-hover-active-indicator-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-active-indicator-height: var(--md-filled-text-field-hover-active-indicator-height, 1px);--_hover-input-text-color: var(--md-filled-text-field-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-filled-text-field-hover-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-leading-icon-color: var(--md-filled-text-field-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-state-layer-color: var(--md-filled-text-field-hover-state-layer-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-state-layer-opacity: var(--md-filled-text-field-hover-state-layer-opacity, 0.08);--_hover-supporting-text-color: var(--md-filled-text-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-icon-color: var(--md-filled-text-field-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-color: var(--md-filled-text-field-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_input-text-font: var(--md-filled-text-field-input-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_input-text-line-height: var(--md-filled-text-field-input-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_input-text-placeholder-color: var(--md-filled-text-field-input-text-placeholder-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-prefix-color: var(--md-filled-text-field-input-text-prefix-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-size: var(--md-filled-text-field-input-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_input-text-suffix-color: var(--md-filled-text-field-input-text-suffix-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-weight: var(--md-filled-text-field-input-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_label-text-color: var(--md-filled-text-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-font: var(--md-filled-text-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-filled-text-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_label-text-populated-line-height: var(--md-filled-text-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_label-text-populated-size: var(--md-filled-text-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_label-text-size: var(--md-filled-text-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_label-text-weight: var(--md-filled-text-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_leading-icon-color: var(--md-filled-text-field-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_leading-icon-size: var(--md-filled-text-field-leading-icon-size, 24px);--_supporting-text-color: var(--md-filled-text-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_supporting-text-font: var(--md-filled-text-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_supporting-text-line-height: var(--md-filled-text-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_supporting-text-size: var(--md-filled-text-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_supporting-text-weight: var(--md-filled-text-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_trailing-icon-color: var(--md-filled-text-field-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-icon-size: var(--md-filled-text-field-trailing-icon-size, 24px);--_container-shape-start-start: var(--md-filled-text-field-container-shape-start-start, var(--md-filled-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-start-end: var(--md-filled-text-field-container-shape-start-end, var(--md-filled-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-end: var(--md-filled-text-field-container-shape-end-end, var(--md-filled-text-field-container-shape, var(--md-sys-shape-corner-none, 0px)));--_container-shape-end-start: var(--md-filled-text-field-container-shape-end-start, var(--md-filled-text-field-container-shape, var(--md-sys-shape-corner-none, 0px)));--_icon-input-space: var(--md-filled-text-field-icon-input-space, 16px);--_leading-space: var(--md-filled-text-field-leading-space, 16px);--_trailing-space: var(--md-filled-text-field-trailing-space, 16px);--_top-space: var(--md-filled-text-field-top-space, 16px);--_bottom-space: var(--md-filled-text-field-bottom-space, 16px);--_input-text-prefix-trailing-space: var(--md-filled-text-field-input-text-prefix-trailing-space, 2px);--_input-text-suffix-leading-space: var(--md-filled-text-field-input-text-suffix-leading-space, 2px);--_with-label-top-space: var(--md-filled-text-field-with-label-top-space, 8px);--_with-label-bottom-space: var(--md-filled-text-field-with-label-bottom-space, 8px);--_focus-caret-color: var(--md-filled-text-field-focus-caret-color, var(--md-sys-color-primary, #6750a4));--_with-leading-icon-leading-space: var(--md-filled-text-field-with-leading-icon-leading-space, 12px);--_with-trailing-icon-trailing-space: var(--md-filled-text-field-with-trailing-icon-trailing-space, 12px);--md-filled-field-active-indicator-color: var(--_active-indicator-color);--md-filled-field-active-indicator-height: var(--_active-indicator-height);--md-filled-field-bottom-space: var(--_bottom-space);--md-filled-field-container-color: var(--_container-color);--md-filled-field-container-shape-end-end: var(--_container-shape-end-end);--md-filled-field-container-shape-end-start: var(--_container-shape-end-start);--md-filled-field-container-shape-start-end: var(--_container-shape-start-end);--md-filled-field-container-shape-start-start: var(--_container-shape-start-start);--md-filled-field-content-color: var(--_input-text-color);--md-filled-field-content-font: var(--_input-text-font);--md-filled-field-content-line-height: var(--_input-text-line-height);--md-filled-field-content-size: var(--_input-text-size);--md-filled-field-content-space: var(--_icon-input-space);--md-filled-field-content-weight: var(--_input-text-weight);--md-filled-field-disabled-active-indicator-color: var(--_disabled-active-indicator-color);--md-filled-field-disabled-active-indicator-height: var(--_disabled-active-indicator-height);--md-filled-field-disabled-active-indicator-opacity: var(--_disabled-active-indicator-opacity);--md-filled-field-disabled-container-color: var(--_disabled-container-color);--md-filled-field-disabled-container-opacity: var(--_disabled-container-opacity);--md-filled-field-disabled-content-color: var(--_disabled-input-text-color);--md-filled-field-disabled-content-opacity: var(--_disabled-input-text-opacity);--md-filled-field-disabled-label-text-color: var(--_disabled-label-text-color);--md-filled-field-disabled-label-text-opacity: var(--_disabled-label-text-opacity);--md-filled-field-disabled-leading-content-color: var(--_disabled-leading-icon-color);--md-filled-field-disabled-leading-content-opacity: var(--_disabled-leading-icon-opacity);--md-filled-field-disabled-supporting-text-color: var(--_disabled-supporting-text-color);--md-filled-field-disabled-supporting-text-opacity: var(--_disabled-supporting-text-opacity);--md-filled-field-disabled-trailing-content-color: var(--_disabled-trailing-icon-color);--md-filled-field-disabled-trailing-content-opacity: var(--_disabled-trailing-icon-opacity);--md-filled-field-error-active-indicator-color: var(--_error-active-indicator-color);--md-filled-field-error-content-color: var(--_error-input-text-color);--md-filled-field-error-focus-active-indicator-color: var(--_error-focus-active-indicator-color);--md-filled-field-error-focus-content-color: var(--_error-focus-input-text-color);--md-filled-field-error-focus-label-text-color: var(--_error-focus-label-text-color);--md-filled-field-error-focus-leading-content-color: var(--_error-focus-leading-icon-color);--md-filled-field-error-focus-supporting-text-color: var(--_error-focus-supporting-text-color);--md-filled-field-error-focus-trailing-content-color: var(--_error-focus-trailing-icon-color);--md-filled-field-error-hover-active-indicator-color: var(--_error-hover-active-indicator-color);--md-filled-field-error-hover-content-color: var(--_error-hover-input-text-color);--md-filled-field-error-hover-label-text-color: var(--_error-hover-label-text-color);--md-filled-field-error-hover-leading-content-color: var(--_error-hover-leading-icon-color);--md-filled-field-error-hover-state-layer-color: var(--_error-hover-state-layer-color);--md-filled-field-error-hover-state-layer-opacity: var(--_error-hover-state-layer-opacity);--md-filled-field-error-hover-supporting-text-color: var(--_error-hover-supporting-text-color);--md-filled-field-error-hover-trailing-content-color: var(--_error-hover-trailing-icon-color);--md-filled-field-error-label-text-color: var(--_error-label-text-color);--md-filled-field-error-leading-content-color: var(--_error-leading-icon-color);--md-filled-field-error-supporting-text-color: var(--_error-supporting-text-color);--md-filled-field-error-trailing-content-color: var(--_error-trailing-icon-color);--md-filled-field-focus-active-indicator-color: var(--_focus-active-indicator-color);--md-filled-field-focus-active-indicator-height: var(--_focus-active-indicator-height);--md-filled-field-focus-content-color: var(--_focus-input-text-color);--md-filled-field-focus-label-text-color: var(--_focus-label-text-color);--md-filled-field-focus-leading-content-color: var(--_focus-leading-icon-color);--md-filled-field-focus-supporting-text-color: var(--_focus-supporting-text-color);--md-filled-field-focus-trailing-content-color: var(--_focus-trailing-icon-color);--md-filled-field-hover-active-indicator-color: var(--_hover-active-indicator-color);--md-filled-field-hover-active-indicator-height: var(--_hover-active-indicator-height);--md-filled-field-hover-content-color: var(--_hover-input-text-color);--md-filled-field-hover-label-text-color: var(--_hover-label-text-color);--md-filled-field-hover-leading-content-color: var(--_hover-leading-icon-color);--md-filled-field-hover-state-layer-color: var(--_hover-state-layer-color);--md-filled-field-hover-state-layer-opacity: var(--_hover-state-layer-opacity);--md-filled-field-hover-supporting-text-color: var(--_hover-supporting-text-color);--md-filled-field-hover-trailing-content-color: var(--_hover-trailing-icon-color);--md-filled-field-label-text-color: var(--_label-text-color);--md-filled-field-label-text-font: var(--_label-text-font);--md-filled-field-label-text-line-height: var(--_label-text-line-height);--md-filled-field-label-text-populated-line-height: var(--_label-text-populated-line-height);--md-filled-field-label-text-populated-size: var(--_label-text-populated-size);--md-filled-field-label-text-size: var(--_label-text-size);--md-filled-field-label-text-weight: var(--_label-text-weight);--md-filled-field-leading-content-color: var(--_leading-icon-color);--md-filled-field-leading-space: var(--_leading-space);--md-filled-field-supporting-text-color: var(--_supporting-text-color);--md-filled-field-supporting-text-font: var(--_supporting-text-font);--md-filled-field-supporting-text-line-height: var(--_supporting-text-line-height);--md-filled-field-supporting-text-size: var(--_supporting-text-size);--md-filled-field-supporting-text-weight: var(--_supporting-text-weight);--md-filled-field-top-space: var(--_top-space);--md-filled-field-trailing-content-color: var(--_trailing-icon-color);--md-filled-field-trailing-space: var(--_trailing-space);--md-filled-field-with-label-bottom-space: var(--_with-label-bottom-space);--md-filled-field-with-label-top-space: var(--_with-label-top-space);--md-filled-field-with-leading-content-leading-space: var(--_with-leading-icon-leading-space);--md-filled-field-with-trailing-content-trailing-space: var(--_with-trailing-icon-trailing-space)}
`;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const f = (o2) => void 0 === o2.strings, u = {}, m = (o2, t2 = u) => o2._$AH = t2;
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const l = e$2(class extends i$1 {
  constructor(r2) {
    if (super(r2), r2.type !== t.PROPERTY && r2.type !== t.ATTRIBUTE && r2.type !== t.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
    if (!f(r2)) throw Error("`live` bindings can only contain a single expression");
  }
  render(r2) {
    return r2;
  }
  update(i3, [t$12]) {
    if (t$12 === w$1 || t$12 === T$1) return t$12;
    const o2 = i3.element, l2 = i3.name;
    if (i3.type === t.PROPERTY) {
      if (t$12 === o2[l2]) return w$1;
    } else if (i3.type === t.BOOLEAN_ATTRIBUTE) {
      if (!!t$12 === o2.hasAttribute(l2)) return w$1;
    } else if (i3.type === t.ATTRIBUTE && o2.getAttribute(l2) === t$12 + "") return w$1;
    return m(i3), t$12;
  }
});
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const stringConverter = {
  fromAttribute(value) {
    return value ?? "";
  },
  toAttribute(value) {
    return value || null;
  }
};
/**
 * @license
 * Copyright 2023 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class TextFieldValidator extends Validator {
  computeValidity({ state, renderedControl }) {
    let inputOrTextArea = renderedControl;
    if (isInputState(state) && !inputOrTextArea) {
      inputOrTextArea = this.inputControl || document.createElement("input");
      this.inputControl = inputOrTextArea;
    } else if (!inputOrTextArea) {
      inputOrTextArea = this.textAreaControl || document.createElement("textarea");
      this.textAreaControl = inputOrTextArea;
    }
    const input = isInputState(state) ? inputOrTextArea : null;
    if (input) {
      input.type = state.type;
    }
    if (inputOrTextArea.value !== state.value) {
      inputOrTextArea.value = state.value;
    }
    inputOrTextArea.required = state.required;
    if (input) {
      const inputState = state;
      if (inputState.pattern) {
        input.pattern = inputState.pattern;
      } else {
        input.removeAttribute("pattern");
      }
      if (inputState.min) {
        input.min = inputState.min;
      } else {
        input.removeAttribute("min");
      }
      if (inputState.max) {
        input.max = inputState.max;
      } else {
        input.removeAttribute("max");
      }
      if (inputState.step) {
        input.step = inputState.step;
      } else {
        input.removeAttribute("step");
      }
    }
    if ((state.minLength ?? -1) > -1) {
      inputOrTextArea.setAttribute("minlength", String(state.minLength));
    } else {
      inputOrTextArea.removeAttribute("minlength");
    }
    if ((state.maxLength ?? -1) > -1) {
      inputOrTextArea.setAttribute("maxlength", String(state.maxLength));
    } else {
      inputOrTextArea.removeAttribute("maxlength");
    }
    return {
      validity: inputOrTextArea.validity,
      validationMessage: inputOrTextArea.validationMessage
    };
  }
  equals({ state: prev }, { state: next }) {
    const inputOrTextAreaEqual = prev.type === next.type && prev.value === next.value && prev.required === next.required && prev.minLength === next.minLength && prev.maxLength === next.maxLength;
    if (!isInputState(prev) || !isInputState(next)) {
      return inputOrTextAreaEqual;
    }
    return inputOrTextAreaEqual && prev.pattern === next.pattern && prev.min === next.min && prev.max === next.max && prev.step === next.step;
  }
  copy({ state }) {
    return {
      state: isInputState(state) ? this.copyInput(state) : this.copyTextArea(state),
      renderedControl: null
    };
  }
  copyInput(state) {
    const { type, pattern, min: min2, max: max2, step } = state;
    return {
      ...this.copySharedState(state),
      type,
      pattern,
      min: min2,
      max: max2,
      step
    };
  }
  copyTextArea(state) {
    return {
      ...this.copySharedState(state),
      type: state.type
    };
  }
  copySharedState({ value, required, minLength, maxLength }) {
    return { value, required, minLength, maxLength };
  }
}
function isInputState(state) {
  return state.type !== "textarea";
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const textFieldBaseClass = mixinDelegatesAria(mixinOnReportValidity(mixinConstraintValidation(mixinFormAssociated(mixinElementInternals(s$1)))));
class TextField extends textFieldBaseClass {
  constructor() {
    super(...arguments);
    this.error = false;
    this.errorText = "";
    this.label = "";
    this.noAsterisk = false;
    this.required = false;
    this.value = "";
    this.prefixText = "";
    this.suffixText = "";
    this.hasLeadingIcon = false;
    this.hasTrailingIcon = false;
    this.supportingText = "";
    this.textDirection = "";
    this.rows = 2;
    this.cols = 20;
    this.inputMode = "";
    this.max = "";
    this.maxLength = -1;
    this.min = "";
    this.minLength = -1;
    this.noSpinner = false;
    this.pattern = "";
    this.placeholder = "";
    this.readOnly = false;
    this.multiple = false;
    this.step = "";
    this.type = "text";
    this.autocomplete = "";
    this.dirty = false;
    this.focused = false;
    this.nativeError = false;
    this.nativeErrorText = "";
  }
  /**
   * Gets or sets the direction in which selection occurred.
   */
  get selectionDirection() {
    return this.getInputOrTextarea().selectionDirection;
  }
  set selectionDirection(value) {
    this.getInputOrTextarea().selectionDirection = value;
  }
  /**
   * Gets or sets the end position or offset of a text selection.
   */
  get selectionEnd() {
    return this.getInputOrTextarea().selectionEnd;
  }
  set selectionEnd(value) {
    this.getInputOrTextarea().selectionEnd = value;
  }
  /**
   * Gets or sets the starting position or offset of a text selection.
   */
  get selectionStart() {
    return this.getInputOrTextarea().selectionStart;
  }
  set selectionStart(value) {
    this.getInputOrTextarea().selectionStart = value;
  }
  /**
   * The text field's value as a number.
   */
  get valueAsNumber() {
    const input = this.getInput();
    if (!input) {
      return NaN;
    }
    return input.valueAsNumber;
  }
  set valueAsNumber(value) {
    const input = this.getInput();
    if (!input) {
      return;
    }
    input.valueAsNumber = value;
    this.value = input.value;
  }
  /**
   * The text field's value as a Date.
   */
  get valueAsDate() {
    const input = this.getInput();
    if (!input) {
      return null;
    }
    return input.valueAsDate;
  }
  set valueAsDate(value) {
    const input = this.getInput();
    if (!input) {
      return;
    }
    input.valueAsDate = value;
    this.value = input.value;
  }
  get hasError() {
    return this.error || this.nativeError;
  }
  /**
   * Selects all the text in the text field.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/select
   */
  select() {
    this.getInputOrTextarea().select();
  }
  setRangeText(...args) {
    this.getInputOrTextarea().setRangeText(...args);
    this.value = this.getInputOrTextarea().value;
  }
  /**
   * Sets the start and end positions of a selection in the text field.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/setSelectionRange
   *
   * @param start The offset into the text field for the start of the selection.
   * @param end The offset into the text field for the end of the selection.
   * @param direction The direction in which the selection is performed.
   */
  setSelectionRange(start2, end2, direction) {
    this.getInputOrTextarea().setSelectionRange(start2, end2, direction);
  }
  /**
   * Decrements the value of a numeric type text field by `step` or `n` `step`
   * number of times.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/stepDown
   *
   * @param stepDecrement The number of steps to decrement, defaults to 1.
   */
  stepDown(stepDecrement) {
    const input = this.getInput();
    if (!input) {
      return;
    }
    input.stepDown(stepDecrement);
    this.value = input.value;
  }
  /**
   * Increments the value of a numeric type text field by `step` or `n` `step`
   * number of times.
   *
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/stepUp
   *
   * @param stepIncrement The number of steps to increment, defaults to 1.
   */
  stepUp(stepIncrement) {
    const input = this.getInput();
    if (!input) {
      return;
    }
    input.stepUp(stepIncrement);
    this.value = input.value;
  }
  /**
   * Reset the text field to its default value.
   */
  reset() {
    this.dirty = false;
    this.value = this.getAttribute("value") ?? "";
    this.nativeError = false;
    this.nativeErrorText = "";
  }
  attributeChangedCallback(attribute, newValue, oldValue) {
    if (attribute === "value" && this.dirty) {
      return;
    }
    super.attributeChangedCallback(attribute, newValue, oldValue);
  }
  render() {
    const classes = {
      "disabled": this.disabled,
      "error": !this.disabled && this.hasError,
      "textarea": this.type === "textarea",
      "no-spinner": this.noSpinner
    };
    return x$1`
      <span class="text-field ${e$1(classes)}">
        ${this.renderField()}
      </span>
    `;
  }
  updated(changedProperties) {
    const value = this.getInputOrTextarea().value;
    if (this.value !== value) {
      this.value = value;
    }
  }
  renderField() {
    return n$2`<${this.fieldTag}
      class="field"
      count=${this.value.length}
      ?disabled=${this.disabled}
      ?error=${this.hasError}
      error-text=${this.getErrorText()}
      ?focused=${this.focused}
      ?has-end=${this.hasTrailingIcon}
      ?has-start=${this.hasLeadingIcon}
      label=${this.label}
      ?no-asterisk=${this.noAsterisk}
      max=${this.maxLength}
      ?populated=${!!this.value}
      ?required=${this.required}
      ?resizable=${this.type === "textarea"}
      supporting-text=${this.supportingText}
    >
      ${this.renderLeadingIcon()}
      ${this.renderInputOrTextarea()}
      ${this.renderTrailingIcon()}
      <div id="description" slot="aria-describedby"></div>
      <slot name="container" slot="container"></slot>
    </${this.fieldTag}>`;
  }
  renderLeadingIcon() {
    return x$1`
      <span class="icon leading" slot="start">
        <slot name="leading-icon" @slotchange=${this.handleIconChange}></slot>
      </span>
    `;
  }
  renderTrailingIcon() {
    return x$1`
      <span class="icon trailing" slot="end">
        <slot name="trailing-icon" @slotchange=${this.handleIconChange}></slot>
      </span>
    `;
  }
  renderInputOrTextarea() {
    const style = { "direction": this.textDirection };
    const ariaLabel = this.ariaLabel || this.label || T$1;
    const autocomplete = this.autocomplete;
    const hasMaxLength = (this.maxLength ?? -1) > -1;
    const hasMinLength = (this.minLength ?? -1) > -1;
    if (this.type === "textarea") {
      return x$1`
        <textarea
          class="input"
          style=${o(style)}
          aria-describedby="description"
          aria-invalid=${this.hasError}
          aria-label=${ariaLabel}
          autocomplete=${autocomplete || T$1}
          name=${this.name || T$1}
          ?disabled=${this.disabled}
          maxlength=${hasMaxLength ? this.maxLength : T$1}
          minlength=${hasMinLength ? this.minLength : T$1}
          placeholder=${this.placeholder || T$1}
          ?readonly=${this.readOnly}
          ?required=${this.required}
          rows=${this.rows}
          cols=${this.cols}
          .value=${l(this.value)}
          @change=${this.redispatchEvent}
          @focus=${this.handleFocusChange}
          @blur=${this.handleFocusChange}
          @input=${this.handleInput}
          @select=${this.redispatchEvent}></textarea>
      `;
    }
    const prefix = this.renderPrefix();
    const suffix = this.renderSuffix();
    const inputMode = this.inputMode;
    return x$1`
      <div class="input-wrapper">
        ${prefix}
        <input
          class="input"
          style=${o(style)}
          aria-describedby="description"
          aria-invalid=${this.hasError}
          aria-label=${ariaLabel}
          autocomplete=${autocomplete || T$1}
          name=${this.name || T$1}
          ?disabled=${this.disabled}
          inputmode=${inputMode || T$1}
          max=${this.max || T$1}
          maxlength=${hasMaxLength ? this.maxLength : T$1}
          min=${this.min || T$1}
          minlength=${hasMinLength ? this.minLength : T$1}
          pattern=${this.pattern || T$1}
          placeholder=${this.placeholder || T$1}
          ?readonly=${this.readOnly}
          ?required=${this.required}
          ?multiple=${this.multiple}
          step=${this.step || T$1}
          type=${this.type}
          .value=${l(this.value)}
          @change=${this.redispatchEvent}
          @focus=${this.handleFocusChange}
          @blur=${this.handleFocusChange}
          @input=${this.handleInput}
          @select=${this.redispatchEvent} />
        ${suffix}
      </div>
    `;
  }
  renderPrefix() {
    return this.renderAffix(
      this.prefixText,
      /* isSuffix */
      false
    );
  }
  renderSuffix() {
    return this.renderAffix(
      this.suffixText,
      /* isSuffix */
      true
    );
  }
  renderAffix(text, isSuffix) {
    if (!text) {
      return T$1;
    }
    const classes = {
      "suffix": isSuffix,
      "prefix": !isSuffix
    };
    return x$1`<span class="${e$1(classes)}">${text}</span>`;
  }
  getErrorText() {
    return this.error ? this.errorText : this.nativeErrorText;
  }
  handleFocusChange() {
    this.focused = this.inputOrTextarea?.matches(":focus") ?? false;
  }
  handleInput(event) {
    this.dirty = true;
    this.value = event.target.value;
  }
  redispatchEvent(event) {
    redispatchEvent(this, event);
  }
  getInputOrTextarea() {
    if (!this.inputOrTextarea) {
      this.connectedCallback();
      this.scheduleUpdate();
    }
    if (this.isUpdatePending) {
      this.scheduleUpdate();
    }
    return this.inputOrTextarea;
  }
  getInput() {
    if (this.type === "textarea") {
      return null;
    }
    return this.getInputOrTextarea();
  }
  handleIconChange() {
    this.hasLeadingIcon = this.leadingIcons.length > 0;
    this.hasTrailingIcon = this.trailingIcons.length > 0;
  }
  [getFormValue]() {
    return this.value;
  }
  formResetCallback() {
    this.reset();
  }
  formStateRestoreCallback(state) {
    this.value = state;
  }
  focus() {
    this.getInputOrTextarea().focus();
  }
  [createValidator]() {
    return new TextFieldValidator(() => ({
      state: this,
      renderedControl: this.inputOrTextarea
    }));
  }
  [getValidityAnchor]() {
    return this.inputOrTextarea;
  }
  [onReportValidity](invalidEvent) {
    invalidEvent?.preventDefault();
    const prevMessage = this.getErrorText();
    this.nativeError = !!invalidEvent;
    this.nativeErrorText = this.validationMessage;
    if (prevMessage === this.getErrorText()) {
      this.field?.reannounceError();
    }
  }
}
TextField.shadowRootOptions = {
  ...s$1.shadowRootOptions,
  delegatesFocus: true
};
__decorate([
  n$5({ type: Boolean, reflect: true })
], TextField.prototype, "error", void 0);
__decorate([
  n$5({ attribute: "error-text" })
], TextField.prototype, "errorText", void 0);
__decorate([
  n$5()
], TextField.prototype, "label", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-asterisk" })
], TextField.prototype, "noAsterisk", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], TextField.prototype, "required", void 0);
__decorate([
  n$5()
], TextField.prototype, "value", void 0);
__decorate([
  n$5({ attribute: "prefix-text" })
], TextField.prototype, "prefixText", void 0);
__decorate([
  n$5({ attribute: "suffix-text" })
], TextField.prototype, "suffixText", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-leading-icon" })
], TextField.prototype, "hasLeadingIcon", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "has-trailing-icon" })
], TextField.prototype, "hasTrailingIcon", void 0);
__decorate([
  n$5({ attribute: "supporting-text" })
], TextField.prototype, "supportingText", void 0);
__decorate([
  n$5({ attribute: "text-direction" })
], TextField.prototype, "textDirection", void 0);
__decorate([
  n$5({ type: Number })
], TextField.prototype, "rows", void 0);
__decorate([
  n$5({ type: Number })
], TextField.prototype, "cols", void 0);
__decorate([
  n$5({ reflect: true })
], TextField.prototype, "inputMode", void 0);
__decorate([
  n$5()
], TextField.prototype, "max", void 0);
__decorate([
  n$5({ type: Number })
], TextField.prototype, "maxLength", void 0);
__decorate([
  n$5()
], TextField.prototype, "min", void 0);
__decorate([
  n$5({ type: Number })
], TextField.prototype, "minLength", void 0);
__decorate([
  n$5({ type: Boolean, attribute: "no-spinner" })
], TextField.prototype, "noSpinner", void 0);
__decorate([
  n$5()
], TextField.prototype, "pattern", void 0);
__decorate([
  n$5({ reflect: true, converter: stringConverter })
], TextField.prototype, "placeholder", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], TextField.prototype, "readOnly", void 0);
__decorate([
  n$5({ type: Boolean, reflect: true })
], TextField.prototype, "multiple", void 0);
__decorate([
  n$5()
], TextField.prototype, "step", void 0);
__decorate([
  n$5({ reflect: true })
], TextField.prototype, "type", void 0);
__decorate([
  n$5({ reflect: true })
], TextField.prototype, "autocomplete", void 0);
__decorate([
  r$4()
], TextField.prototype, "dirty", void 0);
__decorate([
  r$4()
], TextField.prototype, "focused", void 0);
__decorate([
  r$4()
], TextField.prototype, "nativeError", void 0);
__decorate([
  r$4()
], TextField.prototype, "nativeErrorText", void 0);
__decorate([
  e$5(".input")
], TextField.prototype, "inputOrTextarea", void 0);
__decorate([
  e$5(".field")
], TextField.prototype, "field", void 0);
__decorate([
  o$4({ slot: "leading-icon" })
], TextField.prototype, "leadingIcons", void 0);
__decorate([
  o$4({ slot: "trailing-icon" })
], TextField.prototype, "trailingIcons", void 0);
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class FilledTextField extends TextField {
  constructor() {
    super(...arguments);
    this.fieldTag = s2`md-filled-field`;
  }
}
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles$1 = i$4`:host{display:inline-flex;outline:none;resize:both;text-align:start;-webkit-tap-highlight-color:rgba(0,0,0,0)}.text-field,.field{width:100%}.text-field{display:inline-flex}.field{cursor:text}.disabled .field{cursor:default}.text-field,.textarea .field{resize:inherit}slot[name=container]{border-radius:inherit}.icon{color:currentColor;display:flex;align-items:center;justify-content:center;fill:currentColor;position:relative}.icon ::slotted(*){display:flex;position:absolute}[has-start] .icon.leading{font-size:var(--_leading-icon-size);height:var(--_leading-icon-size);width:var(--_leading-icon-size)}[has-end] .icon.trailing{font-size:var(--_trailing-icon-size);height:var(--_trailing-icon-size);width:var(--_trailing-icon-size)}.input-wrapper{display:flex}.input-wrapper>*{all:inherit;padding:0}.input{caret-color:var(--_caret-color);overflow-x:hidden;text-align:inherit}.input::placeholder{color:currentColor;opacity:1}.input::-webkit-calendar-picker-indicator{display:none}.input::-webkit-search-decoration,.input::-webkit-search-cancel-button{display:none}@media(forced-colors: active){.input{background:none}}.no-spinner .input::-webkit-inner-spin-button,.no-spinner .input::-webkit-outer-spin-button{display:none}.no-spinner .input[type=number]{-moz-appearance:textfield}:focus-within .input{caret-color:var(--_focus-caret-color)}.error:focus-within .input{caret-color:var(--_error-focus-caret-color)}.text-field:not(.disabled) .prefix{color:var(--_input-text-prefix-color)}.text-field:not(.disabled) .suffix{color:var(--_input-text-suffix-color)}.text-field:not(.disabled) .input::placeholder{color:var(--_input-text-placeholder-color)}.prefix,.suffix{text-wrap:nowrap;width:min-content}.prefix{padding-inline-end:var(--_input-text-prefix-trailing-space)}.suffix{padding-inline-start:var(--_input-text-suffix-leading-space)}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdFilledTextField = class MdFilledTextField2 extends FilledTextField {
  constructor() {
    super(...arguments);
    this.fieldTag = s2`md-filled-field`;
  }
};
MdFilledTextField.styles = [styles$1, styles$2];
MdFilledTextField = __decorate([
  t$3("md-filled-text-field")
], MdFilledTextField);
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const styles = i$4`:host{--_caret-color: var(--md-outlined-text-field-caret-color, var(--md-sys-color-primary, #6750a4));--_disabled-input-text-color: var(--md-outlined-text-field-disabled-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-input-text-opacity: var(--md-outlined-text-field-disabled-input-text-opacity, 0.38);--_disabled-label-text-color: var(--md-outlined-text-field-disabled-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-label-text-opacity: var(--md-outlined-text-field-disabled-label-text-opacity, 0.38);--_disabled-leading-icon-color: var(--md-outlined-text-field-disabled-leading-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-leading-icon-opacity: var(--md-outlined-text-field-disabled-leading-icon-opacity, 0.38);--_disabled-outline-color: var(--md-outlined-text-field-disabled-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-outline-opacity: var(--md-outlined-text-field-disabled-outline-opacity, 0.12);--_disabled-outline-width: var(--md-outlined-text-field-disabled-outline-width, 1px);--_disabled-supporting-text-color: var(--md-outlined-text-field-disabled-supporting-text-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-supporting-text-opacity: var(--md-outlined-text-field-disabled-supporting-text-opacity, 0.38);--_disabled-trailing-icon-color: var(--md-outlined-text-field-disabled-trailing-icon-color, var(--md-sys-color-on-surface, #1d1b20));--_disabled-trailing-icon-opacity: var(--md-outlined-text-field-disabled-trailing-icon-opacity, 0.38);--_error-focus-caret-color: var(--md-outlined-text-field-error-focus-caret-color, var(--md-sys-color-error, #b3261e));--_error-focus-input-text-color: var(--md-outlined-text-field-error-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-focus-label-text-color: var(--md-outlined-text-field-error-focus-label-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-leading-icon-color: var(--md-outlined-text-field-error-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-focus-outline-color: var(--md-outlined-text-field-error-focus-outline-color, var(--md-sys-color-error, #b3261e));--_error-focus-supporting-text-color: var(--md-outlined-text-field-error-focus-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-focus-trailing-icon-color: var(--md-outlined-text-field-error-focus-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_error-hover-input-text-color: var(--md-outlined-text-field-error-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-hover-label-text-color: var(--md-outlined-text-field-error-hover-label-text-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-leading-icon-color: var(--md-outlined-text-field-error-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-hover-outline-color: var(--md-outlined-text-field-error-hover-outline-color, var(--md-sys-color-on-error-container, #410e0b));--_error-hover-supporting-text-color: var(--md-outlined-text-field-error-hover-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-hover-trailing-icon-color: var(--md-outlined-text-field-error-hover-trailing-icon-color, var(--md-sys-color-on-error-container, #410e0b));--_error-input-text-color: var(--md-outlined-text-field-error-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_error-label-text-color: var(--md-outlined-text-field-error-label-text-color, var(--md-sys-color-error, #b3261e));--_error-leading-icon-color: var(--md-outlined-text-field-error-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_error-outline-color: var(--md-outlined-text-field-error-outline-color, var(--md-sys-color-error, #b3261e));--_error-supporting-text-color: var(--md-outlined-text-field-error-supporting-text-color, var(--md-sys-color-error, #b3261e));--_error-trailing-icon-color: var(--md-outlined-text-field-error-trailing-icon-color, var(--md-sys-color-error, #b3261e));--_focus-input-text-color: var(--md-outlined-text-field-focus-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_focus-label-text-color: var(--md-outlined-text-field-focus-label-text-color, var(--md-sys-color-primary, #6750a4));--_focus-leading-icon-color: var(--md-outlined-text-field-focus-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-outline-color: var(--md-outlined-text-field-focus-outline-color, var(--md-sys-color-primary, #6750a4));--_focus-outline-width: var(--md-outlined-text-field-focus-outline-width, 3px);--_focus-supporting-text-color: var(--md-outlined-text-field-focus-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_focus-trailing-icon-color: var(--md-outlined-text-field-focus-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-input-text-color: var(--md-outlined-text-field-hover-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-label-text-color: var(--md-outlined-text-field-hover-label-text-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-leading-icon-color: var(--md-outlined-text-field-hover-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-outline-color: var(--md-outlined-text-field-hover-outline-color, var(--md-sys-color-on-surface, #1d1b20));--_hover-outline-width: var(--md-outlined-text-field-hover-outline-width, 1px);--_hover-supporting-text-color: var(--md-outlined-text-field-hover-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_hover-trailing-icon-color: var(--md-outlined-text-field-hover-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-color: var(--md-outlined-text-field-input-text-color, var(--md-sys-color-on-surface, #1d1b20));--_input-text-font: var(--md-outlined-text-field-input-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_input-text-line-height: var(--md-outlined-text-field-input-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_input-text-placeholder-color: var(--md-outlined-text-field-input-text-placeholder-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-prefix-color: var(--md-outlined-text-field-input-text-prefix-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-size: var(--md-outlined-text-field-input-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_input-text-suffix-color: var(--md-outlined-text-field-input-text-suffix-color, var(--md-sys-color-on-surface-variant, #49454f));--_input-text-weight: var(--md-outlined-text-field-input-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_label-text-color: var(--md-outlined-text-field-label-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_label-text-font: var(--md-outlined-text-field-label-text-font, var(--md-sys-typescale-body-large-font, var(--md-ref-typeface-plain, Roboto)));--_label-text-line-height: var(--md-outlined-text-field-label-text-line-height, var(--md-sys-typescale-body-large-line-height, 1.5rem));--_label-text-populated-line-height: var(--md-outlined-text-field-label-text-populated-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_label-text-populated-size: var(--md-outlined-text-field-label-text-populated-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_label-text-size: var(--md-outlined-text-field-label-text-size, var(--md-sys-typescale-body-large-size, 1rem));--_label-text-weight: var(--md-outlined-text-field-label-text-weight, var(--md-sys-typescale-body-large-weight, var(--md-ref-typeface-weight-regular, 400)));--_leading-icon-color: var(--md-outlined-text-field-leading-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_leading-icon-size: var(--md-outlined-text-field-leading-icon-size, 24px);--_outline-color: var(--md-outlined-text-field-outline-color, var(--md-sys-color-outline, #79747e));--_outline-width: var(--md-outlined-text-field-outline-width, 1px);--_supporting-text-color: var(--md-outlined-text-field-supporting-text-color, var(--md-sys-color-on-surface-variant, #49454f));--_supporting-text-font: var(--md-outlined-text-field-supporting-text-font, var(--md-sys-typescale-body-small-font, var(--md-ref-typeface-plain, Roboto)));--_supporting-text-line-height: var(--md-outlined-text-field-supporting-text-line-height, var(--md-sys-typescale-body-small-line-height, 1rem));--_supporting-text-size: var(--md-outlined-text-field-supporting-text-size, var(--md-sys-typescale-body-small-size, 0.75rem));--_supporting-text-weight: var(--md-outlined-text-field-supporting-text-weight, var(--md-sys-typescale-body-small-weight, var(--md-ref-typeface-weight-regular, 400)));--_trailing-icon-color: var(--md-outlined-text-field-trailing-icon-color, var(--md-sys-color-on-surface-variant, #49454f));--_trailing-icon-size: var(--md-outlined-text-field-trailing-icon-size, 24px);--_container-shape-start-start: var(--md-outlined-text-field-container-shape-start-start, var(--md-outlined-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-start-end: var(--md-outlined-text-field-container-shape-start-end, var(--md-outlined-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-end: var(--md-outlined-text-field-container-shape-end-end, var(--md-outlined-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_container-shape-end-start: var(--md-outlined-text-field-container-shape-end-start, var(--md-outlined-text-field-container-shape, var(--md-sys-shape-corner-extra-small, 4px)));--_icon-input-space: var(--md-outlined-text-field-icon-input-space, 16px);--_leading-space: var(--md-outlined-text-field-leading-space, 16px);--_trailing-space: var(--md-outlined-text-field-trailing-space, 16px);--_top-space: var(--md-outlined-text-field-top-space, 16px);--_bottom-space: var(--md-outlined-text-field-bottom-space, 16px);--_input-text-prefix-trailing-space: var(--md-outlined-text-field-input-text-prefix-trailing-space, 2px);--_input-text-suffix-leading-space: var(--md-outlined-text-field-input-text-suffix-leading-space, 2px);--_focus-caret-color: var(--md-outlined-text-field-focus-caret-color, var(--md-sys-color-primary, #6750a4));--_with-leading-icon-leading-space: var(--md-outlined-text-field-with-leading-icon-leading-space, 12px);--_with-trailing-icon-trailing-space: var(--md-outlined-text-field-with-trailing-icon-trailing-space, 12px);--md-outlined-field-bottom-space: var(--_bottom-space);--md-outlined-field-container-shape-end-end: var(--_container-shape-end-end);--md-outlined-field-container-shape-end-start: var(--_container-shape-end-start);--md-outlined-field-container-shape-start-end: var(--_container-shape-start-end);--md-outlined-field-container-shape-start-start: var(--_container-shape-start-start);--md-outlined-field-content-color: var(--_input-text-color);--md-outlined-field-content-font: var(--_input-text-font);--md-outlined-field-content-line-height: var(--_input-text-line-height);--md-outlined-field-content-size: var(--_input-text-size);--md-outlined-field-content-space: var(--_icon-input-space);--md-outlined-field-content-weight: var(--_input-text-weight);--md-outlined-field-disabled-content-color: var(--_disabled-input-text-color);--md-outlined-field-disabled-content-opacity: var(--_disabled-input-text-opacity);--md-outlined-field-disabled-label-text-color: var(--_disabled-label-text-color);--md-outlined-field-disabled-label-text-opacity: var(--_disabled-label-text-opacity);--md-outlined-field-disabled-leading-content-color: var(--_disabled-leading-icon-color);--md-outlined-field-disabled-leading-content-opacity: var(--_disabled-leading-icon-opacity);--md-outlined-field-disabled-outline-color: var(--_disabled-outline-color);--md-outlined-field-disabled-outline-opacity: var(--_disabled-outline-opacity);--md-outlined-field-disabled-outline-width: var(--_disabled-outline-width);--md-outlined-field-disabled-supporting-text-color: var(--_disabled-supporting-text-color);--md-outlined-field-disabled-supporting-text-opacity: var(--_disabled-supporting-text-opacity);--md-outlined-field-disabled-trailing-content-color: var(--_disabled-trailing-icon-color);--md-outlined-field-disabled-trailing-content-opacity: var(--_disabled-trailing-icon-opacity);--md-outlined-field-error-content-color: var(--_error-input-text-color);--md-outlined-field-error-focus-content-color: var(--_error-focus-input-text-color);--md-outlined-field-error-focus-label-text-color: var(--_error-focus-label-text-color);--md-outlined-field-error-focus-leading-content-color: var(--_error-focus-leading-icon-color);--md-outlined-field-error-focus-outline-color: var(--_error-focus-outline-color);--md-outlined-field-error-focus-supporting-text-color: var(--_error-focus-supporting-text-color);--md-outlined-field-error-focus-trailing-content-color: var(--_error-focus-trailing-icon-color);--md-outlined-field-error-hover-content-color: var(--_error-hover-input-text-color);--md-outlined-field-error-hover-label-text-color: var(--_error-hover-label-text-color);--md-outlined-field-error-hover-leading-content-color: var(--_error-hover-leading-icon-color);--md-outlined-field-error-hover-outline-color: var(--_error-hover-outline-color);--md-outlined-field-error-hover-supporting-text-color: var(--_error-hover-supporting-text-color);--md-outlined-field-error-hover-trailing-content-color: var(--_error-hover-trailing-icon-color);--md-outlined-field-error-label-text-color: var(--_error-label-text-color);--md-outlined-field-error-leading-content-color: var(--_error-leading-icon-color);--md-outlined-field-error-outline-color: var(--_error-outline-color);--md-outlined-field-error-supporting-text-color: var(--_error-supporting-text-color);--md-outlined-field-error-trailing-content-color: var(--_error-trailing-icon-color);--md-outlined-field-focus-content-color: var(--_focus-input-text-color);--md-outlined-field-focus-label-text-color: var(--_focus-label-text-color);--md-outlined-field-focus-leading-content-color: var(--_focus-leading-icon-color);--md-outlined-field-focus-outline-color: var(--_focus-outline-color);--md-outlined-field-focus-outline-width: var(--_focus-outline-width);--md-outlined-field-focus-supporting-text-color: var(--_focus-supporting-text-color);--md-outlined-field-focus-trailing-content-color: var(--_focus-trailing-icon-color);--md-outlined-field-hover-content-color: var(--_hover-input-text-color);--md-outlined-field-hover-label-text-color: var(--_hover-label-text-color);--md-outlined-field-hover-leading-content-color: var(--_hover-leading-icon-color);--md-outlined-field-hover-outline-color: var(--_hover-outline-color);--md-outlined-field-hover-outline-width: var(--_hover-outline-width);--md-outlined-field-hover-supporting-text-color: var(--_hover-supporting-text-color);--md-outlined-field-hover-trailing-content-color: var(--_hover-trailing-icon-color);--md-outlined-field-label-text-color: var(--_label-text-color);--md-outlined-field-label-text-font: var(--_label-text-font);--md-outlined-field-label-text-line-height: var(--_label-text-line-height);--md-outlined-field-label-text-populated-line-height: var(--_label-text-populated-line-height);--md-outlined-field-label-text-populated-size: var(--_label-text-populated-size);--md-outlined-field-label-text-size: var(--_label-text-size);--md-outlined-field-label-text-weight: var(--_label-text-weight);--md-outlined-field-leading-content-color: var(--_leading-icon-color);--md-outlined-field-leading-space: var(--_leading-space);--md-outlined-field-outline-color: var(--_outline-color);--md-outlined-field-outline-width: var(--_outline-width);--md-outlined-field-supporting-text-color: var(--_supporting-text-color);--md-outlined-field-supporting-text-font: var(--_supporting-text-font);--md-outlined-field-supporting-text-line-height: var(--_supporting-text-line-height);--md-outlined-field-supporting-text-size: var(--_supporting-text-size);--md-outlined-field-supporting-text-weight: var(--_supporting-text-weight);--md-outlined-field-top-space: var(--_top-space);--md-outlined-field-trailing-content-color: var(--_trailing-icon-color);--md-outlined-field-trailing-space: var(--_trailing-space);--md-outlined-field-with-leading-content-leading-space: var(--_with-leading-icon-leading-space);--md-outlined-field-with-trailing-content-trailing-space: var(--_with-trailing-icon-trailing-space)}
`;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
class OutlinedTextField extends TextField {
  constructor() {
    super(...arguments);
    this.fieldTag = s2`md-outlined-field`;
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
let MdOutlinedTextField = class MdOutlinedTextField2 extends OutlinedTextField {
  constructor() {
    super(...arguments);
    this.fieldTag = s2`md-outlined-field`;
  }
};
MdOutlinedTextField.styles = [styles$1, styles];
MdOutlinedTextField = __decorate([
  t$3("md-outlined-text-field")
], MdOutlinedTextField);
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$1(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name2) {
    var style = state.styles[name2] || {};
    var attributes2 = state.attributes[name2] || {};
    var element = state.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes2).forEach(function(name3) {
      var value = attributes2[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name2) {
      var element = state.elements[name2];
      var attributes2 = state.attributes[name2] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name2) ? state.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes2).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name2 = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y2 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }, getWindow(popper2)) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary2, rootBoundary, strategy) {
  var mainClippingParents = boundary2 === "clippingParents" ? getClippingParents(element) : [].concat(boundary2);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary2 = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary2, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary2 = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary: boundary2,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b3) {
    return overflows[a2] - overflows[b3];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  if (state.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary2 = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary: boundary2,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i3 = 0; i3 < placements2.length; i3++) {
    var placement = placements2[i3];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary: boundary2,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name2]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name2 = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name2 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x2;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name2] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name2 = _ref.name;
  state.modifiersData[name2] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary2 = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary: boundary2,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen2 = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen2 + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name2] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve2) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve2(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name: name2,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve2) {
          instance.forceUpdate();
          resolve2(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name2 = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state,
            name: name2,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper$2 = /* @__PURE__ */ popperGenerator();
var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /* @__PURE__ */ popperGenerator({
  defaultModifiers: defaultModifiers$1
});
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const Popper = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain,
  afterRead,
  afterWrite,
  applyStyles: applyStyles$1,
  arrow: arrow$1,
  auto,
  basePlacements,
  beforeMain,
  beforeRead,
  beforeWrite,
  bottom,
  clippingParents,
  computeStyles: computeStyles$1,
  createPopper,
  createPopperBase: createPopper$2,
  createPopperLite: createPopper$1,
  detectOverflow,
  end,
  eventListeners,
  flip: flip$1,
  hide: hide$1,
  left,
  main,
  modifierPhases,
  offset: offset$1,
  placements,
  popper,
  popperGenerator,
  popperOffsets: popperOffsets$1,
  preventOverflow: preventOverflow$1,
  read,
  reference,
  right,
  start,
  top,
  variationPlacements,
  viewport,
  write
}, Symbol.toStringTag, { value: "Module" }));
/*!
  * Bootstrap v5.3.3 (https://getbootstrap.com/)
  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
const elementMap = /* @__PURE__ */ new Map();
const Data = {
  set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, /* @__PURE__ */ new Map());
    }
    const instanceMap = elementMap.get(element);
    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
      return;
    }
    instanceMap.set(key, instance);
  },
  get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }
    return null;
  },
  remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }
    const instanceMap = elementMap.get(element);
    instanceMap.delete(key);
    if (instanceMap.size === 0) {
      elementMap.delete(element);
    }
  }
};
const MAX_UID = 1e6;
const MILLISECONDS_MULTIPLIER = 1e3;
const TRANSITION_END = "transitionend";
const parseSelector = (selector) => {
  if (selector && window.CSS && window.CSS.escape) {
    selector = selector.replace(/#([^\s"#']+)/g, (match, id2) => `#${CSS.escape(id2)}`);
  }
  return selector;
};
const toType = (object) => {
  if (object === null || object === void 0) {
    return `${object}`;
  }
  return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};
const getUID = (prefix) => {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));
  return prefix;
};
const getTransitionDurationFromElement = (element) => {
  if (!element) {
    return 0;
  }
  let {
    transitionDuration,
    transitionDelay
  } = window.getComputedStyle(element);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }
  transitionDuration = transitionDuration.split(",")[0];
  transitionDelay = transitionDelay.split(",")[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
const triggerTransitionEnd = (element) => {
  element.dispatchEvent(new Event(TRANSITION_END));
};
const isElement = (object) => {
  if (!object || typeof object !== "object") {
    return false;
  }
  if (typeof object.jquery !== "undefined") {
    object = object[0];
  }
  return typeof object.nodeType !== "undefined";
};
const getElement = (object) => {
  if (isElement(object)) {
    return object.jquery ? object[0] : object;
  }
  if (typeof object === "string" && object.length > 0) {
    return document.querySelector(parseSelector(object));
  }
  return null;
};
const isVisible = (element) => {
  if (!isElement(element) || element.getClientRects().length === 0) {
    return false;
  }
  const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
  const closedDetails = element.closest("details:not([open])");
  if (!closedDetails) {
    return elementIsVisible;
  }
  if (closedDetails !== element) {
    const summary = element.closest("summary");
    if (summary && summary.parentNode !== closedDetails) {
      return false;
    }
    if (summary === null) {
      return false;
    }
  }
  return elementIsVisible;
};
const isDisabled = (element) => {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  if (element.classList.contains("disabled")) {
    return true;
  }
  if (typeof element.disabled !== "undefined") {
    return element.disabled;
  }
  return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
};
const findShadowRoot = (element) => {
  if (!document.documentElement.attachShadow) {
    return null;
  }
  if (typeof element.getRootNode === "function") {
    const root = element.getRootNode();
    return root instanceof ShadowRoot ? root : null;
  }
  if (element instanceof ShadowRoot) {
    return element;
  }
  if (!element.parentNode) {
    return null;
  }
  return findShadowRoot(element.parentNode);
};
const noop = () => {
};
const reflow = (element) => {
  element.offsetHeight;
};
const getjQuery = () => {
  if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
    return window.jQuery;
  }
  return null;
};
const DOMContentLoadedCallbacks = [];
const onDOMContentLoaded = (callback) => {
  if (document.readyState === "loading") {
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener("DOMContentLoaded", () => {
        for (const callback2 of DOMContentLoadedCallbacks) {
          callback2();
        }
      });
    }
    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};
const isRTL = () => document.documentElement.dir === "rtl";
const defineJQueryPlugin = (plugin) => {
  onDOMContentLoaded(() => {
    const $2 = getjQuery();
    if ($2) {
      const name2 = plugin.NAME;
      const JQUERY_NO_CONFLICT = $2.fn[name2];
      $2.fn[name2] = plugin.jQueryInterface;
      $2.fn[name2].Constructor = plugin;
      $2.fn[name2].noConflict = () => {
        $2.fn[name2] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};
const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
  return typeof possibleCallback === "function" ? possibleCallback(...args) : defaultValue;
};
const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
  if (!waitForTransition) {
    execute(callback);
    return;
  }
  const durationPadding = 5;
  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  let called = false;
  const handler = ({
    target
  }) => {
    if (target !== transitionElement) {
      return;
    }
    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };
  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};
const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
  const listLength = list.length;
  let index = list.indexOf(activeElement);
  if (index === -1) {
    return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
  }
  index += shouldGetNext ? 1 : -1;
  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }
  return list[Math.max(0, Math.min(index, listLength - 1))];
};
const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex = /\..*/;
const stripUidRegex = /::\d+$/;
const eventRegistry = {};
let uidEvent = 1;
const customEvents = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
};
const nativeEvents = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
function makeEventUid(element, uid) {
  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}
function getElementEvents(element) {
  const uid = makeEventUid(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}
function bootstrapHandler(element, fn2) {
  return function handler(event) {
    hydrateObj(event, {
      delegateTarget: element
    });
    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn2);
    }
    return fn2.apply(element, [event]);
  };
}
function bootstrapDelegationHandler(element, selector, fn2) {
  return function handler(event) {
    const domElements = element.querySelectorAll(selector);
    for (let {
      target
    } = event; target && target !== this; target = target.parentNode) {
      for (const domElement of domElements) {
        if (domElement !== target) {
          continue;
        }
        hydrateObj(event, {
          delegateTarget: target
        });
        if (handler.oneOff) {
          EventHandler.off(element, event.type, selector, fn2);
        }
        return fn2.apply(target, [event]);
      }
    }
  };
}
function findHandler(events2, callable, delegationSelector = null) {
  return Object.values(events2).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
}
function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
  const isDelegated = typeof handler === "string";
  const callable = isDelegated ? delegationFunction : handler || delegationFunction;
  let typeEvent = getTypeEvent(originalTypeEvent);
  if (!nativeEvents.has(typeEvent)) {
    typeEvent = originalTypeEvent;
  }
  return [isDelegated, callable, typeEvent];
}
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
  if (typeof originalTypeEvent !== "string" || !element) {
    return;
  }
  let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
  if (originalTypeEvent in customEvents) {
    const wrapFunction = (fn3) => {
      return function(event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn3.call(this, event);
        }
      };
    };
    callable = wrapFunction(callable);
  }
  const events2 = getElementEvents(element);
  const handlers = events2[typeEvent] || (events2[typeEvent] = {});
  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
  if (previousFunction) {
    previousFunction.oneOff = previousFunction.oneOff && oneOff;
    return;
  }
  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
  const fn2 = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
  fn2.delegationSelector = isDelegated ? handler : null;
  fn2.callable = callable;
  fn2.oneOff = oneOff;
  fn2.uidEvent = uid;
  handlers[uid] = fn2;
  element.addEventListener(typeEvent, fn2, isDelegated);
}
function removeHandler(element, events2, typeEvent, handler, delegationSelector) {
  const fn2 = findHandler(events2[typeEvent], handler, delegationSelector);
  if (!fn2) {
    return;
  }
  element.removeEventListener(typeEvent, fn2, Boolean(delegationSelector));
  delete events2[typeEvent][fn2.uidEvent];
}
function removeNamespacedHandlers(element, events2, typeEvent, namespace) {
  const storeElementEvent = events2[typeEvent] || {};
  for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
    if (handlerKey.includes(namespace)) {
      removeHandler(element, events2, typeEvent, event.callable, event.delegationSelector);
    }
  }
}
function getTypeEvent(event) {
  event = event.replace(stripNameRegex, "");
  return customEvents[event] || event;
}
const EventHandler = {
  on(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, false);
  },
  one(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, true);
  },
  off(element, originalTypeEvent, handler, delegationFunction) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    const inNamespace = typeEvent !== originalTypeEvent;
    const events2 = getElementEvents(element);
    const storeElementEvent = events2[typeEvent] || {};
    const isNamespace = originalTypeEvent.startsWith(".");
    if (typeof callable !== "undefined") {
      if (!Object.keys(storeElementEvent).length) {
        return;
      }
      removeHandler(element, events2, typeEvent, callable, isDelegated ? handler : null);
      return;
    }
    if (isNamespace) {
      for (const elementEvent of Object.keys(events2)) {
        removeNamespacedHandlers(element, events2, elementEvent, originalTypeEvent.slice(1));
      }
    }
    for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
      const handlerKey = keyHandlers.replace(stripUidRegex, "");
      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        removeHandler(element, events2, typeEvent, event.callable, event.delegationSelector);
      }
    }
  },
  trigger(element, event, args) {
    if (typeof event !== "string" || !element) {
      return null;
    }
    const $2 = getjQuery();
    const typeEvent = getTypeEvent(event);
    const inNamespace = event !== typeEvent;
    let jQueryEvent = null;
    let bubbles = true;
    let nativeDispatch = true;
    let defaultPrevented = false;
    if (inNamespace && $2) {
      jQueryEvent = $2.Event(event, args);
      $2(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }
    const evt = hydrateObj(new Event(event, {
      bubbles,
      cancelable: true
    }), args);
    if (defaultPrevented) {
      evt.preventDefault();
    }
    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }
    if (evt.defaultPrevented && jQueryEvent) {
      jQueryEvent.preventDefault();
    }
    return evt;
  }
};
function hydrateObj(obj, meta = {}) {
  for (const [key, value] of Object.entries(meta)) {
    try {
      obj[key] = value;
    } catch (_unused) {
      Object.defineProperty(obj, key, {
        configurable: true,
        get() {
          return value;
        }
      });
    }
  }
  return obj;
}
function normalizeData(value) {
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  if (value === Number(value).toString()) {
    return Number(value);
  }
  if (value === "" || value === "null") {
    return null;
  }
  if (typeof value !== "string") {
    return value;
  }
  try {
    return JSON.parse(decodeURIComponent(value));
  } catch (_unused) {
    return value;
  }
}
function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
}
const Manipulator = {
  setDataAttribute(element, key, value) {
    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
  },
  removeDataAttribute(element, key) {
    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
  },
  getDataAttributes(element) {
    if (!element) {
      return {};
    }
    const attributes2 = {};
    const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
    for (const key of bsKeys) {
      let pureKey = key.replace(/^bs/, "");
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes2[pureKey] = normalizeData(element.dataset[key]);
    }
    return attributes2;
  },
  getDataAttribute(element, key) {
    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
  }
};
class Config {
  // Getters
  static get Default() {
    return {};
  }
  static get DefaultType() {
    return {};
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  _getConfig(config) {
    config = this._mergeConfigObj(config);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }
  _configAfterMerge(config) {
    return config;
  }
  _mergeConfigObj(config, element) {
    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, "config") : {};
    return {
      ...this.constructor.Default,
      ...typeof jsonConfig === "object" ? jsonConfig : {},
      ...isElement(element) ? Manipulator.getDataAttributes(element) : {},
      ...typeof config === "object" ? config : {}
    };
  }
  _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
    for (const [property, expectedTypes] of Object.entries(configTypes)) {
      const value = config[property];
      const valueType = isElement(value) ? "element" : toType(value);
      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    }
  }
}
const VERSION = "5.3.3";
class BaseComponent extends Config {
  constructor(element, config) {
    super();
    element = getElement(element);
    if (!element) {
      return;
    }
    this._element = element;
    this._config = this._getConfig(config);
    Data.set(this._element, this.constructor.DATA_KEY, this);
  }
  // Public
  dispose() {
    Data.remove(this._element, this.constructor.DATA_KEY);
    EventHandler.off(this._element, this.constructor.EVENT_KEY);
    for (const propertyName of Object.getOwnPropertyNames(this)) {
      this[propertyName] = null;
    }
  }
  _queueCallback(callback, element, isAnimated = true) {
    executeAfterTransition(callback, element, isAnimated);
  }
  _getConfig(config) {
    config = this._mergeConfigObj(config, this._element);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }
  // Static
  static getInstance(element) {
    return Data.get(getElement(element), this.DATA_KEY);
  }
  static getOrCreateInstance(element, config = {}) {
    return this.getInstance(element) || new this(element, typeof config === "object" ? config : null);
  }
  static get VERSION() {
    return VERSION;
  }
  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
  static eventName(name2) {
    return `${name2}${this.EVENT_KEY}`;
  }
}
const getSelector = (element) => {
  let selector = element.getAttribute("data-bs-target");
  if (!selector || selector === "#") {
    let hrefAttribute = element.getAttribute("href");
    if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
      return null;
    }
    if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
      hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
    }
    selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
  }
  return selector ? selector.split(",").map((sel) => parseSelector(sel)).join(",") : null;
};
const SelectorEngine = {
  find(selector, element = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
  },
  findOne(selector, element = document.documentElement) {
    return Element.prototype.querySelector.call(element, selector);
  },
  children(element, selector) {
    return [].concat(...element.children).filter((child) => child.matches(selector));
  },
  parents(element, selector) {
    const parents = [];
    let ancestor = element.parentNode.closest(selector);
    while (ancestor) {
      parents.push(ancestor);
      ancestor = ancestor.parentNode.closest(selector);
    }
    return parents;
  },
  prev(element, selector) {
    let previous = element.previousElementSibling;
    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }
      previous = previous.previousElementSibling;
    }
    return [];
  },
  // TODO: this is now unused; remove later along with prev()
  next(element, selector) {
    let next = element.nextElementSibling;
    while (next) {
      if (next.matches(selector)) {
        return [next];
      }
      next = next.nextElementSibling;
    }
    return [];
  },
  focusableChildren(element) {
    const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
    return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
  },
  getSelectorFromElement(element) {
    const selector = getSelector(element);
    if (selector) {
      return SelectorEngine.findOne(selector) ? selector : null;
    }
    return null;
  },
  getElementFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.findOne(selector) : null;
  },
  getMultipleElementsFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.find(selector) : [];
  }
};
const enableDismissTrigger = (component, method = "hide") => {
  const clickEvent = `click.dismiss${component.EVENT_KEY}`;
  const name2 = component.NAME;
  EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name2}"]`, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name2}`);
    const instance = component.getOrCreateInstance(target);
    instance[method]();
  });
};
const NAME$f = "alert";
const DATA_KEY$a = "bs.alert";
const EVENT_KEY$b = `.${DATA_KEY$a}`;
const EVENT_CLOSE = `close${EVENT_KEY$b}`;
const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
const CLASS_NAME_FADE$5 = "fade";
const CLASS_NAME_SHOW$8 = "show";
class Alert extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$f;
  }
  // Public
  close() {
    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
    if (closeEvent.defaultPrevented) {
      return;
    }
    this._element.classList.remove(CLASS_NAME_SHOW$8);
    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
  }
  // Private
  _destroyElement() {
    this._element.remove();
    EventHandler.trigger(this._element, EVENT_CLOSED);
    this.dispose();
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Alert.getOrCreateInstance(this);
      if (typeof config !== "string") {
        return;
      }
      if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](this);
    });
  }
}
enableDismissTrigger(Alert, "close");
defineJQueryPlugin(Alert);
const NAME$e = "button";
const DATA_KEY$9 = "bs.button";
const EVENT_KEY$a = `.${DATA_KEY$9}`;
const DATA_API_KEY$6 = ".data-api";
const CLASS_NAME_ACTIVE$3 = "active";
const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
class Button2 extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$e;
  }
  // Public
  toggle() {
    this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Button2.getOrCreateInstance(this);
      if (config === "toggle") {
        data[config]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
  event.preventDefault();
  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
  const data = Button2.getOrCreateInstance(button);
  data.toggle();
});
defineJQueryPlugin(Button2);
const NAME$d = "swipe";
const EVENT_KEY$9 = ".bs.swipe";
const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
const POINTER_TYPE_TOUCH = "touch";
const POINTER_TYPE_PEN = "pen";
const CLASS_NAME_POINTER_EVENT = "pointer-event";
const SWIPE_THRESHOLD = 40;
const Default$c = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
};
const DefaultType$c = {
  endCallback: "(function|null)",
  leftCallback: "(function|null)",
  rightCallback: "(function|null)"
};
class Swipe extends Config {
  constructor(element, config) {
    super();
    this._element = element;
    if (!element || !Swipe.isSupported()) {
      return;
    }
    this._config = this._getConfig(config);
    this._deltaX = 0;
    this._supportPointerEvents = Boolean(window.PointerEvent);
    this._initEvents();
  }
  // Getters
  static get Default() {
    return Default$c;
  }
  static get DefaultType() {
    return DefaultType$c;
  }
  static get NAME() {
    return NAME$d;
  }
  // Public
  dispose() {
    EventHandler.off(this._element, EVENT_KEY$9);
  }
  // Private
  _start(event) {
    if (!this._supportPointerEvents) {
      this._deltaX = event.touches[0].clientX;
      return;
    }
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX;
    }
  }
  _end(event) {
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX - this._deltaX;
    }
    this._handleSwipe();
    execute(this._config.endCallback);
  }
  _move(event) {
    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
  }
  _handleSwipe() {
    const absDeltaX = Math.abs(this._deltaX);
    if (absDeltaX <= SWIPE_THRESHOLD) {
      return;
    }
    const direction = absDeltaX / this._deltaX;
    this._deltaX = 0;
    if (!direction) {
      return;
    }
    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
  }
  _initEvents() {
    if (this._supportPointerEvents) {
      EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
      EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
      this._element.classList.add(CLASS_NAME_POINTER_EVENT);
    } else {
      EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
      EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
      EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
    }
  }
  _eventIsPointerPenTouch(event) {
    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
  }
  // Static
  static isSupported() {
    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
}
const NAME$c = "carousel";
const DATA_KEY$8 = "bs.carousel";
const EVENT_KEY$8 = `.${DATA_KEY$8}`;
const DATA_API_KEY$5 = ".data-api";
const ARROW_LEFT_KEY$1 = "ArrowLeft";
const ARROW_RIGHT_KEY$1 = "ArrowRight";
const TOUCHEVENT_COMPAT_WAIT = 500;
const ORDER_NEXT = "next";
const ORDER_PREV = "prev";
const DIRECTION_LEFT = "left";
const DIRECTION_RIGHT = "right";
const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
const EVENT_SLID = `slid${EVENT_KEY$8}`;
const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
const CLASS_NAME_CAROUSEL = "carousel";
const CLASS_NAME_ACTIVE$2 = "active";
const CLASS_NAME_SLIDE = "slide";
const CLASS_NAME_END = "carousel-item-end";
const CLASS_NAME_START = "carousel-item-start";
const CLASS_NAME_NEXT = "carousel-item-next";
const CLASS_NAME_PREV = "carousel-item-prev";
const SELECTOR_ACTIVE = ".active";
const SELECTOR_ITEM = ".carousel-item";
const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
const SELECTOR_ITEM_IMG = ".carousel-item img";
const SELECTOR_INDICATORS = ".carousel-indicators";
const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
const KEY_TO_DIRECTION = {
  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
const Default$b = {
  interval: 5e3,
  keyboard: true,
  pause: "hover",
  ride: false,
  touch: true,
  wrap: true
};
const DefaultType$b = {
  interval: "(number|boolean)",
  // TODO:v6 remove boolean support
  keyboard: "boolean",
  pause: "(string|boolean)",
  ride: "(boolean|string)",
  touch: "boolean",
  wrap: "boolean"
};
class Carousel extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._interval = null;
    this._activeElement = null;
    this._isSliding = false;
    this.touchTimeout = null;
    this._swipeHelper = null;
    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
    this._addEventListeners();
    if (this._config.ride === CLASS_NAME_CAROUSEL) {
      this.cycle();
    }
  }
  // Getters
  static get Default() {
    return Default$b;
  }
  static get DefaultType() {
    return DefaultType$b;
  }
  static get NAME() {
    return NAME$c;
  }
  // Public
  next() {
    this._slide(ORDER_NEXT);
  }
  nextWhenVisible() {
    if (!document.hidden && isVisible(this._element)) {
      this.next();
    }
  }
  prev() {
    this._slide(ORDER_PREV);
  }
  pause() {
    if (this._isSliding) {
      triggerTransitionEnd(this._element);
    }
    this._clearInterval();
  }
  cycle() {
    this._clearInterval();
    this._updateInterval();
    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
  }
  _maybeEnableCycle() {
    if (!this._config.ride) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
      return;
    }
    this.cycle();
  }
  to(index) {
    const items = this._getItems();
    if (index > items.length - 1 || index < 0) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
      return;
    }
    const activeIndex = this._getItemIndex(this._getActive());
    if (activeIndex === index) {
      return;
    }
    const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
    this._slide(order2, items[index]);
  }
  dispose() {
    if (this._swipeHelper) {
      this._swipeHelper.dispose();
    }
    super.dispose();
  }
  // Private
  _configAfterMerge(config) {
    config.defaultInterval = config.interval;
    return config;
  }
  _addEventListeners() {
    if (this._config.keyboard) {
      EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
    }
    if (this._config.pause === "hover") {
      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
    }
    if (this._config.touch && Swipe.isSupported()) {
      this._addTouchEventListeners();
    }
  }
  _addTouchEventListeners() {
    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
      EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
    }
    const endCallBack = () => {
      if (this._config.pause !== "hover") {
        return;
      }
      this.pause();
      if (this.touchTimeout) {
        clearTimeout(this.touchTimeout);
      }
      this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
    };
    const swipeConfig = {
      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
      endCallback: endCallBack
    };
    this._swipeHelper = new Swipe(this._element, swipeConfig);
  }
  _keydown(event) {
    if (/input|textarea/i.test(event.target.tagName)) {
      return;
    }
    const direction = KEY_TO_DIRECTION[event.key];
    if (direction) {
      event.preventDefault();
      this._slide(this._directionToOrder(direction));
    }
  }
  _getItemIndex(element) {
    return this._getItems().indexOf(element);
  }
  _setActiveIndicatorElement(index) {
    if (!this._indicatorsElement) {
      return;
    }
    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
    activeIndicator.removeAttribute("aria-current");
    const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
    if (newActiveIndicator) {
      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
      newActiveIndicator.setAttribute("aria-current", "true");
    }
  }
  _updateInterval() {
    const element = this._activeElement || this._getActive();
    if (!element) {
      return;
    }
    const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
    this._config.interval = elementInterval || this._config.defaultInterval;
  }
  _slide(order2, element = null) {
    if (this._isSliding) {
      return;
    }
    const activeElement = this._getActive();
    const isNext = order2 === ORDER_NEXT;
    const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
    if (nextElement === activeElement) {
      return;
    }
    const nextElementIndex = this._getItemIndex(nextElement);
    const triggerEvent = (eventName) => {
      return EventHandler.trigger(this._element, eventName, {
        relatedTarget: nextElement,
        direction: this._orderToDirection(order2),
        from: this._getItemIndex(activeElement),
        to: nextElementIndex
      });
    };
    const slideEvent = triggerEvent(EVENT_SLIDE);
    if (slideEvent.defaultPrevented) {
      return;
    }
    if (!activeElement || !nextElement) {
      return;
    }
    const isCycling = Boolean(this._interval);
    this.pause();
    this._isSliding = true;
    this._setActiveIndicatorElement(nextElementIndex);
    this._activeElement = nextElement;
    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
    nextElement.classList.add(orderClassName);
    reflow(nextElement);
    activeElement.classList.add(directionalClassName);
    nextElement.classList.add(directionalClassName);
    const completeCallBack = () => {
      nextElement.classList.remove(directionalClassName, orderClassName);
      nextElement.classList.add(CLASS_NAME_ACTIVE$2);
      activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
      this._isSliding = false;
      triggerEvent(EVENT_SLID);
    };
    this._queueCallback(completeCallBack, activeElement, this._isAnimated());
    if (isCycling) {
      this.cycle();
    }
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_SLIDE);
  }
  _getActive() {
    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
  }
  _getItems() {
    return SelectorEngine.find(SELECTOR_ITEM, this._element);
  }
  _clearInterval() {
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
  }
  _directionToOrder(direction) {
    if (isRTL()) {
      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
    }
    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
  }
  _orderToDirection(order2) {
    if (isRTL()) {
      return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Carousel.getOrCreateInstance(this, config);
      if (typeof config === "number") {
        data.to(config);
        return;
      }
      if (typeof config === "string") {
        if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
    return;
  }
  event.preventDefault();
  const carousel = Carousel.getOrCreateInstance(target);
  const slideIndex = this.getAttribute("data-bs-slide-to");
  if (slideIndex) {
    carousel.to(slideIndex);
    carousel._maybeEnableCycle();
    return;
  }
  if (Manipulator.getDataAttribute(this, "slide") === "next") {
    carousel.next();
    carousel._maybeEnableCycle();
    return;
  }
  carousel.prev();
  carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
  for (const carousel of carousels) {
    Carousel.getOrCreateInstance(carousel);
  }
});
defineJQueryPlugin(Carousel);
const NAME$b = "collapse";
const DATA_KEY$7 = "bs.collapse";
const EVENT_KEY$7 = `.${DATA_KEY$7}`;
const DATA_API_KEY$4 = ".data-api";
const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
const CLASS_NAME_SHOW$7 = "show";
const CLASS_NAME_COLLAPSE = "collapse";
const CLASS_NAME_COLLAPSING = "collapsing";
const CLASS_NAME_COLLAPSED = "collapsed";
const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
const CLASS_NAME_HORIZONTAL = "collapse-horizontal";
const WIDTH = "width";
const HEIGHT = "height";
const SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
const Default$a = {
  parent: null,
  toggle: true
};
const DefaultType$a = {
  parent: "(null|element)",
  toggle: "boolean"
};
class Collapse extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._isTransitioning = false;
    this._triggerArray = [];
    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
    for (const elem of toggleList) {
      const selector = SelectorEngine.getSelectorFromElement(elem);
      const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
      if (selector !== null && filterElement.length) {
        this._triggerArray.push(elem);
      }
    }
    this._initializeChildren();
    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
    }
    if (this._config.toggle) {
      this.toggle();
    }
  }
  // Getters
  static get Default() {
    return Default$a;
  }
  static get DefaultType() {
    return DefaultType$a;
  }
  static get NAME() {
    return NAME$b;
  }
  // Public
  toggle() {
    if (this._isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }
  show() {
    if (this._isTransitioning || this._isShown()) {
      return;
    }
    let activeChildren = [];
    if (this._config.parent) {
      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => Collapse.getOrCreateInstance(element, {
        toggle: false
      }));
    }
    if (activeChildren.length && activeChildren[0]._isTransitioning) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    for (const activeInstance of activeChildren) {
      activeInstance.hide();
    }
    const dimension = this._getDimension();
    this._element.classList.remove(CLASS_NAME_COLLAPSE);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.style[dimension] = 0;
    this._addAriaAndCollapsedClass(this._triggerArray, true);
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      this._element.style[dimension] = "";
      EventHandler.trigger(this._element, EVENT_SHOWN$6);
    };
    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;
    this._queueCallback(complete, this._element, true);
    this._element.style[dimension] = `${this._element[scrollSize]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown()) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    const dimension = this._getDimension();
    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
    for (const trigger of this._triggerArray) {
      const element = SelectorEngine.getElementFromSelector(trigger);
      if (element && !this._isShown(element)) {
        this._addAriaAndCollapsedClass([trigger], false);
      }
    }
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE);
      EventHandler.trigger(this._element, EVENT_HIDDEN$6);
    };
    this._element.style[dimension] = "";
    this._queueCallback(complete, this._element, true);
  }
  _isShown(element = this._element) {
    return element.classList.contains(CLASS_NAME_SHOW$7);
  }
  // Private
  _configAfterMerge(config) {
    config.toggle = Boolean(config.toggle);
    config.parent = getElement(config.parent);
    return config;
  }
  _getDimension() {
    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
  }
  _initializeChildren() {
    if (!this._config.parent) {
      return;
    }
    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
    for (const element of children) {
      const selected = SelectorEngine.getElementFromSelector(element);
      if (selected) {
        this._addAriaAndCollapsedClass([element], this._isShown(selected));
      }
    }
  }
  _getFirstLevelChildren(selector) {
    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
    return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
  }
  _addAriaAndCollapsedClass(triggerArray, isOpen) {
    if (!triggerArray.length) {
      return;
    }
    for (const element of triggerArray) {
      element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
      element.setAttribute("aria-expanded", isOpen);
    }
  }
  // Static
  static jQueryInterface(config) {
    const _config = {};
    if (typeof config === "string" && /show|hide/.test(config)) {
      _config.toggle = false;
    }
    return this.each(function() {
      const data = Collapse.getOrCreateInstance(this, _config);
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
  if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
    event.preventDefault();
  }
  for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
    Collapse.getOrCreateInstance(element, {
      toggle: false
    }).toggle();
  }
});
defineJQueryPlugin(Collapse);
const NAME$a = "dropdown";
const DATA_KEY$6 = "bs.dropdown";
const EVENT_KEY$6 = `.${DATA_KEY$6}`;
const DATA_API_KEY$3 = ".data-api";
const ESCAPE_KEY$2 = "Escape";
const TAB_KEY$1 = "Tab";
const ARROW_UP_KEY$1 = "ArrowUp";
const ARROW_DOWN_KEY$1 = "ArrowDown";
const RIGHT_MOUSE_BUTTON = 2;
const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
const CLASS_NAME_SHOW$6 = "show";
const CLASS_NAME_DROPUP = "dropup";
const CLASS_NAME_DROPEND = "dropend";
const CLASS_NAME_DROPSTART = "dropstart";
const CLASS_NAME_DROPUP_CENTER = "dropup-center";
const CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
const SELECTOR_MENU = ".dropdown-menu";
const SELECTOR_NAVBAR = ".navbar";
const SELECTOR_NAVBAR_NAV = ".navbar-nav";
const SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
const PLACEMENT_TOPCENTER = "top";
const PLACEMENT_BOTTOMCENTER = "bottom";
const Default$9 = {
  autoClose: true,
  boundary: "clippingParents",
  display: "dynamic",
  offset: [0, 2],
  popperConfig: null,
  reference: "toggle"
};
const DefaultType$9 = {
  autoClose: "(boolean|string)",
  boundary: "(string|element)",
  display: "string",
  offset: "(array|string|function)",
  popperConfig: "(null|object|function)",
  reference: "(string|element|object)"
};
class Dropdown extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._popper = null;
    this._parent = this._element.parentNode;
    this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
    this._inNavbar = this._detectNavbar();
  }
  // Getters
  static get Default() {
    return Default$9;
  }
  static get DefaultType() {
    return DefaultType$9;
  }
  static get NAME() {
    return NAME$a;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (isDisabled(this._element) || this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._createPopper();
    if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, "mouseover", noop);
      }
    }
    this._element.focus();
    this._element.setAttribute("aria-expanded", true);
    this._menu.classList.add(CLASS_NAME_SHOW$6);
    this._element.classList.add(CLASS_NAME_SHOW$6);
    EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
  }
  hide() {
    if (isDisabled(this._element) || !this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    this._completeHide(relatedTarget);
  }
  dispose() {
    if (this._popper) {
      this._popper.destroy();
    }
    super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar();
    if (this._popper) {
      this._popper.update();
    }
  }
  // Private
  _completeHide(relatedTarget) {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
    if (hideEvent.defaultPrevented) {
      return;
    }
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, "mouseover", noop);
      }
    }
    if (this._popper) {
      this._popper.destroy();
    }
    this._menu.classList.remove(CLASS_NAME_SHOW$6);
    this._element.classList.remove(CLASS_NAME_SHOW$6);
    this._element.setAttribute("aria-expanded", "false");
    Manipulator.removeDataAttribute(this._menu, "popper");
    EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
  }
  _getConfig(config) {
    config = super._getConfig(config);
    if (typeof config.reference === "object" && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== "function") {
      throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
    }
    return config;
  }
  _createPopper() {
    if (typeof Popper === "undefined") {
      throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
    }
    let referenceElement = this._element;
    if (this._config.reference === "parent") {
      referenceElement = this._parent;
    } else if (isElement(this._config.reference)) {
      referenceElement = getElement(this._config.reference);
    } else if (typeof this._config.reference === "object") {
      referenceElement = this._config.reference;
    }
    const popperConfig = this._getPopperConfig();
    this._popper = createPopper(referenceElement, this._menu, popperConfig);
  }
  _isShown() {
    return this._menu.classList.contains(CLASS_NAME_SHOW$6);
  }
  _getPlacement() {
    const parentDropdown = this._parent;
    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
      return PLACEMENT_RIGHT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
      return PLACEMENT_LEFT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
      return PLACEMENT_TOPCENTER;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
      return PLACEMENT_BOTTOMCENTER;
    }
    const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
    }
    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
  }
  _detectNavbar() {
    return this._element.closest(SELECTOR_NAVBAR) !== null;
  }
  _getOffset() {
    const {
      offset: offset2
    } = this._config;
    if (typeof offset2 === "string") {
      return offset2.split(",").map((value) => Number.parseInt(value, 10));
    }
    if (typeof offset2 === "function") {
      return (popperData) => offset2(popperData, this._element);
    }
    return offset2;
  }
  _getPopperConfig() {
    const defaultBsPopperConfig = {
      placement: this._getPlacement(),
      modifiers: [{
        name: "preventOverflow",
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: "offset",
        options: {
          offset: this._getOffset()
        }
      }]
    };
    if (this._inNavbar || this._config.display === "static") {
      Manipulator.setDataAttribute(this._menu, "popper", "static");
      defaultBsPopperConfig.modifiers = [{
        name: "applyStyles",
        enabled: false
      }];
    }
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _selectMenuItem({
    key,
    target
  }) {
    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
    if (!items.length) {
      return;
    }
    getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Dropdown.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
  static clearMenus(event) {
    if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
      return;
    }
    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
    for (const toggle of openToggles) {
      const context = Dropdown.getInstance(toggle);
      if (!context || context._config.autoClose === false) {
        continue;
      }
      const composedPath = event.composedPath();
      const isMenuTarget = composedPath.includes(context._menu);
      if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
        continue;
      }
      if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
        continue;
      }
      const relatedTarget = {
        relatedTarget: context._element
      };
      if (event.type === "click") {
        relatedTarget.clickEvent = event;
      }
      context._completeHide(relatedTarget);
    }
  }
  static dataApiKeydownHandler(event) {
    const isInput = /input|textarea/i.test(event.target.tagName);
    const isEscapeEvent = event.key === ESCAPE_KEY$2;
    const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
    if (!isUpOrDownEvent && !isEscapeEvent) {
      return;
    }
    if (isInput && !isEscapeEvent) {
      return;
    }
    event.preventDefault();
    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
    const instance = Dropdown.getOrCreateInstance(getToggleButton);
    if (isUpOrDownEvent) {
      event.stopPropagation();
      instance.show();
      instance._selectMenuItem(event);
      return;
    }
    if (instance._isShown()) {
      event.stopPropagation();
      instance.hide();
      getToggleButton.focus();
    }
  }
}
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});
defineJQueryPlugin(Dropdown);
const NAME$9 = "backdrop";
const CLASS_NAME_FADE$4 = "fade";
const CLASS_NAME_SHOW$5 = "show";
const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
const Default$8 = {
  className: "modal-backdrop",
  clickCallback: null,
  isAnimated: false,
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  rootElement: "body"
  // give the choice to place backdrop under different elements
};
const DefaultType$8 = {
  className: "string",
  clickCallback: "(function|null)",
  isAnimated: "boolean",
  isVisible: "boolean",
  rootElement: "(element|string)"
};
class Backdrop extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
    this._isAppended = false;
    this._element = null;
  }
  // Getters
  static get Default() {
    return Default$8;
  }
  static get DefaultType() {
    return DefaultType$8;
  }
  static get NAME() {
    return NAME$9;
  }
  // Public
  show(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._append();
    const element = this._getElement();
    if (this._config.isAnimated) {
      reflow(element);
    }
    element.classList.add(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      execute(callback);
    });
  }
  hide(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._getElement().classList.remove(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      this.dispose();
      execute(callback);
    });
  }
  dispose() {
    if (!this._isAppended) {
      return;
    }
    EventHandler.off(this._element, EVENT_MOUSEDOWN);
    this._element.remove();
    this._isAppended = false;
  }
  // Private
  _getElement() {
    if (!this._element) {
      const backdrop = document.createElement("div");
      backdrop.className = this._config.className;
      if (this._config.isAnimated) {
        backdrop.classList.add(CLASS_NAME_FADE$4);
      }
      this._element = backdrop;
    }
    return this._element;
  }
  _configAfterMerge(config) {
    config.rootElement = getElement(config.rootElement);
    return config;
  }
  _append() {
    if (this._isAppended) {
      return;
    }
    const element = this._getElement();
    this._config.rootElement.append(element);
    EventHandler.on(element, EVENT_MOUSEDOWN, () => {
      execute(this._config.clickCallback);
    });
    this._isAppended = true;
  }
  _emulateAnimation(callback) {
    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
  }
}
const NAME$8 = "focustrap";
const DATA_KEY$5 = "bs.focustrap";
const EVENT_KEY$5 = `.${DATA_KEY$5}`;
const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
const TAB_KEY = "Tab";
const TAB_NAV_FORWARD = "forward";
const TAB_NAV_BACKWARD = "backward";
const Default$7 = {
  autofocus: true,
  trapElement: null
  // The element to trap focus inside of
};
const DefaultType$7 = {
  autofocus: "boolean",
  trapElement: "element"
};
let FocusTrap$1 = class FocusTrap extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
    this._isActive = false;
    this._lastTabNavDirection = null;
  }
  // Getters
  static get Default() {
    return Default$7;
  }
  static get DefaultType() {
    return DefaultType$7;
  }
  static get NAME() {
    return NAME$8;
  }
  // Public
  activate() {
    if (this._isActive) {
      return;
    }
    if (this._config.autofocus) {
      this._config.trapElement.focus();
    }
    EventHandler.off(document, EVENT_KEY$5);
    EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
    EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
    this._isActive = true;
  }
  deactivate() {
    if (!this._isActive) {
      return;
    }
    this._isActive = false;
    EventHandler.off(document, EVENT_KEY$5);
  }
  // Private
  _handleFocusin(event) {
    const {
      trapElement
    } = this._config;
    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
      return;
    }
    const elements2 = SelectorEngine.focusableChildren(trapElement);
    if (elements2.length === 0) {
      trapElement.focus();
    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
      elements2[elements2.length - 1].focus();
    } else {
      elements2[0].focus();
    }
  }
  _handleKeydown(event) {
    if (event.key !== TAB_KEY) {
      return;
    }
    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
  }
};
const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
const SELECTOR_STICKY_CONTENT = ".sticky-top";
const PROPERTY_PADDING = "padding-right";
const PROPERTY_MARGIN = "margin-right";
class ScrollBarHelper {
  constructor() {
    this._element = document.body;
  }
  // Public
  getWidth() {
    const documentWidth = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }
  hide() {
    const width = this.getWidth();
    this._disableOverFlow();
    this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow");
    this._resetElementAttributes(this._element, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
  // Private
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow");
    this._element.style.overflow = "hidden";
  }
  _setElementAttributes(selector, styleProperty, callback) {
    const scrollbarWidth = this.getWidth();
    const manipulationCallBack = (element) => {
      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
        return;
      }
      this._saveInitialAttribute(element, styleProperty);
      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _saveInitialAttribute(element, styleProperty) {
    const actualValue = element.style.getPropertyValue(styleProperty);
    if (actualValue) {
      Manipulator.setDataAttribute(element, styleProperty, actualValue);
    }
  }
  _resetElementAttributes(selector, styleProperty) {
    const manipulationCallBack = (element) => {
      const value = Manipulator.getDataAttribute(element, styleProperty);
      if (value === null) {
        element.style.removeProperty(styleProperty);
        return;
      }
      Manipulator.removeDataAttribute(element, styleProperty);
      element.style.setProperty(styleProperty, value);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _applyManipulationCallback(selector, callBack) {
    if (isElement(selector)) {
      callBack(selector);
      return;
    }
    for (const sel of SelectorEngine.find(selector, this._element)) {
      callBack(sel);
    }
  }
}
const NAME$7 = "modal";
const DATA_KEY$4 = "bs.modal";
const EVENT_KEY$4 = `.${DATA_KEY$4}`;
const DATA_API_KEY$2 = ".data-api";
const ESCAPE_KEY$1 = "Escape";
const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
const CLASS_NAME_OPEN = "modal-open";
const CLASS_NAME_FADE$3 = "fade";
const CLASS_NAME_SHOW$4 = "show";
const CLASS_NAME_STATIC = "modal-static";
const OPEN_SELECTOR$1 = ".modal.show";
const SELECTOR_DIALOG = ".modal-dialog";
const SELECTOR_MODAL_BODY = ".modal-body";
const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
const Default$6 = {
  backdrop: true,
  focus: true,
  keyboard: true
};
const DefaultType$6 = {
  backdrop: "(boolean|string)",
  focus: "boolean",
  keyboard: "boolean"
};
class Modal extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._isShown = false;
    this._isTransitioning = false;
    this._scrollBar = new ScrollBarHelper();
    this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Default$6;
  }
  static get DefaultType() {
    return DefaultType$6;
  }
  static get NAME() {
    return NAME$7;
  }
  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._isTransitioning = true;
    this._scrollBar.hide();
    document.body.classList.add(CLASS_NAME_OPEN);
    this._adjustDialog();
    this._backdrop.show(() => this._showElement(relatedTarget));
  }
  hide() {
    if (!this._isShown || this._isTransitioning) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._isShown = false;
    this._isTransitioning = true;
    this._focustrap.deactivate();
    this._element.classList.remove(CLASS_NAME_SHOW$4);
    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
  }
  dispose() {
    EventHandler.off(window, EVENT_KEY$4);
    EventHandler.off(this._dialog, EVENT_KEY$4);
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _initializeBackDrop() {
    return new Backdrop({
      isVisible: Boolean(this._config.backdrop),
      // 'static' option will be translated to true, and booleans will keep their value,
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap$1({
      trapElement: this._element
    });
  }
  _showElement(relatedTarget) {
    if (!document.body.contains(this._element)) {
      document.body.append(this._element);
    }
    this._element.style.display = "block";
    this._element.removeAttribute("aria-hidden");
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.scrollTop = 0;
    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
    if (modalBody) {
      modalBody.scrollTop = 0;
    }
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW$4);
    const transitionComplete = () => {
      if (this._config.focus) {
        this._focustrap.activate();
      }
      this._isTransitioning = false;
      EventHandler.trigger(this._element, EVENT_SHOWN$4, {
        relatedTarget
      });
    };
    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
      if (event.key !== ESCAPE_KEY$1) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      this._triggerBackdropTransition();
    });
    EventHandler.on(window, EVENT_RESIZE$1, () => {
      if (this._isShown && !this._isTransitioning) {
        this._adjustDialog();
      }
    });
    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
      EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
        if (this._element !== event.target || this._element !== event2.target) {
          return;
        }
        if (this._config.backdrop === "static") {
          this._triggerBackdropTransition();
          return;
        }
        if (this._config.backdrop) {
          this.hide();
        }
      });
    });
  }
  _hideModal() {
    this._element.style.display = "none";
    this._element.setAttribute("aria-hidden", true);
    this._element.removeAttribute("aria-modal");
    this._element.removeAttribute("role");
    this._isTransitioning = false;
    this._backdrop.hide(() => {
      document.body.classList.remove(CLASS_NAME_OPEN);
      this._resetAdjustments();
      this._scrollBar.reset();
      EventHandler.trigger(this._element, EVENT_HIDDEN$4);
    });
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_FADE$3);
  }
  _triggerBackdropTransition() {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const initialOverflowY = this._element.style.overflowY;
    if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
      return;
    }
    if (!isModalOverflowing) {
      this._element.style.overflowY = "hidden";
    }
    this._element.classList.add(CLASS_NAME_STATIC);
    this._queueCallback(() => {
      this._element.classList.remove(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.style.overflowY = initialOverflowY;
      }, this._dialog);
    }, this._dialog);
    this._element.focus();
  }
  /**
   * The following methods are used to handle overflowing modals
   */
  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const scrollbarWidth = this._scrollBar.getWidth();
    const isBodyOverflowing = scrollbarWidth > 0;
    if (isBodyOverflowing && !isModalOverflowing) {
      const property = isRTL() ? "paddingLeft" : "paddingRight";
      this._element.style[property] = `${scrollbarWidth}px`;
    }
    if (!isBodyOverflowing && isModalOverflowing) {
      const property = isRTL() ? "paddingRight" : "paddingLeft";
      this._element.style[property] = `${scrollbarWidth}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "";
    this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(config, relatedTarget) {
    return this.each(function() {
      const data = Modal.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](relatedTarget);
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
    if (showEvent.defaultPrevented) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$4, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
  });
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
  if (alreadyOpen) {
    Modal.getInstance(alreadyOpen).hide();
  }
  const data = Modal.getOrCreateInstance(target);
  data.toggle(this);
});
enableDismissTrigger(Modal);
defineJQueryPlugin(Modal);
const NAME$6 = "offcanvas";
const DATA_KEY$3 = "bs.offcanvas";
const EVENT_KEY$3 = `.${DATA_KEY$3}`;
const DATA_API_KEY$1 = ".data-api";
const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
const ESCAPE_KEY = "Escape";
const CLASS_NAME_SHOW$3 = "show";
const CLASS_NAME_SHOWING$1 = "showing";
const CLASS_NAME_HIDING = "hiding";
const CLASS_NAME_BACKDROP = "offcanvas-backdrop";
const OPEN_SELECTOR = ".offcanvas.show";
const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
const Default$5 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
const DefaultType$5 = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  scroll: "boolean"
};
class Offcanvas extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._isShown = false;
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Default$5;
  }
  static get DefaultType() {
    return DefaultType$5;
  }
  static get NAME() {
    return NAME$6;
  }
  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._backdrop.show();
    if (!this._config.scroll) {
      new ScrollBarHelper().hide();
    }
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.classList.add(CLASS_NAME_SHOWING$1);
    const completeCallBack = () => {
      if (!this._config.scroll || this._config.backdrop) {
        this._focustrap.activate();
      }
      this._element.classList.add(CLASS_NAME_SHOW$3);
      this._element.classList.remove(CLASS_NAME_SHOWING$1);
      EventHandler.trigger(this._element, EVENT_SHOWN$3, {
        relatedTarget
      });
    };
    this._queueCallback(completeCallBack, this._element, true);
  }
  hide() {
    if (!this._isShown) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._focustrap.deactivate();
    this._element.blur();
    this._isShown = false;
    this._element.classList.add(CLASS_NAME_HIDING);
    this._backdrop.hide();
    const completeCallback = () => {
      this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      if (!this._config.scroll) {
        new ScrollBarHelper().reset();
      }
      EventHandler.trigger(this._element, EVENT_HIDDEN$3);
    };
    this._queueCallback(completeCallback, this._element, true);
  }
  dispose() {
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  // Private
  _initializeBackDrop() {
    const clickCallback = () => {
      if (this._config.backdrop === "static") {
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        return;
      }
      this.hide();
    };
    const isVisible2 = Boolean(this._config.backdrop);
    return new Backdrop({
      className: CLASS_NAME_BACKDROP,
      isVisible: isVisible2,
      isAnimated: true,
      rootElement: this._element.parentNode,
      clickCallback: isVisible2 ? clickCallback : null
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap$1({
      trapElement: this._element
    });
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
      if (event.key !== ESCAPE_KEY) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
    });
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Offcanvas.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config](this);
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  EventHandler.one(target, EVENT_HIDDEN$3, () => {
    if (isVisible(this)) {
      this.focus();
    }
  });
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
  if (alreadyOpen && alreadyOpen !== target) {
    Offcanvas.getInstance(alreadyOpen).hide();
  }
  const data = Offcanvas.getOrCreateInstance(target);
  data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
  for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
    Offcanvas.getOrCreateInstance(selector).show();
  }
});
EventHandler.on(window, EVENT_RESIZE, () => {
  for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
    if (getComputedStyle(element).position !== "fixed") {
      Offcanvas.getOrCreateInstance(element).hide();
    }
  }
});
enableDismissTrigger(Offcanvas);
defineJQueryPlugin(Offcanvas);
const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
const DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  dd: [],
  div: [],
  dl: [],
  dt: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
const uriAttributes = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
const allowedAttribute = (attribute, allowedAttributeList) => {
  const attributeName = attribute.nodeName.toLowerCase();
  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
    }
    return true;
  }
  return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }
  if (sanitizeFunction && typeof sanitizeFunction === "function") {
    return sanitizeFunction(unsafeHtml);
  }
  const domParser = new window.DOMParser();
  const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
  const elements2 = [].concat(...createdDocument.body.querySelectorAll("*"));
  for (const element of elements2) {
    const elementName = element.nodeName.toLowerCase();
    if (!Object.keys(allowList).includes(elementName)) {
      element.remove();
      continue;
    }
    const attributeList = [].concat(...element.attributes);
    const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
    for (const attribute of attributeList) {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element.removeAttribute(attribute.nodeName);
      }
    }
  }
  return createdDocument.body.innerHTML;
}
const NAME$5 = "TemplateFactory";
const Default$4 = {
  allowList: DefaultAllowlist,
  content: {},
  // { selector : text ,  selector2 : text2 , }
  extraClass: "",
  html: false,
  sanitize: true,
  sanitizeFn: null,
  template: "<div></div>"
};
const DefaultType$4 = {
  allowList: "object",
  content: "object",
  extraClass: "(string|function)",
  html: "boolean",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  template: "string"
};
const DefaultContentType = {
  entry: "(string|element|function|null)",
  selector: "(string|element)"
};
class TemplateFactory extends Config {
  constructor(config) {
    super();
    this._config = this._getConfig(config);
  }
  // Getters
  static get Default() {
    return Default$4;
  }
  static get DefaultType() {
    return DefaultType$4;
  }
  static get NAME() {
    return NAME$5;
  }
  // Public
  getContent() {
    return Object.values(this._config.content).map((config) => this._resolvePossibleFunction(config)).filter(Boolean);
  }
  hasContent() {
    return this.getContent().length > 0;
  }
  changeContent(content) {
    this._checkContent(content);
    this._config.content = {
      ...this._config.content,
      ...content
    };
    return this;
  }
  toHtml() {
    const templateWrapper = document.createElement("div");
    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
    for (const [selector, text] of Object.entries(this._config.content)) {
      this._setContent(templateWrapper, text, selector);
    }
    const template2 = templateWrapper.children[0];
    const extraClass = this._resolvePossibleFunction(this._config.extraClass);
    if (extraClass) {
      template2.classList.add(...extraClass.split(" "));
    }
    return template2;
  }
  // Private
  _typeCheckConfig(config) {
    super._typeCheckConfig(config);
    this._checkContent(config.content);
  }
  _checkContent(arg) {
    for (const [selector, content] of Object.entries(arg)) {
      super._typeCheckConfig({
        selector,
        entry: content
      }, DefaultContentType);
    }
  }
  _setContent(template2, content, selector) {
    const templateElement = SelectorEngine.findOne(selector, template2);
    if (!templateElement) {
      return;
    }
    content = this._resolvePossibleFunction(content);
    if (!content) {
      templateElement.remove();
      return;
    }
    if (isElement(content)) {
      this._putElementInTemplate(getElement(content), templateElement);
      return;
    }
    if (this._config.html) {
      templateElement.innerHTML = this._maybeSanitize(content);
      return;
    }
    templateElement.textContent = content;
  }
  _maybeSanitize(arg) {
    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this]);
  }
  _putElementInTemplate(element, templateElement) {
    if (this._config.html) {
      templateElement.innerHTML = "";
      templateElement.append(element);
      return;
    }
    templateElement.textContent = element.textContent;
  }
}
const NAME$4 = "tooltip";
const DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
const CLASS_NAME_FADE$2 = "fade";
const CLASS_NAME_MODAL = "modal";
const CLASS_NAME_SHOW$2 = "show";
const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
const EVENT_MODAL_HIDE = "hide.bs.modal";
const TRIGGER_HOVER = "hover";
const TRIGGER_FOCUS = "focus";
const TRIGGER_CLICK = "click";
const TRIGGER_MANUAL = "manual";
const EVENT_HIDE$2 = "hide";
const EVENT_HIDDEN$2 = "hidden";
const EVENT_SHOW$2 = "show";
const EVENT_SHOWN$2 = "shown";
const EVENT_INSERTED = "inserted";
const EVENT_CLICK$1 = "click";
const EVENT_FOCUSIN$1 = "focusin";
const EVENT_FOCUSOUT$1 = "focusout";
const EVENT_MOUSEENTER = "mouseenter";
const EVENT_MOUSELEAVE = "mouseleave";
const AttachmentMap = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: isRTL() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: isRTL() ? "right" : "left"
};
const Default$3 = {
  allowList: DefaultAllowlist,
  animation: true,
  boundary: "clippingParents",
  container: false,
  customClass: "",
  delay: 0,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  html: false,
  offset: [0, 6],
  placement: "top",
  popperConfig: null,
  sanitize: true,
  sanitizeFn: null,
  selector: false,
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  title: "",
  trigger: "hover focus"
};
const DefaultType$3 = {
  allowList: "object",
  animation: "boolean",
  boundary: "(string|element)",
  container: "(string|element|boolean)",
  customClass: "(string|function)",
  delay: "(number|object)",
  fallbackPlacements: "array",
  html: "boolean",
  offset: "(array|string|function)",
  placement: "(string|function)",
  popperConfig: "(null|object|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  selector: "(string|boolean)",
  template: "string",
  title: "(string|element|function)",
  trigger: "string"
};
class Tooltip extends BaseComponent {
  constructor(element, config) {
    if (typeof Popper === "undefined") {
      throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
    }
    super(element, config);
    this._isEnabled = true;
    this._timeout = 0;
    this._isHovered = null;
    this._activeTrigger = {};
    this._popper = null;
    this._templateFactory = null;
    this._newContent = null;
    this.tip = null;
    this._setListeners();
    if (!this._config.selector) {
      this._fixTitle();
    }
  }
  // Getters
  static get Default() {
    return Default$3;
  }
  static get DefaultType() {
    return DefaultType$3;
  }
  static get NAME() {
    return NAME$4;
  }
  // Public
  enable() {
    this._isEnabled = true;
  }
  disable() {
    this._isEnabled = false;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle() {
    if (!this._isEnabled) {
      return;
    }
    this._activeTrigger.click = !this._activeTrigger.click;
    if (this._isShown()) {
      this._leave();
      return;
    }
    this._enter();
  }
  dispose() {
    clearTimeout(this._timeout);
    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    if (this._element.getAttribute("data-bs-original-title")) {
      this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
    }
    this._disposePopper();
    super.dispose();
  }
  show() {
    if (this._element.style.display === "none") {
      throw new Error("Please use show on visible elements");
    }
    if (!(this._isWithContent() && this._isEnabled)) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
    const shadowRoot = findShadowRoot(this._element);
    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
    if (showEvent.defaultPrevented || !isInTheDom) {
      return;
    }
    this._disposePopper();
    const tip = this._getTipElement();
    this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
    const {
      container
    } = this._config;
    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
      container.append(tip);
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
    }
    this._popper = this._createPopper(tip);
    tip.classList.add(CLASS_NAME_SHOW$2);
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, "mouseover", noop);
      }
    }
    const complete = () => {
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
      if (this._isHovered === false) {
        this._leave();
      }
      this._isHovered = false;
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  hide() {
    if (!this._isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
    if (hideEvent.defaultPrevented) {
      return;
    }
    const tip = this._getTipElement();
    tip.classList.remove(CLASS_NAME_SHOW$2);
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, "mouseover", noop);
      }
    }
    this._activeTrigger[TRIGGER_CLICK] = false;
    this._activeTrigger[TRIGGER_FOCUS] = false;
    this._activeTrigger[TRIGGER_HOVER] = false;
    this._isHovered = null;
    const complete = () => {
      if (this._isWithActiveTrigger()) {
        return;
      }
      if (!this._isHovered) {
        this._disposePopper();
      }
      this._element.removeAttribute("aria-describedby");
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  update() {
    if (this._popper) {
      this._popper.update();
    }
  }
  // Protected
  _isWithContent() {
    return Boolean(this._getTitle());
  }
  _getTipElement() {
    if (!this.tip) {
      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
    }
    return this.tip;
  }
  _createTipElement(content) {
    const tip = this._getTemplateFactory(content).toHtml();
    if (!tip) {
      return null;
    }
    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
    tip.classList.add(`bs-${this.constructor.NAME}-auto`);
    const tipId = getUID(this.constructor.NAME).toString();
    tip.setAttribute("id", tipId);
    if (this._isAnimated()) {
      tip.classList.add(CLASS_NAME_FADE$2);
    }
    return tip;
  }
  setContent(content) {
    this._newContent = content;
    if (this._isShown()) {
      this._disposePopper();
      this.show();
    }
  }
  _getTemplateFactory(content) {
    if (this._templateFactory) {
      this._templateFactory.changeContent(content);
    } else {
      this._templateFactory = new TemplateFactory({
        ...this._config,
        // the `content` var has to be after `this._config`
        // to override config.content in case of popover
        content,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      });
    }
    return this._templateFactory;
  }
  _getContentForTemplate() {
    return {
      [SELECTOR_TOOLTIP_INNER]: this._getTitle()
    };
  }
  _getTitle() {
    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
  }
  // Private
  _initializeOnDelegatedTarget(event) {
    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
  }
  _isAnimated() {
    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
  }
  _isShown() {
    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
  }
  _createPopper(tip) {
    const placement = execute(this._config.placement, [this, tip, this._element]);
    const attachment = AttachmentMap[placement.toUpperCase()];
    return createPopper(this._element, tip, this._getPopperConfig(attachment));
  }
  _getOffset() {
    const {
      offset: offset2
    } = this._config;
    if (typeof offset2 === "string") {
      return offset2.split(",").map((value) => Number.parseInt(value, 10));
    }
    if (typeof offset2 === "function") {
      return (popperData) => offset2(popperData, this._element);
    }
    return offset2;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this._element]);
  }
  _getPopperConfig(attachment) {
    const defaultBsPopperConfig = {
      placement: attachment,
      modifiers: [{
        name: "flip",
        options: {
          fallbackPlacements: this._config.fallbackPlacements
        }
      }, {
        name: "offset",
        options: {
          offset: this._getOffset()
        }
      }, {
        name: "preventOverflow",
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: "arrow",
        options: {
          element: `.${this.constructor.NAME}-arrow`
        }
      }, {
        name: "preSetPlacement",
        enabled: true,
        phase: "beforeMain",
        fn: (data) => {
          this._getTipElement().setAttribute("data-popper-placement", data.state.placement);
        }
      }]
    };
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _setListeners() {
    const triggers = this._config.trigger.split(" ");
    for (const trigger of triggers) {
      if (trigger === "click") {
        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context.toggle();
        });
      } else if (trigger !== TRIGGER_MANUAL) {
        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
        EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
          context._enter();
        });
        EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
          context._leave();
        });
      }
    }
    this._hideModalHandler = () => {
      if (this._element) {
        this.hide();
      }
    };
    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
  }
  _fixTitle() {
    const title = this._element.getAttribute("title");
    if (!title) {
      return;
    }
    if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
      this._element.setAttribute("aria-label", title);
    }
    this._element.setAttribute("data-bs-original-title", title);
    this._element.removeAttribute("title");
  }
  _enter() {
    if (this._isShown() || this._isHovered) {
      this._isHovered = true;
      return;
    }
    this._isHovered = true;
    this._setTimeout(() => {
      if (this._isHovered) {
        this.show();
      }
    }, this._config.delay.show);
  }
  _leave() {
    if (this._isWithActiveTrigger()) {
      return;
    }
    this._isHovered = false;
    this._setTimeout(() => {
      if (!this._isHovered) {
        this.hide();
      }
    }, this._config.delay.hide);
  }
  _setTimeout(handler, timeout) {
    clearTimeout(this._timeout);
    this._timeout = setTimeout(handler, timeout);
  }
  _isWithActiveTrigger() {
    return Object.values(this._activeTrigger).includes(true);
  }
  _getConfig(config) {
    const dataAttributes = Manipulator.getDataAttributes(this._element);
    for (const dataAttribute of Object.keys(dataAttributes)) {
      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
        delete dataAttributes[dataAttribute];
      }
    }
    config = {
      ...dataAttributes,
      ...typeof config === "object" && config ? config : {}
    };
    config = this._mergeConfigObj(config);
    config = this._configAfterMerge(config);
    this._typeCheckConfig(config);
    return config;
  }
  _configAfterMerge(config) {
    config.container = config.container === false ? document.body : getElement(config.container);
    if (typeof config.delay === "number") {
      config.delay = {
        show: config.delay,
        hide: config.delay
      };
    }
    if (typeof config.title === "number") {
      config.title = config.title.toString();
    }
    if (typeof config.content === "number") {
      config.content = config.content.toString();
    }
    return config;
  }
  _getDelegateConfig() {
    const config = {};
    for (const [key, value] of Object.entries(this._config)) {
      if (this.constructor.Default[key] !== value) {
        config[key] = value;
      }
    }
    config.selector = false;
    config.trigger = "manual";
    return config;
  }
  _disposePopper() {
    if (this._popper) {
      this._popper.destroy();
      this._popper = null;
    }
    if (this.tip) {
      this.tip.remove();
      this.tip = null;
    }
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Tooltip.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}
defineJQueryPlugin(Tooltip);
const NAME$3 = "popover";
const SELECTOR_TITLE = ".popover-header";
const SELECTOR_CONTENT = ".popover-body";
const Default$2 = {
  ...Tooltip.Default,
  content: "",
  offset: [0, 8],
  placement: "right",
  template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
  trigger: "click"
};
const DefaultType$2 = {
  ...Tooltip.DefaultType,
  content: "(null|string|element|function)"
};
class Popover extends Tooltip {
  // Getters
  static get Default() {
    return Default$2;
  }
  static get DefaultType() {
    return DefaultType$2;
  }
  static get NAME() {
    return NAME$3;
  }
  // Overrides
  _isWithContent() {
    return this._getTitle() || this._getContent();
  }
  // Private
  _getContentForTemplate() {
    return {
      [SELECTOR_TITLE]: this._getTitle(),
      [SELECTOR_CONTENT]: this._getContent()
    };
  }
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Popover.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (typeof data[config] === "undefined") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}
defineJQueryPlugin(Popover);
const NAME$2 = "scrollspy";
const DATA_KEY$2 = "bs.scrollspy";
const EVENT_KEY$2 = `.${DATA_KEY$2}`;
const DATA_API_KEY = ".data-api";
const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
const EVENT_CLICK = `click${EVENT_KEY$2}`;
const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
const CLASS_NAME_ACTIVE$1 = "active";
const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
const SELECTOR_TARGET_LINKS = "[href]";
const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
const SELECTOR_NAV_LINKS = ".nav-link";
const SELECTOR_NAV_ITEMS = ".nav-item";
const SELECTOR_LIST_ITEMS = ".list-group-item";
const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
const SELECTOR_DROPDOWN = ".dropdown";
const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
const Default$1 = {
  offset: null,
  // TODO: v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "0px 0px -25%",
  smoothScroll: false,
  target: null,
  threshold: [0.1, 0.5, 1]
};
const DefaultType$1 = {
  offset: "(number|null)",
  // TODO v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "string",
  smoothScroll: "boolean",
  target: "element",
  threshold: "array"
};
class ScrollSpy extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._targetLinks = /* @__PURE__ */ new Map();
    this._observableSections = /* @__PURE__ */ new Map();
    this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
    this._activeTarget = null;
    this._observer = null;
    this._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    };
    this.refresh();
  }
  // Getters
  static get Default() {
    return Default$1;
  }
  static get DefaultType() {
    return DefaultType$1;
  }
  static get NAME() {
    return NAME$2;
  }
  // Public
  refresh() {
    this._initializeTargetsAndObservables();
    this._maybeEnableSmoothScroll();
    if (this._observer) {
      this._observer.disconnect();
    } else {
      this._observer = this._getNewObserver();
    }
    for (const section of this._observableSections.values()) {
      this._observer.observe(section);
    }
  }
  dispose() {
    this._observer.disconnect();
    super.dispose();
  }
  // Private
  _configAfterMerge(config) {
    config.target = getElement(config.target) || document.body;
    config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
    if (typeof config.threshold === "string") {
      config.threshold = config.threshold.split(",").map((value) => Number.parseFloat(value));
    }
    return config;
  }
  _maybeEnableSmoothScroll() {
    if (!this._config.smoothScroll) {
      return;
    }
    EventHandler.off(this._config.target, EVENT_CLICK);
    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
      const observableSection = this._observableSections.get(event.target.hash);
      if (observableSection) {
        event.preventDefault();
        const root = this._rootElement || window;
        const height = observableSection.offsetTop - this._element.offsetTop;
        if (root.scrollTo) {
          root.scrollTo({
            top: height,
            behavior: "smooth"
          });
          return;
        }
        root.scrollTop = height;
      }
    });
  }
  _getNewObserver() {
    const options = {
      root: this._rootElement,
      threshold: this._config.threshold,
      rootMargin: this._config.rootMargin
    };
    return new IntersectionObserver((entries) => this._observerCallback(entries), options);
  }
  // The logic of selection
  _observerCallback(entries) {
    const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
    const activate = (entry) => {
      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
      this._process(targetElement(entry));
    };
    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
    this._previousScrollData.parentScrollTop = parentScrollTop;
    for (const entry of entries) {
      if (!entry.isIntersecting) {
        this._activeTarget = null;
        this._clearActiveClass(targetElement(entry));
        continue;
      }
      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
      if (userScrollsDown && entryIsLowerThanPrevious) {
        activate(entry);
        if (!parentScrollTop) {
          return;
        }
        continue;
      }
      if (!userScrollsDown && !entryIsLowerThanPrevious) {
        activate(entry);
      }
    }
  }
  _initializeTargetsAndObservables() {
    this._targetLinks = /* @__PURE__ */ new Map();
    this._observableSections = /* @__PURE__ */ new Map();
    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
    for (const anchor of targetLinks) {
      if (!anchor.hash || isDisabled(anchor)) {
        continue;
      }
      const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
      if (isVisible(observableSection)) {
        this._targetLinks.set(decodeURI(anchor.hash), anchor);
        this._observableSections.set(anchor.hash, observableSection);
      }
    }
  }
  _process(target) {
    if (this._activeTarget === target) {
      return;
    }
    this._clearActiveClass(this._config.target);
    this._activeTarget = target;
    target.classList.add(CLASS_NAME_ACTIVE$1);
    this._activateParents(target);
    EventHandler.trigger(this._element, EVENT_ACTIVATE, {
      relatedTarget: target
    });
  }
  _activateParents(target) {
    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
      return;
    }
    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
      for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
        item.classList.add(CLASS_NAME_ACTIVE$1);
      }
    }
  }
  _clearActiveClass(parent) {
    parent.classList.remove(CLASS_NAME_ACTIVE$1);
    const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
    for (const node of activeNodes) {
      node.classList.remove(CLASS_NAME_ACTIVE$1);
    }
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = ScrollSpy.getOrCreateInstance(this, config);
      if (typeof config !== "string") {
        return;
      }
      if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}
EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
  for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
    ScrollSpy.getOrCreateInstance(spy);
  }
});
defineJQueryPlugin(ScrollSpy);
const NAME$1 = "tab";
const DATA_KEY$1 = "bs.tab";
const EVENT_KEY$1 = `.${DATA_KEY$1}`;
const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
const ARROW_LEFT_KEY = "ArrowLeft";
const ARROW_RIGHT_KEY = "ArrowRight";
const ARROW_UP_KEY = "ArrowUp";
const ARROW_DOWN_KEY = "ArrowDown";
const HOME_KEY = "Home";
const END_KEY = "End";
const CLASS_NAME_ACTIVE = "active";
const CLASS_NAME_FADE$1 = "fade";
const CLASS_NAME_SHOW$1 = "show";
const CLASS_DROPDOWN = "dropdown";
const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
const SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
const SELECTOR_OUTER = ".nav-item, .list-group-item";
const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
class Tab2 extends BaseComponent {
  constructor(element) {
    super(element);
    this._parent = this._element.closest(SELECTOR_TAB_PANEL);
    if (!this._parent) {
      return;
    }
    this._setInitialAttributes(this._parent, this._getChildren());
    EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
  }
  // Getters
  static get NAME() {
    return NAME$1;
  }
  // Public
  show() {
    const innerElem = this._element;
    if (this._elemIsActive(innerElem)) {
      return;
    }
    const active = this._getActiveElem();
    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
      relatedTarget: innerElem
    }) : null;
    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
      relatedTarget: active
    });
    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
      return;
    }
    this._deactivate(active, innerElem);
    this._activate(innerElem, active);
  }
  // Private
  _activate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.add(CLASS_NAME_ACTIVE);
    this._activate(SelectorEngine.getElementFromSelector(element));
    const complete = () => {
      if (element.getAttribute("role") !== "tab") {
        element.classList.add(CLASS_NAME_SHOW$1);
        return;
      }
      element.removeAttribute("tabindex");
      element.setAttribute("aria-selected", true);
      this._toggleDropDown(element, true);
      EventHandler.trigger(element, EVENT_SHOWN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _deactivate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.remove(CLASS_NAME_ACTIVE);
    element.blur();
    this._deactivate(SelectorEngine.getElementFromSelector(element));
    const complete = () => {
      if (element.getAttribute("role") !== "tab") {
        element.classList.remove(CLASS_NAME_SHOW$1);
        return;
      }
      element.setAttribute("aria-selected", false);
      element.setAttribute("tabindex", "-1");
      this._toggleDropDown(element, false);
      EventHandler.trigger(element, EVENT_HIDDEN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _keydown(event) {
    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    const children = this._getChildren().filter((element) => !isDisabled(element));
    let nextActiveElement;
    if ([HOME_KEY, END_KEY].includes(event.key)) {
      nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
    } else {
      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
      nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
    }
    if (nextActiveElement) {
      nextActiveElement.focus({
        preventScroll: true
      });
      Tab2.getOrCreateInstance(nextActiveElement).show();
    }
  }
  _getChildren() {
    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
  }
  _getActiveElem() {
    return this._getChildren().find((child) => this._elemIsActive(child)) || null;
  }
  _setInitialAttributes(parent, children) {
    this._setAttributeIfNotExists(parent, "role", "tablist");
    for (const child of children) {
      this._setInitialAttributesOnChild(child);
    }
  }
  _setInitialAttributesOnChild(child) {
    child = this._getInnerElement(child);
    const isActive = this._elemIsActive(child);
    const outerElem = this._getOuterElement(child);
    child.setAttribute("aria-selected", isActive);
    if (outerElem !== child) {
      this._setAttributeIfNotExists(outerElem, "role", "presentation");
    }
    if (!isActive) {
      child.setAttribute("tabindex", "-1");
    }
    this._setAttributeIfNotExists(child, "role", "tab");
    this._setInitialAttributesOnTargetPanel(child);
  }
  _setInitialAttributesOnTargetPanel(child) {
    const target = SelectorEngine.getElementFromSelector(child);
    if (!target) {
      return;
    }
    this._setAttributeIfNotExists(target, "role", "tabpanel");
    if (child.id) {
      this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
    }
  }
  _toggleDropDown(element, open) {
    const outerElem = this._getOuterElement(element);
    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
      return;
    }
    const toggle = (selector, className) => {
      const element2 = SelectorEngine.findOne(selector, outerElem);
      if (element2) {
        element2.classList.toggle(className, open);
      }
    };
    toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
    toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
    outerElem.setAttribute("aria-expanded", open);
  }
  _setAttributeIfNotExists(element, attribute, value) {
    if (!element.hasAttribute(attribute)) {
      element.setAttribute(attribute, value);
    }
  }
  _elemIsActive(elem) {
    return elem.classList.contains(CLASS_NAME_ACTIVE);
  }
  // Try to get the inner element (usually the .nav-link)
  _getInnerElement(elem) {
    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
  }
  // Try to get the outer element (usually the .nav-item)
  _getOuterElement(elem) {
    return elem.closest(SELECTOR_OUTER) || elem;
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Tab2.getOrCreateInstance(this);
      if (typeof config !== "string") {
        return;
      }
      if (data[config] === void 0 || config.startsWith("_") || config === "constructor") {
        throw new TypeError(`No method named "${config}"`);
      }
      data[config]();
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  Tab2.getOrCreateInstance(this).show();
});
EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
  for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
    Tab2.getOrCreateInstance(element);
  }
});
defineJQueryPlugin(Tab2);
const NAME = "toast";
const DATA_KEY = "bs.toast";
const EVENT_KEY = `.${DATA_KEY}`;
const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
const EVENT_HIDE = `hide${EVENT_KEY}`;
const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
const EVENT_SHOW = `show${EVENT_KEY}`;
const EVENT_SHOWN = `shown${EVENT_KEY}`;
const CLASS_NAME_FADE = "fade";
const CLASS_NAME_HIDE = "hide";
const CLASS_NAME_SHOW = "show";
const CLASS_NAME_SHOWING = "showing";
const DefaultType = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
};
const Default = {
  animation: true,
  autohide: true,
  delay: 5e3
};
class Toast extends BaseComponent {
  constructor(element, config) {
    super(element, config);
    this._timeout = null;
    this._hasMouseInteraction = false;
    this._hasKeyboardInteraction = false;
    this._setListeners();
  }
  // Getters
  static get Default() {
    return Default;
  }
  static get DefaultType() {
    return DefaultType;
  }
  static get NAME() {
    return NAME;
  }
  // Public
  show() {
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._clearTimeout();
    if (this._config.animation) {
      this._element.classList.add(CLASS_NAME_FADE);
    }
    const complete = () => {
      this._element.classList.remove(CLASS_NAME_SHOWING);
      EventHandler.trigger(this._element, EVENT_SHOWN);
      this._maybeScheduleHide();
    };
    this._element.classList.remove(CLASS_NAME_HIDE);
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  hide() {
    if (!this.isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const complete = () => {
      this._element.classList.add(CLASS_NAME_HIDE);
      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
      EventHandler.trigger(this._element, EVENT_HIDDEN);
    };
    this._element.classList.add(CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout();
    if (this.isShown()) {
      this._element.classList.remove(CLASS_NAME_SHOW);
    }
    super.dispose();
  }
  isShown() {
    return this._element.classList.contains(CLASS_NAME_SHOW);
  }
  // Private
  _maybeScheduleHide() {
    if (!this._config.autohide) {
      return;
    }
    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
      return;
    }
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _onInteraction(event, isInteracting) {
    switch (event.type) {
      case "mouseover":
      case "mouseout": {
        this._hasMouseInteraction = isInteracting;
        break;
      }
      case "focusin":
      case "focusout": {
        this._hasKeyboardInteraction = isInteracting;
        break;
      }
    }
    if (isInteracting) {
      this._clearTimeout();
      return;
    }
    const nextElement = event.relatedTarget;
    if (this._element === nextElement || this._element.contains(nextElement)) {
      return;
    }
    this._maybeScheduleHide();
  }
  _setListeners() {
    EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
    EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
  }
  _clearTimeout() {
    clearTimeout(this._timeout);
    this._timeout = null;
  }
  // Static
  static jQueryInterface(config) {
    return this.each(function() {
      const data = Toast.getOrCreateInstance(this, config);
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      }
    });
  }
}
enableDismissTrigger(Toast);
defineJQueryPlugin(Toast);
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const name = "app";
const template$s = '<nav class="navbar navbar-expand-lg navbar-dark bg-dark">\n    <div class="container-fluid">\n        <a class="navbar-brand" href="/">\n            D2R Reimagined\n        </a>\n        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">\n            <span class="navbar-toggler-icon"></span>\n        </button>\n        <div class="collapse navbar-collapse" id="navbarSupportedContent">\n            <ul class="navbar-nav me-auto mb-2 mb-lg-0">\n                <li class="nav-item mx-3">\n                    <a class="nav-link active" aria-current="page" href="/">Home</a>\n                </li>\n                <li class="nav-item mx-3">\n                    <a class="nav-link active cursor-pointer" aria-current="page" href="/cube-recipes">\n                        Cube Recipes\n                    </a>\n                </li>\n                <li class="nav-item mx-3">\n                    <a class="nav-link active cursor-pointer" aria-current="page" href="/uniques">\n                        Uniques\n                    </a>\n                </li>\n                <li class="nav-item mx-3">\n                    <a class="nav-link active cursor-pointer" aria-current="page" href="/sets">\n                        Sets\n                    </a>\n                </li>\n                <li class="nav-item mx-3">\n                    <a class="nav-link active cursor-pointer" aria-current="page" href="/runewords">\n                        Runewords\n                    </a>\n                </li>\n                <li class="nav-item mx-3">\n                    <a class="nav-link active cursor-pointer" aria-current="page" href="https://d2r-reimagined.com/talonrage" external>\n                        Original Talonrage Docs\n                    </a>\n                </li>\n            </ul>\n            <div class="d-flex">\n                <a href="https://discord.gg/9zZkYrSA8C" target="_blank">\n                    <svg width=32" height="32" viewBox="0 -28.5 256 256" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" preserveAspectRatio="xMidYMid">\n                        <g>\n                            <path d="M216.856339,16.5966031 C200.285002,8.84328665 182.566144,3.2084988 164.041564,0 C161.766523,4.11318106 159.108624,9.64549908 157.276099,14.0464379 C137.583995,11.0849896 118.072967,11.0849896 98.7430163,14.0464379 C96.9108417,9.64549908 94.1925838,4.11318106 91.8971895,0 C73.3526068,3.2084988 55.6133949,8.86399117 39.0420583,16.6376612 C5.61752293,67.146514 -3.4433191,116.400813 1.08711069,164.955721 C23.2560196,181.510915 44.7403634,191.567697 65.8621325,198.148576 C71.0772151,190.971126 75.7283628,183.341335 79.7352139,175.300261 C72.104019,172.400575 64.7949724,168.822202 57.8887866,164.667963 C59.7209612,163.310589 61.5131304,161.891452 63.2445898,160.431257 C105.36741,180.133187 151.134928,180.133187 192.754523,160.431257 C194.506336,161.891452 196.298154,163.310589 198.110326,164.667963 C191.183787,168.842556 183.854737,172.420929 176.223542,175.320965 C180.230393,183.341335 184.861538,190.991831 190.096624,198.16893 C211.238746,191.588051 232.743023,181.531619 254.911949,164.955721 C260.227747,108.668201 245.831087,59.8662432 216.856339,16.5966031 Z M85.4738752,135.09489 C72.8290281,135.09489 62.4592217,123.290155 62.4592217,108.914901 C62.4592217,94.5396472 72.607595,82.7145587 85.4738752,82.7145587 C98.3405064,82.7145587 108.709962,94.5189427 108.488529,108.914901 C108.508531,123.290155 98.3405064,135.09489 85.4738752,135.09489 Z M170.525237,135.09489 C157.88039,135.09489 147.510584,123.290155 147.510584,108.914901 C147.510584,94.5396472 157.658606,82.7145587 170.525237,82.7145587 C183.391518,82.7145587 193.761324,94.5189427 193.539891,108.914901 C193.539891,123.290155 183.391518,135.09489 170.525237,135.09489 Z" fill="#5865F2" fill-rule="nonzero">\n\n                            </path>\n                        </g>\n                    </svg>\n                </a>\n            </div>\n        </div>\n    </div>\n</nav>\n\n<au-viewport default="Home"></au-viewport>\n';
const dependencies = [];
const bindables = {};
let _e;
function register(container) {
  if (!_e) {
    _e = CustomElement.define({ name, template: template$s, dependencies, bindables });
  }
  container.register(_e);
}
const __au2ViewDef = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bindables,
  default: template$s,
  dependencies,
  name,
  register,
  template: template$s
}, Symbol.toStringTag, { value: "Module" }));
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __knownSymbol = (name2, symbol) => (symbol = Symbol[name2]) ? symbol : Symbol.for("Symbol." + name2);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __decoratorStart = (base) => [, , , __create(null)];
var __decoratorStrings = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"];
var __expectFn = (fn2) => fn2 !== void 0 && typeof fn2 !== "function" ? __typeError("Function expected") : fn2;
var __decoratorContext = (kind, name2, done, metadata, fns) => ({ kind: __decoratorStrings[kind], name: name2, metadata, addInitializer: (fn2) => done._ ? __typeError("Already initialized") : fns.push(__expectFn(fn2 || null)) });
var __decoratorMetadata = (array, target) => __defNormalProp(target, __knownSymbol("metadata"), array[3]);
var __runInitializers$2 = (array, flags, self, value) => {
  for (var i3 = 0, fns = array[flags >> 1], n3 = fns && fns.length; i3 < n3; i3++) fns[i3].call(self);
  return value;
};
var __decorateElement = (array, flags, name2, decorators, target, extra) => {
  var it, done, ctx, k3 = flags & 7, p2 = !!(flags & 16);
  var j2 = 0;
  var extraInitializers = array[j2] || (array[j2] = []);
  var desc = k3 && (target = target.prototype, k3 < 5 && (k3 > 3 || !p2) && __getOwnPropDesc(target, name2));
  __name(target, name2);
  for (var i3 = decorators.length - 1; i3 >= 0; i3--) {
    ctx = __decoratorContext(k3, name2, done = {}, array[3], extraInitializers);
    it = (0, decorators[i3])(target, ctx), done._ = 1;
    __expectFn(it) && (target = it);
  }
  return __decoratorMetadata(array, target), desc && __defProp(target, name2, desc), p2 ? k3 ^ 4 ? extra : desc : target;
};
var _App_decorators, _init;
_App_decorators = [customElement(__au2ViewDef), route({
  title: "D2R Reimagined",
  routes: [
    {
      path: "",
      component: __vitePreload(() => import("./home-DtlZQwq7.js"), true ? [] : void 0),
      title: "Home"
    },
    {
      path: "cube-recipes",
      component: __vitePreload(() => import("./cube-recipes-bkvbiyhy.js"), true ? __vite__mapDeps([0,1]) : void 0),
      title: "Cube Recipes"
    },
    {
      path: "uniques",
      component: __vitePreload(() => import("./uniques-CEeDL2I1.js"), true ? [] : void 0),
      title: "Uniques"
    },
    {
      path: "sets",
      component: __vitePreload(() => import("./sets-CLoALfiV.js"), true ? [] : void 0),
      title: "Sets"
    },
    {
      path: "runewords",
      component: __vitePreload(() => import("./runewords-CLbRf3mF.js"), true ? [] : void 0),
      title: "Runewords"
    }
  ]
})];
class App {
}
_init = __decoratorStart();
App = __decorateElement(_init, 0, "App", _App_decorators, App);
__runInitializers$2(_init, 1, App);
const g = /* @__PURE__ */ DI.createInterface("IValidationExpressionHydrator");
const p = Metadata.get;
const v = Metadata.define;
const y = Metadata.delete;
const { annotation: P$1 } = Protocol;
const w = P$1.keyFor;
const createMappedError$1 = (e2, ...t2) => new Error(`AUR${String(e2).padStart(4, "0")}:${t2.map(String)}`);
const x = Symbol.for("au:validation:explicit-message-key");
const z = /* @__PURE__ */ DI.createInterface("IValidationMessageProvider");
const E = Object.freeze({
  aliasKey: w("validation-rule-alias-message"),
  define(e2, t2, s3) {
    this.setDefaultMessage(e2, t2, s3);
  },
  setDefaultMessage(e2, { aliases: t2 }, i3) {
    const r2 = i3 ? p(this.aliasKey, e2) : void 0;
    if (r2 !== void 0) {
      const e3 = {
        ...Object.fromEntries(r2.map(({ name: e4, defaultMessage: t3 }) => [e4, t3])),
        ...Object.fromEntries(t2.map(({ name: e4, defaultMessage: t3 }) => [e4, t3]))
      };
      t2 = toArray(Object.entries(e3)).map(([e4, t3]) => ({
        name: e4,
        defaultMessage: t3
      }));
    }
    v(t2, e2, this.aliasKey);
  },
  getDefaultMessages(e2) {
    const t2 = p(this.aliasKey, e2);
    if (t2 != null || e2 instanceof Function) return t2;
    return p(this.aliasKey, e2.constructor);
  }
});
class BaseValidationRule {
  get messageKey() {
    return this.t;
  }
  set messageKey(e2) {
    this.t = e2;
  }
  constructor(e2 = void 0) {
    this.tag = void 0;
    this.t = e2;
  }
  canExecute(e2) {
    return true;
  }
  execute(e2, t2) {
    throw createMappedError$1(99, "execute");
  }
  accept(e2) {
    throw createMappedError$1(99, "accept");
  }
}
BaseValidationRule.$TYPE = "";
class RequiredRule extends BaseValidationRule {
  constructor() {
    super("required");
  }
  execute(e2) {
    return e2 !== null && e2 !== void 0 && !(typeof e2 === "string" && !/\S/.test(e2));
  }
  accept(e2) {
    return e2.visitRequiredRule(this);
  }
}
RequiredRule.$TYPE = "RequiredRule";
class RegexRule extends BaseValidationRule {
  constructor(e2, t2 = "matches") {
    super(t2);
    this.pattern = e2;
  }
  execute(e2) {
    return e2 === null || e2 === void 0 || e2.length === 0 || this.pattern.test(e2);
  }
  accept(e2) {
    return e2.visitRegexRule(this);
  }
}
RegexRule.$TYPE = "RegexRule";
class LengthRule extends BaseValidationRule {
  constructor(e2, t2) {
    super(t2 ? "maxLength" : "minLength");
    this.length = e2;
    this.isMax = t2;
  }
  execute(e2) {
    return e2 === null || e2 === void 0 || e2.length === 0 || (this.isMax ? e2.length <= this.length : e2.length >= this.length);
  }
  accept(e2) {
    return e2.visitLengthRule(this);
  }
}
LengthRule.$TYPE = "LengthRule";
class SizeRule extends BaseValidationRule {
  constructor(e2, t2) {
    super(t2 ? "maxItems" : "minItems");
    this.count = e2;
    this.isMax = t2;
  }
  execute(e2) {
    return e2 === null || e2 === void 0 || (this.isMax ? e2.length <= this.count : e2.length >= this.count);
  }
  accept(e2) {
    return e2.visitSizeRule(this);
  }
}
SizeRule.$TYPE = "SizeRule";
class RangeRule extends BaseValidationRule {
  constructor(e2, { min: t2, max: s3 }) {
    super(t2 !== void 0 && s3 !== void 0 ? e2 ? "range" : "between" : t2 !== void 0 ? "min" : "max");
    this.isInclusive = e2;
    this.min = Number.NEGATIVE_INFINITY;
    this.max = Number.POSITIVE_INFINITY;
    this.min = t2 ?? this.min;
    this.max = s3 ?? this.max;
  }
  execute(e2, t2) {
    return e2 === null || e2 === void 0 || (this.isInclusive ? e2 >= this.min && e2 <= this.max : e2 > this.min && e2 < this.max);
  }
  accept(e2) {
    return e2.visitRangeRule(this);
  }
}
RangeRule.$TYPE = "RangeRule";
class EqualsRule extends BaseValidationRule {
  constructor(e2) {
    super("equals");
    this.expectedValue = e2;
  }
  execute(e2) {
    return e2 === null || e2 === void 0 || e2 === "" || e2 === this.expectedValue;
  }
  accept(e2) {
    return e2.visitEqualsRule(this);
  }
}
EqualsRule.$TYPE = "EqualsRule";
class StateRule extends BaseValidationRule {
  get messageKey() {
    return this.i ?? this.t ?? void 0;
  }
  set messageKey(e2) {
    this.i = e2;
  }
  constructor(e2, t2, s3) {
    super(void 0);
    this.validState = e2;
    this.stateFunction = t2;
    this.messages = s3;
    this.i = null;
    const i3 = [];
    for (const [e3, t3] of Object.entries(s3)) {
      i3.push({
        name: e3,
        defaultMessage: t3
      });
    }
    E.setDefaultMessage(this, {
      aliases: i3
    }, false);
  }
  execute(e2, t2) {
    return onResolve(this.stateFunction(e2, t2), (e3) => {
      this.t = e3;
      return e3 === this.validState;
    });
  }
  accept(e2) {
  }
}
StateRule.$TYPE = "StateRule";
E.define(EqualsRule, {
  aliases: [{
    name: "equals",
    defaultMessage: `\${$displayName} must be \${$rule.expectedValue}.`
  }]
}, false);
E.define(RangeRule, {
  aliases: [{
    name: "min",
    defaultMessage: `\${$displayName} must be at least \${$rule.min}.`
  }, {
    name: "max",
    defaultMessage: `\${$displayName} must be at most \${$rule.max}.`
  }, {
    name: "range",
    defaultMessage: `\${$displayName} must be between or equal to \${$rule.min} and \${$rule.max}.`
  }, {
    name: "between",
    defaultMessage: `\${$displayName} must be between but not equal to \${$rule.min} and \${$rule.max}.`
  }]
}, false);
E.define(SizeRule, {
  aliases: [{
    name: "minItems",
    defaultMessage: `\${$displayName} must contain at least \${$rule.count} item\${$rule.count === 1 ? '' : 's'}.`
  }, {
    name: "maxItems",
    defaultMessage: `\${$displayName} cannot contain more than \${$rule.count} item\${$rule.count === 1 ? '' : 's'}.`
  }]
}, false);
E.define(LengthRule, {
  aliases: [{
    name: "minLength",
    defaultMessage: `\${$displayName} must be at least \${$rule.length} character\${$rule.length === 1 ? '' : 's'}.`
  }, {
    name: "maxLength",
    defaultMessage: `\${$displayName} cannot be longer than \${$rule.length} character\${$rule.length === 1 ? '' : 's'}.`
  }]
}, false);
E.define(RegexRule, {
  aliases: [{
    name: "matches",
    defaultMessage: `\${$displayName} is not correctly formatted.`
  }, {
    name: "email",
    defaultMessage: `\${$displayName} is not a valid email.`
  }]
}, false);
E.define(RequiredRule, {
  aliases: [{
    name: "required",
    defaultMessage: `\${$displayName} is required.`
  }]
}, false);
E.define(BaseValidationRule, {
  aliases: [{
    name: void 0,
    defaultMessage: `\${$displayName} is invalid.`
  }]
}, false);
const b2 = /* @__PURE__ */ DI.createInterface("ICustomMessages");
class RuleProperty {
  constructor(e2, t2 = void 0, s3 = void 0) {
    this.expression = e2;
    this.name = t2;
    this.displayName = s3;
  }
  accept(e2) {
    return e2.visitRuleProperty(this);
  }
}
RuleProperty.$TYPE = "RuleProperty";
const V2 = Object.freeze({
  allRulesAnnotations: w("validation-rules-annotations"),
  name: "validation-rules",
  defaultRuleSetName: "__default",
  set(e2, t2, s3) {
    const i3 = `${V2.name}:${s3 ?? V2.defaultRuleSetName}`;
    v(t2, e2, w(i3));
    const r2 = p(this.allRulesAnnotations, e2);
    if (r2 === void 0) {
      v([i3], e2, this.allRulesAnnotations);
    } else {
      r2.push(i3);
    }
  },
  get(e2, t2) {
    const s3 = w(V2.name, t2 ?? V2.defaultRuleSetName);
    return p(s3, e2) ?? p(s3, e2.constructor);
  },
  unset(e2, t2) {
    const s3 = p(this.allRulesAnnotations, e2);
    if (!Array.isArray(s3)) return;
    for (const i3 of s3.slice(0)) {
      if (i3.startsWith(V2.name) && (t2 === void 0 || i3.endsWith(t2))) {
        y(w(i3), e2);
        const t3 = s3.indexOf(i3);
        if (t3 > -1) {
          s3.splice(t3, 1);
        }
      }
    }
  },
  isValidationRulesSet(e2) {
    const t2 = p(this.allRulesAnnotations, e2);
    return t2 !== void 0 && t2.some((e3) => e3.startsWith(V2.name));
  }
});
class ValidationMessageEvaluationContext {
  constructor(e2, t2, s3, i3, r2, n3) {
    this.messageProvider = e2;
    this.$displayName = t2;
    this.$propertyName = s3;
    this.$value = i3;
    this.$rule = r2;
    this.$object = n3;
  }
  $getDisplayName(e2, t2) {
    return this.messageProvider.getDisplayName(e2, t2);
  }
}
class PropertyRule {
  constructor(e2, t2, s3, i3, r2 = [[]]) {
    this.validationRules = t2;
    this.messageProvider = s3;
    this.property = i3;
    this.$rules = r2;
    this.l = e2;
  }
  accept(e2) {
    return e2.visitPropertyRule(this);
  }
  addRule(e2) {
    const t2 = this.getLeafRules();
    t2.push(this.latestRule = e2);
    return this;
  }
  getLeafRules() {
    const e2 = this.$rules.length - 1;
    return this.$rules[e2];
  }
  async validate(e2, t2, s3) {
    if (s3 === void 0) {
      s3 = Scope.create({
        [A$1]: e2
      });
    }
    const i3 = this.property.expression;
    let r2;
    if (i3 === void 0) {
      r2 = e2;
    } else {
      r2 = astEvaluate(i3, s3, this, null);
    }
    let n3 = true;
    const validateRuleset = async (s4) => {
      const validateRule = async (t3) => {
        let s5 = t3.execute(r2, e2);
        if (s5 instanceof Promise) {
          s5 = await s5;
        }
        n3 = n3 && s5;
        const { displayName: i5, name: a2 } = this.property;
        let u2;
        if (!s5) {
          const s6 = Scope.create(new ValidationMessageEvaluationContext(this.messageProvider, this.messageProvider.getDisplayName(a2, i5), a2, r2, t3, e2));
          u2 = astEvaluate(this.messageProvider.getMessage(t3), s6, this, null);
        }
        return new ValidationResult(s5, u2, a2, e2, t3, this);
      };
      const i4 = [];
      for (const r3 of s4) {
        if (r3.canExecute(e2) && (t2 === void 0 || r3.tag === t2)) {
          i4.push(validateRule(r3));
        }
      }
      return Promise.all(i4);
    };
    const accumulateResult = async (e3, t3) => {
      const s4 = await validateRuleset(t3);
      e3.push(...s4);
      return e3;
    };
    return this.$rules.reduce(async (e3, t3) => e3.then(async (e4) => n3 ? accumulateResult(e4, t3) : Promise.resolve(e4)), Promise.resolve([]));
  }
  then() {
    this.$rules.push([]);
    return this;
  }
  withMessageKey(e2) {
    this.assertLatestRule(this.latestRule);
    this.latestRule.messageKey = e2;
    return this;
  }
  withMessage(e2) {
    const t2 = this.latestRule;
    this.assertLatestRule(t2);
    this.messageProvider.setMessage(t2, e2, x);
    return this;
  }
  when(e2) {
    this.assertLatestRule(this.latestRule);
    this.latestRule.canExecute = e2;
    return this;
  }
  tag(e2) {
    this.assertLatestRule(this.latestRule);
    this.latestRule.tag = e2;
    return this;
  }
  assertLatestRule(e2) {
    if (e2 === void 0) {
      throw createMappedError$1(4101);
    }
  }
  displayName(e2) {
    this.property.displayName = e2;
    return this;
  }
  satisfiesState(e2, t2, s3) {
    return this.addRule(new StateRule(e2, t2, s3));
  }
  satisfies(e2) {
    const t2 = new class extends BaseValidationRule {
      constructor() {
        super(...arguments);
        this.execute = e2;
      }
    }();
    return this.addRule(t2);
  }
  satisfiesRule(e2) {
    return this.addRule(e2);
  }
  required() {
    return this.addRule(new RequiredRule());
  }
  matches(e2) {
    return this.addRule(new RegexRule(e2));
  }
  email() {
    const e2 = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    return this.addRule(new RegexRule(e2, "email"));
  }
  minLength(e2) {
    return this.addRule(new LengthRule(e2, false));
  }
  maxLength(e2) {
    return this.addRule(new LengthRule(e2, true));
  }
  minItems(e2) {
    return this.addRule(new SizeRule(e2, false));
  }
  maxItems(e2) {
    return this.addRule(new SizeRule(e2, true));
  }
  min(e2) {
    return this.addRule(new RangeRule(true, {
      min: e2
    }));
  }
  max(e2) {
    return this.addRule(new RangeRule(true, {
      max: e2
    }));
  }
  range(e2, t2) {
    return this.addRule(new RangeRule(true, {
      min: e2,
      max: t2
    }));
  }
  between(e2, t2) {
    return this.addRule(new RangeRule(false, {
      min: e2,
      max: t2
    }));
  }
  equals(e2) {
    return this.addRule(new EqualsRule(e2));
  }
  ensure(e2) {
    this.latestRule = void 0;
    return this.validationRules.ensure(e2);
  }
  ensureObject() {
    this.latestRule = void 0;
    return this.validationRules.ensureObject();
  }
  get rules() {
    return this.validationRules.rules;
  }
  on(e2, t2) {
    return this.validationRules.on(e2, t2);
  }
}
PropertyRule.$TYPE = "PropertyRule";
mixinNoopAstEvaluator(PropertyRule);
const M$1 = /* @__PURE__ */ DI.createInterface("IValidationRules");
class ValidationRules {
  constructor() {
    this.rules = [];
    this.targets = /* @__PURE__ */ new Set();
    this.locator = resolve(IServiceLocator);
    this.parser = resolve(IExpressionParser);
    this.messageProvider = resolve(z);
    this.deserializer = resolve(g);
  }
  ensure(e2) {
    const [t2, s3] = parsePropertyName(e2, this.parser);
    let i3 = this.rules.find((e3) => e3.property.name == t2);
    if (i3 === void 0) {
      i3 = new PropertyRule(this.locator, this, this.messageProvider, new RuleProperty(s3, t2));
      this.rules.push(i3);
    }
    return i3;
  }
  ensureObject() {
    const e2 = new PropertyRule(this.locator, this, this.messageProvider, new RuleProperty());
    this.rules.push(e2);
    return e2;
  }
  on(e2, t2) {
    const s3 = V2.get(e2, t2);
    if (Object.is(s3, this.rules)) {
      return this;
    }
    this.rules = s3 ?? [];
    V2.set(e2, this.rules, t2);
    this.targets.add(e2);
    return this;
  }
  off(e2, t2) {
    const s3 = e2 !== void 0 ? [e2] : Array.from(this.targets);
    for (const e3 of s3) {
      V2.unset(e3, t2);
      if (!V2.isValidationRulesSet(e3)) {
        this.targets.delete(e3);
      }
    }
  }
  applyModelBasedRules(e2, t2) {
    const s3 = /* @__PURE__ */ new Set();
    for (const i3 of t2) {
      const t3 = i3.tag;
      const r2 = this.deserializer.hydrateRuleset(i3.ruleset, this);
      V2.set(e2, r2, t3);
      s3.add(t3);
    }
  }
}
const S2 = /^(?:function)?\s*\(?[$_\w\d]+\)?\s*(?:=>)?\s*\{(?:\s*["']{1}use strict["']{1};)?(?:[$_\s\w\d\/\*.['"\]+;\(\)]+)?\s*return\s+[$_\w\d]+((\.[$_\w\d]+|\[['"$_\w\d]+\])+)\s*;?\s*\}$/;
const T = /^\(?[$_\w\d]+\)?\s*=>\s*[$_\w\d]+((\.[$_\w\d]+|\[['"$_\w\d]+\])+)$/;
const A$1 = "$root";
function parsePropertyName(e2, t2) {
  switch (typeof e2) {
    case "string":
      break;
    case "function": {
      const t3 = e2.toString();
      const s3 = T.exec(t3) ?? S2.exec(t3);
      if (s3 === null) {
        throw createMappedError$1(4102, t3);
      }
      e2 = s3[1].substring(1);
      break;
    }
    default:
      throw createMappedError$1(4102, e2);
  }
  return [e2, t2.parse(`${A$1}.${e2}`, "IsProperty")];
}
class ValidationResult {
  constructor(e2, t2, s3, i3, r2, n3, a2 = false) {
    this.valid = e2;
    this.message = t2;
    this.propertyName = s3;
    this.object = i3;
    this.rule = r2;
    this.propertyRule = n3;
    this.isManual = a2;
    this.id = ValidationResult.nextId++;
  }
  toString() {
    return this.valid ? "Valid." : this.message;
  }
}
ValidationResult.nextId = 0;
const N = /* @__PURE__ */ new Set(["displayName", "propertyName", "value", "object", "config", "getDisplayName"]);
class ValidationMessageProvider {
  constructor(e2 = resolve(ILogger), t2 = resolve(b2)) {
    this.registeredMessages = /* @__PURE__ */ new WeakMap();
    this.parser = resolve(IExpressionParser);
    this.logger = e2.scopeTo(ValidationMessageProvider.name);
    for (const { rule: e3, aliases: s3 } of t2) {
      E.setDefaultMessage(e3, {
        aliases: s3
      }, true);
    }
  }
  getMessage(e2) {
    const t2 = e2.messageKey;
    const s3 = this.registeredMessages.get(e2);
    if (s3 != null) {
      const e3 = s3.get(x) ?? s3.get(t2);
      if (e3 !== void 0) {
        return e3;
      }
    }
    const i3 = E.getDefaultMessages(e2);
    let r2;
    const n3 = i3.length;
    if (n3 === 1 && t2 === void 0) {
      r2 = i3[0].defaultMessage;
    } else {
      r2 = i3.find((e3) => e3.name === t2)?.defaultMessage;
    }
    if (!r2) {
      r2 = E.getDefaultMessages(BaseValidationRule)[0].defaultMessage;
    }
    return this.setMessage(e2, r2);
  }
  setMessage(e2, t2, s3) {
    const i3 = this.parseMessage(t2);
    const r2 = this.registeredMessages;
    let n3 = r2.get(e2);
    if (n3 === void 0) {
      r2.set(e2, n3 = /* @__PURE__ */ new Map());
    }
    n3.set(s3 ?? e2.messageKey, i3);
    return i3;
  }
  parseMessage(e2) {
    const t2 = this.parser.parse(e2, "Interpolation");
    if (t2?.$kind === "Interpolation") {
      for (const s3 of t2.expressions) {
        const t3 = s3.name;
        if (N.has(t3)) {
          this.logger.warn(`Did you mean to use "$${t3}" instead of "${t3}" in this validation message template: "${e2}"?`);
        }
        if (s3.$kind === "AccessThis" || s3.ancestor > 0) {
          throw new Error("$parent is not permitted in validation message expressions.");
        }
      }
      return t2;
    }
    return new PrimitiveLiteralExpression(e2);
  }
  getDisplayName(e2, t2) {
    if (t2 !== null && t2 !== void 0) {
      return t2 instanceof Function ? t2() : t2;
    }
    if (e2 === void 0) {
      return;
    }
    const s3 = e2.toString().split(/(?=[A-Z])/).join(" ");
    return s3.charAt(0).toUpperCase() + s3.slice(1);
  }
}
var q;
(function(e2) {
  e2["BindingBehaviorExpression"] = "BindingBehaviorExpression";
  e2["ValueConverterExpression"] = "ValueConverterExpression";
  e2["AssignExpression"] = "AssignExpression";
  e2["ConditionalExpression"] = "ConditionalExpression";
  e2["AccessThisExpression"] = "AccessThisExpression";
  e2["AccessBoundaryExpression"] = "AccessBoundaryExpression";
  e2["AccessScopeExpression"] = "AccessScopeExpression";
  e2["AccessMemberExpression"] = "AccessMemberExpression";
  e2["AccessKeyedExpression"] = "AccessKeyedExpression";
  e2["CallScopeExpression"] = "CallScopeExpression";
  e2["CallMemberExpression"] = "CallMemberExpression";
  e2["CallFunctionExpression"] = "CallFunctionExpression";
  e2["BinaryExpression"] = "BinaryExpression";
  e2["UnaryExpression"] = "UnaryExpression";
  e2["PrimitiveLiteralExpression"] = "PrimitiveLiteralExpression";
  e2["ArrayLiteralExpression"] = "ArrayLiteralExpression";
  e2["ObjectLiteralExpression"] = "ObjectLiteralExpression";
  e2["TemplateExpression"] = "TemplateExpression";
  e2["TaggedTemplateExpression"] = "TaggedTemplateExpression";
  e2["ArrayBindingPattern"] = "ArrayBindingPattern";
  e2["ObjectBindingPattern"] = "ObjectBindingPattern";
  e2["BindingIdentifier"] = "BindingIdentifier";
  e2["ForOfStatement"] = "ForOfStatement";
  e2["Interpolation"] = "Interpolation";
  e2["DestructuringAssignment"] = "DestructuringAssignment";
  e2["DestructuringSingleAssignment"] = "DestructuringSingleAssignment";
  e2["DestructuringRestAssignment"] = "DestructuringRestAssignment";
  e2["ArrowFunction"] = "ArrowFunction";
  e2["Custom"] = "Custom";
})(q || (q = {}));
class Deserializer {
  static deserialize(e2) {
    const t2 = new Deserializer();
    const s3 = JSON.parse(e2);
    return t2.hydrate(s3);
  }
  hydrate(e2) {
    switch (e2.$TYPE) {
      case q.AccessMemberExpression: {
        const t2 = e2;
        return new AccessMemberExpression(this.hydrate(t2.object), t2.name);
      }
      case q.AccessKeyedExpression: {
        const t2 = e2;
        return new AccessKeyedExpression(this.hydrate(t2.object), this.hydrate(t2.key));
      }
      case q.AccessThisExpression: {
        const t2 = e2;
        return new AccessThisExpression(t2.ancestor);
      }
      case q.AccessBoundaryExpression: {
        return new AccessBoundaryExpression();
      }
      case q.AccessScopeExpression: {
        const t2 = e2;
        return new AccessScopeExpression(t2.name, t2.ancestor);
      }
      case q.ArrayLiteralExpression: {
        const t2 = e2;
        return new ArrayLiteralExpression(this.hydrate(t2.elements));
      }
      case q.ObjectLiteralExpression: {
        const t2 = e2;
        return new ObjectLiteralExpression(this.hydrate(t2.keys), this.hydrate(t2.values));
      }
      case q.PrimitiveLiteralExpression: {
        const t2 = e2;
        return new PrimitiveLiteralExpression(this.hydrate(t2.value));
      }
      case q.CallFunctionExpression: {
        const t2 = e2;
        return new CallFunctionExpression(this.hydrate(t2.func), this.hydrate(t2.args));
      }
      case q.CallMemberExpression: {
        const t2 = e2;
        return new CallMemberExpression(this.hydrate(t2.object), t2.name, this.hydrate(t2.args));
      }
      case q.CallScopeExpression: {
        const t2 = e2;
        return new CallScopeExpression(t2.name, this.hydrate(t2.args), t2.ancestor);
      }
      case q.TemplateExpression: {
        const t2 = e2;
        return new TemplateExpression(this.hydrate(t2.cooked), this.hydrate(t2.expressions));
      }
      case q.TaggedTemplateExpression: {
        const t2 = e2;
        return new TaggedTemplateExpression(this.hydrate(t2.cooked), this.hydrate(t2.raw), this.hydrate(t2.func), this.hydrate(t2.expressions));
      }
      case q.UnaryExpression: {
        const t2 = e2;
        return new UnaryExpression(t2.operation, this.hydrate(t2.expression));
      }
      case q.BinaryExpression: {
        const t2 = e2;
        return new BinaryExpression(t2.operation, this.hydrate(t2.left), this.hydrate(t2.right));
      }
      case q.ConditionalExpression: {
        const t2 = e2;
        return new ConditionalExpression(this.hydrate(t2.condition), this.hydrate(t2.yes), this.hydrate(t2.no));
      }
      case q.AssignExpression: {
        const t2 = e2;
        return new AssignExpression(this.hydrate(t2.target), this.hydrate(t2.value));
      }
      case q.ValueConverterExpression: {
        const t2 = e2;
        return new ValueConverterExpression(this.hydrate(t2.expression), t2.name, this.hydrate(t2.args));
      }
      case q.BindingBehaviorExpression: {
        const t2 = e2;
        return new BindingBehaviorExpression(this.hydrate(t2.expression), t2.name, this.hydrate(t2.args));
      }
      case q.ArrayBindingPattern: {
        const t2 = e2;
        return new ArrayBindingPattern(this.hydrate(t2.elements));
      }
      case q.ObjectBindingPattern: {
        const t2 = e2;
        return new ObjectBindingPattern(this.hydrate(t2.keys), this.hydrate(t2.values));
      }
      case q.BindingIdentifier: {
        const t2 = e2;
        return new BindingIdentifier(t2.name);
      }
      case q.ForOfStatement: {
        const t2 = e2;
        return new ForOfStatement(this.hydrate(t2.declaration), this.hydrate(t2.iterable), this.hydrate(t2.semiIdx));
      }
      case q.Interpolation: {
        const t2 = e2;
        return new Interpolation(this.hydrate(t2.cooked), this.hydrate(t2.expressions));
      }
      case q.DestructuringAssignment: {
        return new DestructuringAssignmentExpression(this.hydrate(e2.$kind), this.hydrate(e2.list), this.hydrate(e2.source), this.hydrate(e2.initializer));
      }
      case q.DestructuringSingleAssignment: {
        return new DestructuringAssignmentSingleExpression(this.hydrate(e2.target), this.hydrate(e2.source), this.hydrate(e2.initializer));
      }
      case q.DestructuringRestAssignment: {
        return new DestructuringAssignmentRestExpression(this.hydrate(e2.target), this.hydrate(e2.indexOrProperties));
      }
      case q.ArrowFunction: {
        return new ArrowFunction(this.hydrate(e2.parameters), this.hydrate(e2.body), this.hydrate(e2.rest));
      }
      default:
        if (Array.isArray(e2)) {
          if (typeof e2[0] === "object") {
            return this.deserializeExpressions(e2);
          } else {
            return e2.map(deserializePrimitive);
          }
        } else if (typeof e2 !== "object") {
          return deserializePrimitive(e2);
        }
        throw createMappedError$1(4100, e2);
    }
  }
  deserializeExpressions(e2) {
    const t2 = [];
    for (const s3 of e2) {
      t2.push(this.hydrate(s3));
    }
    return t2;
  }
}
function deserializePrimitive(e2) {
  if (typeof e2 === "string") {
    if (e2 === "null") {
      return null;
    }
    if (e2 === "undefined") {
      return void 0;
    }
    return e2.substring(1, e2.length - 1);
  } else {
    return e2;
  }
}
class ValidationDeserializer {
  static register(e2) {
    this.container = e2;
  }
  static deserialize(e2, t2) {
    const s3 = this.container.get(z);
    const i3 = this.container.get(IExpressionParser);
    const r2 = new ValidationDeserializer(this.container, s3, i3);
    const n3 = JSON.parse(e2);
    return r2.hydrate(n3, t2);
  }
  constructor(e2 = resolve(IServiceLocator), t2 = resolve(z), s3 = resolve(IExpressionParser)) {
    this.locator = e2;
    this.messageProvider = t2;
    this.parser = s3;
    this.astDeserializer = new Deserializer();
  }
  hydrate(e2, t2) {
    switch (e2.$TYPE) {
      case RequiredRule.$TYPE: {
        const t3 = e2;
        const s3 = new RequiredRule();
        s3.messageKey = t3.messageKey;
        s3.tag = this.astDeserializer.hydrate(t3.tag);
        return s3;
      }
      case RegexRule.$TYPE: {
        const t3 = e2;
        const s3 = t3.pattern;
        const i3 = this.astDeserializer;
        const r2 = new RegexRule(new RegExp(i3.hydrate(s3.source), s3.flags), t3.messageKey);
        r2.tag = i3.hydrate(t3.tag);
        return r2;
      }
      case LengthRule.$TYPE: {
        const t3 = e2;
        const s3 = new LengthRule(t3.length, t3.isMax);
        s3.messageKey = t3.messageKey;
        s3.tag = this.astDeserializer.hydrate(t3.tag);
        return s3;
      }
      case SizeRule.$TYPE: {
        const t3 = e2;
        const s3 = new SizeRule(t3.count, t3.isMax);
        s3.messageKey = t3.messageKey;
        s3.tag = this.astDeserializer.hydrate(t3.tag);
        return s3;
      }
      case RangeRule.$TYPE: {
        const t3 = e2;
        const s3 = new RangeRule(t3.isInclusive, {
          min: t3.min ?? Number.NEGATIVE_INFINITY,
          max: t3.max ?? Number.POSITIVE_INFINITY
        });
        s3.messageKey = t3.messageKey;
        s3.tag = this.astDeserializer.hydrate(t3.tag);
        return s3;
      }
      case EqualsRule.$TYPE: {
        const t3 = e2;
        const s3 = this.astDeserializer;
        const i3 = new EqualsRule(typeof t3.expectedValue !== "object" ? s3.hydrate(t3.expectedValue) : t3.expectedValue);
        i3.messageKey = t3.messageKey;
        i3.tag = s3.hydrate(t3.tag);
        return i3;
      }
      case RuleProperty.$TYPE: {
        const t3 = e2;
        const s3 = this.astDeserializer;
        let i3 = t3.name;
        i3 = i3 === "undefined" ? void 0 : s3.hydrate(i3);
        let r2 = t3.expression;
        if (r2 !== null && r2 !== void 0) {
          r2 = s3.hydrate(r2);
        } else if (i3 !== void 0) {
          [, r2] = parsePropertyName(i3, this.parser);
        } else {
          r2 = void 0;
        }
        let n3 = t3.displayName;
        n3 = n3 === "undefined" ? void 0 : s3.hydrate(n3);
        return new RuleProperty(r2, i3, n3);
      }
      case PropertyRule.$TYPE: {
        const s3 = e2;
        return new PropertyRule(this.locator, t2, this.messageProvider, this.hydrate(s3.property, t2), s3.$rules.map((e3) => e3.map((e4) => this.hydrate(e4, t2))));
      }
    }
  }
  hydrateRuleset(e2, t2) {
    if (!Array.isArray(e2)) {
      throw createMappedError$1(4104);
    }
    return e2.map((e3) => this.hydrate(e3, t2));
  }
}
class ModelValidationExpressionHydrator {
  constructor() {
    this.astDeserializer = new Deserializer();
    this.l = resolve(IServiceLocator);
    this.messageProvider = resolve(z);
    this.parser = resolve(IExpressionParser);
  }
  hydrate(e2, t2) {
    throw createMappedError$1(99, "hydrate");
  }
  hydrateRuleset(e2, t2) {
    const s3 = [];
    const iterate = (e3, i3 = []) => {
      for (const [r2, n3] of e3) {
        if (this.isModelPropertyRule(n3)) {
          const e4 = n3.rules.map((e5) => Object.entries(e5).map(([e6, t3]) => this.hydrateRule(e6, t3)));
          const a2 = i3.join(".");
          const u2 = this.hydrateRuleProperty({
            name: a2 !== "" ? `${a2}.${r2}` : r2,
            displayName: n3.displayName
          });
          s3.push(new PropertyRule(this.l, t2, this.messageProvider, u2, e4));
        } else {
          iterate(Object.entries(n3), [...i3, r2]);
        }
      }
    };
    iterate(Object.entries(e2));
    return s3;
  }
  hydrateRule(e2, t2) {
    switch (e2) {
      case "required":
        return this.hydrateRequiredRule(t2);
      case "regex":
        return this.hydrateRegexRule(t2);
      case "maxLength":
        return this.hydrateLengthRule({
          ...t2,
          isMax: true
        });
      case "minLength":
        return this.hydrateLengthRule({
          ...t2,
          isMax: false
        });
      case "maxItems":
        return this.hydrateSizeRule({
          ...t2,
          isMax: true
        });
      case "minItems":
        return this.hydrateSizeRule({
          ...t2,
          isMax: false
        });
      case "range":
        return this.hydrateRangeRule({
          ...t2,
          isInclusive: true
        });
      case "between":
        return this.hydrateRangeRule({
          ...t2,
          isInclusive: false
        });
      case "equals":
        return this.hydrateEqualsRule(t2);
      default:
        throw createMappedError$1(4105, e2);
    }
  }
  setCommonRuleProperties(e2, t2) {
    const s3 = e2.messageKey;
    if (s3 !== void 0 && s3 !== null) {
      t2.messageKey = s3;
    }
    t2.tag = e2.tag;
    const i3 = e2.when;
    if (i3) {
      if (typeof i3 === "string") {
        const e3 = this.parser.parse(i3, "None");
        t2.canExecute = (t3) => astEvaluate(e3, Scope.create({
          $object: t3
        }), this, null);
      } else if (typeof i3 === "function") {
        t2.canExecute = i3;
      }
    }
  }
  isModelPropertyRule(e2) {
    return typeof e2 === "object" && "rules" in e2;
  }
  hydrateRequiredRule(e2) {
    const t2 = new RequiredRule();
    this.setCommonRuleProperties(e2, t2);
    return t2;
  }
  hydrateRegexRule(e2) {
    const t2 = e2.pattern;
    const s3 = new RegexRule(new RegExp(t2.source, t2.flags), e2.messageKey);
    s3.tag = e2.tag;
    return s3;
  }
  hydrateLengthRule(e2) {
    const t2 = new LengthRule(e2.length, e2.isMax);
    this.setCommonRuleProperties(e2, t2);
    return t2;
  }
  hydrateSizeRule(e2) {
    const t2 = new SizeRule(e2.count, e2.isMax);
    this.setCommonRuleProperties(e2, t2);
    return t2;
  }
  hydrateRangeRule(e2) {
    const t2 = new RangeRule(e2.isInclusive, {
      min: e2.min,
      max: e2.max
    });
    this.setCommonRuleProperties(e2, t2);
    return t2;
  }
  hydrateEqualsRule(e2) {
    const t2 = new EqualsRule(e2.expectedValue);
    this.setCommonRuleProperties(e2, t2);
    return t2;
  }
  hydrateRuleProperty(e2) {
    const t2 = e2.name;
    if (!t2 || typeof t2 !== "string") {
      throw createMappedError$1(4106, typeof t2);
    }
    const [s3, i3] = parsePropertyName(t2, this.parser);
    return new RuleProperty(i3, s3, e2.displayName);
  }
}
mixinAstEvaluator(ModelValidationExpressionHydrator);
class ValidateInstruction {
  constructor(e2 = void 0, t2 = void 0, s3 = void 0, i3 = void 0, r2 = void 0) {
    this.object = e2;
    this.propertyName = t2;
    this.rules = s3;
    this.objectTag = i3;
    this.propertyTag = r2;
  }
}
const B = /* @__PURE__ */ DI.createInterface("IValidator");
class StandardValidator {
  async validate(e2) {
    const t2 = e2.object;
    const s3 = e2.propertyName;
    const i3 = e2.propertyTag;
    const r2 = e2.rules ?? V2.get(t2, e2.objectTag) ?? [];
    const n3 = Scope.create({
      [A$1]: t2
    });
    if (s3 !== void 0) {
      return await r2.find((e3) => e3.property.name === s3)?.validate(t2, i3, n3) ?? [];
    }
    return (await Promise.all(r2.map(async (e3) => e3.validate(t2, i3, n3)))).flat();
  }
}
function getDefaultValidationConfiguration() {
  return {
    ValidatorType: StandardValidator,
    MessageProviderType: ValidationMessageProvider,
    CustomMessages: [],
    HydratorType: ModelValidationExpressionHydrator
  };
}
function createConfiguration$1(e2) {
  return {
    optionsProvider: e2,
    register(t2) {
      const s3 = getDefaultValidationConfiguration();
      e2(s3);
      t2.register(Registration.instance(b2, s3.CustomMessages), Registration.singleton(B, s3.ValidatorType), Registration.singleton(z, s3.MessageProviderType), Registration.singleton(g, s3.HydratorType), Registration.transient(M$1, ValidationRules), ValidationDeserializer);
      return t2;
    },
    customize(t2) {
      return createConfiguration$1(t2 ?? e2);
    }
  };
}
const L2 = /* @__PURE__ */ createConfiguration$1(noop$1);
function __esDecorate$1(t2, i3, e2, s3, n3, r2) {
  function accept(t3) {
    if (t3 !== void 0 && typeof t3 !== "function") throw new TypeError("Function expected");
    return t3;
  }
  var o2 = s3.kind, a2 = o2 === "getter" ? "get" : o2 === "setter" ? "set" : "value";
  var h2 = {};
  var c2, u2 = false;
  for (var d2 = e2.length - 1; d2 >= 0; d2--) {
    var f2 = {};
    for (var v2 in s3) f2[v2] = v2 === "access" ? {} : s3[v2];
    for (var v2 in s3.access) f2.access[v2] = s3.access[v2];
    f2.addInitializer = function(t3) {
      if (u2) throw new TypeError("Cannot add initializers after decoration has completed");
      r2.push(accept(t3 || null));
    };
    var g2 = (0, e2[d2])(o2 === "accessor" ? {
      get: h2.get,
      set: h2.set
    } : h2[a2], f2);
    if (o2 === "accessor") {
      if (g2 === void 0) continue;
      if (g2 === null || typeof g2 !== "object") throw new TypeError("Object expected");
      if (c2 = accept(g2.get)) h2.get = c2;
      if (c2 = accept(g2.set)) h2.set = c2;
      if (c2 = accept(g2.init)) n3.unshift(c2);
    } else if (c2 = accept(g2)) {
      if (o2 === "field") n3.unshift(c2);
      else h2[a2] = c2;
    }
  }
  u2 = true;
}
function __runInitializers$1(t2, i3, e2) {
  var s3 = arguments.length > 2;
  for (var n3 = 0; n3 < i3.length; n3++) {
    e2 = s3 ? i3[n3].call(t2, e2) : i3[n3].call(t2);
  }
  return s3 ? e2 : void 0;
}
typeof SuppressedError === "function" ? SuppressedError : function(t2, i3, e2) {
  var s3 = new Error(e2);
  return s3.name = "SuppressedError", s3.error = t2, s3.suppressed = i3, s3;
};
const createMappedError = (t2, ...i3) => new Error(`AUR${String(t2).padStart(4, "0")}:${i3.map(String)}`);
class ControllerValidateResult {
  constructor(t2, i3, e2) {
    this.valid = t2;
    this.results = i3;
    this.instruction = e2;
  }
}
class ValidationResultTarget {
  constructor(t2, i3) {
    this.result = t2;
    this.targets = i3;
  }
}
class ValidationEvent {
  constructor(t2, i3, e2) {
    this.kind = t2;
    this.addedResults = i3;
    this.removedResults = e2;
  }
}
class BindingInfo {
  constructor(t2, i3, e2, s3 = void 0) {
    this.target = t2;
    this.scope = i3;
    this.rules = e2;
    this.propertyInfo = s3;
  }
}
class PropertyInfo {
  constructor(t2, i3) {
    this.object = t2;
    this.propertyName = i3;
  }
}
function getPropertyInfo(t2, i3) {
  let e2 = i3.propertyInfo;
  if (e2 !== void 0) {
    return e2;
  }
  const s3 = i3.scope;
  let n3 = t2.ast.expression;
  let r2 = true;
  let o2 = "";
  while (n3 !== void 0 && n3?.$kind !== "AccessScope") {
    let i4;
    switch (n3.$kind) {
      case "BindingBehavior":
      case "ValueConverter":
        n3 = n3.expression;
        continue;
      case "AccessMember":
        i4 = n3.name;
        break;
      case "AccessKeyed": {
        const e4 = n3.key;
        if (r2) {
          r2 = e4.$kind === "PrimitiveLiteral";
        }
        i4 = `[${astEvaluate(e4, s3, t2, null).toString()}]`;
        break;
      }
      default:
        throw createMappedError(4205, n3.constructor.name);
    }
    const e3 = o2.startsWith("[") ? "" : ".";
    o2 = o2.length === 0 ? i4 : `${i4}${e3}${o2}`;
    n3 = n3.object;
  }
  if (n3 === void 0) {
    throw createMappedError(4206, t2.ast.expression);
  }
  let a2;
  if (o2.length === 0) {
    o2 = n3.name;
    a2 = s3.bindingContext;
  } else {
    a2 = astEvaluate(n3, s3, t2, null);
  }
  if (a2 === null || a2 === void 0) {
    return void 0;
  }
  e2 = new PropertyInfo(a2, o2);
  if (r2) {
    i3.propertyInfo = e2;
  }
  return e2;
}
const I2 = /* @__PURE__ */ DI.createInterface("IValidationController");
class ValidationController {
  constructor() {
    this.bindings = /* @__PURE__ */ new Map();
    this.subscribers = /* @__PURE__ */ new Set();
    this.results = [];
    this.validating = false;
    this.elements = /* @__PURE__ */ new WeakMap();
    this.objects = /* @__PURE__ */ new Map();
    this.validator = resolve(B);
    this.parser = resolve(IExpressionParser);
    this.platform = resolve(IPlatform);
    this.locator = resolve(IServiceLocator);
  }
  addObject(t2, i3) {
    this.objects.set(t2, i3);
  }
  removeObject(t2) {
    this.objects.delete(t2);
    this.processResultDelta("reset", this.results.filter((i3) => i3.object === t2), []);
  }
  addError(t2, i3, e2) {
    let s3;
    if (e2 !== void 0) {
      [s3] = parsePropertyName(e2, this.parser);
    }
    const n3 = new ValidationResult(false, t2, s3, i3, void 0, void 0, true);
    this.processResultDelta("validate", [], [n3]);
    return n3;
  }
  removeError(t2) {
    if (this.results.includes(t2)) {
      this.processResultDelta("reset", [t2], []);
    }
  }
  addSubscriber(t2) {
    this.subscribers.add(t2);
  }
  removeSubscriber(t2) {
    this.subscribers.delete(t2);
  }
  registerBinding(t2, i3) {
    this.bindings.set(t2, i3);
  }
  unregisterBinding(t2) {
    this.resetBinding(t2);
    this.bindings.delete(t2);
  }
  async validate(t2) {
    const { object: i3, objectTag: e2 } = t2 ?? {};
    let s3;
    if (i3 !== void 0) {
      s3 = [new ValidateInstruction(i3, t2?.propertyName, t2?.rules ?? this.objects.get(i3), e2, t2?.propertyTag)];
    } else {
      s3 = [...Array.from(this.objects.entries()).map(([t3, i4]) => new ValidateInstruction(t3, void 0, i4, e2)), ...Array.from(this.bindings.entries()).reduce((i4, [s4, n4]) => {
        if (!s4.isBound) return i4;
        const r2 = getPropertyInfo(s4, n4);
        if (r2 !== void 0 && !this.objects.has(r2.object)) {
          i4.push(new ValidateInstruction(r2.object, r2.propertyName, n4.rules, e2, t2?.propertyTag));
        }
        return i4;
      }, [])];
    }
    this.validating = true;
    const n3 = this.platform.domQueue.queueTask(async () => {
      try {
        const i4 = await Promise.all(s3.map(async (t3) => this.validator.validate(t3)));
        const e3 = i4.reduce((t3, i5) => {
          t3.push(...i5);
          return t3;
        }, []);
        const n4 = this.getInstructionPredicate(t2);
        const r2 = this.results.filter(n4);
        this.processResultDelta("validate", r2, e3);
        return new ControllerValidateResult(e3.find((t3) => !t3.valid) === void 0, e3, t2);
      } finally {
        this.validating = false;
      }
    });
    return n3.result;
  }
  reset(t2) {
    const i3 = this.getInstructionPredicate(t2);
    const e2 = this.results.filter(i3);
    this.processResultDelta("reset", e2, []);
  }
  async validateBinding(t2) {
    if (!t2.isBound) {
      return;
    }
    const i3 = this.bindings.get(t2);
    if (i3 === void 0) {
      return;
    }
    const e2 = getPropertyInfo(t2, i3);
    const s3 = i3.rules;
    if (e2 === void 0) {
      return;
    }
    const { object: n3, propertyName: r2 } = e2;
    await this.validate(new ValidateInstruction(n3, r2, s3));
  }
  resetBinding(t2) {
    const i3 = this.bindings.get(t2);
    if (i3 === void 0) {
      return;
    }
    const e2 = getPropertyInfo(t2, i3);
    if (e2 === void 0) {
      return;
    }
    i3.propertyInfo = void 0;
    const { object: s3, propertyName: n3 } = e2;
    this.reset(new ValidateInstruction(s3, n3));
  }
  async revalidateErrors() {
    const t2 = this.results.reduce((t3, { isManual: i4, object: e2, propertyRule: s3, rule: n3, valid: r2 }) => {
      if (!r2 && !i4 && s3 !== void 0 && e2 !== void 0 && n3 !== void 0) {
        let i5 = t3.get(e2);
        if (i5 === void 0) {
          t3.set(e2, i5 = /* @__PURE__ */ new Map());
        }
        let r3 = i5.get(s3);
        if (r3 === void 0) {
          i5.set(s3, r3 = []);
        }
        r3.push(n3);
      }
      return t3;
    }, /* @__PURE__ */ new Map());
    const i3 = [];
    for (const [e2, s3] of t2) {
      i3.push(this.validate(new ValidateInstruction(e2, void 0, Array.from(s3).map(([{ validationRules: t3, messageProvider: i4, property: e3 }, s4]) => new PropertyRule(this.locator, t3, i4, e3, [s4])))));
    }
    await Promise.all(i3);
  }
  getInstructionPredicate(t2) {
    if (t2 === void 0) {
      return () => true;
    }
    const i3 = t2.propertyName;
    const e2 = t2.rules;
    return (s3) => !s3.isManual && s3.object === t2.object && (i3 === void 0 || s3.propertyName === i3) && (e2 === void 0 || e2.includes(s3.propertyRule) || e2.some((t3) => s3.propertyRule === void 0 || t3.$rules.flat().every((t4) => s3.propertyRule.$rules.flat().includes(t4))));
  }
  getAssociatedElements({ object: t2, propertyName: i3 }) {
    const e2 = [];
    for (const [s3, n3] of this.bindings.entries()) {
      const r2 = getPropertyInfo(s3, n3);
      if (r2 !== void 0 && r2.object === t2 && r2.propertyName === i3) {
        e2.push(n3.target);
      }
    }
    return e2;
  }
  processResultDelta(t2, i3, e2) {
    const s3 = new ValidationEvent(t2, [], []);
    e2 = e2.slice(0);
    const n3 = this.elements;
    for (const t3 of i3) {
      const i4 = n3.get(t3);
      n3.delete(t3);
      s3.removedResults.push(new ValidationResultTarget(t3, i4));
      const r2 = e2.findIndex((i5) => i5.rule === t3.rule && i5.object === t3.object && i5.propertyName === t3.propertyName);
      if (r2 === -1) {
        this.results.splice(this.results.indexOf(t3), 1);
      } else {
        const i5 = e2.splice(r2, 1)[0];
        const o2 = this.getAssociatedElements(i5);
        n3.set(i5, o2);
        s3.addedResults.push(new ValidationResultTarget(i5, o2));
        this.results.splice(this.results.indexOf(t3), 1, i5);
      }
    }
    for (const t3 of e2) {
      const i4 = this.getAssociatedElements(t3);
      s3.addedResults.push(new ValidationResultTarget(t3, i4));
      n3.set(t3, i4);
      this.results.push(t3);
    }
    for (const t3 of this.subscribers) {
      t3.handleValidationEvent(s3);
    }
  }
}
class ValidationControllerFactory {
  constructor() {
    this.Type = void 0;
  }
  registerTransformer(t2) {
    return false;
  }
  construct(t2, i3) {
    return t2.invoke(ValidationController, i3);
  }
}
function compareDocumentPositionFlat(t2, i3) {
  switch (t2.compareDocumentPosition(i3) & 2) {
    case 0:
      return 0;
    case 2:
      return 1;
    default:
      return -1;
  }
}
const P = `
<slot></slot>
<slot name='secondary'>
  <span repeat.for="error of errors">
    \${error.result.message}
  </span>
</slot>
`;
const A = {
  name: "validation-container",
  shadowOptions: {
    mode: "open"
  },
  hasSlots: true
};
let M2 = (() => {
  var t2;
  let e2;
  let n3 = [];
  let r2 = [];
  let o2;
  let a2 = [];
  let l2 = [];
  return t2 = class ValidationContainerCustomElement {
    constructor() {
      this.controller = __runInitializers$1(this, n3, void 0);
      this.errors = (__runInitializers$1(this, r2), __runInitializers$1(this, a2, []));
      this.host = (__runInitializers$1(this, l2), resolve(INode));
      this.scopedController = resolve(optional(I2));
    }
    handleValidationEvent(t3) {
      for (const { result: i3 } of t3.removedResults) {
        const t4 = this.errors.findIndex((t5) => t5.result === i3);
        if (t4 !== -1) {
          this.errors.splice(t4, 1);
        }
      }
      for (const { result: i3, targets: e3 } of t3.addedResults) {
        if (i3.valid) {
          continue;
        }
        const t4 = e3.filter((t5) => this.host.contains(t5));
        if (t4.length > 0) {
          this.errors.push(new ValidationResultTarget(i3, t4));
        }
      }
      this.errors.sort((t4, i3) => {
        if (t4.targets[0] === i3.targets[0]) {
          return 0;
        }
        return compareDocumentPositionFlat(t4.targets[0], i3.targets[0]);
      });
    }
    binding() {
      this.controller = this.controller ?? this.scopedController;
      this.controller.addSubscriber(this);
    }
    unbinding() {
      this.controller.removeSubscriber(this);
    }
  }, (() => {
    const i3 = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
    e2 = [bindable];
    o2 = [bindable];
    __esDecorate$1(null, null, e2, {
      kind: "field",
      name: "controller",
      static: false,
      private: false,
      access: {
        has: (t3) => "controller" in t3,
        get: (t3) => t3.controller,
        set: (t3, i4) => {
          t3.controller = i4;
        }
      },
      metadata: i3
    }, n3, r2);
    __esDecorate$1(null, null, o2, {
      kind: "field",
      name: "errors",
      static: false,
      private: false,
      access: {
        has: (t3) => "errors" in t3,
        get: (t3) => t3.errors,
        set: (t3, i4) => {
          t3.errors = i4;
        }
      },
      metadata: i3
    }, a2, l2);
    if (i3) Object.defineProperty(t2, Symbol.metadata, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: i3
    });
  })(), t2;
})();
class ValidationErrorsCustomAttribute {
  constructor() {
    this.errors = [];
    this.errorsInternal = [];
    this.host = resolve(INode);
    this.scopedController = resolve(optional(I2));
  }
  handleValidationEvent(t2) {
    for (const { result: i3 } of t2.removedResults) {
      const t3 = this.errorsInternal.findIndex((t4) => t4.result === i3);
      if (t3 !== -1) {
        this.errorsInternal.splice(t3, 1);
      }
    }
    for (const { result: i3, targets: e2 } of t2.addedResults) {
      if (i3.valid) {
        continue;
      }
      const t3 = e2.filter((t4) => this.host.contains(t4));
      if (t3.length > 0) {
        this.errorsInternal.push(new ValidationResultTarget(i3, t3));
      }
    }
    this.errorsInternal.sort((t3, i3) => {
      if (t3.targets[0] === i3.targets[0]) {
        return 0;
      }
      return compareDocumentPositionFlat(t3.targets[0], i3.targets[0]);
    });
    this.errors = this.errorsInternal;
  }
  binding() {
    this.controller = this.controller ?? this.scopedController;
    this.controller.addSubscriber(this);
  }
  unbinding() {
    this.controller.removeSubscriber(this);
  }
}
CustomAttribute.define({
  name: "validation-errors",
  bindables: {
    controller: {},
    errors: {
      primary: true,
      mode: BindingMode.twoWay
    }
  }
}, ValidationErrorsCustomAttribute);
var D;
(function(t2) {
  t2["manual"] = "manual";
  t2["blur"] = "blur";
  t2["focusout"] = "focusout";
  t2["change"] = "change";
  t2["changeOrBlur"] = "changeOrBlur";
  t2["changeOrFocusout"] = "changeOrFocusout";
})(D || (D = {}));
const j = /* @__PURE__ */ DI.createInterface("IDefaultTrigger");
const k2 = /* @__PURE__ */ new WeakMap();
const O = /* @__PURE__ */ new WeakMap();
class ValidateBindingBehavior {
  constructor() {
    this.p = resolve(IPlatform);
    this.oL = resolve(IObserverLocator);
  }
  bind(t2, i3) {
    if (!(i3 instanceof PropertyBinding)) {
      throw createMappedError(4200);
    }
    let e2 = k2.get(i3);
    if (e2 == null) {
      k2.set(i3, e2 = new ValidationConnector(this.p, this.oL, i3.get(j), i3, i3.get(IContainer)));
    }
    let s3 = O.get(i3);
    if (s3 == null) {
      O.set(i3, s3 = new WithValidationTargetSubscriber(e2, i3, i3.get(IFlushQueue)));
    }
    e2.start(t2);
    i3.useTargetSubscriber(s3);
  }
  unbind(t2, i3) {
    k2.get(i3)?.stop();
  }
}
BindingBehavior.define("validate", ValidateBindingBehavior);
class ValidationConnector {
  constructor(t2, i3, e2, s3, n3) {
    this.isChangeTrigger = false;
    this.isDirty = false;
    this.validatedOnce = false;
    this.triggerEvent = null;
    this.task = null;
    this.propertyBinding = s3;
    this.target = s3.target;
    this.defaultTrigger = e2;
    this.p = t2;
    this.oL = i3;
    this.l = n3;
    this.t = new BindingMediator("handleTriggerChange", this, i3, n3);
    this.i = new BindingMediator("handleControllerChange", this, i3, n3);
    this.h = new BindingMediator("handleRulesChange", this, i3, n3);
    if (n3.has(I2, true)) {
      this.scopedController = n3.get(I2);
    }
  }
  u() {
    this.isDirty = true;
    const t2 = this.triggerEvent;
    if (this.isChangeTrigger && (t2 === null || t2 !== null && this.validatedOnce)) {
      this.validateBinding();
    }
  }
  handleEvent(t2) {
    if (!this.isChangeTrigger || this.isChangeTrigger && this.isDirty) {
      this.validateBinding();
    }
  }
  start(t2) {
    this.scope = t2;
    this.target = this.V();
    const i3 = this.C();
    this.B(i3);
  }
  stop() {
    this.task?.cancel();
    this.scope = void 0;
    this.task = null;
    const t2 = this.triggerEvent;
    if (t2 !== null) {
      this.target?.removeEventListener(t2, this);
    }
    this.controller?.resetBinding(this.propertyBinding);
    this.controller?.removeSubscriber(this);
  }
  handleTriggerChange(t2, i3) {
    this.B(new ValidateArgumentsDelta(void 0, this._(t2), void 0));
  }
  handleControllerChange(t2, i3) {
    this.B(new ValidateArgumentsDelta(this.R(t2), void 0, void 0));
  }
  handleRulesChange(t2, i3) {
    this.B(new ValidateArgumentsDelta(void 0, void 0, this.T(t2)));
  }
  handleValidationEvent(t2) {
    if (this.validatedOnce || !this.isChangeTrigger) return;
    const i3 = this.triggerEvent;
    if (i3 === null) return;
    const e2 = this.bindingInfo.propertyInfo?.propertyName;
    if (e2 === void 0) return;
    this.validatedOnce = t2.addedResults.find((t3) => t3.result.propertyName === e2) !== void 0;
  }
  C() {
    const t2 = this.scope;
    let i3;
    let e2;
    let s3;
    let n3 = this.propertyBinding.ast;
    while (n3.name !== "validate" && n3 !== void 0) {
      n3 = n3.expression;
    }
    const r2 = n3.args;
    for (let n4 = 0, o2 = r2.length; n4 < o2; n4++) {
      const o3 = r2[n4];
      switch (n4) {
        case 0:
          e2 = this._(astEvaluate(o3, t2, this, this.t));
          break;
        case 1:
          s3 = this.R(astEvaluate(o3, t2, this, this.i));
          break;
        case 2:
          i3 = this.T(astEvaluate(o3, t2, this, this.h));
          break;
        default:
          throw createMappedError(4201, n4 + 1, astEvaluate(o3, t2, this, null));
      }
    }
    return new ValidateArgumentsDelta(this.R(s3), this._(e2), i3);
  }
  validateBinding() {
    const t2 = this.task;
    this.task = this.p.domQueue.queueTask(() => this.controller.validateBinding(this.propertyBinding));
    if (t2 !== this.task) {
      t2?.cancel();
    }
  }
  B(t2) {
    const i3 = t2.trigger ?? this.trigger;
    const e2 = t2.controller ?? this.controller;
    const s3 = t2.rules;
    if (this.trigger !== i3) {
      let t3 = this.triggerEvent;
      if (t3 !== null) {
        this.target.removeEventListener(t3, this);
      }
      this.validatedOnce = false;
      this.isDirty = false;
      this.trigger = i3;
      this.isChangeTrigger = i3 === D.change || i3 === D.changeOrBlur || i3 === D.changeOrFocusout;
      t3 = this.triggerEvent = this.I(this.trigger);
      if (t3 !== null) {
        this.target.addEventListener(t3, this);
      }
    }
    if (this.controller !== e2 || s3 !== void 0) {
      this.controller?.removeSubscriber(this);
      this.controller?.unregisterBinding(this.propertyBinding);
      this.controller = e2;
      e2.registerBinding(this.propertyBinding, this.P(s3));
      e2.addSubscriber(this);
    }
  }
  _(t2) {
    if (t2 === void 0 || t2 === null) {
      t2 = this.defaultTrigger;
    } else if (!Object.values(D).includes(t2)) {
      throw createMappedError(4202, t2);
    }
    return t2;
  }
  R(t2) {
    if (t2 == null) {
      t2 = this.scopedController;
    } else if (!(t2 instanceof ValidationController)) {
      throw createMappedError(4203, t2);
    }
    return t2;
  }
  T(t2) {
    if (Array.isArray(t2) && t2.every((t3) => t3 instanceof PropertyRule)) {
      return t2;
    }
  }
  V() {
    const t2 = this.propertyBinding.target;
    if (t2 instanceof this.p.Node) {
      return t2;
    } else {
      const i3 = t2?.$controller;
      if (i3 === void 0) {
        throw createMappedError(4204);
      }
      return i3.host;
    }
  }
  I(t2) {
    let i3 = null;
    switch (t2) {
      case D.blur:
      case D.changeOrBlur:
        i3 = "blur";
        break;
      case D.focusout:
      case D.changeOrFocusout:
        i3 = "focusout";
        break;
    }
    return i3;
  }
  P(t2) {
    return this.bindingInfo = new BindingInfo(this.target, this.scope, t2);
  }
}
connectable(ValidationConnector, null);
mixinNoopAstEvaluator(ValidationConnector);
class WithValidationTargetSubscriber extends BindingTargetSubscriber {
  constructor(t2, i3, e2) {
    super(i3, e2);
    this.vs = t2;
  }
  handleChange(t2, i3) {
    super.handleChange(t2, i3);
    this.vs.u();
  }
}
class ValidateArgumentsDelta {
  constructor(t2, i3, e2) {
    this.controller = t2;
    this.trigger = i3;
    this.rules = e2;
  }
}
class BindingMediator {
  constructor(t2, i3, e2, s3) {
    this.key = t2;
    this.binding = i3;
    this.oL = e2;
    this.l = s3;
  }
  handleChange(t2, i3) {
    this.binding[this.key](t2, i3);
  }
}
connectable(BindingMediator, null);
mixinNoopAstEvaluator(BindingMediator);
function getDefaultValidationHtmlConfiguration() {
  return {
    ...getDefaultValidationConfiguration(),
    ValidationControllerFactoryType: ValidationControllerFactory,
    DefaultTrigger: D.focusout,
    UseSubscriberCustomAttribute: true,
    SubscriberCustomElementTemplate: P
  };
}
function createConfiguration(t2) {
  return {
    optionsProvider: t2,
    register(i3) {
      const e2 = getDefaultValidationHtmlConfiguration();
      t2(e2);
      i3.registerFactory(I2, new e2.ValidationControllerFactoryType());
      i3.register(L2.customize((t3) => {
        for (const i4 of Object.keys(t3)) {
          if (i4 in e2) {
            t3[i4] = e2[i4];
          }
        }
      }), Registration.instance(j, e2.DefaultTrigger), ValidateBindingBehavior);
      if (e2.UseSubscriberCustomAttribute) {
        i3.register(ValidationErrorsCustomAttribute);
      }
      const s3 = e2.SubscriberCustomElementTemplate;
      if (s3) {
        i3.register(CustomElement.define({
          ...A,
          template: s3
        }, M2));
      }
      return i3;
    },
    customize(i3) {
      return createConfiguration(i3 ?? t2);
    }
  };
}
const $ = /* @__PURE__ */ createConfiguration(noop$1);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFoundation = (
  /** @class */
  function() {
    function MDCFoundation2(adapter) {
      if (adapter === void 0) {
        adapter = {};
      }
      this.adapter = adapter;
    }
    Object.defineProperty(MDCFoundation2, "cssClasses", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "strings", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "numbers", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFoundation2, "defaultAdapter", {
      get: function() {
        return {};
      },
      enumerable: false,
      configurable: true
    });
    MDCFoundation2.prototype.init = function() {
    };
    MDCFoundation2.prototype.destroy = function() {
    };
    return MDCFoundation2;
  }()
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCComponent = (
  /** @class */
  function() {
    function MDCComponent2(root, foundation) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      this.root = root;
      this.initialize.apply(this, __spreadArray([], __read(args)));
      this.foundation = foundation === void 0 ? this.getDefaultFoundation() : foundation;
      this.foundation.init();
      this.initialSyncWithDOM();
    }
    MDCComponent2.attachTo = function(root) {
      return new MDCComponent2(root, new MDCFoundation({}));
    };
    MDCComponent2.prototype.initialize = function() {
    };
    MDCComponent2.prototype.getDefaultFoundation = function() {
      throw new Error("Subclasses must override getDefaultFoundation to return a properly configured foundation class");
    };
    MDCComponent2.prototype.initialSyncWithDOM = function() {
    };
    MDCComponent2.prototype.destroy = function() {
      this.foundation.destroy();
    };
    MDCComponent2.prototype.listen = function(evtType, handler, options) {
      this.root.addEventListener(evtType, handler, options);
    };
    MDCComponent2.prototype.unlisten = function(evtType, handler, options) {
      this.root.removeEventListener(evtType, handler, options);
    };
    MDCComponent2.prototype.emit = function(evtType, evtData, shouldBubble) {
      if (shouldBubble === void 0) {
        shouldBubble = false;
      }
      var evt;
      if (typeof CustomEvent === "function") {
        evt = new CustomEvent(evtType, {
          bubbles: shouldBubble,
          detail: evtData
        });
      } else {
        evt = document.createEvent("CustomEvent");
        evt.initCustomEvent(evtType, shouldBubble, false, evtData);
      }
      this.root.dispatchEvent(evt);
    };
    return MDCComponent2;
  }()
);
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var FOCUS_SENTINEL_CLASS = "mdc-dom-focus-sentinel";
var FocusTrap2 = (
  /** @class */
  function() {
    function FocusTrap3(root, options) {
      if (options === void 0) {
        options = {};
      }
      this.root = root;
      this.options = options;
      this.elFocusedBeforeTrapFocus = null;
    }
    FocusTrap3.prototype.trapFocus = function() {
      var focusableEls = this.getFocusableElements(this.root);
      if (focusableEls.length === 0) {
        throw new Error("FocusTrap: Element must have at least one focusable child.");
      }
      this.elFocusedBeforeTrapFocus = document.activeElement instanceof HTMLElement ? document.activeElement : null;
      this.wrapTabFocus(this.root);
      if (!this.options.skipInitialFocus) {
        this.focusInitialElement(focusableEls, this.options.initialFocusEl);
      }
    };
    FocusTrap3.prototype.releaseFocus = function() {
      [].slice.call(this.root.querySelectorAll("." + FOCUS_SENTINEL_CLASS)).forEach(function(sentinelEl) {
        sentinelEl.parentElement.removeChild(sentinelEl);
      });
      if (!this.options.skipRestoreFocus && this.elFocusedBeforeTrapFocus) {
        this.elFocusedBeforeTrapFocus.focus();
      }
    };
    FocusTrap3.prototype.wrapTabFocus = function(el) {
      var _this = this;
      var sentinelStart = this.createSentinel();
      var sentinelEnd = this.createSentinel();
      sentinelStart.addEventListener("focus", function() {
        var focusableEls = _this.getFocusableElements(el);
        if (focusableEls.length > 0) {
          focusableEls[focusableEls.length - 1].focus();
        }
      });
      sentinelEnd.addEventListener("focus", function() {
        var focusableEls = _this.getFocusableElements(el);
        if (focusableEls.length > 0) {
          focusableEls[0].focus();
        }
      });
      el.insertBefore(sentinelStart, el.children[0]);
      el.appendChild(sentinelEnd);
    };
    FocusTrap3.prototype.focusInitialElement = function(focusableEls, initialFocusEl) {
      var focusIndex = 0;
      if (initialFocusEl) {
        focusIndex = Math.max(focusableEls.indexOf(initialFocusEl), 0);
      }
      focusableEls[focusIndex].focus();
    };
    FocusTrap3.prototype.getFocusableElements = function(root) {
      var focusableEls = [].slice.call(root.querySelectorAll("[autofocus], [tabindex], a, input, textarea, select, button"));
      return focusableEls.filter(function(el) {
        var isDisabledOrHidden = el.getAttribute("aria-disabled") === "true" || el.getAttribute("disabled") != null || el.getAttribute("hidden") != null || el.getAttribute("aria-hidden") === "true";
        var isTabbableAndVisible = el.tabIndex >= 0 && el.getBoundingClientRect().width > 0 && !el.classList.contains(FOCUS_SENTINEL_CLASS) && !isDisabledOrHidden;
        var isProgrammaticallyHidden = false;
        if (isTabbableAndVisible) {
          var style = getComputedStyle(el);
          isProgrammaticallyHidden = style.display === "none" || style.visibility === "hidden";
        }
        return isTabbableAndVisible && !isProgrammaticallyHidden;
      });
    };
    FocusTrap3.prototype.createSentinel = function() {
      var sentinel = document.createElement("div");
      sentinel.setAttribute("tabindex", "0");
      sentinel.setAttribute("aria-hidden", "true");
      sentinel.classList.add(FOCUS_SENTINEL_CLASS);
      return sentinel;
    };
    return FocusTrap3;
  }()
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function closest(element, selector) {
  if (element.closest) {
    return element.closest(selector);
  }
  var el = element;
  while (el) {
    if (matches(el, selector)) {
      return el;
    }
    el = el.parentElement;
  }
  return null;
}
function matches(element, selector) {
  var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
  return nativeMatches.call(element, selector);
}
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$8 = {
  CLOSING: "mdc-banner--closing",
  OPEN: "mdc-banner--open",
  OPENING: "mdc-banner--opening"
};
var numbers$4 = {
  BANNER_ANIMATION_CLOSE_TIME_MS: 250,
  BANNER_ANIMATION_OPEN_TIME_MS: 300
};
var events = {
  CLOSED: "MDCBanner:closed",
  CLOSING: "MDCBanner:closing",
  OPENED: "MDCBanner:opened",
  OPENING: "MDCBanner:opening",
  ACTION_CLICKED: "MDCBanner:actionClicked"
};
var selectors = {
  CONTENT: ".mdc-banner__content",
  PRIMARY_ACTION: ".mdc-banner__primary-action",
  SECONDARY_ACTION: ".mdc-banner__secondary-action",
  TEXT: ".mdc-banner__text"
};
var CloseReason;
(function(CloseReason2) {
  CloseReason2[CloseReason2["PRIMARY"] = 0] = "PRIMARY";
  CloseReason2[CloseReason2["SECONDARY"] = 1] = "SECONDARY";
  CloseReason2[CloseReason2["UNSPECIFIED"] = 2] = "UNSPECIFIED";
})(CloseReason || (CloseReason = {}));
var Action;
(function(Action2) {
  Action2[Action2["PRIMARY"] = 0] = "PRIMARY";
  Action2[Action2["SECONDARY"] = 1] = "SECONDARY";
  Action2[Action2["UNKNOWN"] = 2] = "UNKNOWN";
})(Action || (Action = {}));
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var OPENING = cssClasses$8.OPENING, OPEN = cssClasses$8.OPEN, CLOSING = cssClasses$8.CLOSING;
var MDCBannerFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCBannerFoundation2, _super);
    function MDCBannerFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCBannerFoundation2.defaultAdapter), adapter)) || this;
      _this.isOpened = false;
      _this.animationFrame = 0;
      _this.animationTimer = 0;
      return _this;
    }
    Object.defineProperty(MDCBannerFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          getContentHeight: function() {
            return 0;
          },
          notifyClosed: function() {
            return void 0;
          },
          notifyClosing: function() {
            return void 0;
          },
          notifyOpened: function() {
            return void 0;
          },
          notifyOpening: function() {
            return void 0;
          },
          notifyActionClicked: function() {
            return void 0;
          },
          releaseFocus: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          setStyleProperty: function() {
            return void 0;
          },
          trapFocus: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCBannerFoundation2.prototype.destroy = function() {
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = 0;
      clearTimeout(this.animationTimer);
      this.animationTimer = 0;
    };
    MDCBannerFoundation2.prototype.open = function() {
      var _this = this;
      this.isOpened = true;
      this.adapter.notifyOpening();
      this.adapter.removeClass(CLOSING);
      this.adapter.addClass(OPENING);
      var contentHeight = this.adapter.getContentHeight();
      this.animationFrame = requestAnimationFrame(function() {
        _this.adapter.addClass(OPEN);
        _this.adapter.setStyleProperty("height", contentHeight + "px");
        _this.animationTimer = setTimeout(function() {
          _this.handleAnimationTimerEnd();
          _this.adapter.trapFocus();
          _this.adapter.notifyOpened();
        }, numbers$4.BANNER_ANIMATION_OPEN_TIME_MS);
      });
    };
    MDCBannerFoundation2.prototype.close = function(reason) {
      var _this = this;
      if (!this.isOpened) {
        return;
      }
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = 0;
      this.isOpened = false;
      this.adapter.notifyClosing(reason);
      this.adapter.addClass(CLOSING);
      this.adapter.setStyleProperty("height", "0");
      this.adapter.removeClass(OPEN);
      this.adapter.removeClass(OPENING);
      clearTimeout(this.animationTimer);
      this.animationTimer = setTimeout(function() {
        _this.adapter.releaseFocus();
        _this.handleAnimationTimerEnd();
        _this.adapter.notifyClosed(reason);
      }, numbers$4.BANNER_ANIMATION_CLOSE_TIME_MS);
    };
    MDCBannerFoundation2.prototype.isOpen = function() {
      return this.isOpened;
    };
    MDCBannerFoundation2.prototype.handlePrimaryActionClick = function(disableAutoClose) {
      if (disableAutoClose === void 0) {
        disableAutoClose = false;
      }
      if (disableAutoClose) {
        this.adapter.notifyActionClicked(
          0
          /* PRIMARY */
        );
      } else {
        this.close(CloseReason.PRIMARY);
      }
    };
    MDCBannerFoundation2.prototype.handleSecondaryActionClick = function(disableAutoClose) {
      if (disableAutoClose === void 0) {
        disableAutoClose = false;
      }
      if (disableAutoClose) {
        this.adapter.notifyActionClicked(
          1
          /* SECONDARY */
        );
      } else {
        this.close(CloseReason.SECONDARY);
      }
    };
    MDCBannerFoundation2.prototype.layout = function() {
      var contentHeight = this.adapter.getContentHeight();
      this.adapter.setStyleProperty("height", contentHeight + "px");
    };
    MDCBannerFoundation2.prototype.handleAnimationTimerEnd = function() {
      this.animationTimer = 0;
      this.adapter.removeClass(OPENING);
      this.adapter.removeClass(CLOSING);
    };
    return MDCBannerFoundation2;
  }(MDCFoundation)
);
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCBanner = (
  /** @class */
  function(_super) {
    __extends(MDCBanner2, _super);
    function MDCBanner2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCBanner2.attachTo = function(root) {
      return new MDCBanner2(root);
    };
    MDCBanner2.prototype.initialize = function(focusTrapFactory) {
      var _this = this;
      if (focusTrapFactory === void 0) {
        focusTrapFactory = function(el, focusOptions) {
          return new FocusTrap2(el, focusOptions);
        };
      }
      this.contentEl = this.root.querySelector(selectors.CONTENT);
      this.textEl = this.root.querySelector(selectors.TEXT);
      this.primaryActionEl = this.root.querySelector(selectors.PRIMARY_ACTION);
      this.secondaryActionEl = this.root.querySelector(selectors.SECONDARY_ACTION);
      this.focusTrapFactory = focusTrapFactory;
      this.handleContentClick = function(evt) {
        var target = evt.target;
        if (closest(target, selectors.PRIMARY_ACTION)) {
          _this.foundation.handlePrimaryActionClick();
        } else if (closest(target, selectors.SECONDARY_ACTION)) {
          _this.foundation.handleSecondaryActionClick();
        }
      };
    };
    MDCBanner2.prototype.initialSyncWithDOM = function() {
      this.registerContentClickHandler(this.handleContentClick);
      this.focusTrap = this.focusTrapFactory(this.root, { initialFocusEl: this.primaryActionEl });
    };
    MDCBanner2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.deregisterContentClickHandler(this.handleContentClick);
    };
    MDCBanner2.prototype.layout = function() {
      this.foundation.layout();
    };
    MDCBanner2.prototype.open = function() {
      this.foundation.open();
    };
    MDCBanner2.prototype.close = function(reason) {
      this.foundation.close(reason);
    };
    MDCBanner2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          _this.root.classList.add(className);
        },
        getContentHeight: function() {
          return _this.contentEl.offsetHeight;
        },
        notifyClosed: function(reason) {
          _this.emit(events.CLOSED, { reason });
        },
        notifyClosing: function(reason) {
          _this.emit(events.CLOSING, { reason });
        },
        notifyOpened: function() {
          _this.emit(events.OPENED, {});
        },
        notifyOpening: function() {
          _this.emit(events.OPENING, {});
        },
        notifyActionClicked: function(action) {
          _this.emit(events.ACTION_CLICKED, { action });
        },
        releaseFocus: function() {
          _this.focusTrap.releaseFocus();
        },
        removeClass: function(className) {
          _this.root.classList.remove(className);
        },
        setStyleProperty: function(propertyName, value) {
          _this.root.style.setProperty(propertyName, value);
        },
        trapFocus: function() {
          _this.focusTrap.trapFocus();
        }
      };
      return new MDCBannerFoundation(adapter);
    };
    Object.defineProperty(MDCBanner2.prototype, "isOpen", {
      get: function() {
        return this.foundation.isOpen();
      },
      enumerable: false,
      configurable: true
    });
    MDCBanner2.prototype.getText = function() {
      return this.textEl.textContent || "";
    };
    MDCBanner2.prototype.setText = function(text) {
      this.textEl.textContent = text;
    };
    MDCBanner2.prototype.getPrimaryActionText = function() {
      return this.primaryActionEl.textContent || "";
    };
    MDCBanner2.prototype.setPrimaryActionText = function(actionButtonText) {
      this.primaryActionEl.textContent = actionButtonText;
    };
    MDCBanner2.prototype.getSecondaryActionText = function() {
      return this.secondaryActionEl ? this.secondaryActionEl.textContent || "" : null;
    };
    MDCBanner2.prototype.setSecondaryActionText = function(actionButtonText) {
      if (this.secondaryActionEl) {
        this.secondaryActionEl.textContent = actionButtonText;
      }
    };
    MDCBanner2.prototype.registerContentClickHandler = function(handler) {
      this.contentEl.addEventListener("click", handler);
    };
    MDCBanner2.prototype.deregisterContentClickHandler = function(handler) {
      this.contentEl.removeEventListener("click", handler);
    };
    return MDCBanner2;
  }(MDCComponent)
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function createFocusTrapInstance$1(surfaceEl, focusTrapFactory, initialFocusEl) {
  return focusTrapFactory(surfaceEl, { initialFocusEl });
}
function isScrollable(el) {
  return el ? el.scrollHeight > el.offsetHeight : false;
}
function isScrollAtTop(el) {
  return el ? el.scrollTop === 0 : false;
}
function isScrollAtBottom(el) {
  return el ? Math.ceil(el.scrollHeight - el.scrollTop) === el.clientHeight : false;
}
function areTopsMisaligned(els) {
  var tops = /* @__PURE__ */ new Set();
  [].forEach.call(els, function(el) {
    return tops.add(el.offsetTop);
  });
  return tops.size > 1;
}
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function applyPassive(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  return supportsPassiveOption(globalObj) ? { passive: true } : false;
}
function supportsPassiveOption(globalObj) {
  if (globalObj === void 0) {
    globalObj = window;
  }
  var passiveSupported = false;
  try {
    var options = {
      // This function will be called when the browser
      // attempts to access the passive property.
      get passive() {
        passiveSupported = true;
        return false;
      }
    };
    var handler = function() {
    };
    globalObj.document.addEventListener("test", handler, options);
    globalObj.document.removeEventListener("test", handler, options);
  } catch (err) {
    passiveSupported = false;
  }
  return passiveSupported;
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$7 = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  BG_FOCUSED: "mdc-ripple-upgraded--background-focused",
  FG_ACTIVATION: "mdc-ripple-upgraded--foreground-activation",
  FG_DEACTIVATION: "mdc-ripple-upgraded--foreground-deactivation",
  ROOT: "mdc-ripple-upgraded",
  UNBOUNDED: "mdc-ripple-upgraded--unbounded"
};
var strings$8 = {
  VAR_FG_SCALE: "--mdc-ripple-fg-scale",
  VAR_FG_SIZE: "--mdc-ripple-fg-size",
  VAR_FG_TRANSLATE_END: "--mdc-ripple-fg-translate-end",
  VAR_FG_TRANSLATE_START: "--mdc-ripple-fg-translate-start",
  VAR_LEFT: "--mdc-ripple-left",
  VAR_TOP: "--mdc-ripple-top"
};
var numbers$3 = {
  DEACTIVATION_TIMEOUT_MS: 225,
  FG_DEACTIVATION_MS: 150,
  INITIAL_ORIGIN_SCALE: 0.6,
  PADDING: 10,
  TAP_DELAY_MS: 300
  // Delay between touch and simulated mouse events on touch devices
};
var supportsCssVariables_;
function supportsCssVariables(windowObj, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  var CSS2 = windowObj.CSS;
  var supportsCssVars = supportsCssVariables_;
  if (typeof supportsCssVariables_ === "boolean" && !forceRefresh) {
    return supportsCssVariables_;
  }
  var supportsFunctionPresent = CSS2 && typeof CSS2.supports === "function";
  if (!supportsFunctionPresent) {
    return false;
  }
  var explicitlySupportsCssVars = CSS2.supports("--css-vars", "yes");
  var weAreFeatureDetectingSafari10plus = CSS2.supports("(--css-vars: yes)") && CSS2.supports("color", "#00000000");
  supportsCssVars = explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus;
  if (!forceRefresh) {
    supportsCssVariables_ = supportsCssVars;
  }
  return supportsCssVars;
}
function getNormalizedEventCoords(evt, pageOffset, clientRect) {
  if (!evt) {
    return { x: 0, y: 0 };
  }
  var x2 = pageOffset.x, y2 = pageOffset.y;
  var documentX = x2 + clientRect.left;
  var documentY = y2 + clientRect.top;
  var normalizedX;
  var normalizedY;
  if (evt.type === "touchstart") {
    var touchEvent = evt;
    normalizedX = touchEvent.changedTouches[0].pageX - documentX;
    normalizedY = touchEvent.changedTouches[0].pageY - documentY;
  } else {
    var mouseEvent = evt;
    normalizedX = mouseEvent.pageX - documentX;
    normalizedY = mouseEvent.pageY - documentY;
  }
  return { x: normalizedX, y: normalizedY };
}
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ACTIVATION_EVENT_TYPES = [
  "touchstart",
  "pointerdown",
  "mousedown",
  "keydown"
];
var POINTER_DEACTIVATION_EVENT_TYPES = [
  "touchend",
  "pointerup",
  "mouseup",
  "contextmenu"
];
var activatedTargets = [];
var MDCRippleFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCRippleFoundation2, _super);
    function MDCRippleFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCRippleFoundation2.defaultAdapter), adapter)) || this;
      _this.activationAnimationHasEnded = false;
      _this.activationTimer = 0;
      _this.fgDeactivationRemovalTimer = 0;
      _this.fgScale = "0";
      _this.frame = { width: 0, height: 0 };
      _this.initialSize = 0;
      _this.layoutFrame = 0;
      _this.maxRadius = 0;
      _this.unboundedCoords = { left: 0, top: 0 };
      _this.activationState = _this.defaultActivationState();
      _this.activationTimerCallback = function() {
        _this.activationAnimationHasEnded = true;
        _this.runDeactivationUXLogicIfReady();
      };
      _this.activateHandler = function(e2) {
        _this.activateImpl(e2);
      };
      _this.deactivateHandler = function() {
        _this.deactivateImpl();
      };
      _this.focusHandler = function() {
        _this.handleFocus();
      };
      _this.blurHandler = function() {
        _this.handleBlur();
      };
      _this.resizeHandler = function() {
        _this.layout();
      };
      return _this;
    }
    Object.defineProperty(MDCRippleFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$7;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation2, "strings", {
      get: function() {
        return strings$8;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation2, "numbers", {
      get: function() {
        return numbers$3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRippleFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          browserSupportsCssVars: function() {
            return true;
          },
          computeBoundingRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          containsEventTarget: function() {
            return true;
          },
          deregisterDocumentInteractionHandler: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          },
          deregisterResizeHandler: function() {
            return void 0;
          },
          getWindowPageOffset: function() {
            return { x: 0, y: 0 };
          },
          isSurfaceActive: function() {
            return true;
          },
          isSurfaceDisabled: function() {
            return true;
          },
          isUnbounded: function() {
            return true;
          },
          registerDocumentInteractionHandler: function() {
            return void 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          },
          registerResizeHandler: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          updateCssVariable: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCRippleFoundation2.prototype.init = function() {
      var _this = this;
      var supportsPressRipple = this.supportsPressRipple();
      this.registerRootHandlers(supportsPressRipple);
      if (supportsPressRipple) {
        var _a2 = MDCRippleFoundation2.cssClasses, ROOT_1 = _a2.ROOT, UNBOUNDED_1 = _a2.UNBOUNDED;
        requestAnimationFrame(function() {
          _this.adapter.addClass(ROOT_1);
          if (_this.adapter.isUnbounded()) {
            _this.adapter.addClass(UNBOUNDED_1);
            _this.layoutInternal();
          }
        });
      }
    };
    MDCRippleFoundation2.prototype.destroy = function() {
      var _this = this;
      if (this.supportsPressRipple()) {
        if (this.activationTimer) {
          clearTimeout(this.activationTimer);
          this.activationTimer = 0;
          this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_ACTIVATION);
        }
        if (this.fgDeactivationRemovalTimer) {
          clearTimeout(this.fgDeactivationRemovalTimer);
          this.fgDeactivationRemovalTimer = 0;
          this.adapter.removeClass(MDCRippleFoundation2.cssClasses.FG_DEACTIVATION);
        }
        var _a2 = MDCRippleFoundation2.cssClasses, ROOT_2 = _a2.ROOT, UNBOUNDED_2 = _a2.UNBOUNDED;
        requestAnimationFrame(function() {
          _this.adapter.removeClass(ROOT_2);
          _this.adapter.removeClass(UNBOUNDED_2);
          _this.removeCssVars();
        });
      }
      this.deregisterRootHandlers();
      this.deregisterDeactivationHandlers();
    };
    MDCRippleFoundation2.prototype.activate = function(evt) {
      this.activateImpl(evt);
    };
    MDCRippleFoundation2.prototype.deactivate = function() {
      this.deactivateImpl();
    };
    MDCRippleFoundation2.prototype.layout = function() {
      var _this = this;
      if (this.layoutFrame) {
        cancelAnimationFrame(this.layoutFrame);
      }
      this.layoutFrame = requestAnimationFrame(function() {
        _this.layoutInternal();
        _this.layoutFrame = 0;
      });
    };
    MDCRippleFoundation2.prototype.setUnbounded = function(unbounded) {
      var UNBOUNDED = MDCRippleFoundation2.cssClasses.UNBOUNDED;
      if (unbounded) {
        this.adapter.addClass(UNBOUNDED);
      } else {
        this.adapter.removeClass(UNBOUNDED);
      }
    };
    MDCRippleFoundation2.prototype.handleFocus = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.adapter.addClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
      });
    };
    MDCRippleFoundation2.prototype.handleBlur = function() {
      var _this = this;
      requestAnimationFrame(function() {
        return _this.adapter.removeClass(MDCRippleFoundation2.cssClasses.BG_FOCUSED);
      });
    };
    MDCRippleFoundation2.prototype.supportsPressRipple = function() {
      return this.adapter.browserSupportsCssVars();
    };
    MDCRippleFoundation2.prototype.defaultActivationState = function() {
      return {
        activationEvent: void 0,
        hasDeactivationUXRun: false,
        isActivated: false,
        isProgrammatic: false,
        wasActivatedByPointer: false,
        wasElementMadeActive: false
      };
    };
    MDCRippleFoundation2.prototype.registerRootHandlers = function(supportsPressRipple) {
      var e_1, _a2;
      if (supportsPressRipple) {
        try {
          for (var ACTIVATION_EVENT_TYPES_1 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next(); !ACTIVATION_EVENT_TYPES_1_1.done; ACTIVATION_EVENT_TYPES_1_1 = ACTIVATION_EVENT_TYPES_1.next()) {
            var evtType = ACTIVATION_EVENT_TYPES_1_1.value;
            this.adapter.registerInteractionHandler(evtType, this.activateHandler);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (ACTIVATION_EVENT_TYPES_1_1 && !ACTIVATION_EVENT_TYPES_1_1.done && (_a2 = ACTIVATION_EVENT_TYPES_1.return)) _a2.call(ACTIVATION_EVENT_TYPES_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (this.adapter.isUnbounded()) {
          this.adapter.registerResizeHandler(this.resizeHandler);
        }
      }
      this.adapter.registerInteractionHandler("focus", this.focusHandler);
      this.adapter.registerInteractionHandler("blur", this.blurHandler);
    };
    MDCRippleFoundation2.prototype.registerDeactivationHandlers = function(evt) {
      var e_2, _a2;
      if (evt.type === "keydown") {
        this.adapter.registerInteractionHandler("keyup", this.deactivateHandler);
      } else {
        try {
          for (var POINTER_DEACTIVATION_EVENT_TYPES_1 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next(); !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done; POINTER_DEACTIVATION_EVENT_TYPES_1_1 = POINTER_DEACTIVATION_EVENT_TYPES_1.next()) {
            var evtType = POINTER_DEACTIVATION_EVENT_TYPES_1_1.value;
            this.adapter.registerDocumentInteractionHandler(evtType, this.deactivateHandler);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (POINTER_DEACTIVATION_EVENT_TYPES_1_1 && !POINTER_DEACTIVATION_EVENT_TYPES_1_1.done && (_a2 = POINTER_DEACTIVATION_EVENT_TYPES_1.return)) _a2.call(POINTER_DEACTIVATION_EVENT_TYPES_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
    };
    MDCRippleFoundation2.prototype.deregisterRootHandlers = function() {
      var e_3, _a2;
      try {
        for (var ACTIVATION_EVENT_TYPES_2 = __values(ACTIVATION_EVENT_TYPES), ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next(); !ACTIVATION_EVENT_TYPES_2_1.done; ACTIVATION_EVENT_TYPES_2_1 = ACTIVATION_EVENT_TYPES_2.next()) {
          var evtType = ACTIVATION_EVENT_TYPES_2_1.value;
          this.adapter.deregisterInteractionHandler(evtType, this.activateHandler);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (ACTIVATION_EVENT_TYPES_2_1 && !ACTIVATION_EVENT_TYPES_2_1.done && (_a2 = ACTIVATION_EVENT_TYPES_2.return)) _a2.call(ACTIVATION_EVENT_TYPES_2);
        } finally {
          if (e_3) throw e_3.error;
        }
      }
      this.adapter.deregisterInteractionHandler("focus", this.focusHandler);
      this.adapter.deregisterInteractionHandler("blur", this.blurHandler);
      if (this.adapter.isUnbounded()) {
        this.adapter.deregisterResizeHandler(this.resizeHandler);
      }
    };
    MDCRippleFoundation2.prototype.deregisterDeactivationHandlers = function() {
      var e_4, _a2;
      this.adapter.deregisterInteractionHandler("keyup", this.deactivateHandler);
      try {
        for (var POINTER_DEACTIVATION_EVENT_TYPES_2 = __values(POINTER_DEACTIVATION_EVENT_TYPES), POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next(); !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done; POINTER_DEACTIVATION_EVENT_TYPES_2_1 = POINTER_DEACTIVATION_EVENT_TYPES_2.next()) {
          var evtType = POINTER_DEACTIVATION_EVENT_TYPES_2_1.value;
          this.adapter.deregisterDocumentInteractionHandler(evtType, this.deactivateHandler);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (POINTER_DEACTIVATION_EVENT_TYPES_2_1 && !POINTER_DEACTIVATION_EVENT_TYPES_2_1.done && (_a2 = POINTER_DEACTIVATION_EVENT_TYPES_2.return)) _a2.call(POINTER_DEACTIVATION_EVENT_TYPES_2);
        } finally {
          if (e_4) throw e_4.error;
        }
      }
    };
    MDCRippleFoundation2.prototype.removeCssVars = function() {
      var _this = this;
      var rippleStrings = MDCRippleFoundation2.strings;
      var keys = Object.keys(rippleStrings);
      keys.forEach(function(key) {
        if (key.indexOf("VAR_") === 0) {
          _this.adapter.updateCssVariable(rippleStrings[key], null);
        }
      });
    };
    MDCRippleFoundation2.prototype.activateImpl = function(evt) {
      var _this = this;
      if (this.adapter.isSurfaceDisabled()) {
        return;
      }
      var activationState = this.activationState;
      if (activationState.isActivated) {
        return;
      }
      var previousActivationEvent = this.previousActivationEvent;
      var isSameInteraction = previousActivationEvent && evt !== void 0 && previousActivationEvent.type !== evt.type;
      if (isSameInteraction) {
        return;
      }
      activationState.isActivated = true;
      activationState.isProgrammatic = evt === void 0;
      activationState.activationEvent = evt;
      activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : evt !== void 0 && (evt.type === "mousedown" || evt.type === "touchstart" || evt.type === "pointerdown");
      var hasActivatedChild = evt !== void 0 && activatedTargets.length > 0 && activatedTargets.some(function(target) {
        return _this.adapter.containsEventTarget(target);
      });
      if (hasActivatedChild) {
        this.resetActivationState();
        return;
      }
      if (evt !== void 0) {
        activatedTargets.push(evt.target);
        this.registerDeactivationHandlers(evt);
      }
      activationState.wasElementMadeActive = this.checkElementMadeActive(evt);
      if (activationState.wasElementMadeActive) {
        this.animateActivation();
      }
      requestAnimationFrame(function() {
        activatedTargets = [];
        if (!activationState.wasElementMadeActive && evt !== void 0 && (evt.key === " " || evt.keyCode === 32)) {
          activationState.wasElementMadeActive = _this.checkElementMadeActive(evt);
          if (activationState.wasElementMadeActive) {
            _this.animateActivation();
          }
        }
        if (!activationState.wasElementMadeActive) {
          _this.activationState = _this.defaultActivationState();
        }
      });
    };
    MDCRippleFoundation2.prototype.checkElementMadeActive = function(evt) {
      return evt !== void 0 && evt.type === "keydown" ? this.adapter.isSurfaceActive() : true;
    };
    MDCRippleFoundation2.prototype.animateActivation = function() {
      var _this = this;
      var _a2 = MDCRippleFoundation2.strings, VAR_FG_TRANSLATE_START = _a2.VAR_FG_TRANSLATE_START, VAR_FG_TRANSLATE_END = _a2.VAR_FG_TRANSLATE_END;
      var _b2 = MDCRippleFoundation2.cssClasses, FG_DEACTIVATION = _b2.FG_DEACTIVATION, FG_ACTIVATION = _b2.FG_ACTIVATION;
      var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation2.numbers.DEACTIVATION_TIMEOUT_MS;
      this.layoutInternal();
      var translateStart = "";
      var translateEnd = "";
      if (!this.adapter.isUnbounded()) {
        var _c2 = this.getFgTranslationCoordinates(), startPoint = _c2.startPoint, endPoint = _c2.endPoint;
        translateStart = startPoint.x + "px, " + startPoint.y + "px";
        translateEnd = endPoint.x + "px, " + endPoint.y + "px";
      }
      this.adapter.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
      this.adapter.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
      clearTimeout(this.activationTimer);
      clearTimeout(this.fgDeactivationRemovalTimer);
      this.rmBoundedActivationClasses();
      this.adapter.removeClass(FG_DEACTIVATION);
      this.adapter.computeBoundingRect();
      this.adapter.addClass(FG_ACTIVATION);
      this.activationTimer = setTimeout(function() {
        _this.activationTimerCallback();
      }, DEACTIVATION_TIMEOUT_MS);
    };
    MDCRippleFoundation2.prototype.getFgTranslationCoordinates = function() {
      var _a2 = this.activationState, activationEvent = _a2.activationEvent, wasActivatedByPointer = _a2.wasActivatedByPointer;
      var startPoint;
      if (wasActivatedByPointer) {
        startPoint = getNormalizedEventCoords(activationEvent, this.adapter.getWindowPageOffset(), this.adapter.computeBoundingRect());
      } else {
        startPoint = {
          x: this.frame.width / 2,
          y: this.frame.height / 2
        };
      }
      startPoint = {
        x: startPoint.x - this.initialSize / 2,
        y: startPoint.y - this.initialSize / 2
      };
      var endPoint = {
        x: this.frame.width / 2 - this.initialSize / 2,
        y: this.frame.height / 2 - this.initialSize / 2
      };
      return { startPoint, endPoint };
    };
    MDCRippleFoundation2.prototype.runDeactivationUXLogicIfReady = function() {
      var _this = this;
      var FG_DEACTIVATION = MDCRippleFoundation2.cssClasses.FG_DEACTIVATION;
      var _a2 = this.activationState, hasDeactivationUXRun = _a2.hasDeactivationUXRun, isActivated = _a2.isActivated;
      var activationHasEnded = hasDeactivationUXRun || !isActivated;
      if (activationHasEnded && this.activationAnimationHasEnded) {
        this.rmBoundedActivationClasses();
        this.adapter.addClass(FG_DEACTIVATION);
        this.fgDeactivationRemovalTimer = setTimeout(function() {
          _this.adapter.removeClass(FG_DEACTIVATION);
        }, numbers$3.FG_DEACTIVATION_MS);
      }
    };
    MDCRippleFoundation2.prototype.rmBoundedActivationClasses = function() {
      var FG_ACTIVATION = MDCRippleFoundation2.cssClasses.FG_ACTIVATION;
      this.adapter.removeClass(FG_ACTIVATION);
      this.activationAnimationHasEnded = false;
      this.adapter.computeBoundingRect();
    };
    MDCRippleFoundation2.prototype.resetActivationState = function() {
      var _this = this;
      this.previousActivationEvent = this.activationState.activationEvent;
      this.activationState = this.defaultActivationState();
      setTimeout(function() {
        return _this.previousActivationEvent = void 0;
      }, MDCRippleFoundation2.numbers.TAP_DELAY_MS);
    };
    MDCRippleFoundation2.prototype.deactivateImpl = function() {
      var _this = this;
      var activationState = this.activationState;
      if (!activationState.isActivated) {
        return;
      }
      var state = __assign({}, activationState);
      if (activationState.isProgrammatic) {
        requestAnimationFrame(function() {
          _this.animateDeactivation(state);
        });
        this.resetActivationState();
      } else {
        this.deregisterDeactivationHandlers();
        requestAnimationFrame(function() {
          _this.activationState.hasDeactivationUXRun = true;
          _this.animateDeactivation(state);
          _this.resetActivationState();
        });
      }
    };
    MDCRippleFoundation2.prototype.animateDeactivation = function(_a2) {
      var wasActivatedByPointer = _a2.wasActivatedByPointer, wasElementMadeActive = _a2.wasElementMadeActive;
      if (wasActivatedByPointer || wasElementMadeActive) {
        this.runDeactivationUXLogicIfReady();
      }
    };
    MDCRippleFoundation2.prototype.layoutInternal = function() {
      var _this = this;
      this.frame = this.adapter.computeBoundingRect();
      var maxDim = Math.max(this.frame.height, this.frame.width);
      var getBoundedRadius = function() {
        var hypotenuse = Math.sqrt(Math.pow(_this.frame.width, 2) + Math.pow(_this.frame.height, 2));
        return hypotenuse + MDCRippleFoundation2.numbers.PADDING;
      };
      this.maxRadius = this.adapter.isUnbounded() ? maxDim : getBoundedRadius();
      var initialSize = Math.floor(maxDim * MDCRippleFoundation2.numbers.INITIAL_ORIGIN_SCALE);
      if (this.adapter.isUnbounded() && initialSize % 2 !== 0) {
        this.initialSize = initialSize - 1;
      } else {
        this.initialSize = initialSize;
      }
      this.fgScale = "" + this.maxRadius / this.initialSize;
      this.updateLayoutCssVars();
    };
    MDCRippleFoundation2.prototype.updateLayoutCssVars = function() {
      var _a2 = MDCRippleFoundation2.strings, VAR_FG_SIZE = _a2.VAR_FG_SIZE, VAR_LEFT = _a2.VAR_LEFT, VAR_TOP = _a2.VAR_TOP, VAR_FG_SCALE = _a2.VAR_FG_SCALE;
      this.adapter.updateCssVariable(VAR_FG_SIZE, this.initialSize + "px");
      this.adapter.updateCssVariable(VAR_FG_SCALE, this.fgScale);
      if (this.adapter.isUnbounded()) {
        this.unboundedCoords = {
          left: Math.round(this.frame.width / 2 - this.initialSize / 2),
          top: Math.round(this.frame.height / 2 - this.initialSize / 2)
        };
        this.adapter.updateCssVariable(VAR_LEFT, this.unboundedCoords.left + "px");
        this.adapter.updateCssVariable(VAR_TOP, this.unboundedCoords.top + "px");
      }
    };
    return MDCRippleFoundation2;
  }(MDCFoundation)
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCRipple = (
  /** @class */
  function(_super) {
    __extends(MDCRipple2, _super);
    function MDCRipple2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.disabled = false;
      return _this;
    }
    MDCRipple2.attachTo = function(root, opts) {
      if (opts === void 0) {
        opts = {
          isUnbounded: void 0
        };
      }
      var ripple = new MDCRipple2(root);
      if (opts.isUnbounded !== void 0) {
        ripple.unbounded = opts.isUnbounded;
      }
      return ripple;
    };
    MDCRipple2.createAdapter = function(instance) {
      return {
        addClass: function(className) {
          return instance.root.classList.add(className);
        },
        browserSupportsCssVars: function() {
          return supportsCssVariables(window);
        },
        computeBoundingRect: function() {
          return instance.root.getBoundingClientRect();
        },
        containsEventTarget: function(target) {
          return instance.root.contains(target);
        },
        deregisterDocumentInteractionHandler: function(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive());
        },
        deregisterInteractionHandler: function(evtType, handler) {
          return instance.root.removeEventListener(evtType, handler, applyPassive());
        },
        deregisterResizeHandler: function(handler) {
          return window.removeEventListener("resize", handler);
        },
        getWindowPageOffset: function() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        },
        isSurfaceActive: function() {
          return matches(instance.root, ":active");
        },
        isSurfaceDisabled: function() {
          return Boolean(instance.disabled);
        },
        isUnbounded: function() {
          return Boolean(instance.unbounded);
        },
        registerDocumentInteractionHandler: function(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive());
        },
        registerInteractionHandler: function(evtType, handler) {
          return instance.root.addEventListener(evtType, handler, applyPassive());
        },
        registerResizeHandler: function(handler) {
          return window.addEventListener("resize", handler);
        },
        removeClass: function(className) {
          return instance.root.classList.remove(className);
        },
        updateCssVariable: function(varName, value) {
          return instance.root.style.setProperty(varName, value);
        }
      };
    };
    Object.defineProperty(MDCRipple2.prototype, "unbounded", {
      get: function() {
        return Boolean(this.isUnbounded);
      },
      set: function(unbounded) {
        this.isUnbounded = Boolean(unbounded);
        this.setUnbounded();
      },
      enumerable: false,
      configurable: true
    });
    MDCRipple2.prototype.activate = function() {
      this.foundation.activate();
    };
    MDCRipple2.prototype.deactivate = function() {
      this.foundation.deactivate();
    };
    MDCRipple2.prototype.layout = function() {
      this.foundation.layout();
    };
    MDCRipple2.prototype.getDefaultFoundation = function() {
      return new MDCRippleFoundation(MDCRipple2.createAdapter(this));
    };
    MDCRipple2.prototype.initialSyncWithDOM = function() {
      var root = this.root;
      this.isUnbounded = "mdcRippleIsUnbounded" in root.dataset;
    };
    MDCRipple2.prototype.setUnbounded = function() {
      this.foundation.setUnbounded(Boolean(this.isUnbounded));
    };
    return MDCRipple2;
  }(MDCComponent)
);
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var AnimationFrame = (
  /** @class */
  function() {
    function AnimationFrame2() {
      this.rafIDs = /* @__PURE__ */ new Map();
    }
    AnimationFrame2.prototype.request = function(key, callback) {
      var _this = this;
      this.cancel(key);
      var frameID = requestAnimationFrame(function(frame) {
        _this.rafIDs.delete(key);
        callback(frame);
      });
      this.rafIDs.set(key, frameID);
    };
    AnimationFrame2.prototype.cancel = function(key) {
      var rafID = this.rafIDs.get(key);
      if (rafID) {
        cancelAnimationFrame(rafID);
        this.rafIDs.delete(key);
      }
    };
    AnimationFrame2.prototype.cancelAll = function() {
      var _this = this;
      this.rafIDs.forEach(function(_2, key) {
        _this.cancel(key);
      });
    };
    AnimationFrame2.prototype.getQueue = function() {
      var queue = [];
      this.rafIDs.forEach(function(_2, key) {
        queue.push(key);
      });
      return queue;
    };
    return AnimationFrame2;
  }()
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$6 = {
  CLOSING: "mdc-dialog--closing",
  OPEN: "mdc-dialog--open",
  OPENING: "mdc-dialog--opening",
  SCROLLABLE: "mdc-dialog--scrollable",
  SCROLL_LOCK: "mdc-dialog-scroll-lock",
  STACKED: "mdc-dialog--stacked",
  FULLSCREEN: "mdc-dialog--fullscreen",
  // Class for showing a scroll divider on full-screen dialog header element.
  // Should only be displayed on scrollable content, when the dialog content is
  // scrolled "underneath" the header.
  SCROLL_DIVIDER_HEADER: "mdc-dialog-scroll-divider-header",
  // Class for showing a scroll divider on a full-screen dialog footer element.
  // Should only be displayed on scrolalble content, when the dialog content is
  // obscured "underneath" the footer.
  SCROLL_DIVIDER_FOOTER: "mdc-dialog-scroll-divider-footer",
  // The "surface scrim" is a scrim covering only the surface of a dialog. This
  // is used in situations where a confirmation dialog is shown over an already
  // opened full-screen dialog. On larger screen-sizes, the full-screen dialog
  // is sized as a modal and so in these situations we display a "surface scrim"
  // to prevent a "double scrim" (where the scrim from the secondary
  // confirmation dialog would overlap with the scrim from the full-screen
  // dialog).
  SURFACE_SCRIM_SHOWN: "mdc-dialog__surface-scrim--shown",
  // "Showing" animating class for the surface-scrim.
  SURFACE_SCRIM_SHOWING: "mdc-dialog__surface-scrim--showing",
  // "Hiding" animating class for the surface-scrim.
  SURFACE_SCRIM_HIDING: "mdc-dialog__surface-scrim--hiding",
  // Class to hide a dialog's scrim (used in conjunction with a surface-scrim).
  // Note that we only hide the original scrim rather than removing it entirely
  // to prevent interactions with the content behind this scrim, and to capture
  // scrim clicks.
  SCRIM_HIDDEN: "mdc-dialog__scrim--hidden"
};
var strings$7 = {
  ACTION_ATTRIBUTE: "data-mdc-dialog-action",
  BUTTON_DEFAULT_ATTRIBUTE: "data-mdc-dialog-button-default",
  BUTTON_SELECTOR: ".mdc-dialog__button",
  CLOSED_EVENT: "MDCDialog:closed",
  CLOSE_ACTION: "close",
  CLOSING_EVENT: "MDCDialog:closing",
  CONTAINER_SELECTOR: ".mdc-dialog__container",
  CONTENT_SELECTOR: ".mdc-dialog__content",
  DESTROY_ACTION: "destroy",
  INITIAL_FOCUS_ATTRIBUTE: "data-mdc-dialog-initial-focus",
  OPENED_EVENT: "MDCDialog:opened",
  OPENING_EVENT: "MDCDialog:opening",
  SCRIM_SELECTOR: ".mdc-dialog__scrim",
  SUPPRESS_DEFAULT_PRESS_SELECTOR: [
    "textarea",
    ".mdc-menu .mdc-list-item",
    ".mdc-menu .mdc-deprecated-list-item"
  ].join(", "),
  SURFACE_SELECTOR: ".mdc-dialog__surface"
};
var numbers$2 = {
  DIALOG_ANIMATION_CLOSE_TIME_MS: 75,
  DIALOG_ANIMATION_OPEN_TIME_MS: 150
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var AnimationKeys;
(function(AnimationKeys2) {
  AnimationKeys2["POLL_SCROLL_POS"] = "poll_scroll_position";
  AnimationKeys2["POLL_LAYOUT_CHANGE"] = "poll_layout_change";
})(AnimationKeys || (AnimationKeys = {}));
var MDCDialogFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCDialogFoundation2, _super);
    function MDCDialogFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCDialogFoundation2.defaultAdapter), adapter)) || this;
      _this.dialogOpen = false;
      _this.isFullscreen = false;
      _this.animationFrame = 0;
      _this.animationTimer = 0;
      _this.escapeKeyAction = strings$7.CLOSE_ACTION;
      _this.scrimClickAction = strings$7.CLOSE_ACTION;
      _this.autoStackButtons = true;
      _this.areButtonsStacked = false;
      _this.suppressDefaultPressSelector = strings$7.SUPPRESS_DEFAULT_PRESS_SELECTOR;
      _this.animFrame = new AnimationFrame();
      _this.contentScrollHandler = function() {
        _this.handleScrollEvent();
      };
      _this.windowResizeHandler = function() {
        _this.layout();
      };
      _this.windowOrientationChangeHandler = function() {
        _this.layout();
      };
      return _this;
    }
    Object.defineProperty(MDCDialogFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$6;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialogFoundation2, "strings", {
      get: function() {
        return strings$7;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialogFoundation2, "numbers", {
      get: function() {
        return numbers$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialogFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addBodyClass: function() {
            return void 0;
          },
          addClass: function() {
            return void 0;
          },
          areButtonsStacked: function() {
            return false;
          },
          clickDefaultButton: function() {
            return void 0;
          },
          eventTargetMatches: function() {
            return false;
          },
          getActionFromEvent: function() {
            return "";
          },
          getInitialFocusEl: function() {
            return null;
          },
          hasClass: function() {
            return false;
          },
          isContentScrollable: function() {
            return false;
          },
          notifyClosed: function() {
            return void 0;
          },
          notifyClosing: function() {
            return void 0;
          },
          notifyOpened: function() {
            return void 0;
          },
          notifyOpening: function() {
            return void 0;
          },
          releaseFocus: function() {
            return void 0;
          },
          removeBodyClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          reverseButtons: function() {
            return void 0;
          },
          trapFocus: function() {
            return void 0;
          },
          registerContentEventHandler: function() {
            return void 0;
          },
          deregisterContentEventHandler: function() {
            return void 0;
          },
          isScrollableContentAtTop: function() {
            return false;
          },
          isScrollableContentAtBottom: function() {
            return false;
          },
          registerWindowEventHandler: function() {
            return void 0;
          },
          deregisterWindowEventHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCDialogFoundation2.prototype.init = function() {
      if (this.adapter.hasClass(cssClasses$6.STACKED)) {
        this.setAutoStackButtons(false);
      }
      this.isFullscreen = this.adapter.hasClass(cssClasses$6.FULLSCREEN);
    };
    MDCDialogFoundation2.prototype.destroy = function() {
      if (this.animationTimer) {
        clearTimeout(this.animationTimer);
        this.handleAnimationTimerEnd();
      }
      if (this.isFullscreen) {
        this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
      }
      this.animFrame.cancelAll();
      this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
      this.adapter.deregisterWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
    };
    MDCDialogFoundation2.prototype.open = function(dialogOptions) {
      var _this = this;
      this.dialogOpen = true;
      this.adapter.notifyOpening();
      this.adapter.addClass(cssClasses$6.OPENING);
      if (this.isFullscreen) {
        this.adapter.registerContentEventHandler("scroll", this.contentScrollHandler);
      }
      if (dialogOptions && dialogOptions.isAboveFullscreenDialog) {
        this.adapter.addClass(cssClasses$6.SCRIM_HIDDEN);
      }
      this.adapter.registerWindowEventHandler("resize", this.windowResizeHandler);
      this.adapter.registerWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
      this.runNextAnimationFrame(function() {
        _this.adapter.addClass(cssClasses$6.OPEN);
        _this.adapter.addBodyClass(cssClasses$6.SCROLL_LOCK);
        _this.layout();
        _this.animationTimer = setTimeout(function() {
          _this.handleAnimationTimerEnd();
          _this.adapter.trapFocus(_this.adapter.getInitialFocusEl());
          _this.adapter.notifyOpened();
        }, numbers$2.DIALOG_ANIMATION_OPEN_TIME_MS);
      });
    };
    MDCDialogFoundation2.prototype.close = function(action) {
      var _this = this;
      if (action === void 0) {
        action = "";
      }
      if (!this.dialogOpen) {
        return;
      }
      this.dialogOpen = false;
      this.adapter.notifyClosing(action);
      this.adapter.addClass(cssClasses$6.CLOSING);
      this.adapter.removeClass(cssClasses$6.OPEN);
      this.adapter.removeBodyClass(cssClasses$6.SCROLL_LOCK);
      if (this.isFullscreen) {
        this.adapter.deregisterContentEventHandler("scroll", this.contentScrollHandler);
      }
      this.adapter.deregisterWindowEventHandler("resize", this.windowResizeHandler);
      this.adapter.deregisterWindowEventHandler("orientationchange", this.windowOrientationChangeHandler);
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = 0;
      clearTimeout(this.animationTimer);
      this.animationTimer = setTimeout(function() {
        _this.adapter.releaseFocus();
        _this.handleAnimationTimerEnd();
        _this.adapter.notifyClosed(action);
      }, numbers$2.DIALOG_ANIMATION_CLOSE_TIME_MS);
    };
    MDCDialogFoundation2.prototype.showSurfaceScrim = function() {
      var _this = this;
      this.adapter.addClass(cssClasses$6.SURFACE_SCRIM_SHOWING);
      this.runNextAnimationFrame(function() {
        _this.adapter.addClass(cssClasses$6.SURFACE_SCRIM_SHOWN);
      });
    };
    MDCDialogFoundation2.prototype.hideSurfaceScrim = function() {
      this.adapter.removeClass(cssClasses$6.SURFACE_SCRIM_SHOWN);
      this.adapter.addClass(cssClasses$6.SURFACE_SCRIM_HIDING);
    };
    MDCDialogFoundation2.prototype.handleSurfaceScrimTransitionEnd = function() {
      this.adapter.removeClass(cssClasses$6.SURFACE_SCRIM_HIDING);
      this.adapter.removeClass(cssClasses$6.SURFACE_SCRIM_SHOWING);
    };
    MDCDialogFoundation2.prototype.isOpen = function() {
      return this.dialogOpen;
    };
    MDCDialogFoundation2.prototype.getEscapeKeyAction = function() {
      return this.escapeKeyAction;
    };
    MDCDialogFoundation2.prototype.setEscapeKeyAction = function(action) {
      this.escapeKeyAction = action;
    };
    MDCDialogFoundation2.prototype.getScrimClickAction = function() {
      return this.scrimClickAction;
    };
    MDCDialogFoundation2.prototype.setScrimClickAction = function(action) {
      this.scrimClickAction = action;
    };
    MDCDialogFoundation2.prototype.getAutoStackButtons = function() {
      return this.autoStackButtons;
    };
    MDCDialogFoundation2.prototype.setAutoStackButtons = function(autoStack) {
      this.autoStackButtons = autoStack;
    };
    MDCDialogFoundation2.prototype.getSuppressDefaultPressSelector = function() {
      return this.suppressDefaultPressSelector;
    };
    MDCDialogFoundation2.prototype.setSuppressDefaultPressSelector = function(selector) {
      this.suppressDefaultPressSelector = selector;
    };
    MDCDialogFoundation2.prototype.layout = function() {
      var _this = this;
      this.animFrame.request(AnimationKeys.POLL_LAYOUT_CHANGE, function() {
        _this.layoutInternal();
      });
    };
    MDCDialogFoundation2.prototype.handleClick = function(evt) {
      var isScrim = this.adapter.eventTargetMatches(evt.target, strings$7.SCRIM_SELECTOR);
      if (isScrim && this.scrimClickAction !== "") {
        this.close(this.scrimClickAction);
      } else {
        var action = this.adapter.getActionFromEvent(evt);
        if (action) {
          this.close(action);
        }
      }
    };
    MDCDialogFoundation2.prototype.handleKeydown = function(evt) {
      var isEnter = evt.key === "Enter" || evt.keyCode === 13;
      if (!isEnter) {
        return;
      }
      var action = this.adapter.getActionFromEvent(evt);
      if (action) {
        return;
      }
      var target = evt.composedPath ? evt.composedPath()[0] : evt.target;
      var isDefault = this.suppressDefaultPressSelector ? !this.adapter.eventTargetMatches(target, this.suppressDefaultPressSelector) : true;
      if (isEnter && isDefault) {
        this.adapter.clickDefaultButton();
      }
    };
    MDCDialogFoundation2.prototype.handleDocumentKeydown = function(evt) {
      var isEscape = evt.key === "Escape" || evt.keyCode === 27;
      if (isEscape && this.escapeKeyAction !== "") {
        this.close(this.escapeKeyAction);
      }
    };
    MDCDialogFoundation2.prototype.handleScrollEvent = function() {
      var _this = this;
      this.animFrame.request(AnimationKeys.POLL_SCROLL_POS, function() {
        _this.toggleScrollDividerHeader();
        _this.toggleScrollDividerFooter();
      });
    };
    MDCDialogFoundation2.prototype.layoutInternal = function() {
      if (this.autoStackButtons) {
        this.detectStackedButtons();
      }
      this.toggleScrollableClasses();
    };
    MDCDialogFoundation2.prototype.handleAnimationTimerEnd = function() {
      this.animationTimer = 0;
      this.adapter.removeClass(cssClasses$6.OPENING);
      this.adapter.removeClass(cssClasses$6.CLOSING);
    };
    MDCDialogFoundation2.prototype.runNextAnimationFrame = function(callback) {
      var _this = this;
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = requestAnimationFrame(function() {
        _this.animationFrame = 0;
        clearTimeout(_this.animationTimer);
        _this.animationTimer = setTimeout(callback, 0);
      });
    };
    MDCDialogFoundation2.prototype.detectStackedButtons = function() {
      this.adapter.removeClass(cssClasses$6.STACKED);
      var areButtonsStacked = this.adapter.areButtonsStacked();
      if (areButtonsStacked) {
        this.adapter.addClass(cssClasses$6.STACKED);
      }
      if (areButtonsStacked !== this.areButtonsStacked) {
        this.adapter.reverseButtons();
        this.areButtonsStacked = areButtonsStacked;
      }
    };
    MDCDialogFoundation2.prototype.toggleScrollableClasses = function() {
      this.adapter.removeClass(cssClasses$6.SCROLLABLE);
      if (this.adapter.isContentScrollable()) {
        this.adapter.addClass(cssClasses$6.SCROLLABLE);
        if (this.isFullscreen) {
          this.toggleScrollDividerHeader();
          this.toggleScrollDividerFooter();
        }
      }
    };
    MDCDialogFoundation2.prototype.toggleScrollDividerHeader = function() {
      if (!this.adapter.isScrollableContentAtTop()) {
        this.adapter.addClass(cssClasses$6.SCROLL_DIVIDER_HEADER);
      } else if (this.adapter.hasClass(cssClasses$6.SCROLL_DIVIDER_HEADER)) {
        this.adapter.removeClass(cssClasses$6.SCROLL_DIVIDER_HEADER);
      }
    };
    MDCDialogFoundation2.prototype.toggleScrollDividerFooter = function() {
      if (!this.adapter.isScrollableContentAtBottom()) {
        this.adapter.addClass(cssClasses$6.SCROLL_DIVIDER_FOOTER);
      } else if (this.adapter.hasClass(cssClasses$6.SCROLL_DIVIDER_FOOTER)) {
        this.adapter.removeClass(cssClasses$6.SCROLL_DIVIDER_FOOTER);
      }
    };
    return MDCDialogFoundation2;
  }(MDCFoundation)
);
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$6 = MDCDialogFoundation.strings;
var MDCDialog = (
  /** @class */
  function(_super) {
    __extends(MDCDialog2, _super);
    function MDCDialog2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCDialog2.prototype, "isOpen", {
      get: function() {
        return this.foundation.isOpen();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialog2.prototype, "escapeKeyAction", {
      get: function() {
        return this.foundation.getEscapeKeyAction();
      },
      set: function(action) {
        this.foundation.setEscapeKeyAction(action);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialog2.prototype, "scrimClickAction", {
      get: function() {
        return this.foundation.getScrimClickAction();
      },
      set: function(action) {
        this.foundation.setScrimClickAction(action);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDialog2.prototype, "autoStackButtons", {
      get: function() {
        return this.foundation.getAutoStackButtons();
      },
      set: function(autoStack) {
        this.foundation.setAutoStackButtons(autoStack);
      },
      enumerable: false,
      configurable: true
    });
    MDCDialog2.attachTo = function(root) {
      return new MDCDialog2(root);
    };
    MDCDialog2.prototype.initialize = function(focusTrapFactory) {
      var e_1, _a2;
      if (focusTrapFactory === void 0) {
        focusTrapFactory = function(el, focusOptions) {
          return new FocusTrap2(el, focusOptions);
        };
      }
      var container = this.root.querySelector(strings$6.CONTAINER_SELECTOR);
      if (!container) {
        throw new Error("Dialog component requires a " + strings$6.CONTAINER_SELECTOR + " container element");
      }
      this.container = container;
      this.content = this.root.querySelector(strings$6.CONTENT_SELECTOR);
      this.buttons = [].slice.call(this.root.querySelectorAll(strings$6.BUTTON_SELECTOR));
      this.defaultButton = this.root.querySelector("[" + strings$6.BUTTON_DEFAULT_ATTRIBUTE + "]");
      this.focusTrapFactory = focusTrapFactory;
      this.buttonRipples = [];
      try {
        for (var _b2 = __values(this.buttons), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
          var buttonEl = _c2.value;
          this.buttonRipples.push(new MDCRipple(buttonEl));
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c2 && !_c2.done && (_a2 = _b2.return)) _a2.call(_b2);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    };
    MDCDialog2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.focusTrap = createFocusTrapInstance$1(this.container, this.focusTrapFactory, this.getInitialFocusEl() || void 0);
      this.handleClick = this.foundation.handleClick.bind(this.foundation);
      this.handleKeydown = this.foundation.handleKeydown.bind(this.foundation);
      this.handleDocumentKeydown = this.foundation.handleDocumentKeydown.bind(this.foundation);
      this.handleOpening = function() {
        document.addEventListener("keydown", _this.handleDocumentKeydown);
      };
      this.handleClosing = function() {
        document.removeEventListener("keydown", _this.handleDocumentKeydown);
      };
      this.listen("click", this.handleClick);
      this.listen("keydown", this.handleKeydown);
      this.listen(strings$6.OPENING_EVENT, this.handleOpening);
      this.listen(strings$6.CLOSING_EVENT, this.handleClosing);
    };
    MDCDialog2.prototype.destroy = function() {
      this.unlisten("click", this.handleClick);
      this.unlisten("keydown", this.handleKeydown);
      this.unlisten(strings$6.OPENING_EVENT, this.handleOpening);
      this.unlisten(strings$6.CLOSING_EVENT, this.handleClosing);
      this.handleClosing();
      this.buttonRipples.forEach(function(ripple) {
        ripple.destroy();
      });
      _super.prototype.destroy.call(this);
    };
    MDCDialog2.prototype.layout = function() {
      this.foundation.layout();
    };
    MDCDialog2.prototype.open = function() {
      this.foundation.open();
    };
    MDCDialog2.prototype.close = function(action) {
      if (action === void 0) {
        action = "";
      }
      this.foundation.close(action);
    };
    MDCDialog2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addBodyClass: function(className) {
          return document.body.classList.add(className);
        },
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        areButtonsStacked: function() {
          return areTopsMisaligned(_this.buttons);
        },
        clickDefaultButton: function() {
          if (_this.defaultButton && !_this.defaultButton.disabled) {
            _this.defaultButton.click();
          }
        },
        eventTargetMatches: function(target, selector) {
          return target ? matches(target, selector) : false;
        },
        getActionFromEvent: function(evt) {
          if (!evt.target) {
            return "";
          }
          var element = closest(evt.target, "[" + strings$6.ACTION_ATTRIBUTE + "]");
          return element && element.getAttribute(strings$6.ACTION_ATTRIBUTE);
        },
        getInitialFocusEl: function() {
          return _this.getInitialFocusEl();
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        isContentScrollable: function() {
          return isScrollable(_this.content);
        },
        notifyClosed: function(action) {
          return _this.emit(strings$6.CLOSED_EVENT, action ? { action } : {});
        },
        notifyClosing: function(action) {
          return _this.emit(strings$6.CLOSING_EVENT, action ? { action } : {});
        },
        notifyOpened: function() {
          return _this.emit(strings$6.OPENED_EVENT, {});
        },
        notifyOpening: function() {
          return _this.emit(strings$6.OPENING_EVENT, {});
        },
        releaseFocus: function() {
          _this.focusTrap.releaseFocus();
        },
        removeBodyClass: function(className) {
          return document.body.classList.remove(className);
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        reverseButtons: function() {
          _this.buttons.reverse();
          _this.buttons.forEach(function(button) {
            button.parentElement.appendChild(button);
          });
        },
        trapFocus: function() {
          _this.focusTrap.trapFocus();
        },
        registerContentEventHandler: function(evt, handler) {
          if (_this.content instanceof HTMLElement) {
            _this.content.addEventListener(evt, handler);
          }
        },
        deregisterContentEventHandler: function(evt, handler) {
          if (_this.content instanceof HTMLElement) {
            _this.content.removeEventListener(evt, handler);
          }
        },
        isScrollableContentAtTop: function() {
          return isScrollAtTop(_this.content);
        },
        isScrollableContentAtBottom: function() {
          return isScrollAtBottom(_this.content);
        },
        registerWindowEventHandler: function(evt, handler) {
          window.addEventListener(evt, handler);
        },
        deregisterWindowEventHandler: function(evt, handler) {
          window.removeEventListener(evt, handler);
        }
      };
      return new MDCDialogFoundation(adapter);
    };
    MDCDialog2.prototype.getInitialFocusEl = function() {
      return this.root.querySelector("[" + strings$6.INITIAL_FOCUS_ATTRIBUTE + "]");
    };
    return MDCDialog2;
  }(MDCComponent)
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function createFocusTrapInstance(surfaceEl, focusTrapFactory) {
  return focusTrapFactory(surfaceEl, {
    // Component handles focusing on active nav item.
    skipInitialFocus: true
  });
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var _a, _b;
var cssClasses$5 = {
  LIST_ITEM_ACTIVATED_CLASS: "mdc-list-item--activated",
  LIST_ITEM_CLASS: "mdc-list-item",
  LIST_ITEM_DISABLED_CLASS: "mdc-list-item--disabled",
  LIST_ITEM_SELECTED_CLASS: "mdc-list-item--selected",
  LIST_ITEM_TEXT_CLASS: "mdc-list-item__text",
  LIST_ITEM_PRIMARY_TEXT_CLASS: "mdc-list-item__primary-text",
  ROOT: "mdc-list"
};
var evolutionClassNameMap = (_a = {}, _a["" + cssClasses$5.LIST_ITEM_ACTIVATED_CLASS] = "mdc-list-item--activated", _a["" + cssClasses$5.LIST_ITEM_CLASS] = "mdc-list-item", _a["" + cssClasses$5.LIST_ITEM_DISABLED_CLASS] = "mdc-list-item--disabled", _a["" + cssClasses$5.LIST_ITEM_SELECTED_CLASS] = "mdc-list-item--selected", _a["" + cssClasses$5.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-list-item__primary-text", _a["" + cssClasses$5.ROOT] = "mdc-list", _a);
var deprecatedClassNameMap = (_b = {}, _b["" + cssClasses$5.LIST_ITEM_ACTIVATED_CLASS] = "mdc-deprecated-list-item--activated", _b["" + cssClasses$5.LIST_ITEM_CLASS] = "mdc-deprecated-list-item", _b["" + cssClasses$5.LIST_ITEM_DISABLED_CLASS] = "mdc-deprecated-list-item--disabled", _b["" + cssClasses$5.LIST_ITEM_SELECTED_CLASS] = "mdc-deprecated-list-item--selected", _b["" + cssClasses$5.LIST_ITEM_TEXT_CLASS] = "mdc-deprecated-list-item__text", _b["" + cssClasses$5.LIST_ITEM_PRIMARY_TEXT_CLASS] = "mdc-deprecated-list-item__primary-text", _b["" + cssClasses$5.ROOT] = "mdc-deprecated-list", _b);
var strings$5 = {
  ACTION_EVENT: "MDCList:action",
  SELECTION_CHANGE_EVENT: "MDCList:selectionChange",
  ARIA_CHECKED: "aria-checked",
  ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
  ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
  ARIA_CURRENT: "aria-current",
  ARIA_DISABLED: "aria-disabled",
  ARIA_ORIENTATION: "aria-orientation",
  ARIA_ORIENTATION_HORIZONTAL: "horizontal",
  ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
  ARIA_SELECTED: "aria-selected",
  ARIA_INTERACTIVE_ROLES_SELECTOR: '[role="listbox"], [role="menu"]',
  ARIA_MULTI_SELECTABLE_SELECTOR: '[aria-multiselectable="true"]',
  CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"], input[type="radio"]',
  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
  CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: "\n    ." + cssClasses$5.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$5.LIST_ITEM_CLASS + " a,\n    ." + deprecatedClassNameMap[cssClasses$5.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$5.LIST_ITEM_CLASS] + " a\n  ",
  DEPRECATED_SELECTOR: ".mdc-deprecated-list",
  FOCUSABLE_CHILD_ELEMENTS: "\n    ." + cssClasses$5.LIST_ITEM_CLASS + " button:not(:disabled),\n    ." + cssClasses$5.LIST_ITEM_CLASS + " a,\n    ." + cssClasses$5.LIST_ITEM_CLASS + ' input[type="radio"]:not(:disabled),\n    .' + cssClasses$5.LIST_ITEM_CLASS + ' input[type="checkbox"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses$5.LIST_ITEM_CLASS] + " button:not(:disabled),\n    ." + deprecatedClassNameMap[cssClasses$5.LIST_ITEM_CLASS] + " a,\n    ." + deprecatedClassNameMap[cssClasses$5.LIST_ITEM_CLASS] + ' input[type="radio"]:not(:disabled),\n    .' + deprecatedClassNameMap[cssClasses$5.LIST_ITEM_CLASS] + ' input[type="checkbox"]:not(:disabled)\n  ',
  RADIO_SELECTOR: 'input[type="radio"]',
  SELECTED_ITEM_SELECTOR: '[aria-selected="true"], [aria-current="true"]'
};
var numbers$1 = {
  UNSET_INDEX: -1,
  TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS: 300
};
var evolutionAttribute = "evolution";
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var KEY = {
  UNKNOWN: "Unknown",
  BACKSPACE: "Backspace",
  ENTER: "Enter",
  SPACEBAR: "Spacebar",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  END: "End",
  HOME: "Home",
  ARROW_LEFT: "ArrowLeft",
  ARROW_UP: "ArrowUp",
  ARROW_RIGHT: "ArrowRight",
  ARROW_DOWN: "ArrowDown",
  DELETE: "Delete",
  ESCAPE: "Escape",
  TAB: "Tab"
};
var normalizedKeys = /* @__PURE__ */ new Set();
normalizedKeys.add(KEY.BACKSPACE);
normalizedKeys.add(KEY.ENTER);
normalizedKeys.add(KEY.SPACEBAR);
normalizedKeys.add(KEY.PAGE_UP);
normalizedKeys.add(KEY.PAGE_DOWN);
normalizedKeys.add(KEY.END);
normalizedKeys.add(KEY.HOME);
normalizedKeys.add(KEY.ARROW_LEFT);
normalizedKeys.add(KEY.ARROW_UP);
normalizedKeys.add(KEY.ARROW_RIGHT);
normalizedKeys.add(KEY.ARROW_DOWN);
normalizedKeys.add(KEY.DELETE);
normalizedKeys.add(KEY.ESCAPE);
normalizedKeys.add(KEY.TAB);
var KEY_CODE = {
  BACKSPACE: 8,
  ENTER: 13,
  SPACEBAR: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  ARROW_LEFT: 37,
  ARROW_UP: 38,
  ARROW_RIGHT: 39,
  ARROW_DOWN: 40,
  DELETE: 46,
  ESCAPE: 27,
  TAB: 9
};
var mappedKeyCodes = /* @__PURE__ */ new Map();
mappedKeyCodes.set(KEY_CODE.BACKSPACE, KEY.BACKSPACE);
mappedKeyCodes.set(KEY_CODE.ENTER, KEY.ENTER);
mappedKeyCodes.set(KEY_CODE.SPACEBAR, KEY.SPACEBAR);
mappedKeyCodes.set(KEY_CODE.PAGE_UP, KEY.PAGE_UP);
mappedKeyCodes.set(KEY_CODE.PAGE_DOWN, KEY.PAGE_DOWN);
mappedKeyCodes.set(KEY_CODE.END, KEY.END);
mappedKeyCodes.set(KEY_CODE.HOME, KEY.HOME);
mappedKeyCodes.set(KEY_CODE.ARROW_LEFT, KEY.ARROW_LEFT);
mappedKeyCodes.set(KEY_CODE.ARROW_UP, KEY.ARROW_UP);
mappedKeyCodes.set(KEY_CODE.ARROW_RIGHT, KEY.ARROW_RIGHT);
mappedKeyCodes.set(KEY_CODE.ARROW_DOWN, KEY.ARROW_DOWN);
mappedKeyCodes.set(KEY_CODE.DELETE, KEY.DELETE);
mappedKeyCodes.set(KEY_CODE.ESCAPE, KEY.ESCAPE);
mappedKeyCodes.set(KEY_CODE.TAB, KEY.TAB);
var navigationKeys = /* @__PURE__ */ new Set();
navigationKeys.add(KEY.PAGE_UP);
navigationKeys.add(KEY.PAGE_DOWN);
navigationKeys.add(KEY.END);
navigationKeys.add(KEY.HOME);
navigationKeys.add(KEY.ARROW_LEFT);
navigationKeys.add(KEY.ARROW_UP);
navigationKeys.add(KEY.ARROW_RIGHT);
navigationKeys.add(KEY.ARROW_DOWN);
function normalizeKey(evt) {
  var key = evt.key;
  if (normalizedKeys.has(key)) {
    return key;
  }
  var mappedKey = mappedKeyCodes.get(evt.keyCode);
  if (mappedKey) {
    return mappedKey;
  }
  return KEY.UNKNOWN;
}
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var ELEMENTS_KEY_ALLOWED_IN = ["input", "button", "textarea", "select"];
var preventDefaultEvent = function(evt) {
  var target = evt.target;
  if (!target) {
    return;
  }
  var tagName = ("" + target.tagName).toLowerCase();
  if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
    evt.preventDefault();
  }
};
/**
 * @license
 * Copyright 2020 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function initState() {
  var state = {
    bufferClearTimeout: 0,
    currentFirstChar: "",
    sortedIndexCursor: 0,
    typeaheadBuffer: ""
  };
  return state;
}
function initSortedIndex(listItemCount, getPrimaryTextByItemIndex) {
  var sortedIndexByFirstChar = /* @__PURE__ */ new Map();
  for (var i3 = 0; i3 < listItemCount; i3++) {
    var primaryText = getPrimaryTextByItemIndex(i3).trim();
    if (!primaryText) {
      continue;
    }
    var firstChar = primaryText[0].toLowerCase();
    if (!sortedIndexByFirstChar.has(firstChar)) {
      sortedIndexByFirstChar.set(firstChar, []);
    }
    sortedIndexByFirstChar.get(firstChar).push({ text: primaryText.toLowerCase(), index: i3 });
  }
  sortedIndexByFirstChar.forEach(function(values) {
    values.sort(function(first, second) {
      return first.index - second.index;
    });
  });
  return sortedIndexByFirstChar;
}
function matchItem(opts, state) {
  var nextChar2 = opts.nextChar, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, focusedItemIndex = opts.focusedItemIndex, skipFocus = opts.skipFocus, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
  clearTimeout(state.bufferClearTimeout);
  state.bufferClearTimeout = setTimeout(function() {
    clearBuffer(state);
  }, numbers$1.TYPEAHEAD_BUFFER_CLEAR_TIMEOUT_MS);
  state.typeaheadBuffer = state.typeaheadBuffer + nextChar2;
  var index;
  if (state.typeaheadBuffer.length === 1) {
    index = matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state);
  } else {
    index = matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state);
  }
  if (index !== -1 && !skipFocus) {
    focusItemAtIndex(index);
  }
  return index;
}
function matchFirstChar(sortedIndexByFirstChar, focusedItemIndex, isItemAtIndexDisabled, state) {
  var firstChar = state.typeaheadBuffer[0];
  var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
  if (!itemsMatchingFirstChar) {
    return -1;
  }
  if (firstChar === state.currentFirstChar && itemsMatchingFirstChar[state.sortedIndexCursor].index === focusedItemIndex) {
    state.sortedIndexCursor = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
    var newIndex = itemsMatchingFirstChar[state.sortedIndexCursor].index;
    if (!isItemAtIndexDisabled(newIndex)) {
      return newIndex;
    }
  }
  state.currentFirstChar = firstChar;
  var newCursorPosition = -1;
  var cursorPosition;
  for (cursorPosition = 0; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
    if (!isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
      newCursorPosition = cursorPosition;
      break;
    }
  }
  for (; cursorPosition < itemsMatchingFirstChar.length; cursorPosition++) {
    if (itemsMatchingFirstChar[cursorPosition].index > focusedItemIndex && !isItemAtIndexDisabled(itemsMatchingFirstChar[cursorPosition].index)) {
      newCursorPosition = cursorPosition;
      break;
    }
  }
  if (newCursorPosition !== -1) {
    state.sortedIndexCursor = newCursorPosition;
    return itemsMatchingFirstChar[state.sortedIndexCursor].index;
  }
  return -1;
}
function matchAllChars(sortedIndexByFirstChar, isItemAtIndexDisabled, state) {
  var firstChar = state.typeaheadBuffer[0];
  var itemsMatchingFirstChar = sortedIndexByFirstChar.get(firstChar);
  if (!itemsMatchingFirstChar) {
    return -1;
  }
  var startingItem = itemsMatchingFirstChar[state.sortedIndexCursor];
  if (startingItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0 && !isItemAtIndexDisabled(startingItem.index)) {
    return startingItem.index;
  }
  var cursorPosition = (state.sortedIndexCursor + 1) % itemsMatchingFirstChar.length;
  var nextCursorPosition = -1;
  while (cursorPosition !== state.sortedIndexCursor) {
    var currentItem = itemsMatchingFirstChar[cursorPosition];
    var matches2 = currentItem.text.lastIndexOf(state.typeaheadBuffer, 0) === 0;
    var isEnabled = !isItemAtIndexDisabled(currentItem.index);
    if (matches2 && isEnabled) {
      nextCursorPosition = cursorPosition;
      break;
    }
    cursorPosition = (cursorPosition + 1) % itemsMatchingFirstChar.length;
  }
  if (nextCursorPosition !== -1) {
    state.sortedIndexCursor = nextCursorPosition;
    return itemsMatchingFirstChar[state.sortedIndexCursor].index;
  }
  return -1;
}
function isTypingInProgress(state) {
  return state.typeaheadBuffer.length > 0;
}
function clearBuffer(state) {
  state.typeaheadBuffer = "";
}
function handleKeydown(opts, state) {
  var event = opts.event, isTargetListItem = opts.isTargetListItem, focusedItemIndex = opts.focusedItemIndex, focusItemAtIndex = opts.focusItemAtIndex, sortedIndexByFirstChar = opts.sortedIndexByFirstChar, isItemAtIndexDisabled = opts.isItemAtIndexDisabled;
  var isArrowLeft = normalizeKey(event) === "ArrowLeft";
  var isArrowUp = normalizeKey(event) === "ArrowUp";
  var isArrowRight = normalizeKey(event) === "ArrowRight";
  var isArrowDown = normalizeKey(event) === "ArrowDown";
  var isHome = normalizeKey(event) === "Home";
  var isEnd = normalizeKey(event) === "End";
  var isEnter = normalizeKey(event) === "Enter";
  var isSpace = normalizeKey(event) === "Spacebar";
  if (event.altKey || event.ctrlKey || event.metaKey || isArrowLeft || isArrowUp || isArrowRight || isArrowDown || isHome || isEnd || isEnter) {
    return -1;
  }
  var isCharacterKey = !isSpace && event.key.length === 1;
  if (isCharacterKey) {
    preventDefaultEvent(event);
    var matchItemOpts = {
      focusItemAtIndex,
      focusedItemIndex,
      nextChar: event.key.toLowerCase(),
      sortedIndexByFirstChar,
      skipFocus: false,
      isItemAtIndexDisabled
    };
    return matchItem(matchItemOpts, state);
  }
  if (!isSpace) {
    return -1;
  }
  if (isTargetListItem) {
    preventDefaultEvent(event);
  }
  var typeaheadOnListItem = isTargetListItem && isTypingInProgress(state);
  if (typeaheadOnListItem) {
    var matchItemOpts = {
      focusItemAtIndex,
      focusedItemIndex,
      nextChar: " ",
      sortedIndexByFirstChar,
      skipFocus: false,
      isItemAtIndexDisabled
    };
    return matchItem(matchItemOpts, state);
  }
  return -1;
}
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
function isNumberArray(selectedIndex) {
  return selectedIndex instanceof Array;
}
var handledModifierKeys = ["Alt", "Control", "Meta", "Shift"];
function createModifierChecker(event) {
  var eventModifiers = new Set(event ? handledModifierKeys.filter(function(m2) {
    return event.getModifierState(m2);
  }) : []);
  return function(modifiers) {
    return modifiers.every(function(m2) {
      return eventModifiers.has(m2);
    }) && modifiers.length === eventModifiers.size;
  };
}
var MDCListFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCListFoundation2, _super);
    function MDCListFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCListFoundation2.defaultAdapter), adapter)) || this;
      _this.wrapFocus = false;
      _this.isVertical = true;
      _this.isSingleSelectionList = false;
      _this.areDisabledItemsFocusable = true;
      _this.selectedIndex = numbers$1.UNSET_INDEX;
      _this.focusedItemIndex = numbers$1.UNSET_INDEX;
      _this.useActivatedClass = false;
      _this.useSelectedAttr = false;
      _this.ariaCurrentAttrValue = null;
      _this.isCheckboxList = false;
      _this.isRadioList = false;
      _this.lastSelectedIndex = null;
      _this.hasTypeahead = false;
      _this.typeaheadState = initState();
      _this.sortedIndexByFirstChar = /* @__PURE__ */ new Map();
      return _this;
    }
    Object.defineProperty(MDCListFoundation2, "strings", {
      get: function() {
        return strings$5;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$5;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "numbers", {
      get: function() {
        return numbers$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCListFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClassForElementIndex: function() {
            return void 0;
          },
          focusItemAtIndex: function() {
            return void 0;
          },
          getAttributeForElementIndex: function() {
            return null;
          },
          getFocusedElementIndex: function() {
            return 0;
          },
          getListItemCount: function() {
            return 0;
          },
          hasCheckboxAtIndex: function() {
            return false;
          },
          hasRadioAtIndex: function() {
            return false;
          },
          isCheckboxCheckedAtIndex: function() {
            return false;
          },
          isFocusInsideList: function() {
            return false;
          },
          isRootFocused: function() {
            return false;
          },
          listItemAtIndexHasClass: function() {
            return false;
          },
          notifyAction: function() {
            return void 0;
          },
          notifySelectionChange: function() {
          },
          removeClassForElementIndex: function() {
            return void 0;
          },
          setAttributeForElementIndex: function() {
            return void 0;
          },
          setCheckedCheckboxOrRadioAtIndex: function() {
            return void 0;
          },
          setTabIndexForListItemChildren: function() {
            return void 0;
          },
          getPrimaryTextAtIndex: function() {
            return "";
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCListFoundation2.prototype.layout = function() {
      if (this.adapter.getListItemCount() === 0) {
        return;
      }
      if (this.adapter.hasCheckboxAtIndex(0)) {
        this.isCheckboxList = true;
      } else if (this.adapter.hasRadioAtIndex(0)) {
        this.isRadioList = true;
      } else {
        this.maybeInitializeSingleSelection();
      }
      if (this.hasTypeahead) {
        this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
      }
    };
    MDCListFoundation2.prototype.getFocusedItemIndex = function() {
      return this.focusedItemIndex;
    };
    MDCListFoundation2.prototype.setWrapFocus = function(value) {
      this.wrapFocus = value;
    };
    MDCListFoundation2.prototype.setVerticalOrientation = function(value) {
      this.isVertical = value;
    };
    MDCListFoundation2.prototype.setSingleSelection = function(value) {
      this.isSingleSelectionList = value;
      if (value) {
        this.maybeInitializeSingleSelection();
        this.selectedIndex = this.getSelectedIndexFromDOM();
      }
    };
    MDCListFoundation2.prototype.setDisabledItemsFocusable = function(value) {
      this.areDisabledItemsFocusable = value;
    };
    MDCListFoundation2.prototype.maybeInitializeSingleSelection = function() {
      var selectedItemIndex = this.getSelectedIndexFromDOM();
      if (selectedItemIndex === numbers$1.UNSET_INDEX)
        return;
      var hasActivatedClass = this.adapter.listItemAtIndexHasClass(selectedItemIndex, cssClasses$5.LIST_ITEM_ACTIVATED_CLASS);
      if (hasActivatedClass) {
        this.setUseActivatedClass(true);
      }
      this.isSingleSelectionList = true;
      this.selectedIndex = selectedItemIndex;
    };
    MDCListFoundation2.prototype.getSelectedIndexFromDOM = function() {
      var selectedIndex = numbers$1.UNSET_INDEX;
      var listItemsCount = this.adapter.getListItemCount();
      for (var i3 = 0; i3 < listItemsCount; i3++) {
        var hasSelectedClass = this.adapter.listItemAtIndexHasClass(i3, cssClasses$5.LIST_ITEM_SELECTED_CLASS);
        var hasActivatedClass = this.adapter.listItemAtIndexHasClass(i3, cssClasses$5.LIST_ITEM_ACTIVATED_CLASS);
        if (!(hasSelectedClass || hasActivatedClass)) {
          continue;
        }
        selectedIndex = i3;
        break;
      }
      return selectedIndex;
    };
    MDCListFoundation2.prototype.setHasTypeahead = function(hasTypeahead) {
      this.hasTypeahead = hasTypeahead;
      if (hasTypeahead) {
        this.sortedIndexByFirstChar = this.typeaheadInitSortedIndex();
      }
    };
    MDCListFoundation2.prototype.isTypeaheadInProgress = function() {
      return this.hasTypeahead && isTypingInProgress(this.typeaheadState);
    };
    MDCListFoundation2.prototype.setUseActivatedClass = function(useActivated) {
      this.useActivatedClass = useActivated;
    };
    MDCListFoundation2.prototype.setUseSelectedAttribute = function(useSelected) {
      this.useSelectedAttr = useSelected;
    };
    MDCListFoundation2.prototype.getSelectedIndex = function() {
      return this.selectedIndex;
    };
    MDCListFoundation2.prototype.setSelectedIndex = function(index, options) {
      if (options === void 0) {
        options = {};
      }
      if (!this.isIndexValid(index)) {
        return;
      }
      if (this.isCheckboxList) {
        this.setCheckboxAtIndex(index, options);
      } else if (this.isRadioList) {
        this.setRadioAtIndex(index, options);
      } else {
        this.setSingleSelectionAtIndex(index, options);
      }
    };
    MDCListFoundation2.prototype.handleFocusIn = function(listItemIndex) {
      if (listItemIndex >= 0) {
        this.focusedItemIndex = listItemIndex;
        this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "0");
        this.adapter.setTabIndexForListItemChildren(listItemIndex, "0");
      }
    };
    MDCListFoundation2.prototype.handleFocusOut = function(listItemIndex) {
      var _this = this;
      if (listItemIndex >= 0) {
        this.adapter.setAttributeForElementIndex(listItemIndex, "tabindex", "-1");
        this.adapter.setTabIndexForListItemChildren(listItemIndex, "-1");
      }
      setTimeout(function() {
        if (!_this.adapter.isFocusInsideList()) {
          _this.setTabindexToFirstSelectedOrFocusedItem();
        }
      }, 0);
    };
    MDCListFoundation2.prototype.isIndexDisabled = function(index) {
      return this.adapter.listItemAtIndexHasClass(index, cssClasses$5.LIST_ITEM_DISABLED_CLASS);
    };
    MDCListFoundation2.prototype.handleKeydown = function(event, isRootListItem, listItemIndex) {
      var _this = this;
      var _a2;
      var isArrowLeft = normalizeKey(event) === "ArrowLeft";
      var isArrowUp = normalizeKey(event) === "ArrowUp";
      var isArrowRight = normalizeKey(event) === "ArrowRight";
      var isArrowDown = normalizeKey(event) === "ArrowDown";
      var isHome = normalizeKey(event) === "Home";
      var isEnd = normalizeKey(event) === "End";
      var isEnter = normalizeKey(event) === "Enter";
      var isSpace = normalizeKey(event) === "Spacebar";
      var isForward = this.isVertical && isArrowDown || !this.isVertical && isArrowRight;
      var isBack = this.isVertical && isArrowUp || !this.isVertical && isArrowLeft;
      var isLetterA = event.key === "A" || event.key === "a";
      var eventHasModifiers = createModifierChecker(event);
      if (this.adapter.isRootFocused()) {
        if ((isBack || isEnd) && eventHasModifiers([])) {
          event.preventDefault();
          this.focusLastElement();
        } else if ((isForward || isHome) && eventHasModifiers([])) {
          event.preventDefault();
          this.focusFirstElement();
        } else if (isBack && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
          event.preventDefault();
          var focusedIndex = this.focusLastElement();
          if (focusedIndex !== -1) {
            this.setSelectedIndexOnAction(focusedIndex, false);
          }
        } else if (isForward && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
          event.preventDefault();
          var focusedIndex = this.focusFirstElement();
          if (focusedIndex !== -1) {
            this.setSelectedIndexOnAction(focusedIndex, false);
          }
        }
        if (this.hasTypeahead) {
          var handleKeydownOpts = {
            event,
            focusItemAtIndex: function(index) {
              _this.focusItemAtIndex(index);
            },
            focusedItemIndex: -1,
            isTargetListItem: isRootListItem,
            sortedIndexByFirstChar: this.sortedIndexByFirstChar,
            isItemAtIndexDisabled: function(index) {
              return _this.isIndexDisabled(index);
            }
          };
          handleKeydown(handleKeydownOpts, this.typeaheadState);
        }
        return;
      }
      var currentIndex = this.adapter.getFocusedElementIndex();
      if (currentIndex === -1) {
        currentIndex = listItemIndex;
        if (currentIndex < 0) {
          return;
        }
      }
      if (isForward && eventHasModifiers([])) {
        preventDefaultEvent(event);
        this.focusNextElement(currentIndex);
      } else if (isBack && eventHasModifiers([])) {
        preventDefaultEvent(event);
        this.focusPrevElement(currentIndex);
      } else if (isForward && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
        preventDefaultEvent(event);
        var focusedIndex = this.focusNextElement(currentIndex);
        if (focusedIndex !== -1) {
          this.setSelectedIndexOnAction(focusedIndex, false);
        }
      } else if (isBack && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
        preventDefaultEvent(event);
        var focusedIndex = this.focusPrevElement(currentIndex);
        if (focusedIndex !== -1) {
          this.setSelectedIndexOnAction(focusedIndex, false);
        }
      } else if (isHome && eventHasModifiers([])) {
        preventDefaultEvent(event);
        this.focusFirstElement();
      } else if (isEnd && eventHasModifiers([])) {
        preventDefaultEvent(event);
        this.focusLastElement();
      } else if (isHome && eventHasModifiers(["Control", "Shift"]) && this.isCheckboxList) {
        preventDefaultEvent(event);
        if (this.isIndexDisabled(currentIndex)) {
          return;
        }
        this.focusFirstElement();
        this.toggleCheckboxRange(0, currentIndex, currentIndex);
      } else if (isEnd && eventHasModifiers(["Control", "Shift"]) && this.isCheckboxList) {
        preventDefaultEvent(event);
        if (this.isIndexDisabled(currentIndex)) {
          return;
        }
        this.focusLastElement();
        this.toggleCheckboxRange(currentIndex, this.adapter.getListItemCount() - 1, currentIndex);
      } else if (isLetterA && eventHasModifiers(["Control"]) && this.isCheckboxList) {
        event.preventDefault();
        this.checkboxListToggleAll(this.selectedIndex === numbers$1.UNSET_INDEX ? [] : this.selectedIndex, true);
      } else if ((isEnter || isSpace) && eventHasModifiers([])) {
        if (isRootListItem) {
          var target = event.target;
          if (target && target.tagName === "A" && isEnter) {
            return;
          }
          preventDefaultEvent(event);
          if (this.isIndexDisabled(currentIndex)) {
            return;
          }
          if (!this.isTypeaheadInProgress()) {
            if (this.isSelectableList()) {
              this.setSelectedIndexOnAction(currentIndex, false);
            }
            this.adapter.notifyAction(currentIndex);
          }
        }
      } else if ((isEnter || isSpace) && eventHasModifiers(["Shift"]) && this.isCheckboxList) {
        var target = event.target;
        if (target && target.tagName === "A" && isEnter) {
          return;
        }
        preventDefaultEvent(event);
        if (this.isIndexDisabled(currentIndex)) {
          return;
        }
        if (!this.isTypeaheadInProgress()) {
          this.toggleCheckboxRange((_a2 = this.lastSelectedIndex) !== null && _a2 !== void 0 ? _a2 : currentIndex, currentIndex, currentIndex);
          this.adapter.notifyAction(currentIndex);
        }
      }
      if (this.hasTypeahead) {
        var handleKeydownOpts = {
          event,
          focusItemAtIndex: function(index) {
            _this.focusItemAtIndex(index);
          },
          focusedItemIndex: this.focusedItemIndex,
          isTargetListItem: isRootListItem,
          sortedIndexByFirstChar: this.sortedIndexByFirstChar,
          isItemAtIndexDisabled: function(index) {
            return _this.isIndexDisabled(index);
          }
        };
        handleKeydown(handleKeydownOpts, this.typeaheadState);
      }
    };
    MDCListFoundation2.prototype.handleClick = function(index, isCheckboxAlreadyUpdatedInAdapter, event) {
      var _a2;
      var eventHasModifiers = createModifierChecker(event);
      if (index === numbers$1.UNSET_INDEX) {
        return;
      }
      if (this.isIndexDisabled(index)) {
        return;
      }
      if (eventHasModifiers([])) {
        if (this.isSelectableList()) {
          this.setSelectedIndexOnAction(index, isCheckboxAlreadyUpdatedInAdapter);
        }
        this.adapter.notifyAction(index);
      } else if (this.isCheckboxList && eventHasModifiers(["Shift"])) {
        this.toggleCheckboxRange((_a2 = this.lastSelectedIndex) !== null && _a2 !== void 0 ? _a2 : index, index, index);
        this.adapter.notifyAction(index);
      }
    };
    MDCListFoundation2.prototype.focusNextElement = function(index) {
      var count = this.adapter.getListItemCount();
      var nextIndex = index;
      var firstChecked = null;
      do {
        nextIndex++;
        if (nextIndex >= count) {
          if (this.wrapFocus) {
            nextIndex = 0;
          } else {
            return index;
          }
        }
        if (nextIndex === firstChecked) {
          return -1;
        }
        firstChecked = firstChecked !== null && firstChecked !== void 0 ? firstChecked : nextIndex;
      } while (!this.areDisabledItemsFocusable && this.isIndexDisabled(nextIndex));
      this.focusItemAtIndex(nextIndex);
      return nextIndex;
    };
    MDCListFoundation2.prototype.focusPrevElement = function(index) {
      var count = this.adapter.getListItemCount();
      var prevIndex = index;
      var firstChecked = null;
      do {
        prevIndex--;
        if (prevIndex < 0) {
          if (this.wrapFocus) {
            prevIndex = count - 1;
          } else {
            return index;
          }
        }
        if (prevIndex === firstChecked) {
          return -1;
        }
        firstChecked = firstChecked !== null && firstChecked !== void 0 ? firstChecked : prevIndex;
      } while (!this.areDisabledItemsFocusable && this.isIndexDisabled(prevIndex));
      this.focusItemAtIndex(prevIndex);
      return prevIndex;
    };
    MDCListFoundation2.prototype.focusFirstElement = function() {
      return this.focusNextElement(-1);
    };
    MDCListFoundation2.prototype.focusLastElement = function() {
      return this.focusPrevElement(this.adapter.getListItemCount());
    };
    MDCListFoundation2.prototype.focusInitialElement = function() {
      var initialIndex = this.getFirstSelectedOrFocusedItemIndex();
      this.focusItemAtIndex(initialIndex);
      return initialIndex;
    };
    MDCListFoundation2.prototype.setEnabled = function(itemIndex, isEnabled) {
      if (!this.isIndexValid(itemIndex, false)) {
        return;
      }
      if (isEnabled) {
        this.adapter.removeClassForElementIndex(itemIndex, cssClasses$5.LIST_ITEM_DISABLED_CLASS);
        this.adapter.setAttributeForElementIndex(itemIndex, strings$5.ARIA_DISABLED, "false");
      } else {
        this.adapter.addClassForElementIndex(itemIndex, cssClasses$5.LIST_ITEM_DISABLED_CLASS);
        this.adapter.setAttributeForElementIndex(itemIndex, strings$5.ARIA_DISABLED, "true");
      }
    };
    MDCListFoundation2.prototype.setSingleSelectionAtIndex = function(index, options) {
      if (options === void 0) {
        options = {};
      }
      if (this.selectedIndex === index && !options.forceUpdate) {
        return;
      }
      var selectedClassName = cssClasses$5.LIST_ITEM_SELECTED_CLASS;
      if (this.useActivatedClass) {
        selectedClassName = cssClasses$5.LIST_ITEM_ACTIVATED_CLASS;
      }
      if (this.selectedIndex !== numbers$1.UNSET_INDEX) {
        this.adapter.removeClassForElementIndex(this.selectedIndex, selectedClassName);
      }
      this.setAriaForSingleSelectionAtIndex(index);
      this.setTabindexAtIndex(index);
      if (index !== numbers$1.UNSET_INDEX) {
        this.adapter.addClassForElementIndex(index, selectedClassName);
      }
      this.selectedIndex = index;
      if (options.isUserInteraction && !options.forceUpdate) {
        this.adapter.notifySelectionChange([index]);
      }
    };
    MDCListFoundation2.prototype.setAriaForSingleSelectionAtIndex = function(index) {
      if (this.selectedIndex === numbers$1.UNSET_INDEX) {
        this.ariaCurrentAttrValue = this.adapter.getAttributeForElementIndex(index, strings$5.ARIA_CURRENT);
      }
      var isAriaCurrent = this.ariaCurrentAttrValue !== null;
      var ariaAttribute = isAriaCurrent ? strings$5.ARIA_CURRENT : strings$5.ARIA_SELECTED;
      if (this.selectedIndex !== numbers$1.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex, ariaAttribute, "false");
      }
      if (index !== numbers$1.UNSET_INDEX) {
        var ariaAttributeValue = isAriaCurrent ? this.ariaCurrentAttrValue : "true";
        this.adapter.setAttributeForElementIndex(index, ariaAttribute, ariaAttributeValue);
      }
    };
    MDCListFoundation2.prototype.getSelectionAttribute = function() {
      return this.useSelectedAttr ? strings$5.ARIA_SELECTED : strings$5.ARIA_CHECKED;
    };
    MDCListFoundation2.prototype.setRadioAtIndex = function(index, options) {
      if (options === void 0) {
        options = {};
      }
      var selectionAttribute = this.getSelectionAttribute();
      this.adapter.setCheckedCheckboxOrRadioAtIndex(index, true);
      if (this.selectedIndex === index && !options.forceUpdate) {
        return;
      }
      if (this.selectedIndex !== numbers$1.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex, selectionAttribute, "false");
      }
      this.adapter.setAttributeForElementIndex(index, selectionAttribute, "true");
      this.selectedIndex = index;
      if (options.isUserInteraction && !options.forceUpdate) {
        this.adapter.notifySelectionChange([index]);
      }
    };
    MDCListFoundation2.prototype.setCheckboxAtIndex = function(index, options) {
      if (options === void 0) {
        options = {};
      }
      var currentIndex = this.selectedIndex;
      var currentlySelected = options.isUserInteraction ? new Set(currentIndex === numbers$1.UNSET_INDEX ? [] : currentIndex) : null;
      var selectionAttribute = this.getSelectionAttribute();
      var changedIndices = [];
      for (var i3 = 0; i3 < this.adapter.getListItemCount(); i3++) {
        var previousIsChecked = currentlySelected === null || currentlySelected === void 0 ? void 0 : currentlySelected.has(i3);
        var newIsChecked = index.indexOf(i3) >= 0;
        if (newIsChecked !== previousIsChecked) {
          changedIndices.push(i3);
        }
        this.adapter.setCheckedCheckboxOrRadioAtIndex(i3, newIsChecked);
        this.adapter.setAttributeForElementIndex(i3, selectionAttribute, newIsChecked ? "true" : "false");
      }
      this.selectedIndex = index;
      if (options.isUserInteraction && changedIndices.length) {
        this.adapter.notifySelectionChange(changedIndices);
      }
    };
    MDCListFoundation2.prototype.toggleCheckboxRange = function(fromIndex, toIndex, toggleIndex) {
      this.lastSelectedIndex = toggleIndex;
      var currentlySelected = new Set(this.selectedIndex === numbers$1.UNSET_INDEX ? [] : this.selectedIndex);
      var newIsChecked = !(currentlySelected === null || currentlySelected === void 0 ? void 0 : currentlySelected.has(toggleIndex));
      var _a2 = __read([fromIndex, toIndex].sort(), 2), startIndex = _a2[0], endIndex = _a2[1];
      var selectionAttribute = this.getSelectionAttribute();
      var changedIndices = [];
      for (var i3 = startIndex; i3 <= endIndex; i3++) {
        if (this.isIndexDisabled(i3)) {
          continue;
        }
        var previousIsChecked = currentlySelected.has(i3);
        if (newIsChecked !== previousIsChecked) {
          changedIndices.push(i3);
          this.adapter.setCheckedCheckboxOrRadioAtIndex(i3, newIsChecked);
          this.adapter.setAttributeForElementIndex(i3, selectionAttribute, "" + newIsChecked);
          if (newIsChecked) {
            currentlySelected.add(i3);
          } else {
            currentlySelected.delete(i3);
          }
        }
      }
      if (changedIndices.length) {
        this.selectedIndex = __spreadArray([], __read(currentlySelected));
        this.adapter.notifySelectionChange(changedIndices);
      }
    };
    MDCListFoundation2.prototype.setTabindexAtIndex = function(index) {
      if (this.focusedItemIndex === numbers$1.UNSET_INDEX && index !== 0) {
        this.adapter.setAttributeForElementIndex(0, "tabindex", "-1");
      } else if (this.focusedItemIndex >= 0 && this.focusedItemIndex !== index) {
        this.adapter.setAttributeForElementIndex(this.focusedItemIndex, "tabindex", "-1");
      }
      if (!(this.selectedIndex instanceof Array) && this.selectedIndex !== index) {
        this.adapter.setAttributeForElementIndex(this.selectedIndex, "tabindex", "-1");
      }
      if (index !== numbers$1.UNSET_INDEX) {
        this.adapter.setAttributeForElementIndex(index, "tabindex", "0");
      }
    };
    MDCListFoundation2.prototype.isSelectableList = function() {
      return this.isSingleSelectionList || this.isCheckboxList || this.isRadioList;
    };
    MDCListFoundation2.prototype.setTabindexToFirstSelectedOrFocusedItem = function() {
      var targetIndex = this.getFirstSelectedOrFocusedItemIndex();
      this.setTabindexAtIndex(targetIndex);
    };
    MDCListFoundation2.prototype.getFirstSelectedOrFocusedItemIndex = function() {
      if (!this.isSelectableList()) {
        return Math.max(this.focusedItemIndex, 0);
      }
      if (typeof this.selectedIndex === "number" && this.selectedIndex !== numbers$1.UNSET_INDEX) {
        return this.selectedIndex;
      }
      if (isNumberArray(this.selectedIndex) && this.selectedIndex.length > 0) {
        return this.selectedIndex.reduce(function(minIndex, currentIndex) {
          return Math.min(minIndex, currentIndex);
        });
      }
      return 0;
    };
    MDCListFoundation2.prototype.isIndexValid = function(index, validateListType) {
      var _this = this;
      if (validateListType === void 0) {
        validateListType = true;
      }
      if (index instanceof Array) {
        if (!this.isCheckboxList && validateListType) {
          throw new Error("MDCListFoundation: Array of index is only supported for checkbox based list");
        }
        if (index.length === 0) {
          return true;
        } else {
          return index.some(function(i3) {
            return _this.isIndexInRange(i3);
          });
        }
      } else if (typeof index === "number") {
        if (this.isCheckboxList && validateListType) {
          throw new Error("MDCListFoundation: Expected array of index for checkbox based list but got number: " + index);
        }
        return this.isIndexInRange(index) || this.isSingleSelectionList && index === numbers$1.UNSET_INDEX;
      } else {
        return false;
      }
    };
    MDCListFoundation2.prototype.isIndexInRange = function(index) {
      var listSize = this.adapter.getListItemCount();
      return index >= 0 && index < listSize;
    };
    MDCListFoundation2.prototype.setSelectedIndexOnAction = function(index, isCheckboxAlreadyUpdatedInAdapter) {
      this.lastSelectedIndex = index;
      if (this.isCheckboxList) {
        this.toggleCheckboxAtIndex(index, isCheckboxAlreadyUpdatedInAdapter);
        this.adapter.notifySelectionChange([index]);
      } else {
        this.setSelectedIndex(index, { isUserInteraction: true });
      }
    };
    MDCListFoundation2.prototype.toggleCheckboxAtIndex = function(index, isCheckboxAlreadyUpdatedInAdapter) {
      var selectionAttribute = this.getSelectionAttribute();
      var adapterIsChecked = this.adapter.isCheckboxCheckedAtIndex(index);
      var newCheckedValue;
      if (isCheckboxAlreadyUpdatedInAdapter) {
        newCheckedValue = adapterIsChecked;
      } else {
        newCheckedValue = !adapterIsChecked;
        this.adapter.setCheckedCheckboxOrRadioAtIndex(index, newCheckedValue);
      }
      this.adapter.setAttributeForElementIndex(index, selectionAttribute, newCheckedValue ? "true" : "false");
      var selectedIndexes = this.selectedIndex === numbers$1.UNSET_INDEX ? [] : this.selectedIndex.slice();
      if (newCheckedValue) {
        selectedIndexes.push(index);
      } else {
        selectedIndexes = selectedIndexes.filter(function(i3) {
          return i3 !== index;
        });
      }
      this.selectedIndex = selectedIndexes;
    };
    MDCListFoundation2.prototype.focusItemAtIndex = function(index) {
      this.adapter.focusItemAtIndex(index);
      this.focusedItemIndex = index;
    };
    MDCListFoundation2.prototype.checkboxListToggleAll = function(currentlySelectedIndexes, isUserInteraction) {
      var count = this.adapter.getListItemCount();
      if (currentlySelectedIndexes.length === count) {
        this.setCheckboxAtIndex([], { isUserInteraction });
      } else {
        var allIndexes = [];
        for (var i3 = 0; i3 < count; i3++) {
          if (!this.isIndexDisabled(i3) || currentlySelectedIndexes.indexOf(i3) > -1) {
            allIndexes.push(i3);
          }
        }
        this.setCheckboxAtIndex(allIndexes, { isUserInteraction });
      }
    };
    MDCListFoundation2.prototype.typeaheadMatchItem = function(nextChar2, startingIndex, skipFocus) {
      var _this = this;
      if (skipFocus === void 0) {
        skipFocus = false;
      }
      var opts = {
        focusItemAtIndex: function(index) {
          _this.focusItemAtIndex(index);
        },
        focusedItemIndex: startingIndex ? startingIndex : this.focusedItemIndex,
        nextChar: nextChar2,
        sortedIndexByFirstChar: this.sortedIndexByFirstChar,
        skipFocus,
        isItemAtIndexDisabled: function(index) {
          return _this.isIndexDisabled(index);
        }
      };
      return matchItem(opts, this.typeaheadState);
    };
    MDCListFoundation2.prototype.typeaheadInitSortedIndex = function() {
      return initSortedIndex(this.adapter.getListItemCount(), this.adapter.getPrimaryTextAtIndex);
    };
    MDCListFoundation2.prototype.clearTypeaheadBuffer = function() {
      clearBuffer(this.typeaheadState);
    };
    return MDCListFoundation2;
  }(MDCFoundation)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCList = (
  /** @class */
  function(_super) {
    __extends(MDCList2, _super);
    function MDCList2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MDCList2.prototype, "vertical", {
      set: function(value) {
        this.foundation.setVerticalOrientation(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCList2.prototype, "listElements", {
      get: function() {
        return Array.from(this.root.querySelectorAll("." + this.classNameMap[cssClasses$5.LIST_ITEM_CLASS]));
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCList2.prototype, "wrapFocus", {
      set: function(value) {
        this.foundation.setWrapFocus(value);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCList2.prototype, "typeaheadInProgress", {
      /**
       * @return Whether typeahead is currently matching a user-specified prefix.
       */
      get: function() {
        return this.foundation.isTypeaheadInProgress();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCList2.prototype, "hasTypeahead", {
      /**
       * Sets whether typeahead functionality is enabled on the list.
       * @param hasTypeahead Whether typeahead is enabled.
       */
      set: function(hasTypeahead) {
        this.foundation.setHasTypeahead(hasTypeahead);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCList2.prototype, "singleSelection", {
      set: function(isSingleSelectionList) {
        this.foundation.setSingleSelection(isSingleSelectionList);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCList2.prototype, "disabledItemsFocusable", {
      set: function(areDisabledItemsFocusable) {
        this.foundation.setDisabledItemsFocusable(areDisabledItemsFocusable);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCList2.prototype, "selectedIndex", {
      get: function() {
        return this.foundation.getSelectedIndex();
      },
      set: function(index) {
        this.foundation.setSelectedIndex(index);
      },
      enumerable: false,
      configurable: true
    });
    MDCList2.attachTo = function(root) {
      return new MDCList2(root);
    };
    MDCList2.prototype.initialSyncWithDOM = function() {
      this.isEvolutionEnabled = evolutionAttribute in this.root.dataset;
      if (this.isEvolutionEnabled) {
        this.classNameMap = evolutionClassNameMap;
      } else if (matches(this.root, strings$5.DEPRECATED_SELECTOR)) {
        this.classNameMap = deprecatedClassNameMap;
      } else {
        this.classNameMap = Object.values(cssClasses$5).reduce(function(obj, className) {
          obj[className] = className;
          return obj;
        }, {});
      }
      this.handleClick = this.handleClickEvent.bind(this);
      this.handleKeydown = this.handleKeydownEvent.bind(this);
      this.focusInEventListener = this.handleFocusInEvent.bind(this);
      this.focusOutEventListener = this.handleFocusOutEvent.bind(this);
      this.listen("keydown", this.handleKeydown);
      this.listen("click", this.handleClick);
      this.listen("focusin", this.focusInEventListener);
      this.listen("focusout", this.focusOutEventListener);
      this.layout();
      this.initializeListType();
      this.ensureFocusable();
    };
    MDCList2.prototype.destroy = function() {
      this.unlisten("keydown", this.handleKeydown);
      this.unlisten("click", this.handleClick);
      this.unlisten("focusin", this.focusInEventListener);
      this.unlisten("focusout", this.focusOutEventListener);
    };
    MDCList2.prototype.layout = function() {
      var direction = this.root.getAttribute(strings$5.ARIA_ORIENTATION);
      this.vertical = direction !== strings$5.ARIA_ORIENTATION_HORIZONTAL;
      var itemSelector = "." + this.classNameMap[cssClasses$5.LIST_ITEM_CLASS] + ":not([tabindex])";
      var childSelector = strings$5.FOCUSABLE_CHILD_ELEMENTS;
      var itemEls = this.root.querySelectorAll(itemSelector);
      if (itemEls.length) {
        Array.prototype.forEach.call(itemEls, function(el) {
          el.setAttribute("tabindex", "-1");
        });
      }
      var focusableChildEls = this.root.querySelectorAll(childSelector);
      if (focusableChildEls.length) {
        Array.prototype.forEach.call(focusableChildEls, function(el) {
          el.setAttribute("tabindex", "-1");
        });
      }
      if (this.isEvolutionEnabled) {
        this.foundation.setUseSelectedAttribute(true);
      }
      this.foundation.layout();
    };
    MDCList2.prototype.getPrimaryText = function(item) {
      var _a2;
      var primaryText = item.querySelector("." + this.classNameMap[cssClasses$5.LIST_ITEM_PRIMARY_TEXT_CLASS]);
      if (this.isEvolutionEnabled || primaryText) {
        return (_a2 = primaryText === null || primaryText === void 0 ? void 0 : primaryText.textContent) !== null && _a2 !== void 0 ? _a2 : "";
      }
      var singleLineText = item.querySelector("." + this.classNameMap[cssClasses$5.LIST_ITEM_TEXT_CLASS]);
      return singleLineText && singleLineText.textContent || "";
    };
    MDCList2.prototype.initializeListType = function() {
      var _this = this;
      this.isInteractive = matches(this.root, strings$5.ARIA_INTERACTIVE_ROLES_SELECTOR);
      if (this.isEvolutionEnabled && this.isInteractive) {
        var selection = Array.from(this.root.querySelectorAll(strings$5.SELECTED_ITEM_SELECTOR), function(listItem) {
          return _this.listElements.indexOf(listItem);
        });
        if (matches(this.root, strings$5.ARIA_MULTI_SELECTABLE_SELECTOR)) {
          this.selectedIndex = selection;
        } else if (selection.length > 0) {
          this.selectedIndex = selection[0];
        }
        return;
      }
      var checkboxListItems = this.root.querySelectorAll(strings$5.ARIA_ROLE_CHECKBOX_SELECTOR);
      var radioSelectedListItem = this.root.querySelector(strings$5.ARIA_CHECKED_RADIO_SELECTOR);
      if (checkboxListItems.length) {
        var preselectedItems = this.root.querySelectorAll(strings$5.ARIA_CHECKED_CHECKBOX_SELECTOR);
        this.selectedIndex = Array.from(preselectedItems, function(listItem) {
          return _this.listElements.indexOf(listItem);
        });
      } else if (radioSelectedListItem) {
        this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
      }
    };
    MDCList2.prototype.setEnabled = function(itemIndex, isEnabled) {
      this.foundation.setEnabled(itemIndex, isEnabled);
    };
    MDCList2.prototype.typeaheadMatchItem = function(nextChar2, startingIndex) {
      return this.foundation.typeaheadMatchItem(
        nextChar2,
        startingIndex,
        /** skipFocus */
        true
      );
    };
    MDCList2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClassForElementIndex: function(index, className) {
          var element = _this.listElements[index];
          if (element) {
            element.classList.add(_this.classNameMap[className]);
          }
        },
        focusItemAtIndex: function(index) {
          var element = _this.listElements[index];
          if (element) {
            element.focus();
          }
        },
        getAttributeForElementIndex: function(index, attr) {
          return _this.listElements[index].getAttribute(attr);
        },
        getFocusedElementIndex: function() {
          return _this.listElements.indexOf(document.activeElement);
        },
        getListItemCount: function() {
          return _this.listElements.length;
        },
        getPrimaryTextAtIndex: function(index) {
          return _this.getPrimaryText(_this.listElements[index]);
        },
        hasCheckboxAtIndex: function(index) {
          var listItem = _this.listElements[index];
          return !!listItem.querySelector(strings$5.CHECKBOX_SELECTOR);
        },
        hasRadioAtIndex: function(index) {
          var listItem = _this.listElements[index];
          return !!listItem.querySelector(strings$5.RADIO_SELECTOR);
        },
        isCheckboxCheckedAtIndex: function(index) {
          var listItem = _this.listElements[index];
          var toggleEl = listItem.querySelector(strings$5.CHECKBOX_SELECTOR);
          return toggleEl.checked;
        },
        isFocusInsideList: function() {
          return _this.root !== document.activeElement && _this.root.contains(document.activeElement);
        },
        isRootFocused: function() {
          return document.activeElement === _this.root;
        },
        listItemAtIndexHasClass: function(index, className) {
          return _this.listElements[index].classList.contains(_this.classNameMap[className]);
        },
        notifyAction: function(index) {
          _this.emit(
            strings$5.ACTION_EVENT,
            { index },
            /** shouldBubble */
            true
          );
        },
        notifySelectionChange: function(changedIndices) {
          _this.emit(
            strings$5.SELECTION_CHANGE_EVENT,
            { changedIndices },
            /** shouldBubble */
            true
          );
        },
        removeClassForElementIndex: function(index, className) {
          var element = _this.listElements[index];
          if (element) {
            element.classList.remove(_this.classNameMap[className]);
          }
        },
        setAttributeForElementIndex: function(index, attr, value) {
          var element = _this.listElements[index];
          if (element) {
            element.setAttribute(attr, value);
          }
        },
        setCheckedCheckboxOrRadioAtIndex: function(index, isChecked) {
          var listItem = _this.listElements[index];
          var toggleEl = listItem.querySelector(strings$5.CHECKBOX_RADIO_SELECTOR);
          toggleEl.checked = isChecked;
          var event = document.createEvent("Event");
          event.initEvent("change", true, true);
          toggleEl.dispatchEvent(event);
        },
        setTabIndexForListItemChildren: function(listItemIndex, tabIndexValue) {
          var element = _this.listElements[listItemIndex];
          var selector = strings$5.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX;
          Array.prototype.forEach.call(element.querySelectorAll(selector), function(el) {
            el.setAttribute("tabindex", tabIndexValue);
          });
        }
      };
      return new MDCListFoundation(adapter);
    };
    MDCList2.prototype.ensureFocusable = function() {
      if (this.isEvolutionEnabled && this.isInteractive) {
        if (!this.root.querySelector("." + this.classNameMap[cssClasses$5.LIST_ITEM_CLASS] + '[tabindex="0"]')) {
          var index = this.initialFocusIndex();
          if (index !== -1) {
            this.listElements[index].tabIndex = 0;
          }
        }
      }
    };
    MDCList2.prototype.initialFocusIndex = function() {
      if (this.selectedIndex instanceof Array && this.selectedIndex.length > 0) {
        return this.selectedIndex[0];
      }
      if (typeof this.selectedIndex === "number" && this.selectedIndex !== numbers$1.UNSET_INDEX) {
        return this.selectedIndex;
      }
      var el = this.root.querySelector("." + this.classNameMap[cssClasses$5.LIST_ITEM_CLASS] + ":not(." + this.classNameMap[cssClasses$5.LIST_ITEM_DISABLED_CLASS] + ")");
      if (el === null) {
        return -1;
      }
      return this.getListItemIndex(el);
    };
    MDCList2.prototype.getListItemIndex = function(el) {
      var nearestParent = closest(el, "." + this.classNameMap[cssClasses$5.LIST_ITEM_CLASS] + ", ." + this.classNameMap[cssClasses$5.ROOT]);
      if (nearestParent && matches(nearestParent, "." + this.classNameMap[cssClasses$5.LIST_ITEM_CLASS])) {
        return this.listElements.indexOf(nearestParent);
      }
      return -1;
    };
    MDCList2.prototype.handleFocusInEvent = function(evt) {
      var index = this.getListItemIndex(evt.target);
      this.foundation.handleFocusIn(index);
    };
    MDCList2.prototype.handleFocusOutEvent = function(evt) {
      var index = this.getListItemIndex(evt.target);
      this.foundation.handleFocusOut(index);
    };
    MDCList2.prototype.handleKeydownEvent = function(evt) {
      var index = this.getListItemIndex(evt.target);
      var target = evt.target;
      this.foundation.handleKeydown(evt, target.classList.contains(this.classNameMap[cssClasses$5.LIST_ITEM_CLASS]), index);
    };
    MDCList2.prototype.handleClickEvent = function(evt) {
      var index = this.getListItemIndex(evt.target);
      var target = evt.target;
      var toggleCheckbox = !matches(target, strings$5.CHECKBOX_RADIO_SELECTOR);
      this.foundation.handleClick(index, toggleCheckbox, evt);
    };
    return MDCList2;
  }(MDCComponent)
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$4 = {
  ANIMATE: "mdc-drawer--animate",
  CLOSING: "mdc-drawer--closing",
  DISMISSIBLE: "mdc-drawer--dismissible",
  MODAL: "mdc-drawer--modal",
  OPEN: "mdc-drawer--open",
  OPENING: "mdc-drawer--opening",
  ROOT: "mdc-drawer"
};
var strings$4 = {
  APP_CONTENT_SELECTOR: ".mdc-drawer-app-content",
  CLOSE_EVENT: "MDCDrawer:closed",
  OPEN_EVENT: "MDCDrawer:opened",
  SCRIM_SELECTOR: ".mdc-drawer-scrim",
  LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
  LIST_ITEM_ACTIVATED_SELECTOR: ".mdc-list-item--activated,.mdc-deprecated-list-item--activated"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCDismissibleDrawerFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCDismissibleDrawerFoundation2, _super);
    function MDCDismissibleDrawerFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCDismissibleDrawerFoundation2.defaultAdapter), adapter)) || this;
      _this.animationFrame = 0;
      _this.animationTimer = 0;
      return _this;
    }
    Object.defineProperty(MDCDismissibleDrawerFoundation2, "strings", {
      get: function() {
        return strings$4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDismissibleDrawerFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDismissibleDrawerFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          elementHasClass: function() {
            return false;
          },
          notifyClose: function() {
            return void 0;
          },
          notifyOpen: function() {
            return void 0;
          },
          saveFocus: function() {
            return void 0;
          },
          restoreFocus: function() {
            return void 0;
          },
          focusActiveNavigationItem: function() {
            return void 0;
          },
          trapFocus: function() {
            return void 0;
          },
          releaseFocus: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCDismissibleDrawerFoundation2.prototype.destroy = function() {
      if (this.animationFrame) {
        cancelAnimationFrame(this.animationFrame);
      }
      if (this.animationTimer) {
        clearTimeout(this.animationTimer);
      }
    };
    MDCDismissibleDrawerFoundation2.prototype.open = function() {
      var _this = this;
      if (this.isOpen() || this.isOpening() || this.isClosing()) {
        return;
      }
      this.adapter.addClass(cssClasses$4.OPEN);
      this.adapter.addClass(cssClasses$4.ANIMATE);
      this.runNextAnimationFrame(function() {
        _this.adapter.addClass(cssClasses$4.OPENING);
      });
      this.adapter.saveFocus();
    };
    MDCDismissibleDrawerFoundation2.prototype.close = function() {
      if (!this.isOpen() || this.isOpening() || this.isClosing()) {
        return;
      }
      this.adapter.addClass(cssClasses$4.CLOSING);
    };
    MDCDismissibleDrawerFoundation2.prototype.isOpen = function() {
      return this.adapter.hasClass(cssClasses$4.OPEN);
    };
    MDCDismissibleDrawerFoundation2.prototype.isOpening = function() {
      return this.adapter.hasClass(cssClasses$4.OPENING) || this.adapter.hasClass(cssClasses$4.ANIMATE);
    };
    MDCDismissibleDrawerFoundation2.prototype.isClosing = function() {
      return this.adapter.hasClass(cssClasses$4.CLOSING);
    };
    MDCDismissibleDrawerFoundation2.prototype.handleKeydown = function(evt) {
      var keyCode = evt.keyCode, key = evt.key;
      var isEscape = key === "Escape" || keyCode === 27;
      if (isEscape) {
        this.close();
      }
    };
    MDCDismissibleDrawerFoundation2.prototype.handleTransitionEnd = function(evt) {
      var OPENING2 = cssClasses$4.OPENING, CLOSING2 = cssClasses$4.CLOSING, OPEN2 = cssClasses$4.OPEN, ANIMATE = cssClasses$4.ANIMATE, ROOT = cssClasses$4.ROOT;
      var isRootElement = this.isElement(evt.target) && this.adapter.elementHasClass(evt.target, ROOT);
      if (!isRootElement) {
        return;
      }
      if (this.isClosing()) {
        this.adapter.removeClass(OPEN2);
        this.closed();
        this.adapter.restoreFocus();
        this.adapter.notifyClose();
      } else {
        this.adapter.focusActiveNavigationItem();
        this.opened();
        this.adapter.notifyOpen();
      }
      this.adapter.removeClass(ANIMATE);
      this.adapter.removeClass(OPENING2);
      this.adapter.removeClass(CLOSING2);
    };
    MDCDismissibleDrawerFoundation2.prototype.opened = function() {
    };
    MDCDismissibleDrawerFoundation2.prototype.closed = function() {
    };
    MDCDismissibleDrawerFoundation2.prototype.runNextAnimationFrame = function(callback) {
      var _this = this;
      cancelAnimationFrame(this.animationFrame);
      this.animationFrame = requestAnimationFrame(function() {
        _this.animationFrame = 0;
        clearTimeout(_this.animationTimer);
        _this.animationTimer = setTimeout(callback, 0);
      });
    };
    MDCDismissibleDrawerFoundation2.prototype.isElement = function(element) {
      return Boolean(element.classList);
    };
    return MDCDismissibleDrawerFoundation2;
  }(MDCFoundation)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCModalDrawerFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCModalDrawerFoundation2, _super);
    function MDCModalDrawerFoundation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCModalDrawerFoundation2.prototype.handleScrimClick = function() {
      this.close();
    };
    MDCModalDrawerFoundation2.prototype.opened = function() {
      this.adapter.trapFocus();
    };
    MDCModalDrawerFoundation2.prototype.closed = function() {
      this.adapter.releaseFocus();
    };
    return MDCModalDrawerFoundation2;
  }(MDCDismissibleDrawerFoundation)
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$3 = MDCDismissibleDrawerFoundation.cssClasses, strings$3 = MDCDismissibleDrawerFoundation.strings;
var MDCDrawer = (
  /** @class */
  function(_super) {
    __extends(MDCDrawer2, _super);
    function MDCDrawer2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCDrawer2.attachTo = function(root) {
      return new MDCDrawer2(root);
    };
    Object.defineProperty(MDCDrawer2.prototype, "open", {
      /**
       * @return boolean Proxies to the foundation's `open`/`close` methods.
       * Also returns true if drawer is in the open position.
       */
      get: function() {
        return this.foundation.isOpen();
      },
      /**
       * Toggles the drawer open and closed.
       */
      set: function(isOpen) {
        if (isOpen) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCDrawer2.prototype, "list", {
      // initialSyncWithDOM()
      get: function() {
        return this.innerList;
      },
      enumerable: false,
      configurable: true
    });
    MDCDrawer2.prototype.initialize = function(focusTrapFactory, listFactory) {
      if (focusTrapFactory === void 0) {
        focusTrapFactory = function(el) {
          return new FocusTrap2(el);
        };
      }
      if (listFactory === void 0) {
        listFactory = function(el) {
          return new MDCList(el);
        };
      }
      var listEl = this.root.querySelector(strings$3.LIST_SELECTOR);
      if (listEl) {
        this.innerList = listFactory(listEl);
        this.innerList.wrapFocus = true;
      }
      this.focusTrapFactory = focusTrapFactory;
    };
    MDCDrawer2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      var MODAL = cssClasses$3.MODAL;
      var SCRIM_SELECTOR = strings$3.SCRIM_SELECTOR;
      this.scrim = this.root.parentNode.querySelector(SCRIM_SELECTOR);
      if (this.scrim && this.root.classList.contains(MODAL)) {
        this.handleScrimClick = function() {
          return _this.foundation.handleScrimClick();
        };
        this.scrim.addEventListener("click", this.handleScrimClick);
        this.focusTrap = createFocusTrapInstance(this.root, this.focusTrapFactory);
      }
      this.handleKeydown = function(evt) {
        _this.foundation.handleKeydown(evt);
      };
      this.handleTransitionEnd = function(evt) {
        _this.foundation.handleTransitionEnd(evt);
      };
      this.listen("keydown", this.handleKeydown);
      this.listen("transitionend", this.handleTransitionEnd);
    };
    MDCDrawer2.prototype.destroy = function() {
      this.unlisten("keydown", this.handleKeydown);
      this.unlisten("transitionend", this.handleTransitionEnd);
      if (this.innerList) {
        this.innerList.destroy();
      }
      var MODAL = cssClasses$3.MODAL;
      if (this.scrim && this.handleScrimClick && this.root.classList.contains(MODAL)) {
        this.scrim.removeEventListener("click", this.handleScrimClick);
        this.open = false;
      }
    };
    MDCDrawer2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          _this.root.classList.add(className);
        },
        removeClass: function(className) {
          _this.root.classList.remove(className);
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        elementHasClass: function(element, className) {
          return element.classList.contains(className);
        },
        saveFocus: function() {
          _this.previousFocus = document.activeElement;
        },
        restoreFocus: function() {
          var previousFocus = _this.previousFocus;
          if (previousFocus && previousFocus.focus && _this.root.contains(document.activeElement)) {
            previousFocus.focus();
          }
        },
        focusActiveNavigationItem: function() {
          var activeNavItemEl = _this.root.querySelector(strings$3.LIST_ITEM_ACTIVATED_SELECTOR);
          if (activeNavItemEl) {
            activeNavItemEl.focus();
          }
        },
        notifyClose: function() {
          _this.emit(
            strings$3.CLOSE_EVENT,
            {},
            true
            /* shouldBubble */
          );
        },
        notifyOpen: function() {
          _this.emit(
            strings$3.OPEN_EVENT,
            {},
            true
            /* shouldBubble */
          );
        },
        trapFocus: function() {
          _this.focusTrap.trapFocus();
        },
        releaseFocus: function() {
          _this.focusTrap.releaseFocus();
        }
      };
      var DISMISSIBLE = cssClasses$3.DISMISSIBLE, MODAL = cssClasses$3.MODAL;
      if (this.root.classList.contains(DISMISSIBLE)) {
        return new MDCDismissibleDrawerFoundation(adapter);
      } else if (this.root.classList.contains(MODAL)) {
        return new MDCModalDrawerFoundation(adapter);
      } else {
        throw new Error("MDCDrawer: Failed to instantiate component. Supported variants are " + DISMISSIBLE + " and " + MODAL + ".");
      }
    };
    return MDCDrawer2;
  }(MDCComponent)
);
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses$2 = {
  ROOT: "mdc-form-field"
};
var strings$2 = {
  LABEL_SELECTOR: ".mdc-form-field > label"
};
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFormFieldFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCFormFieldFoundation2, _super);
    function MDCFormFieldFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCFormFieldFoundation2.defaultAdapter), adapter)) || this;
      _this.click = function() {
        _this.handleClick();
      };
      return _this;
    }
    Object.defineProperty(MDCFormFieldFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFormFieldFoundation2, "strings", {
      get: function() {
        return strings$2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFormFieldFoundation2, "defaultAdapter", {
      get: function() {
        return {
          activateInputRipple: function() {
            return void 0;
          },
          deactivateInputRipple: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCFormFieldFoundation2.prototype.init = function() {
      this.adapter.registerInteractionHandler("click", this.click);
    };
    MDCFormFieldFoundation2.prototype.destroy = function() {
      this.adapter.deregisterInteractionHandler("click", this.click);
    };
    MDCFormFieldFoundation2.prototype.handleClick = function() {
      var _this = this;
      this.adapter.activateInputRipple();
      requestAnimationFrame(function() {
        _this.adapter.deactivateInputRipple();
      });
    };
    return MDCFormFieldFoundation2;
  }(MDCFoundation)
);
/**
 * @license
 * Copyright 2017 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFormField = (
  /** @class */
  function(_super) {
    __extends(MDCFormField2, _super);
    function MDCFormField2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCFormField2.attachTo = function(root) {
      return new MDCFormField2(root);
    };
    MDCFormField2.prototype.labelEl = function() {
      var LABEL_SELECTOR = MDCFormFieldFoundation.strings.LABEL_SELECTOR;
      return this.root.querySelector(LABEL_SELECTOR);
    };
    MDCFormField2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        activateInputRipple: function() {
          if (_this.input && _this.input.ripple) {
            _this.input.ripple.activate();
          }
        },
        deactivateInputRipple: function() {
          if (_this.input && _this.input.ripple) {
            _this.input.ripple.deactivate();
          }
        },
        deregisterInteractionHandler: function(evtType, handler) {
          var labelEl = _this.labelEl();
          if (labelEl) {
            labelEl.removeEventListener(evtType, handler);
          }
        },
        registerInteractionHandler: function(evtType, handler) {
          var labelEl = _this.labelEl();
          if (labelEl) {
            labelEl.addEventListener(evtType, handler);
          }
        }
      };
      return new MDCFormFieldFoundation(adapter);
    };
    return MDCFormField2;
  }(MDCComponent)
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var strings$1 = {
  NATIVE_CONTROL_SELECTOR: ".mdc-radio__native-control"
};
var cssClasses$1 = {
  DISABLED: "mdc-radio--disabled",
  ROOT: "mdc-radio"
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCRadioFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCRadioFoundation2, _super);
    function MDCRadioFoundation2(adapter) {
      return _super.call(this, __assign(__assign({}, MDCRadioFoundation2.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCRadioFoundation2, "cssClasses", {
      get: function() {
        return cssClasses$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRadioFoundation2, "strings", {
      get: function() {
        return strings$1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRadioFoundation2, "defaultAdapter", {
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          setNativeControlDisabled: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCRadioFoundation2.prototype.setDisabled = function(disabled) {
      var DISABLED = MDCRadioFoundation2.cssClasses.DISABLED;
      this.adapter.setNativeControlDisabled(disabled);
      if (disabled) {
        this.adapter.addClass(DISABLED);
      } else {
        this.adapter.removeClass(DISABLED);
      }
    };
    return MDCRadioFoundation2;
  }(MDCFoundation)
);
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCRadio = (
  /** @class */
  function(_super) {
    __extends(MDCRadio2, _super);
    function MDCRadio2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rippleSurface = _this.createRipple();
      return _this;
    }
    MDCRadio2.attachTo = function(root) {
      return new MDCRadio2(root);
    };
    Object.defineProperty(MDCRadio2.prototype, "checked", {
      get: function() {
        return this.nativeControl.checked;
      },
      set: function(checked) {
        this.nativeControl.checked = checked;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRadio2.prototype, "disabled", {
      get: function() {
        return this.nativeControl.disabled;
      },
      set: function(disabled) {
        this.foundation.setDisabled(disabled);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRadio2.prototype, "value", {
      get: function() {
        return this.nativeControl.value;
      },
      set: function(value) {
        this.nativeControl.value = value;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCRadio2.prototype, "ripple", {
      get: function() {
        return this.rippleSurface;
      },
      enumerable: false,
      configurable: true
    });
    MDCRadio2.prototype.destroy = function() {
      this.rippleSurface.destroy();
      _super.prototype.destroy.call(this);
    };
    MDCRadio2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        setNativeControlDisabled: function(disabled) {
          return _this.nativeControl.disabled = disabled;
        }
      };
      return new MDCRadioFoundation(adapter);
    };
    MDCRadio2.prototype.createRipple = function() {
      var _this = this;
      var adapter = __assign(__assign({}, MDCRipple.createAdapter(this)), {
        registerInteractionHandler: function(evtType, handler) {
          _this.nativeControl.addEventListener(evtType, handler, applyPassive());
        },
        deregisterInteractionHandler: function(evtType, handler) {
          _this.nativeControl.removeEventListener(evtType, handler, applyPassive());
        },
        // Radio buttons technically go "active" whenever there is *any* keyboard
        // interaction. This is not the UI we desire.
        isSurfaceActive: function() {
          return false;
        },
        isUnbounded: function() {
          return true;
        }
      });
      return new MDCRipple(this.root, new MDCRippleFoundation(adapter));
    };
    Object.defineProperty(MDCRadio2.prototype, "nativeControl", {
      get: function() {
        var NATIVE_CONTROL_SELECTOR = MDCRadioFoundation.strings.NATIVE_CONTROL_SELECTOR;
        var el = this.root.querySelector(NATIVE_CONTROL_SELECTOR);
        if (!el) {
          throw new Error("Radio component requires a " + NATIVE_CONTROL_SELECTOR + " element");
        }
        return el;
      },
      enumerable: false,
      configurable: true
    });
    return MDCRadio2;
  }(MDCComponent)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var cssClasses = {
  FIXED_CLASS: "mdc-top-app-bar--fixed",
  FIXED_SCROLLED_CLASS: "mdc-top-app-bar--fixed-scrolled",
  SHORT_CLASS: "mdc-top-app-bar--short",
  SHORT_COLLAPSED_CLASS: "mdc-top-app-bar--short-collapsed",
  SHORT_HAS_ACTION_ITEM_CLASS: "mdc-top-app-bar--short-has-action-item"
};
var numbers = {
  DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
  MAX_TOP_APP_BAR_HEIGHT: 128
};
var strings = {
  ACTION_ITEM_SELECTOR: ".mdc-top-app-bar__action-item",
  NAVIGATION_EVENT: "MDCTopAppBar:nav",
  NAVIGATION_ICON_SELECTOR: ".mdc-top-app-bar__navigation-icon",
  ROOT_SELECTOR: ".mdc-top-app-bar",
  TITLE_SELECTOR: ".mdc-top-app-bar__title"
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTopAppBarBaseFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCTopAppBarBaseFoundation2, _super);
    function MDCTopAppBarBaseFoundation2(adapter) {
      return _super.call(this, __assign(__assign({}, MDCTopAppBarBaseFoundation2.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCTopAppBarBaseFoundation2, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTopAppBarBaseFoundation2, "cssClasses", {
      get: function() {
        return cssClasses;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTopAppBarBaseFoundation2, "numbers", {
      get: function() {
        return numbers;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCTopAppBarBaseFoundation2, "defaultAdapter", {
      /**
       * See {@link MDCTopAppBarAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          setStyle: function() {
            return void 0;
          },
          getTopAppBarHeight: function() {
            return 0;
          },
          notifyNavigationIconClicked: function() {
            return void 0;
          },
          getViewportScrollY: function() {
            return 0;
          },
          getTotalActionItems: function() {
            return 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCTopAppBarBaseFoundation2.prototype.handleTargetScroll = function() {
    };
    MDCTopAppBarBaseFoundation2.prototype.handleWindowResize = function() {
    };
    MDCTopAppBarBaseFoundation2.prototype.handleNavigationClick = function() {
      this.adapter.notifyNavigationIconClicked();
    };
    return MDCTopAppBarBaseFoundation2;
  }(MDCFoundation)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var INITIAL_VALUE = 0;
var MDCTopAppBarFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCTopAppBarFoundation2, _super);
    function MDCTopAppBarFoundation2(adapter) {
      var _this = _super.call(this, adapter) || this;
      _this.wasDocked = true;
      _this.isDockedShowing = true;
      _this.currentAppBarOffsetTop = 0;
      _this.isCurrentlyBeingResized = false;
      _this.resizeThrottleId = INITIAL_VALUE;
      _this.resizeDebounceId = INITIAL_VALUE;
      _this.lastScrollPosition = _this.adapter.getViewportScrollY();
      _this.topAppBarHeight = _this.adapter.getTopAppBarHeight();
      return _this;
    }
    MDCTopAppBarFoundation2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.adapter.setStyle("top", "");
    };
    MDCTopAppBarFoundation2.prototype.handleTargetScroll = function() {
      var currentScrollPosition = Math.max(this.adapter.getViewportScrollY(), 0);
      var diff = currentScrollPosition - this.lastScrollPosition;
      this.lastScrollPosition = currentScrollPosition;
      if (!this.isCurrentlyBeingResized) {
        this.currentAppBarOffsetTop -= diff;
        if (this.currentAppBarOffsetTop > 0) {
          this.currentAppBarOffsetTop = 0;
        } else if (Math.abs(this.currentAppBarOffsetTop) > this.topAppBarHeight) {
          this.currentAppBarOffsetTop = -this.topAppBarHeight;
        }
        this.moveTopAppBar();
      }
    };
    MDCTopAppBarFoundation2.prototype.handleWindowResize = function() {
      var _this = this;
      if (!this.resizeThrottleId) {
        this.resizeThrottleId = setTimeout(function() {
          _this.resizeThrottleId = INITIAL_VALUE;
          _this.throttledResizeHandler();
        }, numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
      }
      this.isCurrentlyBeingResized = true;
      if (this.resizeDebounceId) {
        clearTimeout(this.resizeDebounceId);
      }
      this.resizeDebounceId = setTimeout(function() {
        _this.handleTargetScroll();
        _this.isCurrentlyBeingResized = false;
        _this.resizeDebounceId = INITIAL_VALUE;
      }, numbers.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
    };
    MDCTopAppBarFoundation2.prototype.checkForUpdate = function() {
      var offscreenBoundaryTop = -this.topAppBarHeight;
      var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop < 0;
      var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop > offscreenBoundaryTop;
      var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen;
      if (partiallyShowing) {
        this.wasDocked = false;
      } else {
        if (!this.wasDocked) {
          this.wasDocked = true;
          return true;
        } else if (this.isDockedShowing !== hasAnyPixelsOnscreen) {
          this.isDockedShowing = hasAnyPixelsOnscreen;
          return true;
        }
      }
      return partiallyShowing;
    };
    MDCTopAppBarFoundation2.prototype.moveTopAppBar = function() {
      if (this.checkForUpdate()) {
        var offset2 = this.currentAppBarOffsetTop;
        if (Math.abs(offset2) >= this.topAppBarHeight) {
          offset2 = -numbers.MAX_TOP_APP_BAR_HEIGHT;
        }
        this.adapter.setStyle("top", offset2 + "px");
      }
    };
    MDCTopAppBarFoundation2.prototype.throttledResizeHandler = function() {
      var currentHeight = this.adapter.getTopAppBarHeight();
      if (this.topAppBarHeight !== currentHeight) {
        this.wasDocked = false;
        this.currentAppBarOffsetTop -= this.topAppBarHeight - currentHeight;
        this.topAppBarHeight = currentHeight;
      }
      this.handleTargetScroll();
    };
    return MDCTopAppBarFoundation2;
  }(MDCTopAppBarBaseFoundation)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCFixedTopAppBarFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCFixedTopAppBarFoundation2, _super);
    function MDCFixedTopAppBarFoundation2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.wasScrolled = false;
      return _this;
    }
    MDCFixedTopAppBarFoundation2.prototype.handleTargetScroll = function() {
      var currentScroll = this.adapter.getViewportScrollY();
      if (currentScroll <= 0) {
        if (this.wasScrolled) {
          this.adapter.removeClass(cssClasses.FIXED_SCROLLED_CLASS);
          this.wasScrolled = false;
        }
      } else {
        if (!this.wasScrolled) {
          this.adapter.addClass(cssClasses.FIXED_SCROLLED_CLASS);
          this.wasScrolled = true;
        }
      }
    };
    return MDCFixedTopAppBarFoundation2;
  }(MDCTopAppBarFoundation)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCShortTopAppBarFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCShortTopAppBarFoundation2, _super);
    function MDCShortTopAppBarFoundation2(adapter) {
      var _this = _super.call(this, adapter) || this;
      _this.collapsed = false;
      _this.isAlwaysCollapsed = false;
      return _this;
    }
    Object.defineProperty(MDCShortTopAppBarFoundation2.prototype, "isCollapsed", {
      // Public visibility for backward compatibility.
      get: function() {
        return this.collapsed;
      },
      enumerable: false,
      configurable: true
    });
    MDCShortTopAppBarFoundation2.prototype.init = function() {
      _super.prototype.init.call(this);
      if (this.adapter.getTotalActionItems() > 0) {
        this.adapter.addClass(cssClasses.SHORT_HAS_ACTION_ITEM_CLASS);
      }
      this.setAlwaysCollapsed(this.adapter.hasClass(cssClasses.SHORT_COLLAPSED_CLASS));
    };
    MDCShortTopAppBarFoundation2.prototype.setAlwaysCollapsed = function(value) {
      this.isAlwaysCollapsed = !!value;
      if (this.isAlwaysCollapsed) {
        this.collapse();
      } else {
        this.maybeCollapseBar();
      }
    };
    MDCShortTopAppBarFoundation2.prototype.getAlwaysCollapsed = function() {
      return this.isAlwaysCollapsed;
    };
    MDCShortTopAppBarFoundation2.prototype.handleTargetScroll = function() {
      this.maybeCollapseBar();
    };
    MDCShortTopAppBarFoundation2.prototype.maybeCollapseBar = function() {
      if (this.isAlwaysCollapsed) {
        return;
      }
      var currentScroll = this.adapter.getViewportScrollY();
      if (currentScroll <= 0) {
        if (this.collapsed) {
          this.uncollapse();
        }
      } else {
        if (!this.collapsed) {
          this.collapse();
        }
      }
    };
    MDCShortTopAppBarFoundation2.prototype.uncollapse = function() {
      this.adapter.removeClass(cssClasses.SHORT_COLLAPSED_CLASS);
      this.collapsed = false;
    };
    MDCShortTopAppBarFoundation2.prototype.collapse = function() {
      this.adapter.addClass(cssClasses.SHORT_COLLAPSED_CLASS);
      this.collapsed = true;
    };
    return MDCShortTopAppBarFoundation2;
  }(MDCTopAppBarBaseFoundation)
);
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var MDCTopAppBar = (
  /** @class */
  function(_super) {
    __extends(MDCTopAppBar2, _super);
    function MDCTopAppBar2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCTopAppBar2.attachTo = function(root) {
      return new MDCTopAppBar2(root);
    };
    MDCTopAppBar2.prototype.initialize = function(rippleFactory) {
      if (rippleFactory === void 0) {
        rippleFactory = function(el) {
          return MDCRipple.attachTo(el);
        };
      }
      this.navIcon = this.root.querySelector(strings.NAVIGATION_ICON_SELECTOR);
      var icons = [].slice.call(this.root.querySelectorAll(strings.ACTION_ITEM_SELECTOR));
      if (this.navIcon) {
        icons.push(this.navIcon);
      }
      this.iconRipples = icons.map(function(icon) {
        var ripple = rippleFactory(icon);
        ripple.unbounded = true;
        return ripple;
      });
      this.scrollTarget = window;
    };
    MDCTopAppBar2.prototype.initialSyncWithDOM = function() {
      this.handleNavigationClick = this.foundation.handleNavigationClick.bind(this.foundation);
      this.handleWindowResize = this.foundation.handleWindowResize.bind(this.foundation);
      this.handleTargetScroll = this.foundation.handleTargetScroll.bind(this.foundation);
      this.scrollTarget.addEventListener("scroll", this.handleTargetScroll);
      if (this.navIcon) {
        this.navIcon.addEventListener("click", this.handleNavigationClick);
      }
      var isFixed = this.root.classList.contains(cssClasses.FIXED_CLASS);
      var isShort = this.root.classList.contains(cssClasses.SHORT_CLASS);
      if (!isShort && !isFixed) {
        window.addEventListener("resize", this.handleWindowResize);
      }
    };
    MDCTopAppBar2.prototype.destroy = function() {
      var e_1, _a2;
      try {
        for (var _b2 = __values(this.iconRipples), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
          var iconRipple = _c2.value;
          iconRipple.destroy();
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c2 && !_c2.done && (_a2 = _b2.return)) _a2.call(_b2);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      this.scrollTarget.removeEventListener("scroll", this.handleTargetScroll);
      if (this.navIcon) {
        this.navIcon.removeEventListener("click", this.handleNavigationClick);
      }
      var isFixed = this.root.classList.contains(cssClasses.FIXED_CLASS);
      var isShort = this.root.classList.contains(cssClasses.SHORT_CLASS);
      if (!isShort && !isFixed) {
        window.removeEventListener("resize", this.handleWindowResize);
      }
      _super.prototype.destroy.call(this);
    };
    MDCTopAppBar2.prototype.setScrollTarget = function(target) {
      this.scrollTarget.removeEventListener("scroll", this.handleTargetScroll);
      this.scrollTarget = target;
      this.handleTargetScroll = this.foundation.handleTargetScroll.bind(this.foundation);
      this.scrollTarget.addEventListener("scroll", this.handleTargetScroll);
    };
    MDCTopAppBar2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        setStyle: function(property, value) {
          return _this.root.style.setProperty(property, value);
        },
        getTopAppBarHeight: function() {
          return _this.root.clientHeight;
        },
        notifyNavigationIconClicked: function() {
          return _this.emit(strings.NAVIGATION_EVENT, {});
        },
        getViewportScrollY: function() {
          var win = _this.scrollTarget;
          var el = _this.scrollTarget;
          return win.pageYOffset !== void 0 ? win.pageYOffset : el.scrollTop;
        },
        getTotalActionItems: function() {
          return _this.root.querySelectorAll(strings.ACTION_ITEM_SELECTOR).length;
        }
      };
      var foundation;
      if (this.root.classList.contains(cssClasses.SHORT_CLASS)) {
        foundation = new MDCShortTopAppBarFoundation(adapter);
      } else if (this.root.classList.contains(cssClasses.FIXED_CLASS)) {
        foundation = new MDCFixedTopAppBarFoundation(adapter);
      } else {
        foundation = new MDCTopAppBarFoundation(adapter);
      }
      return foundation;
    };
    return MDCTopAppBar2;
  }(MDCComponent)
);
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f2) {
    if (f2 !== void 0 && typeof f2 !== "function") throw new TypeError("Function expected");
    return f2;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i3 = decorators.length - 1; i3 >= 0; i3--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f2) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f2 || null));
    };
    var result = (0, decorators[i3])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_2 = accept(result.get)) descriptor.get = _2;
      if (_2 = accept(result.set)) descriptor.set = _2;
      if (_2 = accept(result.init)) initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field") initializers.unshift(_2);
      else descriptor[key] = _2;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i3 = 0; i3 < initializers.length; i3++) {
    value = useValue ? initializers[i3].call(thisArg, value) : initializers[i3].call(thisArg);
  }
  return useValue ? value : void 0;
}
typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error2, e2.suppressed = suppressed, e2;
};
let Align = (() => {
  let _classDecorators = [
    customAttribute({
      name: "align"
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _value_decorators = [
        bindable()
      ];
      __esDecorate(null, null, _value_decorators, {
        kind: "field",
        name: "value",
        static: false,
        private: false,
        access: {
          has: (obj) => "value" in obj,
          get: (obj) => obj.value,
          set: (obj, value) => {
            obj.value = value;
          }
        },
        metadata: _metadata
      }, _value_initializers, _value_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    value = __runInitializers(this, _value_initializers, void 0);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    element = (__runInitializers(this, _value_extraInitializers), resolve(INode));
    afterBind() {
      this.element.style.textAlign = this.value ?? "";
    }
    /* Example of change detection */
    valueChanged() {
      this.afterBind();
    }
  });
  return _classThis;
})();
let FullHeight = (() => {
  let _classDecorators = [
    customAttribute({
      name: "full-height"
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    element = resolve(INode);
    constructor() {
      this.element.style.height = "100%";
    }
  });
  return _classThis;
})();
let FullWidth = (() => {
  let _classDecorators = [
    customAttribute({
      name: "full-width"
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    element = resolve(INode);
    constructor() {
      this.element.style.width = "100%";
    }
  });
  return _classThis;
})();
let Link = (() => {
  let _classDecorators = [
    customAttribute({
      name: "link",
      noMultiBindings: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _value_decorators = [
        bindable
      ];
      __esDecorate(null, null, _value_decorators, {
        kind: "field",
        name: "value",
        static: false,
        private: false,
        access: {
          has: (obj) => "value" in obj,
          get: (obj) => obj.value,
          set: (obj, value) => {
            obj.value = value;
          }
        },
        metadata: _metadata
      }, _value_initializers, _value_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    value = __runInitializers(this, _value_initializers, "");
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    element = (__runInitializers(this, _value_extraInitializers), resolve(INode));
    platform = resolve(IPlatform$1);
    constructor() {
      this.element.addEventListener("mousedown", this.clickEvent);
    }
    clickEvent = () => {
      this.platform.window.open(this.value, "_blank");
    };
    detaching() {
      this.element.removeEventListener("mousedown", this.clickEvent);
    }
  });
  return _classThis;
})();
let Underline = (() => {
  let _classDecorators = [
    customAttribute({
      name: "underline"
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    element = resolve(INode);
    constructor() {
      this.element.style.textDecoration = "underline";
    }
  });
  return _classThis;
})();
let Elevation2 = (() => {
  let _classDecorators = [
    customAttribute({
      name: "elevation"
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _value_decorators = [
        bindable()
      ];
      __esDecorate(null, null, _value_decorators, {
        kind: "field",
        name: "value",
        static: false,
        private: false,
        access: {
          has: (obj) => "value" in obj,
          get: (obj) => obj.value,
          set: (obj, value) => {
            obj.value = value;
          }
        },
        metadata: _metadata
      }, _value_initializers, _value_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    value = __runInitializers(this, _value_initializers, void 0);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-expect-error
    element = (__runInitializers(this, _value_extraInitializers), resolve(INode));
    constructor() {
      this.element.style.boxShadow = "0 8px 12px rgba(0, 0, 0, 0.1), 0 2px 6px rgba(0, 0, 0, 0.08)";
      this.element.style.borderRadius = "5px";
    }
  });
  return _classThis;
})();
const attributes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Align,
  Elevation: Elevation2,
  FullHeight,
  FullWidth,
  Link,
  Underline
}, Symbol.toStringTag, { value: "Module" }));
const IBetsyWebComponentsConfiguration = DI.createInterface("IBetsyWebComponentsConfiguration");
const template$r = '<div class="accordion-item ${extraAccordionClasses}" ref="accordionItemEl" ...$attrs>\r\n    <div class="accordion-header" tabindex="0" ref="accordionHeaderEl">\r\n        <span>${header}</span>\r\n    </div>\r\n    <div class="accordion-content">\r\n        <au-slot></au-slot>\r\n    </div>\r\n</div>\r\n';
let MooAccordion = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-accordion",
      template: template$r,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _header_decorators;
  let _header_initializers = [];
  let _header_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _header_decorators = [
        bindable
      ];
      __esDecorate(null, null, _header_decorators, {
        kind: "field",
        name: "header",
        static: false,
        private: false,
        access: {
          has: (obj) => "header" in obj,
          get: (obj) => obj.header,
          set: (obj, value) => {
            obj.header = value;
          }
        },
        metadata: _metadata
      }, _header_initializers, _header_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    header = __runInitializers(this, _header_initializers, void 0);
    accordionItemEl = __runInitializers(this, _header_extraInitializers);
    accordionHeaderEl;
    closeAllOtherAccordions(element) {
      const accordionHeaders = document.querySelectorAll(".accordion-header");
      accordionHeaders.forEach((header) => {
        if (header !== element) {
          header.parentElement.classList.remove("accordion-expanded");
          header.nextElementSibling.style.maxHeight = 0;
        }
      });
    }
    attached() {
      this.accordionHeaderEl.addEventListener("click", () => {
        const content = this.accordionHeaderEl.nextElementSibling;
        const isOpen = this.accordionHeaderEl.parentElement.classList.contains("accordion-expanded");
        this.closeAllOtherAccordions(this.accordionHeaderEl);
        if (isOpen) {
          content.style.maxHeight = "0";
        } else {
          content.style.maxHeight = content.scrollHeight + 50 + "px";
        }
        this.accordionHeaderEl.parentElement.classList.toggle("accordion-expanded");
      });
    }
  });
  return _classThis;
})();
const template$q = '<div class="mdc-banner" role="banner" ref="bannerEl">\r\n    <div class="mdc-banner__content"\r\n         role="alertdialog"\r\n         aria-live="assertive">\r\n        <div class="mdc-banner__graphic-text-wrapper">\r\n            <div class="mdc-banner__text">\r\n                <au-slot></au-slot>\r\n            </div>\r\n        </div>\r\n        <div class="mdc-banner__actions">\r\n            <moo-button type="button" class="mdc-banner__secondary-action" if.bind="secondaryAction" click.trigger="handleSecondaryClicked()">\r\n                <div class="mdc-button__ripple"></div>\r\n                <div class="mdc-button__label">\r\n                    ${secondaryAction}\r\n                </div>\r\n            </moo-button>\r\n            <moo-button type="button" class="mdc-banner__primary-action" if.bind="primaryAction" click.trigger="handlePrimaryClicked()">\r\n                <div class="mdc-button__ripple"></div>\r\n                <div class="mdc-button__label">\r\n                    ${primaryAction}\r\n                </div>\r\n            </moo-button>\r\n        </div>\r\n    </div>\r\n</div>\r\n';
let MooBanner = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-banner",
      template: template$q,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _instanceExtraInitializers = [];
  let _primaryAction_decorators;
  let _primaryAction_initializers = [];
  let _primaryAction_extraInitializers = [];
  let _secondaryAction_decorators;
  let _secondaryAction_initializers = [];
  let _secondaryAction_extraInitializers = [];
  let _secondaryClicked_decorators;
  let _secondaryClicked_initializers = [];
  let _secondaryClicked_extraInitializers = [];
  let _primaryClicked_decorators;
  let _primaryClicked_initializers = [];
  let _primaryClicked_extraInitializers = [];
  let _open_decorators;
  let _open_initializers = [];
  let _open_extraInitializers = [];
  let _openChanged_decorators;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _primaryAction_decorators = [
        bindable
      ];
      _secondaryAction_decorators = [
        bindable
      ];
      _secondaryClicked_decorators = [
        bindable
      ];
      _primaryClicked_decorators = [
        bindable
      ];
      _open_decorators = [
        bindable({
          mode: BindingMode.twoWay
        })
      ];
      _openChanged_decorators = [
        watch("open")
      ];
      __esDecorate(this, null, _openChanged_decorators, {
        kind: "method",
        name: "openChanged",
        static: false,
        private: false,
        access: {
          has: (obj) => "openChanged" in obj,
          get: (obj) => obj.openChanged
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate(null, null, _primaryAction_decorators, {
        kind: "field",
        name: "primaryAction",
        static: false,
        private: false,
        access: {
          has: (obj) => "primaryAction" in obj,
          get: (obj) => obj.primaryAction,
          set: (obj, value) => {
            obj.primaryAction = value;
          }
        },
        metadata: _metadata
      }, _primaryAction_initializers, _primaryAction_extraInitializers);
      __esDecorate(null, null, _secondaryAction_decorators, {
        kind: "field",
        name: "secondaryAction",
        static: false,
        private: false,
        access: {
          has: (obj) => "secondaryAction" in obj,
          get: (obj) => obj.secondaryAction,
          set: (obj, value) => {
            obj.secondaryAction = value;
          }
        },
        metadata: _metadata
      }, _secondaryAction_initializers, _secondaryAction_extraInitializers);
      __esDecorate(null, null, _secondaryClicked_decorators, {
        kind: "field",
        name: "secondaryClicked",
        static: false,
        private: false,
        access: {
          has: (obj) => "secondaryClicked" in obj,
          get: (obj) => obj.secondaryClicked,
          set: (obj, value) => {
            obj.secondaryClicked = value;
          }
        },
        metadata: _metadata
      }, _secondaryClicked_initializers, _secondaryClicked_extraInitializers);
      __esDecorate(null, null, _primaryClicked_decorators, {
        kind: "field",
        name: "primaryClicked",
        static: false,
        private: false,
        access: {
          has: (obj) => "primaryClicked" in obj,
          get: (obj) => obj.primaryClicked,
          set: (obj, value) => {
            obj.primaryClicked = value;
          }
        },
        metadata: _metadata
      }, _primaryClicked_initializers, _primaryClicked_extraInitializers);
      __esDecorate(null, null, _open_decorators, {
        kind: "field",
        name: "open",
        static: false,
        private: false,
        access: {
          has: (obj) => "open" in obj,
          get: (obj) => obj.open,
          set: (obj, value) => {
            obj.open = value;
          }
        },
        metadata: _metadata
      }, _open_initializers, _open_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    primaryAction = (__runInitializers(this, _instanceExtraInitializers), __runInitializers(this, _primaryAction_initializers, void 0));
    secondaryAction = (__runInitializers(this, _primaryAction_extraInitializers), __runInitializers(this, _secondaryAction_initializers, void 0));
    secondaryClicked = (__runInitializers(this, _secondaryAction_extraInitializers), __runInitializers(this, _secondaryClicked_initializers, void 0));
    primaryClicked = (__runInitializers(this, _secondaryClicked_extraInitializers), __runInitializers(this, _primaryClicked_initializers, void 0));
    open = (__runInitializers(this, _primaryClicked_extraInitializers), __runInitializers(this, _open_initializers, void 0));
    bannerEl = __runInitializers(this, _open_extraInitializers);
    banner;
    attached() {
      this.banner = new MDCBanner(this.bannerEl);
      if (this.open) {
        this.banner.open();
      }
    }
    handlePrimaryClicked() {
      if (this.primaryClicked) {
        this.primaryClicked();
      }
    }
    handleSecondaryClicked() {
      if (this.secondaryClicked) {
        this.secondaryClicked();
      }
    }
    openChanged() {
      if (this.open) {
        this.banner.open();
      } else {
        this.banner.close(CloseReason.PRIMARY);
      }
    }
  });
  return _classThis;
})();
const template$p = `<md-filled-button\r
    ...$attrs\r
    if.bind="variant === 'filled'"\r
    disabled.bind="disabled"\r
    data-mdc-dialog-action.bind="dataMdcDialogAction"\r
>\r
    <au-slot></au-slot>\r
</md-filled-button>\r
\r
<md-filled-tonal-button\r
        ...$attrs\r
        if.bind="variant === 'filled-tonal'"\r
        disabled.bind="disabled"\r
        data-mdc-dialog-action.bind="dataMdcDialogAction"\r
>\r
    <au-slot></au-slot>\r
</md-filled-tonal-button>\r
\r
<md-outlined-button\r
    ...$attrs\r
    if.bind="variant === 'outlined'"\r
    disabled.bind="disabled"\r
    data-mdc-dialog-action.bind="dataMdcDialogAction"\r
>\r
    <au-slot></au-slot>\r
</md-outlined-button>\r
\r
<md-text-button\r
    ...$attrs\r
    if.bind="variant === 'text'"\r
    disabled.bind="disabled"\r
    data-mdc-dialog-action.bind="dataMdcDialogAction"\r
>\r
    <au-slot></au-slot>\r
</md-text-button>\r
\r
<md-elevated-button\r
    ...$attrs\r
    if.bind="variant === 'elevated'"\r
    disabled.bind="disabled"\r
    data-mdc-dialog-action.bind="dataMdcDialogAction"\r
>\r
    <au-slot></au-slot>\r
</md-elevated-button>\r
`;
let MooButton = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-button",
      template: template$p,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _label_decorators;
  let _label_initializers = [];
  let _label_extraInitializers = [];
  let _variant_decorators;
  let _variant_initializers = [];
  let _variant_extraInitializers = [];
  let _icon_decorators;
  let _icon_initializers = [];
  let _icon_extraInitializers = [];
  let _click_decorators;
  let _click_initializers = [];
  let _click_extraInitializers = [];
  let _dataMdcDialogAction_decorators;
  let _dataMdcDialogAction_initializers = [];
  let _dataMdcDialogAction_extraInitializers = [];
  let _disabled_decorators;
  let _disabled_initializers = [];
  let _disabled_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _label_decorators = [
        bindable
      ];
      _variant_decorators = [
        bindable
      ];
      _icon_decorators = [
        bindable
      ];
      _click_decorators = [
        bindable
      ];
      _dataMdcDialogAction_decorators = [
        bindable
      ];
      _disabled_decorators = [
        bindable
      ];
      __esDecorate(null, null, _label_decorators, {
        kind: "field",
        name: "label",
        static: false,
        private: false,
        access: {
          has: (obj) => "label" in obj,
          get: (obj) => obj.label,
          set: (obj, value) => {
            obj.label = value;
          }
        },
        metadata: _metadata
      }, _label_initializers, _label_extraInitializers);
      __esDecorate(null, null, _variant_decorators, {
        kind: "field",
        name: "variant",
        static: false,
        private: false,
        access: {
          has: (obj) => "variant" in obj,
          get: (obj) => obj.variant,
          set: (obj, value) => {
            obj.variant = value;
          }
        },
        metadata: _metadata
      }, _variant_initializers, _variant_extraInitializers);
      __esDecorate(null, null, _icon_decorators, {
        kind: "field",
        name: "icon",
        static: false,
        private: false,
        access: {
          has: (obj) => "icon" in obj,
          get: (obj) => obj.icon,
          set: (obj, value) => {
            obj.icon = value;
          }
        },
        metadata: _metadata
      }, _icon_initializers, _icon_extraInitializers);
      __esDecorate(null, null, _click_decorators, {
        kind: "field",
        name: "click",
        static: false,
        private: false,
        access: {
          has: (obj) => "click" in obj,
          get: (obj) => obj.click,
          set: (obj, value) => {
            obj.click = value;
          }
        },
        metadata: _metadata
      }, _click_initializers, _click_extraInitializers);
      __esDecorate(null, null, _dataMdcDialogAction_decorators, {
        kind: "field",
        name: "dataMdcDialogAction",
        static: false,
        private: false,
        access: {
          has: (obj) => "dataMdcDialogAction" in obj,
          get: (obj) => obj.dataMdcDialogAction,
          set: (obj, value) => {
            obj.dataMdcDialogAction = value;
          }
        },
        metadata: _metadata
      }, _dataMdcDialogAction_initializers, _dataMdcDialogAction_extraInitializers);
      __esDecorate(null, null, _disabled_decorators, {
        kind: "field",
        name: "disabled",
        static: false,
        private: false,
        access: {
          has: (obj) => "disabled" in obj,
          get: (obj) => obj.disabled,
          set: (obj, value) => {
            obj.disabled = value;
          }
        },
        metadata: _metadata
      }, _disabled_initializers, _disabled_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    button;
    label = __runInitializers(this, _label_initializers, void 0);
    variant = (__runInitializers(this, _label_extraInitializers), __runInitializers(this, _variant_initializers, "filled"));
    icon = (__runInitializers(this, _variant_extraInitializers), __runInitializers(this, _icon_initializers, void 0));
    click = (__runInitializers(this, _icon_extraInitializers), __runInitializers(this, _click_initializers, void 0));
    dataMdcDialogAction = (__runInitializers(this, _click_extraInitializers), __runInitializers(this, _dataMdcDialogAction_initializers, void 0));
    disabled = (__runInitializers(this, _dataMdcDialogAction_extraInitializers), __runInitializers(this, _disabled_initializers, false));
    constructor() {
      __runInitializers(this, _disabled_extraInitializers);
    }
  });
  return _classThis;
})();
const template$o = "<md-icon-button ...$attrs>\r\n    <au-slot></au-slot>\r\n</md-icon-button>\r\n";
let MooButtonIcon = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-button-icon",
      template: template$o,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
  });
  return _classThis;
})();
const template$n = '<div class="card">\r\n    <au-slot></au-slot>\r\n</div>\r\n';
let MooCard = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-banner",
      template: template$n,
      containerless: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _outlined_decorators;
  let _outlined_initializers = [];
  let _outlined_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _outlined_decorators = [
        bindable
      ];
      __esDecorate(null, null, _outlined_decorators, {
        kind: "field",
        name: "outlined",
        static: false,
        private: false,
        access: {
          has: (obj) => "outlined" in obj,
          get: (obj) => obj.outlined,
          set: (obj, value) => {
            obj.outlined = value;
          }
        },
        metadata: _metadata
      }, _outlined_initializers, _outlined_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    outlined = __runInitializers(this, _outlined_initializers, void 0);
    constructor() {
      __runInitializers(this, _outlined_extraInitializers);
    }
  });
  return _classThis;
})();
const template$m = '<div class="card-content">\r\n    <au-slot></au-slot>\r\n</div>\r\n';
let MooCardContent = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-card-content",
      template: template$m,
      containerless: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _outlined_decorators;
  let _outlined_initializers = [];
  let _outlined_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _outlined_decorators = [
        bindable
      ];
      __esDecorate(null, null, _outlined_decorators, {
        kind: "field",
        name: "outlined",
        static: false,
        private: false,
        access: {
          has: (obj) => "outlined" in obj,
          get: (obj) => obj.outlined,
          set: (obj, value) => {
            obj.outlined = value;
          }
        },
        metadata: _metadata
      }, _outlined_initializers, _outlined_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    outlined = __runInitializers(this, _outlined_initializers, void 0);
    constructor() {
      __runInitializers(this, _outlined_extraInitializers);
    }
  });
  return _classThis;
})();
const template$l = '<div class="card-footer">\r\n    <au-slot></au-slot>\r\n</div>\r\n';
let MooCardFooter = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-card-footer",
      template: template$l,
      containerless: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _outlined_decorators;
  let _outlined_initializers = [];
  let _outlined_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _outlined_decorators = [
        bindable
      ];
      __esDecorate(null, null, _outlined_decorators, {
        kind: "field",
        name: "outlined",
        static: false,
        private: false,
        access: {
          has: (obj) => "outlined" in obj,
          get: (obj) => obj.outlined,
          set: (obj, value) => {
            obj.outlined = value;
          }
        },
        metadata: _metadata
      }, _outlined_initializers, _outlined_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    outlined = __runInitializers(this, _outlined_initializers, void 0);
    constructor() {
      __runInitializers(this, _outlined_extraInitializers);
    }
  });
  return _classThis;
})();
const template$k = '<div class="card-header">\r\n    <au-slot></au-slot>\r\n</div>\r\n';
let MooCardHeader = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-card-header",
      template: template$k,
      containerless: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _outlined_decorators;
  let _outlined_initializers = [];
  let _outlined_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _outlined_decorators = [
        bindable
      ];
      __esDecorate(null, null, _outlined_decorators, {
        kind: "field",
        name: "outlined",
        static: false,
        private: false,
        access: {
          has: (obj) => "outlined" in obj,
          get: (obj) => obj.outlined,
          set: (obj, value) => {
            obj.outlined = value;
          }
        },
        metadata: _metadata
      }, _outlined_initializers, _outlined_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    outlined = __runInitializers(this, _outlined_initializers, void 0);
    constructor() {
      __runInitializers(this, _outlined_extraInitializers);
    }
  });
  return _classThis;
})();
const template$j = '<label ...$attrs class="moo-checkbox_align-center">\r\n    <md-checkbox touch-target="wrapper" checked.bind="checked" value.bind="value" click.trigger="() => handleChange()"></md-checkbox>\r\n    <au-slot></au-slot>\r\n</label>\r\n';
let MooCheckbox = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-checkbox",
      template: template$j,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _checked_decorators;
  let _checked_initializers = [];
  let _checked_extraInitializers = [];
  let _changed_decorators;
  let _changed_initializers = [];
  let _changed_extraInitializers = [];
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _checked_decorators = [
        bindable({
          mode: BindingMode.twoWay
        })
      ];
      _changed_decorators = [
        bindable
      ];
      _value_decorators = [
        bindable({
          mode: BindingMode.twoWay
        })
      ];
      __esDecorate(null, null, _checked_decorators, {
        kind: "field",
        name: "checked",
        static: false,
        private: false,
        access: {
          has: (obj) => "checked" in obj,
          get: (obj) => obj.checked,
          set: (obj, value) => {
            obj.checked = value;
          }
        },
        metadata: _metadata
      }, _checked_initializers, _checked_extraInitializers);
      __esDecorate(null, null, _changed_decorators, {
        kind: "field",
        name: "changed",
        static: false,
        private: false,
        access: {
          has: (obj) => "changed" in obj,
          get: (obj) => obj.changed,
          set: (obj, value) => {
            obj.changed = value;
          }
        },
        metadata: _metadata
      }, _changed_initializers, _changed_extraInitializers);
      __esDecorate(null, null, _value_decorators, {
        kind: "field",
        name: "value",
        static: false,
        private: false,
        access: {
          has: (obj) => "value" in obj,
          get: (obj) => obj.value,
          set: (obj, value) => {
            obj.value = value;
          }
        },
        metadata: _metadata
      }, _value_initializers, _value_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    checked = __runInitializers(this, _checked_initializers, void 0);
    changed = (__runInitializers(this, _checked_extraInitializers), __runInitializers(this, _changed_initializers, void 0));
    value = (__runInitializers(this, _changed_extraInitializers), __runInitializers(this, _value_initializers, void 0));
    handleChange() {
      this.checked = !this.checked;
      if (this.changed) {
        this.changed(this.value, this.checked);
      }
    }
    constructor() {
      __runInitializers(this, _value_extraInitializers);
    }
  });
  return _classThis;
})();
const template$i = `<md-assist-chip ...$attrs if.bind="variant === 'assist'" ref="chipEl">\r
    <au-slot></au-slot>\r
</md-assist-chip>\r
\r
<md-filter-chip ...$attrs if.bind="variant === 'filter'" ref="chipEl">\r
    <au-slot></au-slot>\r
</md-filter-chip>\r
\r
<md-input-chip ...$attrs if.bind="variant === 'input'" ref="chipEl">\r
    <au-slot></au-slot>\r
</md-input-chip>\r
\r
<md-suggestion-chip ...$attrs if.bind="variant === 'suggestion'" ref="chipEl">\r
    <au-slot></au-slot>\r
</md-suggestion-chip>\r
`;
let MooChip = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-chip",
      template: template$i,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _variant_decorators;
  let _variant_initializers = [];
  let _variant_extraInitializers = [];
  let _remove_decorators;
  let _remove_initializers = [];
  let _remove_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _variant_decorators = [
        bindable
      ];
      _remove_decorators = [
        bindable
      ];
      __esDecorate(null, null, _variant_decorators, {
        kind: "field",
        name: "variant",
        static: false,
        private: false,
        access: {
          has: (obj) => "variant" in obj,
          get: (obj) => obj.variant,
          set: (obj, value) => {
            obj.variant = value;
          }
        },
        metadata: _metadata
      }, _variant_initializers, _variant_extraInitializers);
      __esDecorate(null, null, _remove_decorators, {
        kind: "field",
        name: "remove",
        static: false,
        private: false,
        access: {
          has: (obj) => "remove" in obj,
          get: (obj) => obj.remove,
          set: (obj, value) => {
            obj.remove = value;
          }
        },
        metadata: _metadata
      }, _remove_initializers, _remove_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    variant = __runInitializers(this, _variant_initializers, "input");
    remove = (__runInitializers(this, _variant_extraInitializers), __runInitializers(this, _remove_initializers, void 0));
    chipEl = __runInitializers(this, _remove_extraInitializers);
    attached() {
      this.chipEl.addEventListener("remove", () => this.handleRemove());
    }
    handleRemove() {
      if (this.remove) {
        this.remove();
      }
    }
  });
  return _classThis;
})();
const template$h = "<md-chip-set ...$attrs>\r\n    <au-slot></au-slot>\r\n</md-chip-set>\r\n";
let MooChipSet = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-chip-set",
      template: template$h,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
  });
  return _classThis;
})();
const template$g = '<div class="mdc-dialog" ref="dialogEl">\r\n    <div class="mdc-dialog__container">\r\n        <div class="mdc-dialog__surface"\r\n             role="alertdialog"\r\n             aria-modal="true"\r\n             aria-labelledby="my-dialog-title"\r\n             aria-describedby="my-dialog-content">\r\n            <h2 class="mdc-dialog__title" id="my-dialog-title" if.bind="title">${title}</h2>\r\n            <div class="mdc-dialog__content" id="my-dialog-content">\r\n                <au-slot></au-slot>\r\n            </div>\r\n            <div class="mdc-dialog__actions">\r\n                <moo-button type="button" data-mdc-dialog-action="cancel">\r\n                    Cancel\r\n                </moo-button>\r\n                <moo-button type="button" data-mdc-dialog-action="ok" class="ms-3">\r\n                    Confirm\r\n                </moo-button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n    <div class="mdc-dialog__scrim"></div>\r\n</div>\r\n';
let MooDialog = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-dialog",
      template: template$g,
      containerless: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _dialogEl_decorators;
  let _dialogEl_initializers = [];
  let _dialogEl_extraInitializers = [];
  let _dialog_decorators;
  let _dialog_initializers = [];
  let _dialog_extraInitializers = [];
  let _handler_decorators;
  let _handler_initializers = [];
  let _handler_extraInitializers = [];
  let _title_decorators;
  let _title_initializers = [];
  let _title_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _dialogEl_decorators = [
        bindable
      ];
      _dialog_decorators = [
        bindable({
          mode: BindingMode.twoWay
        })
      ];
      _handler_decorators = [
        bindable
      ];
      _title_decorators = [
        bindable
      ];
      __esDecorate(null, null, _dialogEl_decorators, {
        kind: "field",
        name: "dialogEl",
        static: false,
        private: false,
        access: {
          has: (obj) => "dialogEl" in obj,
          get: (obj) => obj.dialogEl,
          set: (obj, value) => {
            obj.dialogEl = value;
          }
        },
        metadata: _metadata
      }, _dialogEl_initializers, _dialogEl_extraInitializers);
      __esDecorate(null, null, _dialog_decorators, {
        kind: "field",
        name: "dialog",
        static: false,
        private: false,
        access: {
          has: (obj) => "dialog" in obj,
          get: (obj) => obj.dialog,
          set: (obj, value) => {
            obj.dialog = value;
          }
        },
        metadata: _metadata
      }, _dialog_initializers, _dialog_extraInitializers);
      __esDecorate(null, null, _handler_decorators, {
        kind: "field",
        name: "handler",
        static: false,
        private: false,
        access: {
          has: (obj) => "handler" in obj,
          get: (obj) => obj.handler,
          set: (obj, value) => {
            obj.handler = value;
          }
        },
        metadata: _metadata
      }, _handler_initializers, _handler_extraInitializers);
      __esDecorate(null, null, _title_decorators, {
        kind: "field",
        name: "title",
        static: false,
        private: false,
        access: {
          has: (obj) => "title" in obj,
          get: (obj) => obj.title,
          set: (obj, value) => {
            obj.title = value;
          }
        },
        metadata: _metadata
      }, _title_initializers, _title_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    dialogEl = __runInitializers(this, _dialogEl_initializers, void 0);
    dialog = (__runInitializers(this, _dialogEl_extraInitializers), __runInitializers(this, _dialog_initializers, void 0));
    handler = (__runInitializers(this, _dialog_extraInitializers), __runInitializers(this, _handler_initializers, void 0));
    title = (__runInitializers(this, _handler_extraInitializers), __runInitializers(this, _title_initializers, void 0));
    attached() {
      this.dialog = new MDCDialog(this.dialogEl);
      this.dialog.listen("MDCDialog:closed", (e2) => {
        if (this.handler) {
          this.handler(e2);
        }
      });
    }
    constructor() {
      __runInitializers(this, _title_extraInitializers);
    }
  });
  return _classThis;
})();
const template$f = '<div if.bind="!open">\r\n    <moo-fab click.trigger="() => open = true" class="bottomRight">\r\n        <moo-icon>chevron_right</moo-icon>\r\n    </moo-fab>\r\n</div>\r\n<aside class="mdc-drawer mdc-drawer--dismissible" ref="drawerEl">\r\n    <div class="close-icon">\r\n        <moo-fab click.trigger="() => open = false" class="topRight">\r\n            <moo-icon>chevron_left</moo-icon>\r\n        </moo-fab>\r\n    </div>\r\n    <div class="mdc-drawer__content">\r\n        <au-slot></au-slot>\r\n    </div>\r\n</aside>\r\n';
let MooDrawer = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-drawer",
      template: template$f,
      containerless: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _open_decorators;
  let _open_initializers = [];
  let _open_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _open_decorators = [
        bindable
      ];
      __esDecorate(null, null, _open_decorators, {
        kind: "field",
        name: "open",
        static: false,
        private: false,
        access: {
          has: (obj) => "open" in obj,
          get: (obj) => obj.open,
          set: (obj, value) => {
            obj.open = value;
          }
        },
        metadata: _metadata
      }, _open_initializers, _open_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    open = __runInitializers(this, _open_initializers, void 0);
    drawerEl = __runInitializers(this, _open_extraInitializers);
    drawer;
    didAttach = false;
    attached() {
      if (!this.didAttach) {
        this.drawer = MDCDrawer.attachTo(this.drawerEl);
        this.drawer.open = this.open;
        this.didAttach = true;
      }
    }
    openChanged() {
      this.drawer.open = this.open;
    }
  });
  return _classThis;
})();
const template$e = '<a if.bind="url" href.bind="url" ...$attrs>\r\n    <md-fab variant.bind="variant" label.bind="label">\r\n        <au-slot></au-slot>\r\n    </md-fab>\r\n</a>\r\n<md-fab else ...$attrs variant.bind="variant" label.bind="label">\r\n    <au-slot></au-slot>\r\n</md-fab>\r\n';
let MooFab = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-fab",
      template: template$e,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _url_decorators;
  let _url_initializers = [];
  let _url_extraInitializers = [];
  let _variant_decorators;
  let _variant_initializers = [];
  let _variant_extraInitializers = [];
  let _label_decorators;
  let _label_initializers = [];
  let _label_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _url_decorators = [
        bindable
      ];
      _variant_decorators = [
        bindable
      ];
      _label_decorators = [
        bindable
      ];
      __esDecorate(null, null, _url_decorators, {
        kind: "field",
        name: "url",
        static: false,
        private: false,
        access: {
          has: (obj) => "url" in obj,
          get: (obj) => obj.url,
          set: (obj, value) => {
            obj.url = value;
          }
        },
        metadata: _metadata
      }, _url_initializers, _url_extraInitializers);
      __esDecorate(null, null, _variant_decorators, {
        kind: "field",
        name: "variant",
        static: false,
        private: false,
        access: {
          has: (obj) => "variant" in obj,
          get: (obj) => obj.variant,
          set: (obj, value) => {
            obj.variant = value;
          }
        },
        metadata: _metadata
      }, _variant_initializers, _variant_extraInitializers);
      __esDecorate(null, null, _label_decorators, {
        kind: "field",
        name: "label",
        static: false,
        private: false,
        access: {
          has: (obj) => "label" in obj,
          get: (obj) => obj.label,
          set: (obj, value) => {
            obj.label = value;
          }
        },
        metadata: _metadata
      }, _label_initializers, _label_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    url = __runInitializers(this, _url_initializers, void 0);
    variant = (__runInitializers(this, _url_extraInitializers), __runInitializers(this, _variant_initializers, void 0));
    label = (__runInitializers(this, _variant_extraInitializers), __runInitializers(this, _label_initializers, void 0));
    constructor() {
      __runInitializers(this, _label_extraInitializers);
    }
  });
  return _classThis;
})();
const template$d = '<div class="mdc-form-field" ref="formFieldEl">\r\n    <au-slot></au-slot>\r\n    <label>${label}</label>\r\n</div>\r\n';
let MooFormField = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-form-field",
      template: template$d,
      containerless: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _label_decorators;
  let _label_initializers = [];
  let _label_extraInitializers = [];
  let _options_decorators;
  let _options_initializers = [];
  let _options_extraInitializers = [];
  let _class_decorators;
  let _class_initializers = [];
  let _class_extraInitializers = [];
  let _disabled_decorators;
  let _disabled_initializers = [];
  let _disabled_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _label_decorators = [
        bindable
      ];
      _options_decorators = [
        bindable
      ];
      _class_decorators = [
        bindable
      ];
      _disabled_decorators = [
        bindable
      ];
      __esDecorate(null, null, _label_decorators, {
        kind: "field",
        name: "label",
        static: false,
        private: false,
        access: {
          has: (obj) => "label" in obj,
          get: (obj) => obj.label,
          set: (obj, value) => {
            obj.label = value;
          }
        },
        metadata: _metadata
      }, _label_initializers, _label_extraInitializers);
      __esDecorate(null, null, _options_decorators, {
        kind: "field",
        name: "options",
        static: false,
        private: false,
        access: {
          has: (obj) => "options" in obj,
          get: (obj) => obj.options,
          set: (obj, value) => {
            obj.options = value;
          }
        },
        metadata: _metadata
      }, _options_initializers, _options_extraInitializers);
      __esDecorate(null, null, _class_decorators, {
        kind: "field",
        name: "class",
        static: false,
        private: false,
        access: {
          has: (obj) => "class" in obj,
          get: (obj) => obj.class,
          set: (obj, value) => {
            obj.class = value;
          }
        },
        metadata: _metadata
      }, _class_initializers, _class_extraInitializers);
      __esDecorate(null, null, _disabled_decorators, {
        kind: "field",
        name: "disabled",
        static: false,
        private: false,
        access: {
          has: (obj) => "disabled" in obj,
          get: (obj) => obj.disabled,
          set: (obj, value) => {
            obj.disabled = value;
          }
        },
        metadata: _metadata
      }, _disabled_initializers, _disabled_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    label = __runInitializers(this, _label_initializers, void 0);
    options = (__runInitializers(this, _label_extraInitializers), __runInitializers(this, _options_initializers, void 0));
    class = (__runInitializers(this, _options_extraInitializers), __runInitializers(this, _class_initializers, void 0));
    disabled = (__runInitializers(this, _class_extraInitializers), __runInitializers(this, _disabled_initializers, void 0));
    formFieldEl = __runInitializers(this, _disabled_extraInitializers);
    formField;
    attached() {
      this.formField = new MDCFormField(this.formFieldEl);
    }
  });
  return _classThis;
})();
const template$c = '<md-icon slot="icon">\r\n    <au-slot></au-slot>\r\n</md-icon>\r\n';
let MooIcon = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-icon",
      template: template$c,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
  });
  return _classThis;
})();
const template$b = "<md-list ...$attrs>\r\n    <au-slot></au-slot>\r\n</md-list>\r\n";
let MooList = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-list",
      template: template$b,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
  });
  return _classThis;
})();
const template$a = '<a ...$attrs load="${route}" if.bind="route">\r\n    <md-list-item>\r\n        <au-slot></au-slot>\r\n    </md-list-item>\r\n</a>\r\n<md-list-item ...$attrs else>\r\n    <au-slot></au-slot>\r\n</md-list-item>\r\n';
let MooListItem = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-list-item",
      template: template$a,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _route_decorators;
  let _route_initializers = [];
  let _route_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _route_decorators = [
        bindable
      ];
      __esDecorate(null, null, _route_decorators, {
        kind: "field",
        name: "route",
        static: false,
        private: false,
        access: {
          has: (obj) => "route" in obj,
          get: (obj) => obj.route,
          set: (obj, value) => {
            obj.route = value;
          }
        },
        metadata: _metadata
      }, _route_initializers, _route_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    route = __runInitializers(this, _route_initializers, void 0);
    constructor() {
      __runInitializers(this, _route_extraInitializers);
    }
  });
  return _classThis;
})();
const template$9 = "<md-menu ...$attrs>\r\n    <au-slot></au-slot>\r\n</md-menu>\r\n";
let MooMenu = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-menu",
      template: template$9,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
  });
  return _classThis;
})();
const template$8 = '<md-menu-item ...$attrs>\r\n    <div slot="headline">\r\n        <au-slot></au-slot>\r\n    </div>\r\n</md-menu-item>\r\n';
let MooMenuItem = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-menu-item",
      template: template$8,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
  });
  return _classThis;
})();
const template$7 = `<md-circular-progress ...$attrs if.bind="variant === 'circular'"></md-circular-progress>\r
<md-linear-progress ...$attrs if.bind="variant === 'linear'"></md-linear-progress>\r
`;
let MooProgress = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-progress",
      template: template$7,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _variant_decorators;
  let _variant_initializers = [];
  let _variant_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _variant_decorators = [
        bindable
      ];
      __esDecorate(null, null, _variant_decorators, {
        kind: "field",
        name: "variant",
        static: false,
        private: false,
        access: {
          has: (obj) => "variant" in obj,
          get: (obj) => obj.variant,
          set: (obj, value) => {
            obj.variant = value;
          }
        },
        metadata: _metadata
      }, _variant_initializers, _variant_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    variant = __runInitializers(this, _variant_initializers, "circular");
    constructor() {
      __runInitializers(this, _variant_extraInitializers);
    }
  });
  return _classThis;
})();
const template$6 = '<div class="mdc-radio" ref="radioEl">\r\n    <input class="mdc-radio__native-control" type="radio" name="radios" checked.bind="checked" disabled.bind="disabled">\r\n    <div class="mdc-radio__background">\r\n        <div class="mdc-radio__outer-circle"></div>\r\n        <div class="mdc-radio__inner-circle"></div>\r\n    </div>\r\n    <div class="mdc-radio__ripple"></div>\r\n    <div class="mdc-radio__focus-ring"></div>\r\n</div>\r\n';
let MooRadio = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-radio",
      template: template$6,
      containerless: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _instanceExtraInitializers = [];
  let _label_decorators;
  let _label_initializers = [];
  let _label_extraInitializers = [];
  let _options_decorators;
  let _options_initializers = [];
  let _options_extraInitializers = [];
  let _model_decorators;
  let _model_initializers = [];
  let _model_extraInitializers = [];
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  let _class_decorators;
  let _class_initializers = [];
  let _class_extraInitializers = [];
  let _disabled_decorators;
  let _disabled_initializers = [];
  let _disabled_extraInitializers = [];
  let _handleRadioChecked_decorators;
  let _handleRadioValue_decorators;
  let _handleCheckChanged_decorators;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _label_decorators = [
        bindable
      ];
      _options_decorators = [
        bindable
      ];
      _model_decorators = [
        bindable({
          mode: BindingMode.twoWay
        })
      ];
      _value_decorators = [
        bindable({
          mode: BindingMode.twoWay
        })
      ];
      _class_decorators = [
        bindable
      ];
      _disabled_decorators = [
        bindable
      ];
      _handleRadioChecked_decorators = [
        watch("radio.checked")
      ];
      _handleRadioValue_decorators = [
        watch("radio")
      ];
      _handleCheckChanged_decorators = [
        watch("checked")
      ];
      __esDecorate(this, null, _handleRadioChecked_decorators, {
        kind: "method",
        name: "handleRadioChecked",
        static: false,
        private: false,
        access: {
          has: (obj) => "handleRadioChecked" in obj,
          get: (obj) => obj.handleRadioChecked
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate(this, null, _handleRadioValue_decorators, {
        kind: "method",
        name: "handleRadioValue",
        static: false,
        private: false,
        access: {
          has: (obj) => "handleRadioValue" in obj,
          get: (obj) => obj.handleRadioValue
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate(this, null, _handleCheckChanged_decorators, {
        kind: "method",
        name: "handleCheckChanged",
        static: false,
        private: false,
        access: {
          has: (obj) => "handleCheckChanged" in obj,
          get: (obj) => obj.handleCheckChanged
        },
        metadata: _metadata
      }, null, _instanceExtraInitializers);
      __esDecorate(null, null, _label_decorators, {
        kind: "field",
        name: "label",
        static: false,
        private: false,
        access: {
          has: (obj) => "label" in obj,
          get: (obj) => obj.label,
          set: (obj, value) => {
            obj.label = value;
          }
        },
        metadata: _metadata
      }, _label_initializers, _label_extraInitializers);
      __esDecorate(null, null, _options_decorators, {
        kind: "field",
        name: "options",
        static: false,
        private: false,
        access: {
          has: (obj) => "options" in obj,
          get: (obj) => obj.options,
          set: (obj, value) => {
            obj.options = value;
          }
        },
        metadata: _metadata
      }, _options_initializers, _options_extraInitializers);
      __esDecorate(null, null, _model_decorators, {
        kind: "field",
        name: "model",
        static: false,
        private: false,
        access: {
          has: (obj) => "model" in obj,
          get: (obj) => obj.model,
          set: (obj, value) => {
            obj.model = value;
          }
        },
        metadata: _metadata
      }, _model_initializers, _model_extraInitializers);
      __esDecorate(null, null, _value_decorators, {
        kind: "field",
        name: "value",
        static: false,
        private: false,
        access: {
          has: (obj) => "value" in obj,
          get: (obj) => obj.value,
          set: (obj, value) => {
            obj.value = value;
          }
        },
        metadata: _metadata
      }, _value_initializers, _value_extraInitializers);
      __esDecorate(null, null, _class_decorators, {
        kind: "field",
        name: "class",
        static: false,
        private: false,
        access: {
          has: (obj) => "class" in obj,
          get: (obj) => obj.class,
          set: (obj, value) => {
            obj.class = value;
          }
        },
        metadata: _metadata
      }, _class_initializers, _class_extraInitializers);
      __esDecorate(null, null, _disabled_decorators, {
        kind: "field",
        name: "disabled",
        static: false,
        private: false,
        access: {
          has: (obj) => "disabled" in obj,
          get: (obj) => obj.disabled,
          set: (obj, value) => {
            obj.disabled = value;
          }
        },
        metadata: _metadata
      }, _disabled_initializers, _disabled_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    label = (__runInitializers(this, _instanceExtraInitializers), __runInitializers(this, _label_initializers, void 0));
    options = (__runInitializers(this, _label_extraInitializers), __runInitializers(this, _options_initializers, void 0));
    model = (__runInitializers(this, _options_extraInitializers), __runInitializers(this, _model_initializers, void 0));
    value = (__runInitializers(this, _model_extraInitializers), __runInitializers(this, _value_initializers, void 0));
    class = (__runInitializers(this, _value_extraInitializers), __runInitializers(this, _class_initializers, void 0));
    disabled = (__runInitializers(this, _class_extraInitializers), __runInitializers(this, _disabled_initializers, void 0));
    checked = (__runInitializers(this, _disabled_extraInitializers), false);
    radioEl;
    radio;
    attached() {
      if (this.model == this.value) {
        this.checked = true;
      }
      console.log("this.model", this.model);
      console.log("this.value", this.value);
      this.radio = new MDCRadio(this.radioEl);
      console.log(this.checked);
    }
    clickHandler() {
      console.log("clicked", this.radio.value);
    }
    handleRadioChecked() {
      console.log("radio checked", this.radio.checked);
    }
    handleRadioValue() {
      console.log("radio value", this.radio.value);
    }
    handleCheckChanged() {
      console.log("this.checked", this.checked);
    }
  });
  return _classThis;
})();
const template$5 = '<md-outlined-select ...$attrs if.bind="variant === \'outlined\'" onchange.bind="(e) => handleChange(e)">\r\n    <md-select-option aria-label="blank" if.bind="includeNull" selected.bind="shouldBeSelected(null)">\r\n        -- None --\r\n    </md-select-option>\r\n    <md-select-option repeat.for="option of options" value.bind="option.value" selected.bind="shouldBeSelected(option)">\r\n        <div slot="headline">${option.label}</div>\r\n    </md-select-option>\r\n</md-outlined-select>\r\n\r\n\r\n<md-filled-select ...$attrs else onchange.bind="(e) => handleChange(e)">\r\n    <md-select-option aria-label="blank" if.bind="includeNull" selected.bind="shouldBeSelected(null)">\r\n        -- None --\r\n    </md-select-option>\r\n    <md-select-option repeat.for="option of options" value.bind="option.value" selected.bind="shouldBeSelected(option)">\r\n        <div slot="headline">${option.label}</div>\r\n    </md-select-option>\r\n</md-filled-select>\r\n';
let MooSelect = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-select",
      template: template$5,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _options_decorators;
  let _options_initializers = [];
  let _options_extraInitializers = [];
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  let _variant_decorators;
  let _variant_initializers = [];
  let _variant_extraInitializers = [];
  let _includeNull_decorators;
  let _includeNull_initializers = [];
  let _includeNull_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _options_decorators = [
        bindable
      ];
      _value_decorators = [
        bindable({
          mode: BindingMode.twoWay
        })
      ];
      _variant_decorators = [
        bindable
      ];
      _includeNull_decorators = [
        bindable
      ];
      __esDecorate(null, null, _options_decorators, {
        kind: "field",
        name: "options",
        static: false,
        private: false,
        access: {
          has: (obj) => "options" in obj,
          get: (obj) => obj.options,
          set: (obj, value) => {
            obj.options = value;
          }
        },
        metadata: _metadata
      }, _options_initializers, _options_extraInitializers);
      __esDecorate(null, null, _value_decorators, {
        kind: "field",
        name: "value",
        static: false,
        private: false,
        access: {
          has: (obj) => "value" in obj,
          get: (obj) => obj.value,
          set: (obj, value) => {
            obj.value = value;
          }
        },
        metadata: _metadata
      }, _value_initializers, _value_extraInitializers);
      __esDecorate(null, null, _variant_decorators, {
        kind: "field",
        name: "variant",
        static: false,
        private: false,
        access: {
          has: (obj) => "variant" in obj,
          get: (obj) => obj.variant,
          set: (obj, value) => {
            obj.variant = value;
          }
        },
        metadata: _metadata
      }, _variant_initializers, _variant_extraInitializers);
      __esDecorate(null, null, _includeNull_decorators, {
        kind: "field",
        name: "includeNull",
        static: false,
        private: false,
        access: {
          has: (obj) => "includeNull" in obj,
          get: (obj) => obj.includeNull,
          set: (obj, value) => {
            obj.includeNull = value;
          }
        },
        metadata: _metadata
      }, _includeNull_initializers, _includeNull_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    options = __runInitializers(this, _options_initializers, void 0);
    value = (__runInitializers(this, _options_extraInitializers), __runInitializers(this, _value_initializers, void 0));
    variant = (__runInitializers(this, _value_extraInitializers), __runInitializers(this, _variant_initializers, "outlined"));
    includeNull = (__runInitializers(this, _variant_extraInitializers), __runInitializers(this, _includeNull_initializers, false));
    handleChange(e2) {
      this.value = e2.target.value;
    }
    shouldBeSelected(option) {
      if (this.includeNull && !this.value) {
        return true;
      }
      if (!option) {
        return false;
      }
      return option.value == this.value;
    }
    constructor() {
      __runInitializers(this, _includeNull_extraInitializers);
    }
  });
  return _classThis;
})();
const template$4 = '<label class="pt-1 pe-1" for="switch">${label}</label>\r\n<md-switch ref="switch" selected.bind="value" id="switch" ...$attrs></md-switch>\r\n';
let MooSwitch = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-switch",
      template: template$4,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  let _class_decorators;
  let _class_initializers = [];
  let _class_extraInitializers = [];
  let _change_decorators;
  let _change_initializers = [];
  let _change_extraInitializers = [];
  let _label_decorators;
  let _label_initializers = [];
  let _label_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _value_decorators = [
        bindable({
          mode: BindingMode.twoWay
        })
      ];
      _class_decorators = [
        bindable
      ];
      _change_decorators = [
        bindable
      ];
      _label_decorators = [
        bindable
      ];
      __esDecorate(null, null, _value_decorators, {
        kind: "field",
        name: "value",
        static: false,
        private: false,
        access: {
          has: (obj) => "value" in obj,
          get: (obj) => obj.value,
          set: (obj, value) => {
            obj.value = value;
          }
        },
        metadata: _metadata
      }, _value_initializers, _value_extraInitializers);
      __esDecorate(null, null, _class_decorators, {
        kind: "field",
        name: "class",
        static: false,
        private: false,
        access: {
          has: (obj) => "class" in obj,
          get: (obj) => obj.class,
          set: (obj, value) => {
            obj.class = value;
          }
        },
        metadata: _metadata
      }, _class_initializers, _class_extraInitializers);
      __esDecorate(null, null, _change_decorators, {
        kind: "field",
        name: "change",
        static: false,
        private: false,
        access: {
          has: (obj) => "change" in obj,
          get: (obj) => obj.change,
          set: (obj, value) => {
            obj.change = value;
          }
        },
        metadata: _metadata
      }, _change_initializers, _change_extraInitializers);
      __esDecorate(null, null, _label_decorators, {
        kind: "field",
        name: "label",
        static: false,
        private: false,
        access: {
          has: (obj) => "label" in obj,
          get: (obj) => obj.label,
          set: (obj, value) => {
            obj.label = value;
          }
        },
        metadata: _metadata
      }, _label_initializers, _label_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    value = __runInitializers(this, _value_initializers, void 0);
    class = (__runInitializers(this, _value_extraInitializers), __runInitializers(this, _class_initializers, void 0));
    change = (__runInitializers(this, _class_extraInitializers), __runInitializers(this, _change_initializers, void 0));
    label = (__runInitializers(this, _change_extraInitializers), __runInitializers(this, _label_initializers, void 0));
    switch = __runInitializers(this, _label_extraInitializers);
    attached() {
      this.switch.selected = this.value;
      this.switch.addEventListener("change", () => this.handleChange());
    }
    handleChange() {
      this.value = !this.value;
      if (this.change) {
        this.change();
      }
    }
  });
  return _classThis;
})();
const template$3 = `<md-primary-tab ...$attrs if.bind="variant === 'primary'">\r
    <au-slot></au-slot>\r
</md-primary-tab>\r
\r
<md-secondary-tab ...$attrs if.bind="variant === 'secondary'">\r
    <au-slot></au-slot>\r
</md-secondary-tab>\r
`;
let MooTab = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-tab",
      template: template$3,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _variant_decorators;
  let _variant_initializers = [];
  let _variant_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _variant_decorators = [
        bindable
      ];
      __esDecorate(null, null, _variant_decorators, {
        kind: "field",
        name: "variant",
        static: false,
        private: false,
        access: {
          has: (obj) => "variant" in obj,
          get: (obj) => obj.variant,
          set: (obj, value) => {
            obj.variant = value;
          }
        },
        metadata: _metadata
      }, _variant_initializers, _variant_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    variant = __runInitializers(this, _variant_initializers, "primary");
    constructor() {
      __runInitializers(this, _variant_extraInitializers);
    }
  });
  return _classThis;
})();
const template$2 = "<md-tabs ...$attrs>\r\n    <au-slot></au-slot>\r\n</md-tabs>\r\n";
let MooTabs = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-tabs",
      template: template$2,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
  });
  return _classThis;
})();
const template$1 = `<md-filled-text-field\r
    ...$attrs\r
    value.bind="value ?? ''"\r
    if.bind="variant === 'filled'"\r
    ref="mdElement"\r
>\r
    <au-slot></au-slot>\r
</md-filled-text-field>\r
\r
<md-outlined-text-field\r
    ...$attrs\r
    else\r
    value.bind="value ?? ''"\r
    ref="mdElement"\r
>\r
    <au-slot></au-slot>\r
</md-outlined-text-field>\r
`;
let MooTextField = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-text-field",
      template: template$1,
      containerless: true,
      capture: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  let _value_decorators;
  let _value_initializers = [];
  let _value_extraInitializers = [];
  let _variant_decorators;
  let _variant_initializers = [];
  let _variant_extraInitializers = [];
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      _value_decorators = [
        bindable({
          mode: BindingMode.twoWay
        })
      ];
      _variant_decorators = [
        bindable
      ];
      __esDecorate(null, null, _value_decorators, {
        kind: "field",
        name: "value",
        static: false,
        private: false,
        access: {
          has: (obj) => "value" in obj,
          get: (obj) => obj.value,
          set: (obj, value) => {
            obj.value = value;
          }
        },
        metadata: _metadata
      }, _value_initializers, _value_extraInitializers);
      __esDecorate(null, null, _variant_decorators, {
        kind: "field",
        name: "variant",
        static: false,
        private: false,
        access: {
          has: (obj) => "variant" in obj,
          get: (obj) => obj.variant,
          set: (obj, value) => {
            obj.variant = value;
          }
        },
        metadata: _metadata
      }, _variant_initializers, _variant_extraInitializers);
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    value = __runInitializers(this, _value_initializers, "");
    variant = (__runInitializers(this, _value_extraInitializers), __runInitializers(this, _variant_initializers, "outlined"));
    mdElement = __runInitializers(this, _variant_extraInitializers);
    bound() {
      if (!this.value) {
        this.value = "";
      }
    }
    attached() {
      this.mdElement.addEventListener("keyup", () => this.value = this.mdElement.value);
    }
  });
  return _classThis;
})();
const template = '<header class="mdc-top-app-bar mdc-top-app-bar--fixed" ref="header">\r\n    <div class="mdc-top-app-bar__row">\r\n        <au-slot></au-slot>\r\n    </div>\r\n</header>\r\n<div class="mdc-top-app-bar--fixed-adjust"></div>\r\n';
let MooTopbar = (() => {
  let _classDecorators = [
    customElement({
      name: "moo-topbar",
      template,
      containerless: true
    })
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    header;
    attached() {
      new MDCTopAppBar(this.header);
    }
  });
  return _classThis;
})();
const elements = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MooAccordion,
  MooBanner,
  MooButton,
  MooButtonIcon,
  MooCard,
  MooCardContent,
  MooCardFooter,
  MooCardHeader,
  MooCheckbox,
  MooChip,
  MooChipSet,
  MooDialog,
  MooDrawer,
  MooFab,
  MooFormField,
  MooIcon,
  MooList,
  MooListItem,
  MooMenu,
  MooMenuItem,
  MooProgress,
  MooRadio,
  MooSelect,
  MooSwitch,
  MooTab,
  MooTabs,
  MooTextField,
  MooTopbar
}, Symbol.toStringTag, { value: "Module" }));
let TakeValueConverter = (() => {
  let _classDecorators = [
    valueConverter("take")
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    toView(value, amount) {
      return value.slice(0, amount);
    }
  });
  return _classThis;
})();
let SkipValueConverter = (() => {
  let _classDecorators = [
    valueConverter("skip")
  ];
  let _classDescriptor;
  let _classExtraInitializers = [];
  let _classThis;
  (class {
    static {
      _classThis = this;
    }
    static {
      const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
      __esDecorate(null, _classDescriptor = {
        value: _classThis
      }, _classDecorators, {
        kind: "class",
        name: _classThis.name,
        metadata: _metadata
      }, null, _classExtraInitializers);
      _classThis = _classDescriptor.value;
      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {
        enumerable: true,
        configurable: true,
        writable: true,
        value: _metadata
      });
      __runInitializers(_classThis, _classExtraInitializers);
    }
    toView(value, amount) {
      return value.slice(amount);
    }
  });
  return _classThis;
})();
const valueConverters = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SkipValueConverter,
  TakeValueConverter
}, Symbol.toStringTag, { value: "Module" }));
class BetsyWebComponentsPlugin {
  #configuration;
  static configure(...args) {
    const instance = new BetsyWebComponentsPlugin();
    if (typeof args[0] === "function") {
      instance.#configuration = {
        iconMap: /* @__PURE__ */ new Map()
      };
      args[0](instance.#configuration);
    } else {
      instance.#configuration = args[0];
    }
    if (!instance.#configuration.formatDateTime) {
      instance.#configuration.formatDateTime = (date) => new Intl.DateTimeFormat("default", {
        dateStyle: "full"
      }).format(typeof date === "string" ? new Date(date) : date);
    }
    if (!instance.#configuration.formatDate) {
      instance.#configuration.formatDate = (date) => new Intl.DateTimeFormat("default", {
        month: "2-digit",
        day: "2-digit",
        year: "numeric"
      }).format(typeof date === "string" ? new Date(date) : date);
    }
    if (!instance.#configuration.formatNumber) {
      instance.#configuration.formatNumber = (number) => new Intl.NumberFormat("default", {
        maximumFractionDigits: 2
      }).format(number == null ? 0 : Number(number));
    }
    if (!instance.#configuration.formatCurrency) {
      instance.#configuration.formatCurrency = (number) => new Intl.NumberFormat("default", {
        style: "currency",
        currency: "usd"
      }).format(number == null ? 0 : Number(number));
    }
    if (!instance.#configuration.formatPercent) {
      instance.#configuration.formatPercent = (number) => new Intl.NumberFormat("default", {
        style: "percent"
      }).format(number == null ? 0 : Number(number));
    }
    return instance;
  }
  register(container) {
    container.register(attributes);
    container.register(elements);
    container.register(valueConverters);
    container.register(Registration.instance(IBetsyWebComponentsConfiguration, this.#configuration));
    container.register($.customize((options) => {
      options.DefaultTrigger = D.changeOrFocusout;
    }));
    return container;
  }
}
const BetsyWebComponentsPlugin$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BetsyWebComponentsPlugin,
  IBetsyWebComponentsConfiguration,
  attributes,
  elements,
  valueConverters
}, Symbol.toStringTag, { value: "Module" }));
Aurelia2.register(
  RouterConfiguration.customize({
    //title: "Betsy Bot Admin Panel",
    useUrlFragmentHash: false
  })
).register(BetsyWebComponentsPlugin$1).app(App).start();
export {
  CustomElement as C,
  bindable as b,
  customElement as c,
  watch as w
};
